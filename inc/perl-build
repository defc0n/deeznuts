#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"CPAN/Perl/Releases.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_PERL_RELEASES';
  package CPAN::Perl::Releases;$CPAN::Perl::Releases::VERSION='3.08';use strict;use warnings;use vars qw[@ISA @EXPORT_OK];use Exporter;@ISA=qw(Exporter);@EXPORT_OK=qw(perl_tarballs perl_versions perl_pumpkins);our$cache={};our$data={"5.004"=>{id=>'CHIPS' },"5.004_01"=>{id=>'TIMB' },"5.004_02"=>{id=>'TIMB' },"5.004_03"=>{id=>'TIMB' },"5.004_04"=>{id=>'TIMB' },"5.004_05"=>{id=>'CHIPS' },"5.005"=>{id=>'GSAR' },"5.005_01"=>{id=>'GSAR' },"5.005_02"=>{id=>'GSAR' },"5.005_03"=>{id=>'GBARR' },"5.005_04"=>{id=>'LBROCARD' },"5.6.0"=>{id=>'GSAR' },"5.6.1-TRIAL1"=>{id=>'GSAR' },"5.6.1-TRIAL2"=>{id=>'GSAR' },"5.6.1-TRIAL3"=>{id=>'GSAR' },"5.6.1"=>{id=>'GSAR' },"5.6.2"=>{id=>'RGARCIA' },"5.7.0"=>{id=>'JHI' },"5.7.2"=>{id=>'JHI' },"5.7.3"=>{id=>'JHI' },"5.8.0"=>{id=>'JHI' },"5.8.1"=>{id=>'JHI' },"5.8.2"=>{id=>'NWCLARK' },"5.8.3"=>{id=>'NWCLARK' },"5.8.4"=>{id=>'NWCLARK' },"5.8.5"=>{id=>'NWCLARK' },"5.8.6"=>{id=>'NWCLARK' },"5.8.7"=>{id=>'NWCLARK' },"5.8.8"=>{id=>'NWCLARK' },"5.8.9"=>{id=>'NWCLARK' },"5.9.0"=>{id=>'HVDS' },"5.9.1"=>{id=>'RGARCIA' },"5.9.2"=>{id=>'RGARCIA' },"5.9.3"=>{id=>'RGARCIA' },"5.9.4"=>{id=>'RGARCIA' },"5.9.5"=>{id=>'RGARCIA' },"5.10.0"=>{id=>'RGARCIA' },"5.10.1"=>{id=>'DAPM' },"5.11.0"=>{id=>'JESSE' },"5.11.1"=>{id=>'JESSE' },"5.11.2"=>{id=>'LBROCARD' },"5.11.3"=>{id=>'JESSE' },"5.11.4"=>{id=>'RJBS' },"5.11.5"=>{id=>'SHAY' },"5.12.0"=>{id=>'JESSE' },"5.12.1"=>{id=>'JESSE' },"5.12.2"=>{id=>'JESSE' },"5.12.3"=>{id=>'RJBS' },"5.12.4"=>{id=>'LBROCARD' },"5.12.5"=>{id=>'DOM' },"5.13.0"=>{id=>'LBROCARD' },"5.13.1"=>{id=>'RJBS' },"5.13.2"=>{id=>'MSTROUT' },"5.13.3"=>{id=>'DAGOLDEN' },"5.13.4"=>{id=>'FLORA' },"5.13.5"=>{id=>'SHAY' },"5.13.6"=>{id=>'MIYAGAWA' },"5.13.7"=>{id=>'BINGOS' },"5.13.8"=>{id=>'ZEFRAM' },"5.13.9"=>{id=>'JESSE' },"5.13.10"=>{id=>'AVAR' },"5.13.11"=>{id=>'FLORA' },"5.14.0"=>{id=>'JESSE' },"5.14.1"=>{id=>'JESSE' },"5.14.2-RC1"=>{id=>'FLORA' },"5.14.2"=>{id=>'FLORA' },"5.14.3"=>{id=>'DOM' },"5.14.4-RC1"=>{id=>'DAPM' },"5.14.4-RC2"=>{id=>'DAPM' },"5.14.4"=>{id=>'DAPM' },"5.15.0"=>{id=>'DAGOLDEN' },"5.15.1"=>{id=>'ZEFRAM' },"5.15.2"=>{id=>'RJBS' },"5.15.3"=>{id=>'STEVAN' },"5.15.4"=>{id=>'FLORA' },"5.15.5"=>{id=>'SHAY' },"5.15.6"=>{id=>'DROLSKY' },"5.15.7"=>{id=>'BINGOS' },"5.15.8"=>{id=>'CORION' },"5.15.9"=>{id=>'ABIGAIL' },"5.16.0"=>{id=>'RJBS' },"5.16.1"=>{id=>'RJBS' },"5.16.2"=>{id=>'RJBS' },"5.16.3"=>{id=>'RJBS' },"5.17.0"=>{id=>'ZEFRAM' },"5.17.1"=>{id=>'DOY' },"5.17.2"=>{id=>'TONYC' },"5.17.3"=>{id=>'SHAY' },"5.17.4"=>{id=>'FLORA' },"5.17.5"=>{id=>'FLORA' },"5.17.6"=>{id=>'RJBS' },"5.17.7"=>{id=>'DROLSKY' },"5.17.8"=>{id=>'ARC' },"5.17.9"=>{id=>'BINGOS' },"5.17.10"=>{id=>'CORION' },"5.17.11"=>{id=>'RJBS' },"5.18.0"=>{id=>'RJBS' },"5.18.1"=>{id=>'RJBS' },"5.19.0"=>{id=>'RJBS' },"5.19.1"=>{id=>'DAGOLDEN' },"5.19.2"=>{id=>'ARISTOTLE' },"5.19.3"=>{id=>'SHAY' },"5.19.4"=>{id=>'SHAY' },"5.19.5"=>{id=>'SHAY' },"5.19.6"=>{id=>'BINGOS' },"5.19.7"=>{id=>'ABIGAIL' },"5.18.2"=>{id=>'RJBS' },"5.19.8"=>{id=>'RJBS' },"5.19.9"=>{id=>'TONYC' },"5.19.10"=>{id=>'ARC' },"5.19.11"=>{id=>'SHAY' },"5.20.0"=>{id=>'RJBS' },"5.21.0"=>{id=>'RJBS' },"5.21.1"=>{id=>'WOLFSAGE' },"5.21.2"=>{id=>'ABIGAIL' },"5.21.3"=>{id=>'PCM' },"5.20.1-RC1"=>{id=>'SHAY' },"5.20.1-RC2"=>{id=>'SHAY' },"5.20.1"=>{id=>'SHAY' },"5.21.4"=>{id=>'SHAY' },"5.18.3"=>{id=>'RJBS' },"5.18.4"=>{id=>'RJBS' },"5.21.5"=>{id=>'ABIGAIL' },"5.21.6"=>{id=>'BINGOS' },"5.21.7"=>{id=>'CORION' },"5.21.8"=>{id=>'WOLFSAGE' },"5.20.2-RC1"=>{id=>'SHAY' },"5.20.2"=>{id=>'SHAY' },"5.21.9"=>{id=>'XSAWYERX' },"5.21.10"=>{id=>'SHAY' },"5.21.11"=>{id=>'SHAY' },"5.22.0"=>{id=>'RJBS' },"5.23.0"=>{id=>'RJBS' },"5.23.1"=>{id=>'WOLFSAGE' },"5.23.2"=>{id=>'WOLFSAGE' },"5.20.3-RC1"=>{id=>'SHAY' },"5.20.3-RC2"=>{id=>'SHAY' },"5.20.3"=>{id=>'SHAY' },"5.23.3"=>{id=>'PCM' },"5.23.4"=>{id=>'SHAY' },"5.22.1-RC1"=>{id=>'SHAY' },"5.22.1-RC2"=>{id=>'SHAY' },"5.23.5"=>{id=>'ABIGAIL' },"5.22.1-RC3"=>{id=>'SHAY' },"5.22.1-RC4"=>{id=>'SHAY' },"5.22.1"=>{id=>'SHAY' },"5.23.6"=>{id=>'DAGOLDEN' },"5.23.7"=>{id=>'STEVAN' },"5.23.8"=>{id=>'XSAWYERX' },"5.23.9"=>{id=>'ABIGAIL' },"5.22.2-RC1"=>{id=>'SHAY' },"5.24.0-RC1"=>{id=>'RJBS' },"5.24.0-RC2"=>{id=>'RJBS' },"5.24.0-RC3"=>{id=>'RJBS' },"5.22.2"=>{id=>'SHAY' },"5.24.0-RC4"=>{id=>'RJBS' },"5.24.0-RC5"=>{id=>'RJBS' },"5.24.0"=>{id=>'RJBS' },"5.25.0"=>{id=>'RJBS' },"5.25.1"=>{id=>'XSAWYERX' },"5.25.2"=>{id=>'WOLFSAGE' },"5.22.3-RC1"=>{id=>'SHAY' },"5.24.1-RC1"=>{id=>'SHAY' },"5.25.3"=>{id=>'SHAY' },"5.22.3-RC2"=>{id=>'SHAY' },"5.24.1-RC2"=>{id=>'SHAY' },"5.22.3-RC3"=>{id=>'SHAY' },"5.24.1-RC3"=>{id=>'SHAY' },"5.25.4"=>{id=>'BINGOS' },"5.25.5"=>{id=>'STEVAN' },"5.22.3-RC4"=>{id=>'SHAY' },"5.24.1-RC4"=>{id=>'SHAY' },"5.25.6"=>{id=>'ARC' },"5.25.7"=>{id=>'EXODIST' },"5.25.8"=>{id=>'XSAWYERX' },"5.22.3-RC5"=>{id=>'SHAY' },"5.24.1-RC5"=>{id=>'SHAY' },"5.22.3"=>{id=>'SHAY' },"5.24.1"=>{id=>'SHAY' },"5.25.9"=>{id=>'ABIGAIL' },};sub perl_tarballs {my$vers=shift;$vers=shift if eval {$vers->isa(__PACKAGE__)};return unless exists$data->{$vers };if (exists$cache->{$vers }){return {%{$cache->{$vers }}}}my$pumpkin=$data->{$vers }->{id};my$path=join '/',substr($pumpkin,0,1),substr($pumpkin,0,2),$pumpkin;my$sep=($vers =~ m!^5\.0! ? '' : '-');my$perl=join$sep,'perl',$vers;my$onlygz=1 if$vers =~ m!(?-xism:5.(?:00(?:4(?:_0[12345])?|5(?:_0[1234])?|3_07)|1(?:0.0(?:-RC[12])?|6.0-RC0)|6.(?:[02]|1(?:-TRIAL[123])?)|9.[12345]|7.[0123]|8.[01]))! || $data->{$vers }->{onlygz};my$onlybz2=1 if$data->{$vers }->{onlybz2};my$noxz=1 if$data->{$vers }->{noxz};my$lvers;{my$tvers=$vers;$tvers =~ s!\-?(TRIAL|RC)\d*!!g;$tvers =~ s!_!.!g;my@parts=split m!\.!,$tvers;push@parts,0 if scalar@parts < 3;$lvers=sprintf("%d.%03d%03d",@parts)}my$foo={};$foo->{'tar.gz'}="$path/$perl.tar.gz" unless$onlybz2;$foo->{'tar.bz2'}="$path/$perl.tar.bz2" unless$onlygz;$foo->{'tar.xz'}="$path/$perl.tar.xz" if$lvers > 5.021005 &&!$noxz;$cache->{$vers }=$foo;return {%$foo }}sub perl_versions {return sort _by_version keys %$data}sub _by_version {my%v=map {my@v=split(qr/[-._]0*/,$_);$v[2]||= 0;$v[3]||= 'Z';($_=>sprintf '%d.%03d%03d-%s',@v)}$a,$b;$v{$a}cmp $v{$b}}sub perl_pumpkins {my%pumps=map {($data->{$_}->{id}=>1)}keys %$data;return sort keys%pumps}q|Acme::Why::Did::I::Not::Read::The::Fecking::Memo|;
CPAN_PERL_RELEASES

$fatpacked{"Devel/InnerPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_INNERPACKAGE';
  package Devel::InnerPackage;use strict;use Exporter 5.57 'import';use vars qw($VERSION @EXPORT_OK);use if $] > 5.017,'deprecate';$VERSION='0.4';@EXPORT_OK=qw(list_packages);sub list_packages {my$pack=shift;$pack .= "::" unless$pack =~ m!::$!;no strict 'refs';my@packs;my@stuff=grep!/^(main|)::$/,keys %{$pack};for my$cand (grep /::$/,@stuff){$cand =~ s!::$!!;my@children=list_packages($pack.$cand);push@packs,"$pack$cand" unless$cand =~ /^::/ || !__PACKAGE__->_loaded($pack.$cand);push@packs,@children}return grep {$_ !~ /::(::ISA::CACHE|SUPER)/}@packs}sub _loaded {my ($class,$name)=@_;no strict 'refs';return 1 if defined ${"${name}::VERSION"};return 1 if @{"${name}::ISA"};for (keys %{"${name}::"}){next if substr($_,-2,2)eq '::';return 1 if defined &{"${name}::$_"}}my$filename=join('/',split /(?:'|::)/,$name).'.pm';return 1 if defined$INC{$filename};''}1;
DEVEL_INNERPACKAGE

$fatpacked{"Devel/PatchPerl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_PATCHPERL';
  package Devel::PatchPerl;$Devel::PatchPerl::VERSION='1.48';use strict;use warnings;use File::pushd qw[pushd];use File::Spec;use IO::File;use Devel::PatchPerl::Hints qw[hint_file];use Module::Pluggable search_path=>['Devel::PatchPerl::Plugin'];use vars qw[@ISA @EXPORT_OK];@ISA=qw(Exporter);@EXPORT_OK=qw(patch_source);my$patch_exe=_can_run('gpatch')|| _can_run('patch');my@patch=({perl=>[qw/5.005/,],subs=>[[\&_patch_5_005,1 ],],},{perl=>[qw/5.005_01/,],subs=>[[\&_patch_5_005_01,1 ],],},{perl=>[qw/5.005_02/,],subs=>[[\&_patch_5_005_02,1 ],],},{perl=>[qr/^5\.00[2345]/,qw/5.001n/,],subs=>[[\&_patch_handy,1 ],],},{perl=>[qw/5.005 5.005_01 5.005_02 5.005_03 5.005_04/,],subs=>[[\&_replace_makedepend,1 ],],},{perl=>[qr/^5\.00[01234]/,qw/5.005 5.005_01 5.005_02 5.005_03/,],subs=>[[\&_patch_db,1 ],],},{perl=>[qr/^5\.6\.[1-2]$/,qr/^5\.7\.[0-1]$/,],subs=>[[\&_patch_makefile_sh_phony ],],},{perl=>[qw/5.6.0 5.6.1 5.7.0 5.7.1 5.7.2 5.7.3 5.8.0/,],subs=>[[\&_patch_db,3 ],],},{perl=>[qr/^5\.004_0[1234]$/,],subs=>[[\&_patch_doio ],],},{perl=>[qw/5.005 5.005_01 5.005_02/,],subs=>[[\&_patch_sysv,old_format=>1 ],],},{perl=>[qw/5.005_03 5.005_04/,qr/^5\.6\.[0-2]$/,qr/^5\.7\.[0-3]$/,qr/^5\.8\.[0-8]$/,qr/^5\.9\.[0-5]$/ ],subs=>[[\&_patch_sysv,old_format=>0 ],],},{perl=>[qr/^5\.004_05$/,qr/^5\.005(?:_0[1-4])?$/,qr/^5\.6\.[01]$/,],subs=>[[\&_patch_configure ],[\&_patch_makedepend_lc ],],},{perl=>[qr/^5\.6\.[0-2]$/,],subs=>[[\&_patch_conf_gconvert ],[\&_patch_sort_N ],],},{perl=>['5.8.0',],subs=>[[\&_patch_makedepend_lc ],],},{perl=>[qr/.*/,],subs=>[[\&_patch_conf_solaris ],[\&_patch_bitrig ],[\&_patch_hints ],[\&_patch_patchlevel ],[\&_patch_develpatchperlversion ],[\&_patch_errno_gcc5 ],],},{perl=>[qr/^5\.6\.[0-2]$/,qr/^5\.7\.[0-3]$/,qr/^5\.8\.[0-8]$/,],subs=>[[\&_patch_makedepend_SH ],],},{perl=>[qr/^5\.1[0-2]/,],subs=>[[\&_patch_archive_tar_tests ],[\&_patch_odbm_file_hints_linux ],],},{perl=>[qr/^5.1([24].\d+|0.1)/,],subs=>[[\&_patch_make_ext_pl ],],},{perl=>[qr/^5\.8\.9$/,],subs=>[[\&_patch_589_perlio_c ],],},{perl=>[qr/^5\.8\.[89]$/ ],subs=>[[\&_patch_hsplit_rehash_58 ]],},{perl=>[qr/^5\.10\.1$/,qr/^5\.12\.5$/,],subs=>[[\&_patch_hsplit_rehash_510 ]],},{perl=>[qr/^5\.18\.0$/,],subs=>[[\&_patch_regmatch_pointer_5180 ]],},{perl=>[qr/^5\.20\.0$/,],subs=>[[\&_patch_cow_speed ]],},{perl=>[qr/^5\.6\.[012]$/,qr/^5\.8\.[89]$/,qr/^5\.10\.[01]$/,],subs=>[[\&_patch_preprocess_options ]],},{perl=>[qr/^5\.18\.3$/,],subs=>[[\&_patch_5183_metajson ]],},{perl=>[qr/^5\.24\.[01]$/,],subs=>[[\&_patch_time_hires ]],},);sub patch_source {my$vers=shift;$vers=shift if eval {$vers->isa(__PACKAGE__)};my$source=shift || '.';if (!$vers){$vers=_determine_version($source);if ($vers){warn "Auto-guessed '$vers'\n"}else {die "You didn't provide a perl version and I don't appear to be in a perl source tree\n"}}$source=File::Spec->rel2abs($source);{my$dir=pushd($source);for my$p (grep {_is($_->{perl},$vers)}@patch){for my$s (@{$p->{subs}}){my($sub,@args)=@$s;push@args,$vers unless scalar@args;$sub->(@args)}}_process_plugin(version=>$vers,source=>$source,patchexe=>$patch_exe)}}sub _process_plugin {my%args=@_;return unless my$possible=$ENV{PERL5_PATCHPERL_PLUGIN};my ($plugin)=grep {$possible eq $_ or /\Q$possible\E$/}__PACKAGE__->plugins;unless ($plugin){warn "# You specified a plugin '",$ENV{PERL5_PATCHPERL_PLUGIN},"' that isn't installed, just thought you might be interested.\n";return}{local $@;eval "require $plugin";if ($@){die "# I tried to load '",$ENV{PERL5_PATCHPERL_PLUGIN},"' but it didn't work out. Here is what happened '$@'\n"}}{local $@;eval {$plugin->patchperl(%args,)};if ($@){warn "# Warnings from the plugin: '$@'\n"}}return 1}sub _can_run {my$command=shift;if ($^O eq 'VMS'){require VMS::DCLsym;my$syms=VMS::DCLsym->new;return$command if scalar$syms->getsym(uc$command)}require File::Spec;require ExtUtils::MakeMaker;my@possibles;if(File::Spec->file_name_is_absolute($command)){return MM->maybe_command($command)}else {for my$dir (File::Spec->path,File::Spec->curdir){next if!$dir ||!-d $dir;my$abs=File::Spec->catfile($^O eq 'MSWin32' ? Win32::GetShortPathName($dir): $dir,$command);push@possibles,$abs if$abs=MM->maybe_command($abs)}}return@possibles if wantarray;return shift@possibles}sub _is {my($s1,$s2)=@_;defined$s1!=defined$s2 and return 0;ref$s2 and ($s1,$s2)=($s2,$s1);if (ref$s1){if (ref$s1 eq 'ARRAY'){_is($_,$s2)and return 1 for @$s1;return 0}return$s2 =~ $s1}return$s1 eq $s2}sub _patch {my($patch)=@_;print "patching $_\n" for$patch =~ /^\+{3}\s+(\S+)/gm;my$diff='tmp.diff';_write_or_die($diff,$patch);die "No patch utility found\n" unless$patch_exe;local$ENV{PATCH_GET}=0;_run_or_die("$patch_exe -f -s -p0 <$diff");unlink$diff or die "unlink $diff: $!\n"}sub _write_or_die {my($file,$data)=@_;my$fh=IO::File->new(">$file")or die "$file: $!\n";$fh->print($data)}sub _run_or_die {die unless system(@_)==0}sub determine_version {my$src=shift;$src=shift if eval {$src->isa(__PACKAGE__)};$src='.' unless$src;_determine_version($src)}sub _determine_version {my ($source)=@_;my$patchlevel_h=File::Spec->catfile($source,'patchlevel.h');return unless -e $patchlevel_h;my$version;{my%defines;open my$fh,'<',$patchlevel_h;my@vers;while (<$fh>){chomp;next unless /^#define/;my ($foo,$bar)=(split /\s+/)[1,2];$defines{$foo}=$bar}if (my@wotsits=grep {defined$defines{$_}}qw(PERL_REVISION PERL_VERSION PERL_SUBVERSION)){$version=join '.',map {$defines{$_}}@wotsits}elsif (my@watsits=grep {defined$defines{$_}}qw(PATCHLEVEL SUBVERSION)){$version=sprintf '5.%03d_%02d',map {$defines{$_}}@watsits}else {return}}return$version}sub _patch_patchlevel {return if -d '.git';my$dpv=$Devel::PatchPerl::VERSION || "(unreleased)";open my$plin,"patchlevel.h" or die "Couldn't open patchlevel.h : $!";open my$plout,">patchlevel.new" or die "Couldn't write on patchlevel.new : $!";my$seen=0;while (<$plin>){if (/\t,NULL/ and $seen){print {$plout}qq{\t,"Devel::PatchPerl $dpv"\n}}$seen++ if /local_patches\[\]/;print {$plout}$_}close$plout or die "Couldn't close filehandle writing to patchlevel.new : $!";close$plin or die "Couldn't close filehandle reading from patchlevel.h : $!";unlink "patchlevel.bak" or warn "Couldn't unlink patchlevel.bak : $!" if -e "patchlevel.bak";rename "patchlevel.h","patchlevel.bak" or die "Couldn't rename patchlevel.h to patchlevel.bak : $!";rename "patchlevel.new","patchlevel.h" or die "Couldn't rename patchlevel.new to patchlevel.h : $!"}sub _patch_hints {my@os;push@os,$^O;push@os,'linux' if $^O eq 'gnukfreebsd';for my$os (@os){return unless my ($file,$data)=hint_file($os);my$path=File::Spec->catfile('hints',$file);if (-e $path){chmod 0644,$path or die "$!\n"}open my$fh,'>',$path or die "$!\n";print$fh $data;close$fh}return 1}sub _patch_db {my$ver=shift;for my$file ('ext/DB_File/DB_File.xs','Configure'){print "patching $file\n";_run_or_die($^X,'-pi.bak','-e',"s/<db.h>/<db$ver\\/db.h>/",$file);unlink "$file.bak" if -e "$file.bak"}}sub _patch_doio {_patch(<<'END')}sub _patch_sysv {my%opt=@_;return if $^O ne 'linux' or -f '/usr/include/asm/page.h';if ($opt{old_format}){_patch(<<'END')}else {_patch(<<'END')}}sub _patch_configure {_patch(<<'END')}sub _patch_makedepend_lc {_patch(<<'END')}sub _patch_makedepend_SH {my$perl=shift;SWITCH: {if ($perl eq '5.6.0'){_patch(<<'BADGER');last SWITCH}if ($perl eq '5.6.1'){_patch(<<'BADGER');last SWITCH}if ($perl eq '5.6.2'){_patch(<<'BADGER');last SWITCH}if ($perl eq '5.7.0'){_patch(<<'BADGER');last SWITCH}if ($perl eq '5.7.1'){_patch(<<'BADGER');last SWITCH}if ($perl eq '5.7.2'){_patch(<<'BADGER');last SWITCH}if ($perl eq '5.7.3'){_patch(<<'BADGER');last SWITCH}if ($perl eq '5.8.0'){_patch(<<'BADGER');last SWITCH}_patch(<<'BADGER')}}sub _patch_conf_gconvert {my$perl=shift;_patch(<<'END')}sub _patch_sort_N {system($^X,'-pi.bak','-e','s!\$sort \-n \+1!(\$sort -n -k 2 2>/dev/null || \$sort -n +1)!','Configure')}sub _patch_archive_tar_tests {my$perl=shift;if ($perl =~ /^5\.10/){_patch(<<'END')}else {_patch(<<'END')}}sub _patch_odbm_file_hints_linux {_patch(<<'END')}sub _patch_make_ext_pl {_patch(<<'END')}sub _patch_589_perlio_c {_patch(<<'END')}sub _patch_hsplit_rehash_58 {my$perl=shift;my$patch=<<'END';if ($perl =~ qr/^5\.8\.8$/){$patch =~ s/non-pathological/non-pathalogical/;$patch =~ s/triggering/triggerring/}_patch($patch)}sub _patch_hsplit_rehash_510 {_patch(<<'END')}sub _patch_bitrig {return unless $^O eq 'bitrig';my$perlver=shift;my$num=_norm_ver($perlver);return unless$num < 5.019004;unless ($num < 5.00800){_patch(<<'BOOGLE')}if ($num < 5.008009){_patch(<<'BITRIGM1')}else {_patch(<<'BITRIGMX')}if ($num < 5.008001){}elsif ($num < 5.008007){_patch(<<'BITRIGC3')}elsif ($num < 5.008009){_patch(<<'BITRIGC2')}elsif ($num < 5.013000){_patch(<<'BITRIGC1')}else {_patch(<<'BITRIGCX')}}sub _patch_conf_solaris {return unless $^O eq 'solaris';my$perlver=shift;my$num=_norm_ver($perlver);return unless$num < 5.018000;_patch(<<'BUBBLE')}sub _patch_regmatch_pointer_5180 {_patch(<<'BOBBLE')}sub _patch_makefile_sh_phony {_patch(<<'END')}sub _patch_cow_speed {_patch(<<'COWSAY')}sub _patch_preprocess_options {my$perl=shift;if ($perl =~ /^5\.(?:8|10)\./){_patch(<<'END')}elsif ($perl =~ /^5\.6\./){_patch(<<'END')}}sub _patch_5183_metajson {_patch(<<'DOGSAY')}sub _patch_handy {_patch(<<'END')}sub _replace_makedepend {_write_or_die('makedepend.SH',<<'END')}sub _patch_5_005_02 {_patch(<<'END')}sub _patch_5_005_01 {_patch(<<'END')}sub _patch_5_005 {_patch(<<'END')}sub _patch_errno_gcc5 {my$perlver=shift;my$num=_norm_ver($perlver);return unless$num < 5.021009;return if$num > 5.020002 && $num < 5.021;if ($num < 5.006){warn "The Errno GCC 5 patch only goes back as far as v5.6.0\n";warn "You will have to generate your own patch to go farther back\n";return}elsif ($num < 5.006001){_patch(<<'END')}elsif ($num < 5.007002){_patch(<<'END')}elsif ($num < 5.007003){_patch(<<'END')}elsif ($num < 5.008009){_patch(<<'END')}else {_patch(<<'END')}}sub _patch_time_hires {_patch(<<'END')}sub _norm_ver {my$ver=shift;my@v=split(qr/[._]0*/,$ver);$v[2]||= 0;return sprintf '%d.%03d%03d',@v}sub _patch_develpatchperlversion {return if -d '.git';my$dpv=$Devel::PatchPerl::VERSION || "(unreleased)";_patch(<<"END")}qq[patchin'];
  --- doio.c.org  2004-06-07 23:14:45.000000000 +0200
  +++ doio.c  2003-11-04 08:03:03.000000000 +0100
  @@ -75,6 +75,16 @@
   #  endif
   #endif
  
  +#if _SEM_SEMUN_UNDEFINED
  +union semun
  +{
  +  int val;
  +  struct semid_ds *buf;
  +  unsigned short int *array;
  +  struct seminfo *__buf;
  +};
  +#endif
  +
   bool
   do_open(gv,name,len,as_raw,rawmode,rawperm,supplied_fp)
   GV *gv;
  END
  --- ext/IPC/SysV/SysV.xs.org  1998-07-20 10:20:07.000000000 +0200
  +++ ext/IPC/SysV/SysV.xs  2007-08-12 10:51:06.000000000 +0200
  @@ -3,9 +3,6 @@
   #include "XSUB.h"
   
   #include <sys/types.h>
  -#ifdef __linux__
  -#include <asm/page.h>
  -#endif
   #if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
   #include <sys/ipc.h>
   #ifdef HAS_MSG
  END
  --- ext/IPC/SysV/SysV.xs.org  2007-08-11 00:12:46.000000000 +0200
  +++ ext/IPC/SysV/SysV.xs  2007-08-11 00:10:51.000000000 +0200
  @@ -3,9 +3,6 @@
   #include "XSUB.h"
   
   #include <sys/types.h>
  -#ifdef __linux__
  -#   include <asm/page.h>
  -#endif
   #if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
   #ifndef HAS_SEM
   #   include <sys/ipc.h>
  END
  --- Configure
  +++ Configure
  @@ -3380,6 +3380,18 @@
   test "X$gfpthkeep" != Xy && gfpth=""
   EOSC
   
  +# gcc 3.1 complains about adding -Idirectories that it already knows about,
  +# so we will take those off from locincpth.
  +case "$gccversion" in
  +3*)
  +    echo "main(){}">try.c
  +    for incdir in `$cc -v -c try.c 2>&1 | \
  +       sed '1,/^#include <\.\.\.>/d;/^End of search list/,$d;s/^ //'` ; do
  +       locincpth=`echo $locincpth | sed s!$incdir!!`
  +    done
  +    $rm -f try try.*
  +esac
  +
   : What should the include directory be ?
   echo " "
   $echo $n "Hmm...  $c"
  END
  --- makedepend.SH
  +++ makedepend.SH
  @@ -58,6 +58,10 @@ case $PERL_CONFIG_SH in
         ;;
   esac
   
  +# Avoid localized gcc/cc messages
  +LC_ALL=C
  +export LC_ALL
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  END
  --- makedepend.SH.org	2000-03-02 18:12:26.000000000 +0000
  +++ makedepend.SH	2010-09-01 10:13:37.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -51,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -58,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -67,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -99,25 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				uwinfix=
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -130,22 +140,45 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
       if [ "$osname" = os390 -a "$file" = perly.c ]; then
           $echo '#endif' >>UU/$file.c
       fi
  -    $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  -    $sed \
  -	-e '1d' \
  -	-e '/^#.*<stdin>/d' \
  -	-e '/^#.*"-"/d' \
  -	-e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  -	-e 's/^[	 ]*#[	 ]*line/#/' \
  -	-e '/^# *[0-9][0-9]* *[".\/]/!d' \
  -	-e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  -	-e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  -	-e 's|: \./|: |' \
  -	-e 's|\.c\.c|.c|' $uwinfix | \
  -    $uniq | $sort | $uniq >> .deptmp
  +
  +    if [ "$osname" = os390 ]; then
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $sed \
  +    	    -e '/^#.*<stdin>/d' \
  +	    -e '/^#.*"-"/d' \
  +	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  +	    -e 's/^[	 ]*#[	 ]*line/#/' \
  +	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
  +	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  +	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  +	    -e 's|: \./|: |' \
  +	    -e 's|\.c\.c|.c|' $uwinfix | \
  +        $uniq | $sort | $uniq >> .deptmp
  +    else
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
  +        $sed \
  +	    -e '1d' \
  +	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
  +	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
  +	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  +	    -e 's/^[	 ]*#[	 ]*line/#/' \
  +	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
  +	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  +	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  +	    -e 's|: \./|: |' \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
  +        $uniq | $sort | $uniq >> .deptmp
  +    fi
   done
   
   $sed <$mf >$mf.new -e '1,/^# AUTOMATICALLY/!d'
  @@ -177,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -208,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
  --- makedepend.SH.org	2001-03-19 07:33:17.000000000 +0000
  +++ makedepend.SH	2010-09-01 10:14:47.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -51,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -58,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -67,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -99,29 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				if [ "$osname" = posix-bc ]; then
  -					uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/"
  -				else
  -					uwinfix=
  -				fi
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -134,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -151,18 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -196,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -227,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
  --- makedepend.SH.org	2003-07-30 23:46:59.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:15:47.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -63,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -72,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -104,29 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				if [ "$osname" = posix-bc ]; then
  -					uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/"
  -				else
  -					uwinfix=
  -				fi
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -139,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -156,21 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  -	    -e '/^#.*<builtin>/d' \
  -	    -e '/^#.*<built-in>/d' \
  -	    -e '/^#.*<command line>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -204,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -235,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
  --- makedepend.SH.org	2000-08-13 19:35:04.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:47:14.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -51,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -58,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -67,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -99,25 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				uwinfix=
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -130,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -147,18 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -192,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -223,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
  --- makedepend.SH.org	2001-03-11 16:30:08.000000000 +0000
  +++ makedepend.SH	2010-09-01 10:44:54.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -51,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -58,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -67,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -99,29 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				if [ "$osname" = posix-bc ]; then
  -					uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/"
  -				else
  -					uwinfix=
  -				fi
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -134,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -151,18 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -196,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -227,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
  --- makedepend.SH.org	2001-07-09 15:11:05.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:45:32.000000000 +0100
  @@ -18,10 +18,6 @@
   */*) cd `expr X$0 : 'X\(.*\)/'` ;;
   esac
   
  -case "$osname" in
  -amigaos) cat=/bin/cat ;; # must be absolute
  -esac
  -
   echo "Extracting makedepend (with variable substitutions)"
   rm -f makedepend
   $spitshell >makedepend <<!GROK!THIS!
  @@ -33,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -55,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -62,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -71,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -103,29 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				if [ "$osname" = posix-bc ]; then
  -					uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/"
  -				else
  -					uwinfix=
  -				fi
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -138,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -155,18 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -200,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -231,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
  --- makedepend.SH.org	2002-03-05 01:10:22.000000000 +0000
  +++ makedepend.SH	2010-09-01 10:46:13.000000000 +0100
  @@ -18,10 +18,6 @@
   */*) cd `expr X$0 : 'X\(.*\)/'` ;;
   esac
   
  -case "$osname" in
  -amigaos) cat=/bin/cat ;; # must be absolute
  -esac
  -
   echo "Extracting makedepend (with variable substitutions)"
   rm -f makedepend
   $spitshell >makedepend <<!GROK!THIS!
  @@ -33,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -55,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -62,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -71,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -116,7 +127,7 @@
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -129,6 +140,11 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
  @@ -143,13 +159,16 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c 2>&1 |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
               -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
               -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
   	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
  @@ -157,7 +176,7 @@
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -191,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -222,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
  --- makedepend.SH.org	2002-07-09 15:06:42.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:16:37.000000000 +0100
  @@ -58,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -78,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -123,7 +127,7 @@
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -136,6 +140,11 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
  @@ -157,7 +166,9 @@
               -e '/^#.*<builtin>/d' \
               -e '/^#.*<built-in>/d' \
               -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
   	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
  @@ -199,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  BADGER
  --- makedepend.SH.org	2003-06-05 19:11:10.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:24:39.000000000 +0100
  @@ -83,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -128,7 +127,7 @@
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -167,7 +166,9 @@
               -e '/^#.*<builtin>/d' \
               -e '/^#.*<built-in>/d' \
               -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
   	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
  @@ -209,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  BADGER
  --- Configure
  +++ Configure
  @@ -7851,6 +7851,21 @@ int main()
   	Gconvert((DOUBLETYPE)0.1, 8, 0, buf);
   	checkit("0.1", buf);
   
  +	Gconvert((DOUBLETYPE)0.01, 8, 0, buf);
  +	checkit("0.01", buf);
  +
  +	Gconvert((DOUBLETYPE)0.001, 8, 0, buf);
  +	checkit("0.001", buf);
  +
  +	Gconvert((DOUBLETYPE)0.0001, 8, 0, buf);
  +	checkit("0.0001", buf);
  +
  +	Gconvert((DOUBLETYPE)0.00009, 8, 0, buf);
  +	if (strlen(buf) > 5)
  +	    checkit("9e-005", buf); /* for Microsoft ?? */
  +	else
  +	    checkit("9e-05", buf);
  +
   	Gconvert((DOUBLETYPE)1.0, 8, 0, buf); 
   	checkit("1", buf);
   
  @@ -7889,6 +7904,19 @@ int main()
   	Gconvert((DOUBLETYPE)123.456, 8, 0, buf); 
   	checkit("123.456", buf);
   
  +	/* Testing of 1e+129 in bigintpm.t must not get extra '.' here. */
  +	Gconvert((DOUBLETYPE)1e34, 8, 0, buf);
  +	/* 34 should be enough to scare even long double
  +	 * places into using the e notation. */
  +	if (strlen(buf) > 5)
  +	    checkit("1e+034", buf); /* for Microsoft */
  +	else
  +	    checkit("1e+34", buf);
  +
  +	/* For Perl, if you add additional tests here, also add them to
  +	 * t/base/num.t for benefit of platforms not using Configure or
  +	 * overriding d_Gconvert */
  +
   	exit(0);
   }
   EOP
  END
  --- lib/Archive/Tar/t/02_methods.t
  +++ lib/Archive/Tar/t/02_methods.t
  @@ -70,6 +70,20 @@ my $LONG_FILE = qq[directory/really-really-really-really-really-really-really-re
   my $TOO_LONG    =   ($^O eq 'MSWin32' or $^O eq 'cygwin' or $^O eq 'VMS')
                       && length( cwd(). $LONG_FILE ) > 247;
   
  +if(!$TOO_LONG) {
  +    my $alt = File::Spec->catfile( cwd(), $LONG_FILE);
  +    eval 'mkpath([$alt]);';
  +    if($@)
  +    {
  +        $TOO_LONG = 1;
  +    }
  +    else
  +    {
  +        $@ = '';
  +        my $base = File::Spec->catfile( cwd(), 'directory');
  +        rmtree $base;
  +    }
  +}
   ### warn if we are going to skip long file names
   if ($TOO_LONG) {
       diag("No long filename support - long filename extraction disabled") if ! $ENV{PERL_CORE};
  END
  --- cpan/Archive-Tar/t/02_methods.t
  +++ cpan/Archive-Tar/t/02_methods.t
  @@ -70,6 +70,20 @@ my $LONG_FILE = qq[directory/really-really-really-really-really-really-really-re
   my $TOO_LONG    =   ($^O eq 'MSWin32' or $^O eq 'cygwin' or $^O eq 'VMS')
                       && length( cwd(). $LONG_FILE ) > 247;
   
  +if(!$TOO_LONG) {
  +    my $alt = File::Spec->catfile( cwd(), $LONG_FILE);
  +    eval 'mkpath([$alt]);';
  +    if($@)
  +    {
  +        $TOO_LONG = 1;
  +    }
  +    else
  +    {
  +        $@ = '';
  +        my $base = File::Spec->catfile( cwd(), 'directory');
  +        rmtree $base;
  +    }
  +}
   ### warn if we are going to skip long file names
   if ($TOO_LONG) {
       diag("No long filename support - long filename extraction disabled") if ! $ENV{PERL_CORE};
  END
  --- ext/ODBM_File/hints/linux.pl
  +++ ext/ODBM_File/hints/linux.pl
  @@ -1,8 +1,8 @@
   # uses GDBM dbm compatibility feature - at least on SuSE 8.0
   $self->{LIBS} = ['-lgdbm'];
   
  -# Debian/Ubuntu have /usr/lib/libgdbm_compat.so.3* but not this file,
  +# Debian/Ubuntu have libgdbm_compat.so but not this file,
   # so linking may fail
  -if (-e '/usr/lib/libgdbm_compat.so' or -e '/usr/lib64/libgdbm_compat.so') {
  -    $self->{LIBS}->[0] .= ' -lgdbm_compat';
  +foreach (split / /, $Config{libpth}) {
  +    $self->{LIBS}->[0] .= ' -lgdbm_compat' if -e $_.'/libgdbm_compat.so';
   }
  END
  --- make_ext.pl
  +++ make_ext.pl
  @@ -377,6 +377,10 @@ WriteMakefile(
   EOM
   	    close $fh or die "Can't close Makefile.PL: $!";
   	}
  +  eval {
  +    my $ftime = time - 4;
  +    utime $ftime, $ftime, 'Makefile.PL';
  +  };
   	print "\nRunning Makefile.PL in $ext_dir\n";
   
   	# Presumably this can be simplified
  END
  --- perlio.c
  +++ perlio.c
  @@ -2323,6 +2323,12 @@ PerlIO_init(pTHX)
   {
       /* MUTEX_INIT(&PL_perlio_mutex) is done in PERL_SYS_INIT3(). */
       PERL_UNUSED_CONTEXT;
  +    /*
  +     * No, for backwards compatibility (before PERL_SYS_INIT3 changed to be
  +     * defined as a separate function call), we need to call
  +     * MUTEX_INIT(&PL_perlio_mutex) (via the PERLIO_INIT macro).
  +     */
  +    PERLIO_INIT;
   }
   
   void
  END
  --- hv.c
  +++ hv.c
  @@ -31,7 +31,8 @@ holds the key and hash value.
   #define PERL_HASH_INTERNAL_ACCESS
   #include "perl.h"
   
  -#define HV_MAX_LENGTH_BEFORE_SPLIT 14
  +#define HV_MAX_LENGTH_BEFORE_REHASH 14
  +#define SHOULD_DO_HSPLIT(xhv) ((xhv)->xhv_keys > (xhv)->xhv_max) /* HvTOTALKEYS(hv) > HvMAX(hv) */
   
   STATIC void
   S_more_he(pTHX)
  @@ -705,23 +706,8 @@ Perl_hv_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen,
   	xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
   	if (!counter) {				/* initial entry? */
   	    xhv->xhv_fill++; /* HvFILL(hv)++ */
  -	} else if (xhv->xhv_keys > (IV)xhv->xhv_max) {
  +	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
   	    hsplit(hv);
  -	} else if(!HvREHASH(hv)) {
  -	    U32 n_links = 1;
  -
  -	    while ((counter = HeNEXT(counter)))
  -		n_links++;
  -
  -	    if (n_links > HV_MAX_LENGTH_BEFORE_SPLIT) {
  -		/* Use only the old HvKEYS(hv) > HvMAX(hv) condition to limit
  -		   bucket splits on a rehashed hash, as we're not going to
  -		   split it again, and if someone is lucky (evil) enough to
  -		   get all the keys in one list they could exhaust our memory
  -		   as we repeatedly double the number of buckets on every
  -		   entry. Linear search feels a less worse thing to do.  */
  -		hsplit(hv);
  -	    }
   	}
       }
   
  @@ -1048,7 +1034,7 @@ S_hsplit(pTHX_ HV *hv)
   
   
       /* Pick your policy for "hashing isn't working" here:  */
  -    if (longest_chain <= HV_MAX_LENGTH_BEFORE_SPLIT /* split worked?  */
  +    if (longest_chain <= HV_MAX_LENGTH_BEFORE_REHASH /* split worked?  */
   	|| HvREHASH(hv)) {
   	return;
       }
  @@ -1966,8 +1952,8 @@ S_share_hek_flags(pTHX_ const char *str, I32 len, register U32 hash, int flags)
   	xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
   	if (!next) {			/* initial entry? */
   	    xhv->xhv_fill++; /* HvFILL(hv)++ */
  -	} else if (xhv->xhv_keys > (IV)xhv->xhv_max /* HvKEYS(hv) > HvMAX(hv) */) {
  -		hsplit(PL_strtab);
  +	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
  +            hsplit(PL_strtab);
   	}
       }
   
  --- t/op/hash.t
  +++ t/op/hash.t
  @@ -39,22 +39,36 @@ use constant THRESHOLD => 14;
   use constant START     => "a";
   
   # some initial hash data
  -my %h2 = map {$_ => 1} 'a'..'cc';
  +my %h2;
  +my $counter= "a";
  +$h2{$counter++}++ while $counter ne 'cd';
   
   ok (!Internals::HvREHASH(%h2), 
       "starting with pre-populated non-pathological hash (rehash flag if off)");
   
   my @keys = get_keys(\%h2);
  +my $buckets= buckets(\%h2);
   $h2{$_}++ for @keys;
  +$h2{$counter++}++ while buckets(\%h2) == $buckets; # force a split
   ok (Internals::HvREHASH(%h2), 
  -    scalar(@keys) . " colliding into the same bucket keys are triggering rehash");
  +    scalar(@keys) . " colliding into the same bucket keys are triggering rehash after split");
  +
  +# returns the number of buckets in a hash
  +sub buckets {
  +    my $hr = shift;
  +    my $keys_buckets= scalar(%$hr);
  +    if ($keys_buckets=~m!/([0-9]+)\z!) {
  +        return 0+$1;
  +    } else {
  +        return 8;
  +    }
  +}
   
   sub get_keys {
       my $hr = shift;
   
       # the minimum of bits required to mount the attack on a hash
       my $min_bits = log(THRESHOLD)/log(2);
  -
       # if the hash has already been populated with a significant amount
       # of entries the number of mask bits can be higher
       my $keys = scalar keys %$hr;
  -- 
  1.7.4.1
  
  END
  --- ext/Hash-Util-FieldHash/t/10_hash.t
  +++ ext/Hash-Util-FieldHash/t/10_hash.t
  @@ -46,15 +46,29 @@ use constant START     => "a";
   
   # some initial hash data
   fieldhash my %h2;
  -%h2 = map {$_ => 1} 'a'..'cc';
  +my $counter= "a";
  +$h2{$counter++}++ while $counter ne 'cd';
   
   ok (!Internals::HvREHASH(%h2), 
       "starting with pre-populated non-pathological hash (rehash flag if off)");
   
   my @keys = get_keys(\%h2);
  +my $buckets= buckets(\%h2);
   $h2{$_}++ for @keys;
  +$h2{$counter++}++ while buckets(\%h2) == $buckets; # force a split
   ok (Internals::HvREHASH(%h2), 
  -    scalar(@keys) . " colliding into the same bucket keys are triggering rehash");
  +    scalar(@keys) . " colliding into the same bucket keys are triggering rehash after split");
  +
  +# returns the number of buckets in a hash
  +sub buckets {
  +    my $hr = shift;
  +    my $keys_buckets= scalar(%$hr);
  +    if ($keys_buckets=~m!/([0-9]+)\z!) {
  +        return 0+$1;
  +    } else {
  +        return 8;
  +    }
  +}
   
   sub get_keys {
       my $hr = shift;
  --- hv.c
  +++ hv.c
  @@ -35,7 +35,8 @@ holds the key and hash value.
   #define PERL_HASH_INTERNAL_ACCESS
   #include "perl.h"
   
  -#define HV_MAX_LENGTH_BEFORE_SPLIT 14
  +#define HV_MAX_LENGTH_BEFORE_REHASH 14
  +#define SHOULD_DO_HSPLIT(xhv) ((xhv)->xhv_keys > (xhv)->xhv_max) /* HvTOTALKEYS(hv) > HvMAX(hv) */
   
   static const char S_strtab_error[]
       = "Cannot modify shared string table in hv_%s";
  @@ -818,23 +819,8 @@ Perl_hv_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen,
   	xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
   	if (!counter) {				/* initial entry? */
   	    xhv->xhv_fill++; /* HvFILL(hv)++ */
  -	} else if (xhv->xhv_keys > (IV)xhv->xhv_max) {
  +	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
   	    hsplit(hv);
  -	} else if(!HvREHASH(hv)) {
  -	    U32 n_links = 1;
  -
  -	    while ((counter = HeNEXT(counter)))
  -		n_links++;
  -
  -	    if (n_links > HV_MAX_LENGTH_BEFORE_SPLIT) {
  -		/* Use only the old HvKEYS(hv) > HvMAX(hv) condition to limit
  -		   bucket splits on a rehashed hash, as we're not going to
  -		   split it again, and if someone is lucky (evil) enough to
  -		   get all the keys in one list they could exhaust our memory
  -		   as we repeatedly double the number of buckets on every
  -		   entry. Linear search feels a less worse thing to do.  */
  -		hsplit(hv);
  -	    }
   	}
       }
   
  @@ -1180,7 +1166,7 @@ S_hsplit(pTHX_ HV *hv)
   
   
       /* Pick your policy for "hashing isn't working" here:  */
  -    if (longest_chain <= HV_MAX_LENGTH_BEFORE_SPLIT /* split worked?  */
  +    if (longest_chain <= HV_MAX_LENGTH_BEFORE_REHASH /* split worked?  */
   	|| HvREHASH(hv)) {
   	return;
       }
  @@ -2506,8 +2492,8 @@ S_share_hek_flags(pTHX_ const char *str, I32 len, register U32 hash, int flags)
   	xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
   	if (!next) {			/* initial entry? */
   	    xhv->xhv_fill++; /* HvFILL(hv)++ */
  -	} else if (xhv->xhv_keys > (IV)xhv->xhv_max /* HvKEYS(hv) > HvMAX(hv) */) {
  -		hsplit(PL_strtab);
  +	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
  +            hsplit(PL_strtab);
   	}
       }
   
  diff --git a/t/op/hash.t b/t/op/hash.t
  index 9bde518..45eb782 100644
  --- t/op/hash.t
  +++ t/op/hash.t
  @@ -39,22 +39,36 @@ use constant THRESHOLD => 14;
   use constant START     => "a";
   
   # some initial hash data
  -my %h2 = map {$_ => 1} 'a'..'cc';
  +my %h2;
  +my $counter= "a";
  +$h2{$counter++}++ while $counter ne 'cd';
   
   ok (!Internals::HvREHASH(%h2), 
       "starting with pre-populated non-pathological hash (rehash flag if off)");
   
   my @keys = get_keys(\%h2);
  +my $buckets= buckets(\%h2);
   $h2{$_}++ for @keys;
  +$h2{$counter++}++ while buckets(\%h2) == $buckets; # force a split
   ok (Internals::HvREHASH(%h2), 
  -    scalar(@keys) . " colliding into the same bucket keys are triggering rehash");
  +    scalar(@keys) . " colliding into the same bucket keys are triggering rehash after split");
  +
  +# returns the number of buckets in a hash
  +sub buckets {
  +    my $hr = shift;
  +    my $keys_buckets= scalar(%$hr);
  +    if ($keys_buckets=~m!/([0-9]+)\z!) {
  +        return 0+$1;
  +    } else {
  +        return 8;
  +    }
  +}
   
   sub get_keys {
       my $hr = shift;
   
       # the minimum of bits required to mount the attack on a hash
       my $min_bits = log(THRESHOLD)/log(2);
  -
       # if the hash has already been populated with a significant amount
       # of entries the number of mask bits can be higher
       my $keys = scalar keys %$hr;
  -- 
  1.7.4.1
  
  
  END
  diff --git a/Configure b/Configure
  index 19bed50..e4e4075 100755
  --- Configure
  +++ Configure
  @@ -3312,6 +3312,9 @@ EOM
   			;;
   		next*) osname=next ;;
   		nonstop-ux) osname=nonstopux ;;
  +		bitrig) osname=bitrig
  +			osvers="$3"
  +			;;
   		openbsd) osname=openbsd
                   	osvers="$3"
                   	;;
  BOOGLE
  diff --git a/Makefile.SH b/Makefile.SH
  index 17298fa..ecaa8ac 100755
  --- Makefile.SH
  +++ Makefile.SH
  @@ -77,7 +77,7 @@ true)
   	sunos*)
   		linklibperl="-lperl"
   		;;
  -	netbsd*|freebsd[234]*|openbsd*)
  +	netbsd*|freebsd[234]*|openbsd*|bitrig*)
   		linklibperl="-L. -lperl"
   		;;
   	interix*)
  BITRIGM1
  diff --git a/Makefile.SH b/Makefile.SH
  index 17298fa..ecaa8ac 100755
  --- Makefile.SH
  +++ Makefile.SH
  @@ -77,7 +77,7 @@ true)
   	sunos*)
   		linklibperl="-lperl"
   		;;
  -	netbsd*|freebsd[234]*|openbsd*|dragonfly*)
  +	netbsd*|freebsd[234]*|openbsd*|dragonfly*|bitrig*)
   		linklibperl="-L. -lperl"
   		;;
   	interix*)
  BITRIGMX
  diff --git a/Configure b/Configure
  index 19bed50..e4e4075 100755
  --- Configure	Thu Aug 22 23:20:14 2013
  +++ Configure	Thu Aug 22 23:20:35 2013
  @@ -7855,7 +7855,7 @@
   	solaris)
   		xxx="-R $shrpdir"
   		;;
  -	freebsd|netbsd|openbsd)
  +	freebsd|netbsd|openbsd|bitrig)
   		xxx="-Wl,-R$shrpdir"
   		;;
   	bsdos|linux|irix*|dec_osf)
  BITRIGC3
  diff --git a/Configure b/Configure
  index 19bed50..e4e4075 100755
  --- Configure	Thu Aug 22 22:56:04 2013
  +++ Configure	Thu Aug 22 22:56:25 2013
  @@ -7892,7 +7892,7 @@
   	solaris)
   		xxx="-R $shrpdir"
   		;;
  -	freebsd|netbsd|openbsd|interix)
  +	freebsd|netbsd|openbsd|interix|bitrig)
   		xxx="-Wl,-R$shrpdir"
   		;;
   	bsdos|linux|irix*|dec_osf|gnu*)
  BITRIGC2
  diff --git a/Configure b/Configure
  index 19bed50..e4e4075 100755
  --- Configure
  +++ Configure
  @@ -8328,7 +8331,7 @@ if "$useshrplib"; then
   	solaris)
   		xxx="-R $shrpdir"
   		;;
  -	freebsd|netbsd|openbsd|interix|dragonfly)
  +	freebsd|netbsd|openbsd|interix|dragonfly|bitrig)
   		xxx="-Wl,-R$shrpdir"
   		;;
   	bsdos|linux|irix*|dec_osf|gnu*)
  BITRIGC1
  diff --git a/Configure b/Configure
  index 19bed50..e4e4075 100755
  --- Configure
  +++ Configure
  @@ -8328,7 +8331,7 @@ if "$useshrplib"; then
   	solaris)
   		xxx="-R $shrpdir"
   		;;
  -	freebsd|mirbsd|netbsd|openbsd|interix|dragonfly)
  +	freebsd|mirbsd|netbsd|openbsd|interix|dragonfly|bitrig)
   		xxx="-Wl,-R$shrpdir"
   		;;
   	bsdos|linux|irix*|dec_osf|gnu*)
  BITRIGCX
  diff --git a/Configure b/Configure
  index ff511d3..30ab78a 100755
  --- Configure
  +++ Configure
  @@ -8048,7 +8048,20 @@ EOM
   			      ;;
   			linux|irix*|gnu*)  dflt="-shared $optimize" ;;
   			next)  dflt='none' ;;
  -			solaris) dflt='-G' ;;
  +			solaris) # See [perl #66604].  On Solaris 11, gcc -m64 on amd64
  +				# appears not to understand -G.  gcc versions at
  +				# least as old as 3.4.3 support -shared, so just
  +				# use that with Solaris 11 and later, but keep
  +				# the old behavior for older Solaris versions.
  +				case "$gccversion" in
  +					'') dflt='-G' ;;
  +					*)	case "$osvers" in
  +							2.?|2.10) dflt='-G' ;;
  +							*) dflt='-shared' ;;
  +						esac
  +						;;
  +				esac
  +				;;
   			sunos) dflt='-assert nodefinitions' ;;
   			svr4*|esix*|nonstopux) dflt="-G $ldflags" ;;
   	        *)     dflt='none' ;;
  BUBBLE
  diff --git a/regexec.c b/regexec.c
  index bc38839..b865b46 100644
  --- regexec.c
  +++ regexec.c
  @@ -6662,7 +6662,7 @@ S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p,
       scan = *startposp;
       if (max == REG_INFTY)
   	max = I32_MAX;
  -    else if (! utf8_target && scan + max < loceol)
  +    else if (! utf8_target && loceol - scan > max)
   	loceol = scan + max;
   
       /* Here, for the case of a non-UTF-8 target we have adjusted <loceol> down
  @@ -6711,7 +6711,7 @@ S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p,
   	    scan = loceol;
   	break;
       case CANY:  /* Move <scan> forward <max> bytes, unless goes off end */
  -        if (utf8_target && scan + max < loceol) {
  +        if (utf8_target && loceol - scan > max) {
   
               /* <loceol> hadn't been adjusted in the UTF-8 case */
               scan +=  max;
  @@ -6730,7 +6730,7 @@ S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p,
            * can use UTF8_IS_INVARIANT() even if the pattern isn't UTF-8, as it's
            * true iff it doesn't matter if the argument is in UTF-8 or not */
           if (UTF8_IS_INVARIANT(c) || (! utf8_target && ! is_utf8_pat)) {
  -            if (utf8_target && scan + max < loceol) {
  +            if (utf8_target && loceol - scan > max) {
                   /* We didn't adjust <loceol> because is UTF-8, but ok to do so,
                    * since here, to match at all, 1 char == 1 byte */
                   loceol = scan + max;
  @@ -6910,7 +6910,7 @@ S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p,
           /* FALLTHROUGH */
   
       case POSIXA:
  -        if (utf8_target && scan + max < loceol) {
  +        if (utf8_target && loceol - scan > max) {
   
               /* We didn't adjust <loceol> at the beginning of this routine
                * because is UTF-8, but it is actually ok to do so, since here, to
  diff --git a/t/re/pat_rt_report.t b/t/re/pat_rt_report.t
  index 2244fdf..9a9b5f5 100644
  --- t/re/pat_rt_report.t
  +++ t/re/pat_rt_report.t
  @@ -22,7 +22,7 @@ BEGIN {
   }
   
   
  -plan tests => 2530;  # Update this when adding/deleting tests.
  +plan tests => 2532;  # Update this when adding/deleting tests.
   
   run_tests() unless caller;
   
  @@ -1158,6 +1158,21 @@ EOP
               '$_ = "abc"; /b/g; $_ = "hello"; print eval q|$\'|,"\n"',
               "c\n", {}, '$\' first mentioned after match');
       }
  +
  +    {
  +	# [perl #118175] threaded perl-5.18.0 fails pat_rt_report_thr.t
  +	# this tests some related failures
  +	#
  +	# The tests in the block *only* fail when run on 32-bit systems
  +	# with a malloc that allocates above the 2GB line.  On the system
  +	# in the report above that only happened in a thread.
  +	my $s = "\x{1ff}" . "f" x 32;
  +	ok($s =~ /\x{1ff}[[:alpha:]]+/gca, "POSIXA pointer wrap");
  +
  +	# this one segfaulted under the conditions above
  +	# of course, CANY is evil, maybe it should crash
  +	ok($s =~ /.\C+/, "CANY pointer wrap");
  +    }
   } # End of sub run_tests
   
   1;
  BOBBLE
  diff --git a/Makefile.SH b/Makefile.SH
  index ac5ade4..8e66603 100755
  --- Makefile.SH
  +++ Makefile.SH
  @@ -295,6 +295,30 @@ obj = $(obj1) $(obj2) $(obj3) $(ARCHOBJS)
   # EMBEDDING is on by default, and MULTIPLICITY doesn't work.
   #
  
  +.PHONY: all compile translators utilities \
  +       FORCE \
  +       preplibrary \
  +       install install-strip install-all install-verbose install-silent \
  +       no-install install.perl install.man installman install.html installhtml \
  +       check_byacc run_byacc \
  +       regen_headers regen_pods regen_all \
  +       clean _tidy _mopup _cleaner1 _cleaner2 \
  +       realclean _realcleaner clobber _clobber \
  +       distclean veryclean _verycleaner \
  +       lint \
  +       depend \
  +       test check test_prep _test_prep \
  +       test_tty test-tty _test_tty test_notty test-notty _test_notty \
  +       utest ucheck test.utf8 check.utf8 \
  +       test.third check.third utest.third ucheck.third test_notty.third \
  +       test.deparse test_notty.deparse \
  +       minitest \
  +       ok okfile oknack okfilenack nok nokfile noknack nokfilenack \
  +       clist hlist shlist pllist \
  +       distcheck \
  +       elc \
  +       etags ctags tags
  +
   lintflags = -hbvxac
  
   .c$(OBJ_EXT):
  END
  diff --git a/sv.c b/sv.c
  index 06c0b83..ac1d972 100644
  --- sv.c
  +++ sv.c
  @@ -1574,14 +1574,19 @@ Perl_sv_grow(pTHX_ SV *const sv, STRLEN newlen)
           newlen++;
   #endif
   
  +#if defined(PERL_USE_MALLOC_SIZE) && defined(Perl_safesysmalloc_size)
  +#define PERL_UNWARANTED_CHUMMINESS_WITH_MALLOC
  +#endif
  +
       if (newlen > SvLEN(sv)) {		/* need more room? */
   	STRLEN minlen = SvCUR(sv);
   	minlen += (minlen >> PERL_STRLEN_EXPAND_SHIFT) + 10;
   	if (newlen < minlen)
   	    newlen = minlen;
  -#ifndef Perl_safesysmalloc_size
  -        if (SvLEN(sv))
  +#ifndef PERL_UNWARANTED_CHUMMINESS_WITH_MALLOC
  +        if (SvLEN(sv)) {
               newlen = PERL_STRLEN_ROUNDUP(newlen);
  +        }
   #endif
   	if (SvLEN(sv) && s) {
   	    s = (char*)saferealloc(s, newlen);
  @@ -1593,7 +1598,7 @@ Perl_sv_grow(pTHX_ SV *const sv, STRLEN newlen)
   	    }
   	}
   	SvPV_set(sv, s);
  -#ifdef Perl_safesysmalloc_size
  +#ifdef PERL_UNWARANTED_CHUMMINESS_WITH_MALLOC
   	/* Do this here, do it once, do it right, and then we will never get
   	   called back into sv_grow() unless there really is some growing
   	   needed.  */
  COWSAY
  diff --git a/perl.c b/perl.c
  index 82e5538..b9e02fe 100644
  --- perl.c
  +++ perl.c
  @@ -3758,7 +3758,7 @@ S_open_script(pTHX_ const char *scriptname, bool dosearch, SV *sv,
   #       ifdef VMS
               cpp_discard_flag = "";
   #       else
  -            cpp_discard_flag = "-C";
  +            cpp_discard_flag = "-C -ffreestanding";
   #       endif
   
   #       ifdef OS2
  END
  diff --git a/perl.c b/perl.c
  index 623f9be..014d318 100644
  --- perl.c
  +++ perl.c
  @@ -2631,7 +2631,7 @@ sed %s -e \"/^[^#]/b\" \
    -e '/^#[ 	]*undef[ 	]/b' \
    -e '/^#[ 	]*endif/b' \
    -e 's/^[ 	]*#.*//' \
  - %s | %"SVf" -C %"SVf" %s",
  + %s | %"SVf" -C -ffreestanding %"SVf" %s",
   #  endif
   #ifdef LOC_SED
   	  LOC_SED,
  END
  diff --git a/META.json b/META.json
  index 64caea7..200e324 100644
  --- META.json
  +++ META.json
  @@ -118,7 +118,7 @@
            "TestInit.pm"
         ]
      },
  -   "release_status" : "testing",
  +   "release_status" : "stable",
      "resources" : {
         "bugtracker" : {
            "web" : "http://rt.perl.org/perlbug/"
  DOGSAY
  --- handy.h
  +++ handy.h
  @@ -43,12 +43,10 @@
      this file first, then you will have to manually set -DHAS_BOOL in 
      your command line to avoid a conflict.
   */
  -#ifdef _G_HAVE_BOOL
  -# if _G_HAVE_BOOL
  +#ifdef __GNUG__
   #  ifndef HAS_BOOL
   #   define HAS_BOOL 1
   #  endif
  -# endif
   #endif
   
   /* The NeXT dynamic loader headers will not build with the bool macro
  END
  #! /bin/sh
  case $PERL_CONFIG_SH in
  '')
  	if test -f config.sh; then TOP=.;
  	elif test -f ../config.sh; then TOP=..;
  	elif test -f ../../config.sh; then TOP=../..;
  	elif test -f ../../../config.sh; then TOP=../../..;
  	elif test -f ../../../../config.sh; then TOP=../../../..;
  	else
  		echo "Can't find config.sh."; exit 1
  	fi
  	. $TOP/config.sh
  	;;
  esac
  : This forces SH files to create target in same directory as SH file.
  : This is so that make depend always knows where to find SH derivatives.
  case "$0" in
  */*) cd `expr X$0 : 'X\(.*\)/'` ;;
  esac
  
  echo "Extracting makedepend (with variable substitutions)"
  rm -f makedepend
  $spitshell >makedepend <<!GROK!THIS!
  $startsh
  # makedepend.SH
  #
  MAKE=$make
  trnl='$trnl'
  !GROK!THIS!
  $spitshell >>makedepend <<'!NO!SUBS!'
  
  if test -d .depending; then
  	echo "$0: Already running, exiting."
  	exit 0
  fi
  
  mkdir .depending
  
  # This script should be called with 
  #     sh ./makedepend MAKE=$(MAKE)
  case "$1" in 
  	MAKE=*) eval $1; shift ;;
  esac
  
  export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
  
  case $PERL_CONFIG_SH in
  '')
  	if test -f config.sh; then TOP=.;
  	elif test -f ../config.sh; then TOP=..;
  	elif test -f ../../config.sh; then TOP=../..;
  	elif test -f ../../../config.sh; then TOP=../../..;
  	elif test -f ../../../../config.sh; then TOP=../../../..;
  	else
  		echo "Can't find config.sh."; exit 1
  	fi
  	. $TOP/config.sh
  	;;
  esac
  
  # Avoid localized gcc messages
  case "$ccname" in
      gcc) LC_ALL=C ; export LC_ALL ;;
  esac
  
  # We need .. when we are in the x2p directory if we are using the
  # cppstdin wrapper script.
  # Put .. and . first so that we pick up the present cppstdin, not
  # an older one lying about in /usr/local/bin.
  PATH=".$path_sep..$path_sep$PATH"
  export PATH
  
  case "$osname" in
  amigaos) cat=/bin/cat ;; # must be absolute
  esac
  
  $cat /dev/null >.deptmp
  $rm -f *.c.c c/*.c.c
  if test -f Makefile; then
      rm -f $firstmakefile
      cp Makefile $firstmakefile
      # On QNX, 'cp' preserves timestamp, so $firstmakefile appears
      # to be out of date.  I don't know if OS/2 has touch, so do this:
      case "$osname" in
      os2) ;;
      *) $touch $firstmakefile ;;
      esac
  fi
  mf=$firstmakefile
  if test -f $mf; then
      defrule=`<$mf sed -n		\
  	-e '/^\.c\$(OBJ_EXT):.*;/{'	\
  	-e    's/\$\*\.c//'		\
  	-e    's/^[^;]*;[	 ]*//p'	\
  	-e    q				\
  	-e '}'				\
  	-e '/^\.c\$(OBJ_EXT): *$/{'	\
  	-e    N				\
  	-e    's/\$\*\.c//'		\
  	-e    's/^.*\n[	 ]*//p'		\
  	-e    q				\
  	-e '}'`
  fi
  case "$defrule" in
  '') defrule='$(CC) -c $(CFLAGS)' ;;
  esac
  
  : Create files in UU directory to avoid problems with long filenames
  : on systems with 14 character filename limits so file.c.c and file.c
  : might be identical
  $test -d UU || mkdir UU
  
  $MAKE clist || ($echo "Searching for .c files..."; \
  	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
  for file in `$cat .clist`; do
  # for file in `cat /dev/null`; do
      case "$osname" in
      uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
      os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
      cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
      posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
      vos)      uwinfix="-e s/\#/\\\#/" ;;
      *)        uwinfix="" ;;
      esac
      case "$file" in
      *.c) filebase=`basename $file .c` ;;
      *.y) filebase=`basename $file .y` ;;
      esac
      case "$file" in
      */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
      *)   finc= ;;
      esac
      $echo "Finding dependencies for $filebase$_o."
      # Below, we strip out all but preprocessor directives.
      # We have to take care of situations like
      #       #if defined(FOO) BAR   /* comment line 1
      #                                 more comment lines */
      # If we just delete text starting from the '/*' to the end of line, we will
      # screw up cases like
      #      #if defined(FOO)    /* comment */ \
      #          && defined(BAR) /* comment */ \
      #          && defined(BAZ) /* comment */ \
      #               etc.
      # Also, in lines like
      #      #defined FOO(a,b)    a/**/b
      # the comment may be important and so needs to be retained.
      # This code processes the single-line comments first; it assumes there is
      # at most one straightforward comment per continued preprocessor line,
      # replacing each non-empty comment (and its surrounding white space) by a
      # single space.  (sed only has a greedy '*' quantifier, so this doesn't
      # work right if there are multiple comments per line, and strings can look
      # like comments to it; both are unlikely in a preprocessor statement.) Any
      # continuation line is joined, and the process repeated on the enlarged
      # line as long as there are continuations.  At the end, if there are any
      # comments remaining, they are either completely empty or are like the
      # first situation.  The latter are just deleted by first deleting to the
      # end of line (including preceding white space) things that start with '/*'
      # and the next char isn't a '*'; then things that start with '/**', but the
      # next char isn't a '/'.  (Subsequent lines of the comment are irrelevant
      # and get dropped.)  At the end, we unjoin very long lines to avoid
      # preprocessor limitations
      ( $echo "#line 2 \"$file\"";                               \
        $sed -n <$file                                           \
  	-e "/^${filebase}_init(/q"                             \
          -e ': testcont'                                        \
  	-e '/^[ 	]*#/s|[ 	]*/\*..*\*/[ 	]*| |' \
          -e '/\\$/{'                                            \
              -e 'N'                                             \
              -e 'b testcont'                                    \
          -e '}'                                                 \
  	-e 's/\\\n//g'                                         \
  	-e '/^#line/d'                                         \
  	-e '/^[ 	]*#/{'                                 \
  	    -e 's|[ 	]*/\*[^*].*$||'                        \
  	    -e 's|[ 	]*/\*\*[^/].*$||'                      \
              -e 's/.\{255\}/&\\\n/g'                           \
  	    -e p                                               \
  	-e '}' ) >UU/$file.c
  
      # We're not sure why this was there; the #endif is extraneous on modern z/OS
      #if [ "$osname" = os390 -a "$file" = perly.c ]; then
      #   $echo '#endif' >>UU/$file.c
      #fi
  
      if [ "$osname" = os390 ]; then
          $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
          $sed \
      	    -e '/^#.*<stdin>/d' \
  	    -e '/^#.*"-"/d' \
  	    -e '/^#.*git_version\.h/d' \
  	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  	    -e 's/^[	 ]*#[	 ]*line/#/' \
  	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
  	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  	    -e 's|: \./|: |' \
  	    -e 's|\.c\.c|.c|' $uwinfix | \
          $uniq | $sort | $uniq >> .deptmp
      else
          $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
          $sed \
  	    -e '1d' \
  	    -e '/^#.*<stdin>/d' \
              -e '/^#.*<builtin>/d' \
              -e '/^#.*<built-in>/d' \
              -e '/^#.*<command line>/d' \
              -e '/^#.*<command-line>/d' \
  	    -e '/^#.*"-"/d' \
  	    -e '/^#.*"\/.*\/"/d' \
  	    -e '/: file path prefix .* never used$/d' \
  	    -e '/^#.*git_version\.h/d' \
  	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  	    -e 's/^[	 ]*#[	 ]*line/#/' \
  	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
  	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  	    -e 's|: \./|: |' \
             -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
          $uniq | $sort | $uniq >> .deptmp
      fi
      echo "$filebase\$(OBJ_EXT): $@" >> .deptmp
  done
  
  $sed <$mf >$mf.new -e '1,/^# AUTOMATICALLY/!d'
  
  if $test -s .deptmp; then
      $echo "Updating $mf..."
      $echo "# If this runs make out of memory, delete /usr/include lines." \
  	>> $mf.new
      if [ "$osname" = vos ]; then
          $sed 's|\.incl\.c|.h|' .deptmp >.deptmp.vos
          mv -f .deptmp.vos .deptmp
      fi
      $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
         >>$mf.new
  else
      $MAKE hlist || ($echo "Searching for .h files..."; \
  	$echo *.h | $tr ' ' $trnl | $egrep -v '\*' >.hlist)
      $echo "You don't seem to have a proper C preprocessor.  Using grep instead."
      $egrep '^#include ' `cat .clist` `cat .hlist`  >.deptmp
      $echo "Updating $mf..."
      <.clist $sed -n							\
  	-e '/\//{'							\
  	-e   's|^\(.*\)/\(.*\)\.c|\2\$(OBJ_EXT): \1/\2.c; '"$defrule \1/\2.c|p"	\
  	-e   d								\
  	-e '}'								\
  	-e 's|^\(.*\)\.c|\1\$(OBJ_EXT): \1.c|p' >> $mf.new
      <.hlist $sed -n 's|\(.*/\)\(.*\)|s= \2= \1\2=|p' >.hsed
      <.deptmp $sed -n 's|c:#include "\(.*\)".*$|o: \1|p' | \
         $sed 's|^[^;]*/||' | \
         $sed -f .hsed >> $mf.new
      <.deptmp $sed -n 's|h:#include "\(.*\)".*$|h: \1|p' | \
         $sed -f .hsed >> $mf.new
  fi
  $rm -f $mf.old
  $cp $mf $mf.old
  $rm -f $mf
  $cp $mf.new $mf
  $rm $mf.new
  $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  $rm -rf .deptmp UU .clist .hlist .hsed .cout .cerr
  rmdir .depending
  
  !NO!SUBS!
  $eunicefix makedepend
  chmod +x makedepend
  END
  --- Configure
  +++ Configure
  @@ -21,7 +21,7 @@
   # $Id: Head.U,v 3.0.1.9 1997/02/28 15:02:09 ram Exp $
   #
   # Generated on Tue Jul  7 10:10:21 EDT 1998 [metaconfig 3.0 PL70]
  -# (with additional metaconfig patches by doughera@lafayette.edu)
  +# (with additional metaconfig patches by jhi@iki.fi)
   
   cat >/tmp/c1$$ <<EOF
   ARGGGHHHH!!!!!
  @@ -56,33 +56,6 @@ case "$0" in
   	;;
   esac
   
  -: the newline for tr
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\n' x 2>/dev/null`" in
  -	foox)
  -		trnl='\n'
  -		;;
  -	esac
  -fi
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\012' x 2>/dev/null`" in
  -	foox)
  -		trnl='\012'
  -		;;
  -	esac
  -fi
  -if test -n "$DJGPP"; then
  -	trnl='\012'
  -fi
  -if test X"$trnl" = X; then
  -	cat <<EOM >&2
  -
  -$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  -
  -EOM
  -	exit 1
  -fi
  -
   : Proper separator for the PATH environment variable
   p_=:
   : On OS/2 this directory should exist if this is not floppy only system :-]
  @@ -391,7 +364,6 @@ d_getservprotos=''
   d_getsbyname=''
   d_getsbyport=''
   d_gnulibc=''
  -i_arpainet=''
   d_htonl=''
   d_inetaton=''
   d_isascii=''
  @@ -540,6 +512,7 @@ dlsrc=''
   ld=''
   lddlflags=''
   usedl=''
  +ebcdic=''
   doublesize=''
   fpostype=''
   gidtype=''
  @@ -548,6 +521,7 @@ h_fcntl=''
   h_sysfile=''
   db_hashtype=''
   db_prefixtype=''
  +i_arpainet=''
   i_db=''
   i_dbm=''
   i_rpcsvcdbm=''
  @@ -633,6 +607,7 @@ libpth=''
   loclibpth=''
   plibpth=''
   xlibpth=''
  +ignore_versioned_solibs=''
   libs=''
   lns=''
   lseektype=''
  @@ -697,11 +672,13 @@ randbits=''
   installscript=''
   scriptdir=''
   scriptdirexp=''
  +selectminbits=''
   selecttype=''
   sh=''
   sig_name=''
   sig_name_init=''
   sig_num=''
  +sig_num_init=''
   installsitearch=''
   sitearch=''
   sitearchexp=''
  @@ -719,6 +696,7 @@ startperl=''
   startsh=''
   stdchar=''
   sysman=''
  +trnl=''
   uidtype=''
   nm_opt=''
   nm_so_opt=''
  @@ -733,7 +711,6 @@ mips_type=''
   usrinc=''
   defvoidused=''
   voidflags=''
  -ebcdic=''
   CONFIG=''
   
   define='define'
  @@ -836,6 +813,8 @@ plibpth=''
   
   : default library list
   libswanted=''
  +: some systems want only to use the non-versioned libso:s
  +ignore_versioned_solibs=''
   : Possible local include directories to search.
   : Set locincpth to "" in a hint file to defeat local include searches.
   locincpth="/usr/local/include /opt/local/include /usr/gnu/include"
  @@ -904,7 +883,7 @@ case "$sh" in
   $me:  Fatal Error:  I can't find a Bourne Shell anywhere.  
   
   Usually it's in /bin/sh.  How did you even get this far?
  -Please contact me (Andy Dougherty) at doughera@lafayette.edu and 
  +Please contact me (Jarkko Hietaniemi) at jhi@iki.fi and 
   we'll try to straighten this all out.
   EOM
   	exit 1
  @@ -1240,7 +1219,7 @@ cat >extract <<'EOS'
   CONFIG=true
   echo "Doing variable substitutions on .SH files..."
   if test -f $src/MANIFEST; then
  -	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH'`
  +	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH$'`
   else
   	echo "(Looking for .SH files under the source directory.)"
   	set x `(cd $src; find . -name "*.SH" -print)`
  @@ -1373,7 +1352,7 @@ THIS PACKAGE SEEMS TO BE INCOMPLETE.
   You have the option of continuing the configuration process, despite the
   distinct possibility that your kit is damaged, by typing 'y'es.  If you
   do, don't blame me if something goes wrong.  I advise you to type 'n'o
  -and contact the author (doughera@lafayette.edu).
  +and contact the author (jhi@iki.fi).
   
   EOM
   		echo $n "Continue? [n] $c" >&4
  @@ -1396,6 +1375,30 @@ else
   fi
   rm -f missing x??
   
  +echo " "
  +: Find the appropriate value for a newline for tr
  +if test -n "$DJGPP"; then
  +       trnl='\012'
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\n' x 2>/dev/null`" in
  +	foox) trnl='\n' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\012' x 2>/dev/null`" in
  +	foox) trnl='\012' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	cat <<EOM >&2
  +
  +$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  +
  +EOM
  +	exit 1
  +fi
  +
   : compute the number of columns on the terminal for proper question formatting
   case "$COLUMNS" in
   '') COLUMNS='80';;
  @@ -1574,7 +1577,7 @@ Much effort has been expended to ensure that this shell script will run on any
   Unix system.  If despite that it blows up on yours, your best bet is to edit
   Configure and run it again.  If you can't run Configure for some reason,
   you'll have to generate a config.sh file by hand.  Whatever problems you
  -have, let me (doughera@lafayette.edu) know how I blew it.
  +have, let me (jhi@iki.fi) know how I blew it.
   
   This installation script affects things in two ways:
   
  @@ -1841,14 +1844,14 @@ ABYZ)
   	    *C9D1*|*c9d1*)
   		echo "Hey, this might be EBCDIC." >&4
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
  +		    case "`echo IJ | $tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
   		    ij) up='[A-IJ-RS-Z]'
   		        low='[a-ij-rs-z]'
   			;;
   		    esac
   		fi
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
  +		    case "`echo IJ | $tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
   		    ij) up='A-IJ-RS-Z'
   		        low='a-ij-rs-z'
   			;;
  @@ -1941,7 +1944,7 @@ EOM
   	(cd $src/hints; ls -C *.sh) | $sed 's/\.sh/   /g' >&4
   	dflt=''
   	: Half the following guesses are probably wrong... If you have better
  -	: tests or hints, please send them to doughera@lafayette.edu
  +	: tests or hints, please send them to jhi@iki.fi
   	: The metaconfig authors would also appreciate a copy...
   	$test -f /irix && osname=irix
   	$test -f /xenix && osname=sco_xenix
  @@ -2025,7 +2028,7 @@ EOM
   			osvers="$3"
   			;;
   		dynixptx*) osname=dynixptx
  -			osvers="$3"
  +			osvers=`echo "$4" | $sed 's/^v//'`
   			;;
   		freebsd) osname=freebsd 
   			osvers="$3" ;;
  @@ -3442,7 +3445,11 @@ cat <<'EOT' >testcpp.c
   ABC.XYZ
   EOT
   cd ..
  +if test ! -f cppstdin; then
   echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
  +else
  +	echo "Keeping your $hint cppstdin wrapper."
  +fi
   chmod 755 cppstdin
   wrapper=`pwd`/cppstdin
   ok='false'
  @@ -3693,7 +3700,8 @@ case "$libswanted" in
   esac
   for thislib in $libswanted; do
   	
  -	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`; $test -f "$xxx"; then
  +	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`;
  +		$test -f "$xxx" -a "X$ignore_versioned_solibs" = "X"; then
   		echo "Found -l$thislib (shared)."
   		case " $dflt " in
   		*"-l$thislib "*);;
  @@ -3980,10 +3988,21 @@ rmlist="$rmlist pdp11"
   : coherency check
   echo " "
   echo "Checking your choice of C compiler and flags for coherency..." >&4
  +$cat > try.c <<'EOF'
  +#include <stdio.h>
  +main() { printf("Ok\n"); exit(0); }
  +EOF
   set X $cc $optimize $ccflags -o try $ldflags try.c $libs
   shift
  -$cat >try.msg <<EOM
  -I've tried to compile and run a simple program with:
  +$cat >try.msg <<'EOM'
  +I've tried to compile and run the following simple program:
  +
  +EOM
  +$cat try.c
  +
  +$cat >> try.msg <<EOM
  +
  +I used the command:
   
   	$*
   	./try
  @@ -3991,10 +4010,6 @@ I've tried to compile and run a simple program with:
   and I got the following output:
   
   EOM
  -$cat > try.c <<'EOF'
  -#include <stdio.h>
  -main() { printf("Ok\n"); exit(0); }
  -EOF
   dflt=y
   if sh -c "$cc $optimize $ccflags -o try $ldflags try.c $libs" >>try.msg 2>&1; then
   	if sh -c './try' >>try.msg 2>&1; then
  @@ -4031,7 +4046,7 @@ y)
   	$cat try.msg >&4
   	case "$knowitall" in
   	'')
  -		echo "(The supplied flags might be incorrect with this C compiler.)"
  +		echo "(The supplied flags or libraries might be incorrect.)"
   		;;
   	*) dflt=n;;
   	esac
  @@ -4149,9 +4164,8 @@ eval $inhdr
   : determine which malloc to compile in
   echo " "
   case "$usemymalloc" in
  -''|y*|true)	dflt='y' ;;
  -n*|false)	dflt='n' ;;
  -*)	dflt="$usemymalloc" ;;
  +''|[yY]*|true|$define)	dflt='y' ;;
  +*)	dflt='n' ;;
   esac
   rp="Do you wish to attempt to use the malloc that comes with $package?"
   . ./myread
  @@ -4253,7 +4267,7 @@ understands function prototypes.  Unfortunately, your C compiler
   	$cc $ccflags
   doesn't seem to understand them.  Sorry about that.
   
  -If GNU cc is avaiable for your system, perhaps you could try that instead.  
  +If GNU cc is available for your system, perhaps you could try that instead.  
   
   Eventually, we hope to support building Perl with pre-ANSI compilers.
   If you would like to help in that effort, please contact <perlbug@perl.org>.
  @@ -4308,32 +4322,6 @@ shift;
   $cc $optimize $ccflags $ldflags -o ${mc_file} $* ${mc_file}.c $libs;'
   
   echo " "
  -echo "Determining whether or not we are on an EBCDIC system..." >&4
  -cat >tebcdic.c <<EOM
  -int main()
  -{
  -  if ('M'==0xd4) return 0;
  -  return 1;
  -}
  -EOM
  -val=$undef
  -set tebcdic
  -if eval $compile_ok; then
  -	if ./tebcdic; then
  -		echo "You have EBCDIC." >&4
  -		val="$define"
  -	else
  -		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  -	fi
  -else
  -	echo "I'm unable to compile the test program." >&4
  -	echo "I'll asuume ASCII or some ISO Latin." >&4
  -fi
  -$rm -f tebcdic.c tebcdic
  -set ebcdic
  -eval $setvar
  -
  -echo " "
   echo "Checking for GNU C Library..." >&4
   cat >gnulibc.c <<EOM
   #include <stdio.h>
  @@ -5147,7 +5135,7 @@ case "$shrpdir" in
   *)	$cat >&4 <<EOM
   WARNING:  Use of the shrpdir variable for the installation location of
   the shared $libperl is not supported.  It was never documented and
  -will not work in this version.  Let me (doughera@lafayette.edu)
  +will not work in this version.  Let me (jhi@iki.fi)
   know of any problems this may cause.
   
   EOM
  @@ -6703,6 +6691,10 @@ eval $setvar
   set difftime d_difftime
   eval $inlibc
   
  +: see if sys/stat.h is available
  +set sys/stat.h i_sysstat
  +eval $inhdr
  +
   : see if this is a dirent system
   echo " "
   if xinc=`./findhdr dirent.h`; $test "$xinc"; then
  @@ -6771,6 +6763,23 @@ set d_dirnamlen
   eval $setvar
   $rm -f try.c
   
  +hasfield='varname=$1; struct=$2; field=$3; shift; shift; shift;
  +while $test $# -ge 2; do
  +	case "$1" in
  +	$define) echo "#include <$2>";;
  +	esac ;
  +    shift 2;
  +done > try.c;
  +echo "int main () { struct $struct foo; foo.$field = 0; }" >> try.c;
  +if eval $cc $optimize $ccflags -c try.c >/dev/null 2>&1; then
  +	val="$define";
  +else
  +	val="$undef";
  +fi;
  +set $varname;
  +eval $setvar;
  +$rm -f try.c try.o'
  +
   : see if dlerror exists
   xxx_runnm="$runnm"
   runnm=false
  @@ -7305,7 +7314,7 @@ esac
   set netinet/in.h i_niin sys/in.h i_sysin
   eval $inhdr
   
  -: see if this is an arpa/inet.h
  +: see if arpa/inet.h has to be included
   set arpa/inet.h i_arpainet
   eval $inhdr
   
  @@ -7635,7 +7644,7 @@ case "$osname" in
   freebsd)
       case "`ipcs 2>&1`" in
       "SVID messages"*"not configured"*)
  -	echo "But your FreeBSD kernel does not have the msg*(2) configured." >&4
  +	echo "But your $osname does not have the msg*(2) configured." >&4
           h_msg=false
   	val="$undef"
   	set msgctl d_msgctl
  @@ -7678,7 +7687,7 @@ set poll d_poll
   eval $inlibc
   
   
  -: see whether the various POSIXish _yields exist within given cccmd
  +: see whether the various POSIXish _yields exist
   $cat >try.c <<EOP
   #include <pthread.h>
   main() {
  @@ -8136,7 +8145,7 @@ case "$osname" in
   freebsd)
       case "`ipcs 2>&1`" in
       "SVID messages"*"not configured"*)
  -	echo "But your FreeBSD kernel does not have the sem*(2) configured." >&4
  +	echo "But your $osname does not have the sem*(2) configured." >&4
           h_sem=false
   	val="$undef"
   	set semctl d_semctl
  @@ -8185,6 +8194,31 @@ case "$d_sem" in
   $define)
       : see whether semctl IPC_STAT can use union semun
       echo " "
  +    $cat > try.h <<END
  +#ifndef S_IRUSR
  +#   ifdef S_IREAD
  +#	define S_IRUSR S_IREAD
  +#	define S_IWUSR S_IWRITE
  +#	define S_IXUSR S_IEXEC
  +#   else
  +#	define S_IRUSR 0400
  +#	define S_IWUSR 0200
  +#	define S_IXUSR 0100
  +#   endif
  +#   define S_IRGRP (S_IRUSR>>3)
  +#   define S_IWGRP (S_IWUSR>>3)
  +#   define S_IXGRP (S_IXUSR>>3)
  +#   define S_IROTH (S_IRUSR>>6)
  +#   define S_IWOTH (S_IWUSR>>6)
  +#   define S_IXOTH (S_IXUSR>>6)
  +#endif
  +#ifndef S_IRWXU
  +#   define S_IRWXU (S_IRUSR|S_IWUSR|S_IXUSR)
  +#   define S_IRWXG (S_IRGRP|S_IWGRP|S_IXGRP)
  +#   define S_IRWXO (S_IROTH|S_IWOTH|S_IXOTH)
  +#endif
  +END
  +
       $cat > try.c <<END
   #include <sys/types.h>
   #include <sys/ipc.h>
  @@ -8259,6 +8293,7 @@ END
   #include <sys/stat.h>
   #include <stdio.h>
   #include <errno.h>
  +#include "try.h"
   #ifndef errno
   extern int errno;
   #endif
  @@ -8305,6 +8340,7 @@ END
       *)  echo "You cannot use struct semid_ds * for semctl IPC_STAT." >&4
           ;;
       esac
  +    $rm -f try.h
       ;;
   *)  val="$undef"
   
  @@ -8499,7 +8535,7 @@ case "$osname" in
   freebsd)
       case "`ipcs 2>&1`" in
       "SVID shared memory"*"not configured"*)
  -	echo "But your FreeBSD kernel does not have the shm*(2) configured." >&4
  +	echo "But your $osname does not have the shm*(2) configured." >&4
           h_shm=false
   	val="$undef"
   	set shmctl d_shmctl
  @@ -8652,21 +8688,8 @@ eval $inlibc
   
   : see if stat knows about block sizes
   echo " "
  -xxx=`./findhdr sys/stat.h`
  -if $contains 'st_blocks;' "$xxx" >/dev/null 2>&1 ; then
  -	if $contains 'st_blksize;' "$xxx" >/dev/null 2>&1 ; then
  -		echo "Your stat() knows about block sizes." >&4
  -		val="$define"
  -	else
  -		echo "Your stat() doesn't know about block sizes." >&4
  -		val="$undef"
  -	fi
  -else
  -	echo "Your stat() doesn't know about block sizes." >&4
  -	val="$undef"
  -fi
  -set d_statblks
  -eval $setvar
  +set d_statblks stat st_blocks $i_sysstat sys/stat.h
  +eval $hasfield
   
   : see if _ptr and _cnt from stdio act std
   echo " "
  @@ -9610,6 +9633,32 @@ EOCP
   esac
   $rm -f try.c try
   
  +echo " "
  +echo "Determining whether or not we are on an EBCDIC system..." >&4
  +$cat >tebcdic.c <<EOM
  +int main()
  +{
  +  if ('M'==0xd4) return 0;
  +  return 1;
  +}
  +EOM
  +val=$undef
  +set tebcdic
  +if eval $compile_ok; then
  +	if ./tebcdic; then
  +		echo "You have EBCDIC." >&4
  +		val="$define"
  +	else
  +		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  +	fi
  +else
  +	echo "I'm unable to compile the test program." >&4
  +	echo "I'll assume ASCII or some ISO Latin." >&4
  +fi
  +$rm -f tebcdic.c tebcdic
  +set ebcdic
  +eval $setvar
  +
   : see what type file positions are declared as in the library
   rp="What is the type for file position used by fsetpos()?"
   set fpos_t fpostype long stdio.h sys/types.h
  @@ -10217,8 +10266,10 @@ EOM
   		: The first arg can be int, unsigned, or size_t
   		: The last arg may or may not be 'const'
   		val=''
  +		: void pointer has been seen but using that
  +		: breaks the selectminbits test
   		for xxx in 'fd_set *' 'int *'; do
  -			for nfd in 'int' 'size_t' 'unsigned' ; do
  +			for nfd in 'int' 'size_t' 'unsigned' 'unsigned long'; do
   				for tmo in 'struct timeval *' 'const struct timeval *'; do
   					case "$val" in
   					'')	try="extern select _(($nfd, $xxx, $xxx, $xxx, $tmo));"
  @@ -10250,6 +10301,100 @@ EOM
   	;;
   esac
   
  +: check for the select 'width'
  +case "$selectminbits" in
  +'') case "$d_select" in
  +	$define)
  +		$cat <<EOM
  +
  +Checking to see on how many bits at a time your select() operates...
  +EOM
  +		$cat >try.c <<EOCP
  +#include <sys/types.h>
  +#$i_time I_TIME
  +#$i_systime I_SYS_TIME
  +#$i_systimek I_SYS_TIME_KERNEL
  +#ifdef I_TIME
  +#   include <time.h>
  +#endif
  +#ifdef I_SYS_TIME
  +#   ifdef I_SYS_TIME_KERNEL
  +#	define KERNEL
  +#   endif
  +#   include <sys/time.h>
  +#   ifdef I_SYS_TIME_KERNEL
  +#	undef KERNEL
  +#   endif
  +#endif
  +#$i_sysselct I_SYS_SELECT
  +#ifdef I_SYS_SELECT
  +#include <sys/select.h>
  +#endif
  +#include <stdio.h>
  +$selecttype b;
  +#define S sizeof(*(b))
  +#define MINBITS	64
  +#define NBYTES (S * 8 > MINBITS ? S : MINBITS/8)
  +#define NBITS  (NBYTES * 8)
  +int main() {
  +    char s[NBYTES];
  +    struct timeval t;
  +    int i;
  +    FILE* fp;
  +    int fd;
  +
  +    fclose(stdin);
  +    fp = fopen("try.c", "r");
  +    if (fp == 0)
  +      exit(1);
  +    fd = fileno(fp);
  +    if (fd < 0)
  +      exit(2);
  +    b = ($selecttype)s;
  +    for (i = 0; i < NBITS; i++)
  +	FD_SET(i, b);
  +    t.tv_sec  = 0;
  +    t.tv_usec = 0;
  +    select(fd + 1, b, 0, 0, &t);
  +    for (i = NBITS - 1; i > fd && FD_ISSET(i, b); i--);
  +    printf("%d\n", i + 1);
  +    return 0;
  +}
  +EOCP
  +		set try
  +		if eval $compile_ok; then
  +			selectminbits=`./try`
  +			case "$selectminbits" in
  +			'')	cat >&4 <<EOM
  +Cannot figure out on how many bits at a time your select() operates.
  +I'll play safe and guess it is 32 bits.
  +EOM
  +				selectminbits=32
  +				bits="32 bits"
  +				;;
  +			1)	bits="1 bit" ;;
  +			*)	bits="$selectminbits bits" ;;
  +			esac
  +			echo "Your select() operates on $bits at a time." >&4
  +		else
  +			rp='What is the minimum number of bits your select() operates on?'
  +			case "$byteorder" in
  +			1234|12345678)	dflt=32 ;;
  +			*)		dflt=1	;;
  +			esac
  +			. ./myread
  +			val=$ans
  +			selectminbits="$val"
  +		fi
  +		$rm -f try.* try
  +		;;
  +	*)	: no select, so pick a harmless default
  +		selectminbits='32'
  +		;;
  +	esac
  +	;;
  +esac
  +
   : Trace out the files included by signal.h, then look for SIGxxx names.
   : Remove SIGARRAYSIZE used by HPUX.
   : Remove SIGTYP void lines used by OS2.
  @@ -10458,7 +10603,13 @@ $eunicefix signal_cmd
   : generate list of signal names
   echo " "
   case "$sig_name_init" in
  -'')
  +'') doinit=yes ;;
  +*)  case "$sig_num_init" in
  +    ''|*,*) doinit=yes ;;
  +    esac ;;
  +esac
  +case "$doinit" in
  +yes)
   	echo "Generating a list of signal names and numbers..." >&4
   	. ./signal_cmd
   	sig_name=`$awk '{printf "%s ", $1}' signal.lst`
  @@ -10466,7 +10617,9 @@ case "$sig_name_init" in
   	sig_name_init=`$awk 'BEGIN { printf "\"ZERO\", " }
   						{ printf "\"%s\", ", $1 }
   						END { printf "0\n" }' signal.lst`
  -	sig_num=`$awk 'BEGIN { printf "0, " }
  +	sig_num=`$awk '{printf "%d ", $2}' signal.lst`
  +	sig_num="0 $sig_num"
  +	sig_num_init=`$awk 'BEGIN { printf "0, " }
   					{ printf "%d, ", $2}
   					END { printf "0\n"}' signal.lst`
   	;;
  @@ -10830,7 +10983,13 @@ $rm -f try.c
   EOS
   chmod +x ccsym
   $eunicefix ccsym
  -./ccsym | $sort | $uniq >ccsym.raw
  +./ccsym > ccsym1.raw
  +if $test -s ccsym1.raw; then
  +       $sort ccsym1.raw | $uniq >ccsym.raw
  +else
  +       mv ccsym1.raw ccsym.raw
  +fi
  +
   $awk '/\=/ { print $0; next }
   	{ print $0"=1" }' ccsym.raw >ccsym.list
   $awk '{ print $0"=1" }' Cppsym.true >ccsym.true
  @@ -11055,10 +11214,6 @@ eval $inhdr
   set sys/resource.h i_sysresrc
   eval $inhdr
   
  -: see if sys/stat.h is available
  -set sys/stat.h i_sysstat
  -eval $inhdr
  -
   : see if this is a sys/un.h system
   set sys/un.h i_sysun
   eval $inhdr
  @@ -11195,6 +11350,7 @@ for xxx in $known_extensions ; do
   		esac
   		;;
   	IPC/SysV|ipc/sysv)
  +		: XXX Do we need a useipcsysv variable here
   		case "${d_msg}${d_sem}${d_shm}" in 
   		*"${define}"*) avail_ext="$avail_ext $xxx" ;;
   		esac
  @@ -11774,6 +11930,7 @@ i_values='$i_values'
   i_varargs='$i_varargs'
   i_varhdr='$i_varhdr'
   i_vfork='$i_vfork'
  +ignore_versioned_solibs='$ignore_versioned_solibs'
   incpath='$incpath'
   inews='$inews'
   installarchlib='$installarchlib'
  @@ -11882,6 +12039,7 @@ runnm='$runnm'
   scriptdir='$scriptdir'
   scriptdirexp='$scriptdirexp'
   sed='$sed'
  +selectminbits='$selectminbits'
   selecttype='$selecttype'
   sendmail='$sendmail'
   sh='$sh'
  @@ -11894,6 +12052,7 @@ shsharp='$shsharp'
   sig_name='$sig_name'
   sig_name_init='$sig_name_init'
   sig_num='$sig_num'
  +sig_num_init='$sig_num_init'
   signal_t='$signal_t'
   sitearch='$sitearch'
   sitearchexp='$sitearchexp'
  @@ -12023,51 +12182,6 @@ esac
   : if this fails, just run all the .SH files by hand
   . ./config.sh
   
  -case "$ebcdic" in
  -$define)
  -    xxx=''
  -    echo "This is an EBCDIC system, checking if any parser files need regenerating." >&4
  -    rm -f y.tab.c y.tab.h
  -    yacc -d perly.y >/dev/null 2>&1
  -    if cmp -s y.tab.c perly.c; then
  -        rm -f y.tab.c
  -    else
  -        echo "perly.y -> perly.c" >&4
  -        mv -f y.tab.c perly.c
  -        chmod u+w perly.c
  -        sed -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  -            -e 's/y\.tab/perly/g' perly.c >perly.tmp && mv perly.tmp perly.c
  -        xxx="$xxx perly.c"
  -    fi
  -    if cmp -s y.tab.h perly.h; then
  -        rm -f y.tab.h
  -    else
  -        echo "perly.y -> perly.h" >&4
  -        mv -f y.tab.h perly.h
  -        xxx="$xxx perly.h"
  -    fi
  -    echo "x2p/a2p.y" >&4
  -    cd x2p
  -    rm -f y.tab.c
  -    yacc a2p.y >/dev/null 2>&1
  -    if cmp -s y.tab.c a2p.c
  -    then
  -        rm -f y.tab.c
  -    else
  -        echo "a2p.y -> a2p.c" >&4
  -        mv -f y.tab.c a2p.c
  -        chmod u+w a2p.c
  -        sed -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  -            -e 's/y\.tab/a2p/g' a2p.c >a2p.tmp && mv a2p.tmp a2p.c
  -        xxx="$xxx a2p.c"
  -    fi
  -    cd ..
  -    case "$xxx" in
  -    '') echo "No parser files were regenerated.  That's okay." >&4 ;;
  -    esac
  -    ;;
  -esac
  -
   echo " "
   exec 1>&4
   . ./UU/extract
  --- Makefile.SH
  +++ Makefile.SH
  @@ -644,3 +644,83 @@ case `pwd` in
       ;;
   esac
   $rm -f $firstmakefile
  +
  +# Now do any special processing required before building.
  +
  +case "$ebcdic" in
  +$define)
  +    xxx=''
  +    echo "This is an EBCDIC system, checking if any parser files need regenerating." >&4
  +case "$osname" in
  +os390)
  +    rm -f y.tab.c y.tab.h
  +    yacc -d perly.y >/dev/null 2>&1
  +    if cmp -s y.tab.c perly.c; then
  +        rm -f y.tab.c
  +    else
  +        echo "perly.y -> perly.c" >&2
  +        mv -f y.tab.c perly.c
  +        chmod u+w perly.c
  +        sed -e '/^#include "perl\.h"/a\
  +\
  +#define yydebug    PL_yydebug\
  +#define yynerrs    PL_yynerrs\
  +#define yyerrflag  PL_yyerrflag\
  +#define yychar     PL_yychar\
  +#define yyval      PL_yyval\
  +#define yylval     PL_yylval'				\
  +            -e '/YYSTYPE *yyval;/D'			\
  +            -e '/YYSTYPE *yylval;/D'			\
  +            -e '/int  yychar,/,/yynerrs;/D'		\
  +            -e 's/int yydebug = 0;/yydebug = 0;/'	\
  +            -e 's/[^_]realloc(/PerlMem_realloc(/g'	\
  +            -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +            -e 's/y\.tab/perly/g' perly.c >perly.tmp && mv perly.tmp perly.c
  +        xxx="$xxx perly.c"
  +    fi
  +    if cmp -s y.tab.h perly.h; then
  +        rm -f y.tab.h
  +    else
  +        echo "perly.y -> perly.h" >&2
  +        mv -f y.tab.h perly.h
  +        xxx="$xxx perly.h"
  +    fi
  +    if cd x2p
  +    then
  +        rm -f y.tab.c y.tab.h
  +        yacc a2p.y >/dev/null 2>&1
  +        if cmp -s y.tab.c a2p.c
  +        then
  +            rm -f y.tab.c
  +        else
  +            echo "a2p.y -> a2p.c" >&2
  +            mv -f y.tab.c a2p.c
  +            chmod u+w a2p.c
  +            sed -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +                -e 's/y\.tab/a2p/g' a2p.c >a2p.tmp && mv a2p.tmp a2p.c
  +            xxx="$xxx a2p.c"
  +        fi
  +        # In case somebody yacc -d:ed the a2p.y.
  +        if test -f y.tab.h
  +        then
  +            if cmp -s y.tab.h a2p.h
  +            then
  +                rm -f y.tab.h
  +            else
  +                echo "a2p.h -> a2p.h" >&2
  +                mv -f y.tab.h a2p.h
  +                xxx="$xxx a2p.h"
  +            fi
  +        fi
  +        cd ..
  +    fi
  +    ;;
  +*)
  +    echo "'$osname' is an EBCDIC system I don't know that well." >&4
  +    ;;
  +esac
  +    case "$xxx" in
  +    '') echo "No parser files were regenerated.  That's okay." >&2 ;;
  +    esac
  +    ;;
  +esac
  --- config_h.SH
  +++ config_h.SH
  @@ -1813,7 +1813,7 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
    *	the sig_name list.
    */
   #define SIG_NAME $sig_name_init		/**/
  -#define SIG_NUM  $sig_num			/**/
  +#define SIG_NUM  $sig_num_init		/**/
   
   /* VOIDFLAGS:
    *	This symbol indicates how much support of the void type is given by this
  @@ -1902,6 +1902,15 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
   #define PRIVLIB "$privlib"		/**/
   #define PRIVLIB_EXP "$privlibexp"		/**/
   
  +/* SELECT_MIN_BITS:
  + *	This symbol holds the minimum number of bits operated by select.
  + *	That is, if you do select(n, ...), how many bits at least will be
  + *	cleared in the masks if some activity is detected.  Usually this
  + *	is either n or 32*ceil(n/32), especially many little-endians do
  + *	the latter.  This is only useful if you have select(), naturally.
  + */
  +#define SELECT_MIN_BITS 	$selectminbits	/**/
  +
   /* SITEARCH:
    *	This symbol contains the name of the private library for this package.
    *	The library is private in the sense that it needn't be in anyone's
  --- pp_sys.c
  +++ pp_sys.c
  @@ -56,7 +56,10 @@ extern "C" int syscall(unsigned long,...);
   
   /* XXX Configure test needed.
      h_errno might not be a simple 'int', especially for multi-threaded
  -   applications.  HOST_NOT_FOUND is typically defined in <netdb.h>.
  +   applications, see "extern int errno in perl.h".  Creating such
  +   a test requires taking into account the differences between
  +   compiling multithreaded and singlethreaded ($ccflags et al).
  +   HOST_NOT_FOUND is typically defined in <netdb.h>.
   */
   #if defined(HOST_NOT_FOUND) && !defined(h_errno)
   extern int h_errno;
  @@ -753,12 +756,17 @@ PP(pp_sselect)
   	    maxlen = j;
       }
   
  +/* little endians can use vecs directly */
   #if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678
  -/* XXX Configure test needed. */
  -#if defined(__linux__) || defined(OS2) || defined(NeXT) || defined(__osf__) || defined(sun)
  -    growsize = sizeof(fd_set);
  +#  if SELECT_MIN_BITS > 1
  +    /* If SELECT_MIN_BITS is greater than one we most probably will want
  +     * to align the sizes with SELECT_MIN_BITS/8 because for example
  +     * in many little-endian (Intel, Alpha) systems (Linux, OS/2, Digital
  +     * UNIX, Solaris, NeXT) the smallest quantum select() operates on
  +     * (sets bit) is 32 bits.  */
  +    growsize = maxlen + (SELECT_MIN_BITS/8 - (maxlen % (SELECT_MIN_BITS/8)));
   #else
  -    growsize = maxlen;		/* little endians can use vecs directly */
  +    growsize = sizeof(fd_set);
   #endif
   #else
   #ifdef NFDBITS
  END
  --- Configure
  +++ Configure
  @@ -21,7 +21,7 @@
   # $Id: Head.U,v 3.0.1.9 1997/02/28 15:02:09 ram Exp $
   #
   # Generated on Tue Jul  7 10:10:21 EDT 1998 [metaconfig 3.0 PL70]
  -# (with additional metaconfig patches by doughera@lafayette.edu)
  +# (with additional metaconfig patches by jhi@iki.fi)
   
   cat >/tmp/c1$$ <<EOF
   ARGGGHHHH!!!!!
  @@ -56,33 +56,6 @@ case "$0" in
   	;;
   esac
   
  -: the newline for tr
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\n' x 2>/dev/null`" in
  -	foox)
  -		trnl='\n'
  -		;;
  -	esac
  -fi
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\012' x 2>/dev/null`" in
  -	foox)
  -		trnl='\012'
  -		;;
  -	esac
  -fi
  -if test -n "$DJGPP"; then
  -	trnl='\012'
  -fi
  -if test X"$trnl" = X; then
  -	cat <<EOM >&2
  -
  -$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  -
  -EOM
  -	exit 1
  -fi
  -
   : Proper separator for the PATH environment variable
   p_=:
   : On OS/2 this directory should exist if this is not floppy only system :-]
  @@ -391,7 +364,6 @@ d_getservprotos=''
   d_getsbyname=''
   d_getsbyport=''
   d_gnulibc=''
  -i_arpainet=''
   d_htonl=''
   d_inetaton=''
   d_isascii=''
  @@ -540,6 +512,7 @@ dlsrc=''
   ld=''
   lddlflags=''
   usedl=''
  +ebcdic=''
   doublesize=''
   fpostype=''
   gidtype=''
  @@ -548,6 +521,7 @@ h_fcntl=''
   h_sysfile=''
   db_hashtype=''
   db_prefixtype=''
  +i_arpainet=''
   i_db=''
   i_dbm=''
   i_rpcsvcdbm=''
  @@ -633,6 +607,7 @@ libpth=''
   loclibpth=''
   plibpth=''
   xlibpth=''
  +ignore_versioned_solibs=''
   libs=''
   lns=''
   lseektype=''
  @@ -697,11 +672,13 @@ randbits=''
   installscript=''
   scriptdir=''
   scriptdirexp=''
  +selectminbits=''
   selecttype=''
   sh=''
   sig_name=''
   sig_name_init=''
   sig_num=''
  +sig_num_init=''
   installsitearch=''
   sitearch=''
   sitearchexp=''
  @@ -719,6 +696,7 @@ startperl=''
   startsh=''
   stdchar=''
   sysman=''
  +trnl=''
   uidtype=''
   nm_opt=''
   nm_so_opt=''
  @@ -733,7 +711,6 @@ mips_type=''
   usrinc=''
   defvoidused=''
   voidflags=''
  -ebcdic=''
   CONFIG=''
   
   define='define'
  @@ -836,6 +813,8 @@ plibpth=''
   
   : default library list
   libswanted=''
  +: some systems want only to use the non-versioned libso:s
  +ignore_versioned_solibs=''
   : Possible local include directories to search.
   : Set locincpth to "" in a hint file to defeat local include searches.
   locincpth="/usr/local/include /opt/local/include /usr/gnu/include"
  @@ -904,7 +883,7 @@ case "$sh" in
   $me:  Fatal Error:  I can't find a Bourne Shell anywhere.  
   
   Usually it's in /bin/sh.  How did you even get this far?
  -Please contact me (Andy Dougherty) at doughera@lafayette.edu and 
  +Please contact me (Jarkko Hietaniemi) at jhi@iki.fi and 
   we'll try to straighten this all out.
   EOM
   	exit 1
  @@ -1240,7 +1219,7 @@ cat >extract <<'EOS'
   CONFIG=true
   echo "Doing variable substitutions on .SH files..."
   if test -f $src/MANIFEST; then
  -	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH'`
  +	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH$'`
   else
   	echo "(Looking for .SH files under the source directory.)"
   	set x `(cd $src; find . -name "*.SH" -print)`
  @@ -1373,7 +1352,7 @@ THIS PACKAGE SEEMS TO BE INCOMPLETE.
   You have the option of continuing the configuration process, despite the
   distinct possibility that your kit is damaged, by typing 'y'es.  If you
   do, don't blame me if something goes wrong.  I advise you to type 'n'o
  -and contact the author (doughera@lafayette.edu).
  +and contact the author (jhi@iki.fi).
   
   EOM
   		echo $n "Continue? [n] $c" >&4
  @@ -1396,6 +1375,30 @@ else
   fi
   rm -f missing x??
   
  +echo " "
  +: Find the appropriate value for a newline for tr
  +if test -n "$DJGPP"; then
  +       trnl='\012'
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\n' x 2>/dev/null`" in
  +	foox) trnl='\n' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\012' x 2>/dev/null`" in
  +	foox) trnl='\012' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	cat <<EOM >&2
  +
  +$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  +
  +EOM
  +	exit 1
  +fi
  +
   : compute the number of columns on the terminal for proper question formatting
   case "$COLUMNS" in
   '') COLUMNS='80';;
  @@ -1574,7 +1577,7 @@ Much effort has been expended to ensure that this shell script will run on any
   Unix system.  If despite that it blows up on yours, your best bet is to edit
   Configure and run it again.  If you can't run Configure for some reason,
   you'll have to generate a config.sh file by hand.  Whatever problems you
  -have, let me (doughera@lafayette.edu) know how I blew it.
  +have, let me (jhi@iki.fi) know how I blew it.
   
   This installation script affects things in two ways:
   
  @@ -1841,14 +1844,14 @@ ABYZ)
   	    *C9D1*|*c9d1*)
   		echo "Hey, this might be EBCDIC." >&4
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
  +		    case "`echo IJ | $tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
   		    ij) up='[A-IJ-RS-Z]'
   		        low='[a-ij-rs-z]'
   			;;
   		    esac
   		fi
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
  +		    case "`echo IJ | $tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
   		    ij) up='A-IJ-RS-Z'
   		        low='a-ij-rs-z'
   			;;
  @@ -1941,7 +1944,7 @@ EOM
   	(cd $src/hints; ls -C *.sh) | $sed 's/\.sh/   /g' >&4
   	dflt=''
   	: Half the following guesses are probably wrong... If you have better
  -	: tests or hints, please send them to doughera@lafayette.edu
  +	: tests or hints, please send them to jhi@iki.fi
   	: The metaconfig authors would also appreciate a copy...
   	$test -f /irix && osname=irix
   	$test -f /xenix && osname=sco_xenix
  @@ -2025,7 +2028,7 @@ EOM
   			osvers="$3"
   			;;
   		dynixptx*) osname=dynixptx
  -			osvers="$3"
  +			osvers=`echo "$4" | $sed 's/^v//'`
   			;;
   		freebsd) osname=freebsd 
   			osvers="$3" ;;
  @@ -3454,7 +3457,11 @@ cat <<'EOT' >testcpp.c
   ABC.XYZ
   EOT
   cd ..
  +if test ! -f cppstdin; then
   echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
  +else
  +	echo "Keeping your $hint cppstdin wrapper."
  +fi
   chmod 755 cppstdin
   wrapper=`pwd`/cppstdin
   ok='false'
  @@ -3705,7 +3712,8 @@ case "$libswanted" in
   esac
   for thislib in $libswanted; do
   	
  -	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`; $test -f "$xxx"; then
  +	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`;
  +		$test -f "$xxx" -a "X$ignore_versioned_solibs" = "X"; then
   		echo "Found -l$thislib (shared)."
   		case " $dflt " in
   		*"-l$thislib "*);;
  @@ -3992,10 +4000,21 @@ rmlist="$rmlist pdp11"
   : coherency check
   echo " "
   echo "Checking your choice of C compiler and flags for coherency..." >&4
  +$cat > try.c <<'EOF'
  +#include <stdio.h>
  +main() { printf("Ok\n"); exit(0); }
  +EOF
   set X $cc $optimize $ccflags -o try $ldflags try.c $libs
   shift
  -$cat >try.msg <<EOM
  -I've tried to compile and run a simple program with:
  +$cat >try.msg <<'EOM'
  +I've tried to compile and run the following simple program:
  +
  +EOM
  +$cat try.c
  +
  +$cat >> try.msg <<EOM
  +
  +I used the command:
   
   	$*
   	./try
  @@ -4003,10 +4022,6 @@ I've tried to compile and run a simple program with:
   and I got the following output:
   
   EOM
  -$cat > try.c <<'EOF'
  -#include <stdio.h>
  -main() { printf("Ok\n"); exit(0); }
  -EOF
   dflt=y
   if sh -c "$cc $optimize $ccflags -o try $ldflags try.c $libs" >>try.msg 2>&1; then
   	if sh -c './try' >>try.msg 2>&1; then
  @@ -4043,7 +4058,7 @@ y)
   	$cat try.msg >&4
   	case "$knowitall" in
   	'')
  -		echo "(The supplied flags might be incorrect with this C compiler.)"
  +		echo "(The supplied flags or libraries might be incorrect.)"
   		;;
   	*) dflt=n;;
   	esac
  @@ -4161,9 +4176,8 @@ eval $inhdr
   : determine which malloc to compile in
   echo " "
   case "$usemymalloc" in
  -''|y*|true)	dflt='y' ;;
  -n*|false)	dflt='n' ;;
  -*)	dflt="$usemymalloc" ;;
  +''|[yY]*|true|$define)	dflt='y' ;;
  +*)	dflt='n' ;;
   esac
   rp="Do you wish to attempt to use the malloc that comes with $package?"
   . ./myread
  @@ -4265,7 +4279,7 @@ understands function prototypes.  Unfortunately, your C compiler
   	$cc $ccflags
   doesn't seem to understand them.  Sorry about that.
   
  -If GNU cc is avaiable for your system, perhaps you could try that instead.  
  +If GNU cc is available for your system, perhaps you could try that instead.  
   
   Eventually, we hope to support building Perl with pre-ANSI compilers.
   If you would like to help in that effort, please contact <perlbug@perl.org>.
  @@ -4320,32 +4334,6 @@ shift;
   $cc $optimize $ccflags $ldflags -o ${mc_file} $* ${mc_file}.c $libs;'
   
   echo " "
  -echo "Determining whether or not we are on an EBCDIC system..." >&4
  -cat >tebcdic.c <<EOM
  -int main()
  -{
  -  if ('M'==0xd4) return 0;
  -  return 1;
  -}
  -EOM
  -val=$undef
  -set tebcdic
  -if eval $compile_ok; then
  -	if ./tebcdic; then
  -		echo "You have EBCDIC." >&4
  -		val="$define"
  -	else
  -		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  -	fi
  -else
  -	echo "I'm unable to compile the test program." >&4
  -	echo "I'll asuume ASCII or some ISO Latin." >&4
  -fi
  -$rm -f tebcdic.c tebcdic
  -set ebcdic
  -eval $setvar
  -
  -echo " "
   echo "Checking for GNU C Library..." >&4
   cat >gnulibc.c <<EOM
   #include <stdio.h>
  @@ -5159,7 +5147,7 @@ case "$shrpdir" in
   *)	$cat >&4 <<EOM
   WARNING:  Use of the shrpdir variable for the installation location of
   the shared $libperl is not supported.  It was never documented and
  -will not work in this version.  Let me (doughera@lafayette.edu)
  +will not work in this version.  Let me (jhi@iki.fi)
   know of any problems this may cause.
   
   EOM
  @@ -6715,6 +6703,10 @@ eval $setvar
   set difftime d_difftime
   eval $inlibc
   
  +: see if sys/stat.h is available
  +set sys/stat.h i_sysstat
  +eval $inhdr
  +
   : see if this is a dirent system
   echo " "
   if xinc=`./findhdr dirent.h`; $test "$xinc"; then
  @@ -6783,6 +6775,23 @@ set d_dirnamlen
   eval $setvar
   $rm -f try.c
   
  +hasfield='varname=$1; struct=$2; field=$3; shift; shift; shift;
  +while $test $# -ge 2; do
  +	case "$1" in
  +	$define) echo "#include <$2>";;
  +	esac ;
  +    shift 2;
  +done > try.c;
  +echo "int main () { struct $struct foo; foo.$field = 0; }" >> try.c;
  +if eval $cc $optimize $ccflags -c try.c >/dev/null 2>&1; then
  +	val="$define";
  +else
  +	val="$undef";
  +fi;
  +set $varname;
  +eval $setvar;
  +$rm -f try.c try.o'
  +
   : see if dlerror exists
   xxx_runnm="$runnm"
   runnm=false
  @@ -7317,7 +7326,7 @@ esac
   set netinet/in.h i_niin sys/in.h i_sysin
   eval $inhdr
   
  -: see if this is an arpa/inet.h
  +: see if arpa/inet.h has to be included
   set arpa/inet.h i_arpainet
   eval $inhdr
   
  @@ -7643,6 +7652,27 @@ echo " "
   case "$d_msgctl$d_msgget$d_msgsnd$d_msgrcv" in
   *"$undef"*) h_msg=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID messages"*"not configured"*)
  +	echo "But your $osname does not have the msg*(2) configured." >&4
  +        h_msg=false
  +	val="$undef"
  +	set msgctl d_msgctl
  +	eval $setvar
  +	set msgget d_msgget
  +	eval $setvar
  +	set msgsnd d_msgsnd
  +	eval $setvar
  +	set msgrcv d_msgrcv
  +	eval $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_msg && $test `./findhdr sys/msg.h`; then
   	echo "You have the full msg*(2) library." >&4
  @@ -7671,7 +7701,7 @@ set poll d_poll
   eval $inlibc
   
   
  -: see whether the various POSIXish _yields exist within given cccmd
  +: see whether the various POSIXish _yields exist
   $cat >try.c <<EOP
   #include <pthread.h>
   main() {
  @@ -8125,6 +8155,25 @@ echo " "
   case "$d_semctl$d_semget$d_semop" in
   *"$undef"*) h_sem=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID messages"*"not configured"*)
  +	echo "But your $osname does not have the sem*(2) configured." >&4
  +        h_sem=false
  +	val="$undef"
  +	set semctl d_semctl
  +	eval $setvar
  +	set semget d_semget
  +	eval $setvar
  +	set semop d_semop
  +	eval $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_sem && $test `./findhdr sys/sem.h`; then
   	echo "You have the full sem*(2) library." >&4
  @@ -8161,6 +8210,31 @@ case "$d_sem" in
   $define)
       : see whether semctl IPC_STAT can use union semun
       echo " "
  +    $cat > try.h <<END
  +#ifndef S_IRUSR
  +#   ifdef S_IREAD
  +#	define S_IRUSR S_IREAD
  +#	define S_IWUSR S_IWRITE
  +#	define S_IXUSR S_IEXEC
  +#   else
  +#	define S_IRUSR 0400
  +#	define S_IWUSR 0200
  +#	define S_IXUSR 0100
  +#   endif
  +#   define S_IRGRP (S_IRUSR>>3)
  +#   define S_IWGRP (S_IWUSR>>3)
  +#   define S_IXGRP (S_IXUSR>>3)
  +#   define S_IROTH (S_IRUSR>>6)
  +#   define S_IWOTH (S_IWUSR>>6)
  +#   define S_IXOTH (S_IXUSR>>6)
  +#endif
  +#ifndef S_IRWXU
  +#   define S_IRWXU (S_IRUSR|S_IWUSR|S_IXUSR)
  +#   define S_IRWXG (S_IRGRP|S_IWGRP|S_IXGRP)
  +#   define S_IRWXO (S_IROTH|S_IWOTH|S_IXOTH)
  +#endif
  +END
  +
       $cat > try.c <<END
   #include <sys/types.h>
   #include <sys/ipc.h>
  @@ -8235,6 +8309,7 @@ END
   #include <sys/stat.h>
   #include <stdio.h>
   #include <errno.h>
  +#include "try.h"
   #ifndef errno
   extern int errno;
   #endif
  @@ -8281,6 +8356,7 @@ END
       *)  echo "You cannot use struct semid_ds * for semctl IPC_STAT." >&4
           ;;
       esac
  +    $rm -f try.h
       ;;
   *)  val="$undef"
   
  @@ -8471,6 +8547,27 @@ echo " "
   case "$d_shmctl$d_shmget$d_shmat$d_shmdt" in
   *"$undef"*) h_shm=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID shared memory"*"not configured"*)
  +	echo "But your $osname does not have the shm*(2) configured." >&4
  +        h_shm=false
  +	val="$undef"
  +	set shmctl d_shmctl
  +	evat $setvar
  +	set shmget d_shmget
  +	evat $setvar
  +	set shmat d_shmat
  +	evat $setvar
  +	set shmdt d_shmdt
  +	evat $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_shm && $test `./findhdr sys/shm.h`; then
   	echo "You have the full shm*(2) library." >&4
  @@ -8609,21 +8706,8 @@ eval $inlibc
   
   : see if stat knows about block sizes
   echo " "
  -xxx=`./findhdr sys/stat.h`
  -if $contains 'st_blocks;' "$xxx" >/dev/null 2>&1 ; then
  -	if $contains 'st_blksize;' "$xxx" >/dev/null 2>&1 ; then
  -		echo "Your stat() knows about block sizes." >&4
  -		val="$define"
  -	else
  -		echo "Your stat() doesn't know about block sizes." >&4
  -		val="$undef"
  -	fi
  -else
  -	echo "Your stat() doesn't know about block sizes." >&4
  -	val="$undef"
  -fi
  -set d_statblks
  -eval $setvar
  +set d_statblks stat st_blocks $i_sysstat sys/stat.h
  +eval $hasfield
   
   : see if _ptr and _cnt from stdio act std
   echo " "
  @@ -9567,6 +9651,32 @@ EOCP
   esac
   $rm -f try.c try
   
  +echo " "
  +echo "Determining whether or not we are on an EBCDIC system..." >&4
  +$cat >tebcdic.c <<EOM
  +int main()
  +{
  +  if ('M'==0xd4) return 0;
  +  return 1;
  +}
  +EOM
  +val=$undef
  +set tebcdic
  +if eval $compile_ok; then
  +	if ./tebcdic; then
  +		echo "You have EBCDIC." >&4
  +		val="$define"
  +	else
  +		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  +	fi
  +else
  +	echo "I'm unable to compile the test program." >&4
  +	echo "I'll assume ASCII or some ISO Latin." >&4
  +fi
  +$rm -f tebcdic.c tebcdic
  +set ebcdic
  +eval $setvar
  +
   : see what type file positions are declared as in the library
   rp="What is the type for file position used by fsetpos()?"
   set fpos_t fpostype long stdio.h sys/types.h
  @@ -10174,8 +10284,10 @@ EOM
   		: The first arg can be int, unsigned, or size_t
   		: The last arg may or may not be 'const'
   		val=''
  +		: void pointer has been seen but using that
  +		: breaks the selectminbits test
   		for xxx in 'fd_set *' 'int *'; do
  -			for nfd in 'int' 'size_t' 'unsigned' ; do
  +			for nfd in 'int' 'size_t' 'unsigned' 'unsigned long'; do
   				for tmo in 'struct timeval *' 'const struct timeval *'; do
   					case "$val" in
   					'')	try="extern select _(($nfd, $xxx, $xxx, $xxx, $tmo));"
  @@ -10207,6 +10319,100 @@ EOM
   	;;
   esac
   
  +: check for the select 'width'
  +case "$selectminbits" in
  +'') case "$d_select" in
  +	$define)
  +		$cat <<EOM
  +
  +Checking to see on how many bits at a time your select() operates...
  +EOM
  +		$cat >try.c <<EOCP
  +#include <sys/types.h>
  +#$i_time I_TIME
  +#$i_systime I_SYS_TIME
  +#$i_systimek I_SYS_TIME_KERNEL
  +#ifdef I_TIME
  +#   include <time.h>
  +#endif
  +#ifdef I_SYS_TIME
  +#   ifdef I_SYS_TIME_KERNEL
  +#	define KERNEL
  +#   endif
  +#   include <sys/time.h>
  +#   ifdef I_SYS_TIME_KERNEL
  +#	undef KERNEL
  +#   endif
  +#endif
  +#$i_sysselct I_SYS_SELECT
  +#ifdef I_SYS_SELECT
  +#include <sys/select.h>
  +#endif
  +#include <stdio.h>
  +$selecttype b;
  +#define S sizeof(*(b))
  +#define MINBITS	64
  +#define NBYTES (S * 8 > MINBITS ? S : MINBITS/8)
  +#define NBITS  (NBYTES * 8)
  +int main() {
  +    char s[NBYTES];
  +    struct timeval t;
  +    int i;
  +    FILE* fp;
  +    int fd;
  +
  +    fclose(stdin);
  +    fp = fopen("try.c", "r");
  +    if (fp == 0)
  +      exit(1);
  +    fd = fileno(fp);
  +    if (fd < 0)
  +      exit(2);
  +    b = ($selecttype)s;
  +    for (i = 0; i < NBITS; i++)
  +	FD_SET(i, b);
  +    t.tv_sec  = 0;
  +    t.tv_usec = 0;
  +    select(fd + 1, b, 0, 0, &t);
  +    for (i = NBITS - 1; i > fd && FD_ISSET(i, b); i--);
  +    printf("%d\n", i + 1);
  +    return 0;
  +}
  +EOCP
  +		set try
  +		if eval $compile_ok; then
  +			selectminbits=`./try`
  +			case "$selectminbits" in
  +			'')	cat >&4 <<EOM
  +Cannot figure out on how many bits at a time your select() operates.
  +I'll play safe and guess it is 32 bits.
  +EOM
  +				selectminbits=32
  +				bits="32 bits"
  +				;;
  +			1)	bits="1 bit" ;;
  +			*)	bits="$selectminbits bits" ;;
  +			esac
  +			echo "Your select() operates on $bits at a time." >&4
  +		else
  +			rp='What is the minimum number of bits your select() operates on?'
  +			case "$byteorder" in
  +			1234|12345678)	dflt=32 ;;
  +			*)		dflt=1	;;
  +			esac
  +			. ./myread
  +			val=$ans
  +			selectminbits="$val"
  +		fi
  +		$rm -f try.* try
  +		;;
  +	*)	: no select, so pick a harmless default
  +		selectminbits='32'
  +		;;
  +	esac
  +	;;
  +esac
  +
   : Trace out the files included by signal.h, then look for SIGxxx names.
   : Remove SIGARRAYSIZE used by HPUX.
   : Remove SIGTYP void lines used by OS2.
  @@ -10415,7 +10621,13 @@ $eunicefix signal_cmd
   : generate list of signal names
   echo " "
   case "$sig_name_init" in
  -'')
  +'') doinit=yes ;;
  +*)  case "$sig_num_init" in
  +    ''|*,*) doinit=yes ;;
  +    esac ;;
  +esac
  +case "$doinit" in
  +yes)
   	echo "Generating a list of signal names and numbers..." >&4
   	. ./signal_cmd
   	sig_name=`$awk '{printf "%s ", $1}' signal.lst`
  @@ -10423,7 +10635,9 @@ case "$sig_name_init" in
   	sig_name_init=`$awk 'BEGIN { printf "\"ZERO\", " }
   						{ printf "\"%s\", ", $1 }
   						END { printf "0\n" }' signal.lst`
  -	sig_num=`$awk 'BEGIN { printf "0, " }
  +	sig_num=`$awk '{printf "%d ", $2}' signal.lst`
  +	sig_num="0 $sig_num"
  +	sig_num_init=`$awk 'BEGIN { printf "0, " }
   					{ printf "%d, ", $2}
   					END { printf "0\n"}' signal.lst`
   	;;
  @@ -10787,7 +11001,13 @@ $rm -f try.c
   EOS
   chmod +x ccsym
   $eunicefix ccsym
  -./ccsym | $sort | $uniq >ccsym.raw
  +./ccsym > ccsym1.raw
  +if $test -s ccsym1.raw; then
  +       $sort ccsym1.raw | $uniq >ccsym.raw
  +else
  +       mv ccsym1.raw ccsym.raw
  +fi
  +
   $awk '/\=/ { print $0; next }
   	{ print $0"=1" }' ccsym.raw >ccsym.list
   $awk '{ print $0"=1" }' Cppsym.true >ccsym.true
  @@ -11012,10 +11232,6 @@ eval $inhdr
   set sys/resource.h i_sysresrc
   eval $inhdr
   
  -: see if sys/stat.h is available
  -set sys/stat.h i_sysstat
  -eval $inhdr
  -
   : see if this is a sys/un.h system
   set sys/un.h i_sysun
   eval $inhdr
  @@ -11152,6 +11368,7 @@ for xxx in $known_extensions ; do
   		esac
   		;;
   	IPC/SysV|ipc/sysv)
  +		: XXX Do we need a useipcsysv variable here
   		case "${d_msg}${d_sem}${d_shm}" in 
   		*"${define}"*) avail_ext="$avail_ext $xxx" ;;
   		esac
  @@ -11731,6 +11948,7 @@ i_values='$i_values'
   i_varargs='$i_varargs'
   i_varhdr='$i_varhdr'
   i_vfork='$i_vfork'
  +ignore_versioned_solibs='$ignore_versioned_solibs'
   incpath='$incpath'
   inews='$inews'
   installarchlib='$installarchlib'
  @@ -11839,6 +12057,7 @@ runnm='$runnm'
   scriptdir='$scriptdir'
   scriptdirexp='$scriptdirexp'
   sed='$sed'
  +selectminbits='$selectminbits'
   selecttype='$selecttype'
   sendmail='$sendmail'
   sh='$sh'
  @@ -11851,6 +12070,7 @@ shsharp='$shsharp'
   sig_name='$sig_name'
   sig_name_init='$sig_name_init'
   sig_num='$sig_num'
  +sig_num_init='$sig_num_init'
   signal_t='$signal_t'
   sitearch='$sitearch'
   sitearchexp='$sitearchexp'
  --- Makefile.SH
  +++ Makefile.SH
  @@ -644,3 +644,83 @@ case `pwd` in
       ;;
   esac
   $rm -f $firstmakefile
  +
  +# Now do any special processing required before building.
  +
  +case "$ebcdic" in
  +$define)
  +    xxx=''
  +    echo "This is an EBCDIC system, checking if any parser files need regenerating." >&4
  +case "$osname" in
  +os390)
  +    rm -f y.tab.c y.tab.h
  +    yacc -d perly.y >/dev/null 2>&1
  +    if cmp -s y.tab.c perly.c; then
  +        rm -f y.tab.c
  +    else
  +        echo "perly.y -> perly.c" >&2
  +        mv -f y.tab.c perly.c
  +        chmod u+w perly.c
  +        sed -e '/^#include "perl\.h"/a\
  +\
  +#define yydebug    PL_yydebug\
  +#define yynerrs    PL_yynerrs\
  +#define yyerrflag  PL_yyerrflag\
  +#define yychar     PL_yychar\
  +#define yyval      PL_yyval\
  +#define yylval     PL_yylval'				\
  +            -e '/YYSTYPE *yyval;/D'			\
  +            -e '/YYSTYPE *yylval;/D'			\
  +            -e '/int  yychar,/,/yynerrs;/D'		\
  +            -e 's/int yydebug = 0;/yydebug = 0;/'	\
  +            -e 's/[^_]realloc(/PerlMem_realloc(/g'	\
  +            -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +            -e 's/y\.tab/perly/g' perly.c >perly.tmp && mv perly.tmp perly.c
  +        xxx="$xxx perly.c"
  +    fi
  +    if cmp -s y.tab.h perly.h; then
  +        rm -f y.tab.h
  +    else
  +        echo "perly.y -> perly.h" >&2
  +        mv -f y.tab.h perly.h
  +        xxx="$xxx perly.h"
  +    fi
  +    if cd x2p
  +    then
  +        rm -f y.tab.c y.tab.h
  +        yacc a2p.y >/dev/null 2>&1
  +        if cmp -s y.tab.c a2p.c
  +        then
  +            rm -f y.tab.c
  +        else
  +            echo "a2p.y -> a2p.c" >&2
  +            mv -f y.tab.c a2p.c
  +            chmod u+w a2p.c
  +            sed -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +                -e 's/y\.tab/a2p/g' a2p.c >a2p.tmp && mv a2p.tmp a2p.c
  +            xxx="$xxx a2p.c"
  +        fi
  +        # In case somebody yacc -d:ed the a2p.y.
  +        if test -f y.tab.h
  +        then
  +            if cmp -s y.tab.h a2p.h
  +            then
  +                rm -f y.tab.h
  +            else
  +                echo "a2p.h -> a2p.h" >&2
  +                mv -f y.tab.h a2p.h
  +                xxx="$xxx a2p.h"
  +            fi
  +        fi
  +        cd ..
  +    fi
  +    ;;
  +*)
  +    echo "'$osname' is an EBCDIC system I don't know that well." >&4
  +    ;;
  +esac
  +    case "$xxx" in
  +    '') echo "No parser files were regenerated.  That's okay." >&2 ;;
  +    esac
  +    ;;
  +esac
  --- config_h.SH
  +++ config_h.SH
  @@ -1813,7 +1813,7 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
    *	the sig_name list.
    */
   #define SIG_NAME $sig_name_init		/**/
  -#define SIG_NUM  $sig_num			/**/
  +#define SIG_NUM  $sig_num_init		/**/
   
   /* VOIDFLAGS:
    *	This symbol indicates how much support of the void type is given by this
  @@ -1902,6 +1902,15 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
   #define PRIVLIB "$privlib"		/**/
   #define PRIVLIB_EXP "$privlibexp"		/**/
   
  +/* SELECT_MIN_BITS:
  + *	This symbol holds the minimum number of bits operated by select.
  + *	That is, if you do select(n, ...), how many bits at least will be
  + *	cleared in the masks if some activity is detected.  Usually this
  + *	is either n or 32*ceil(n/32), especially many little-endians do
  + *	the latter.  This is only useful if you have select(), naturally.
  + */
  +#define SELECT_MIN_BITS 	$selectminbits	/**/
  +
   /* SITEARCH:
    *	This symbol contains the name of the private library for this package.
    *	The library is private in the sense that it needn't be in anyone's
  --- pp_sys.c
  +++ pp_sys.c
  @@ -56,7 +56,10 @@ extern "C" int syscall(unsigned long,...);
   
   /* XXX Configure test needed.
      h_errno might not be a simple 'int', especially for multi-threaded
  -   applications.  HOST_NOT_FOUND is typically defined in <netdb.h>.
  +   applications, see "extern int errno in perl.h".  Creating such
  +   a test requires taking into account the differences between
  +   compiling multithreaded and singlethreaded ($ccflags et al).
  +   HOST_NOT_FOUND is typically defined in <netdb.h>.
   */
   #if defined(HOST_NOT_FOUND) && !defined(h_errno)
   extern int h_errno;
  @@ -753,12 +756,17 @@ PP(pp_sselect)
   	    maxlen = j;
       }
   
  +/* little endians can use vecs directly */
   #if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678
  -/* XXX Configure test needed. */
  -#if defined(__linux__) || defined(OS2) || defined(NeXT) || defined(__osf__) || defined(sun)
  -    growsize = sizeof(fd_set);
  +#  if SELECT_MIN_BITS > 1
  +    /* If SELECT_MIN_BITS is greater than one we most probably will want
  +     * to align the sizes with SELECT_MIN_BITS/8 because for example
  +     * in many little-endian (Intel, Alpha) systems (Linux, OS/2, Digital
  +     * UNIX, Solaris, NeXT) the smallest quantum select() operates on
  +     * (sets bit) is 32 bits.  */
  +    growsize = maxlen + (SELECT_MIN_BITS/8 - (maxlen % (SELECT_MIN_BITS/8)));
   #else
  -    growsize = maxlen;		/* little endians can use vecs directly */
  +    growsize = sizeof(fd_set);
   #endif
   #else
   #ifdef NFDBITS
  END
  --- Configure
  +++ Configure
  @@ -21,7 +21,7 @@
   # $Id: Head.U,v 3.0.1.9 1997/02/28 15:02:09 ram Exp $
   #
   # Generated on Tue Jul  7 10:10:21 EDT 1998 [metaconfig 3.0 PL70]
  -# (with additional metaconfig patches by doughera@lafayette.edu)
  +# (with additional metaconfig patches by jhi@iki.fi)
   
   cat >/tmp/c1$$ <<EOF
   ARGGGHHHH!!!!!
  @@ -56,33 +56,6 @@ case "$0" in
   	;;
   esac
   
  -: the newline for tr
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\n' x 2>/dev/null`" in
  -	foox)
  -		trnl='\n'
  -		;;
  -	esac
  -fi
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\012' x 2>/dev/null`" in
  -	foox)
  -		trnl='\012'
  -		;;
  -	esac
  -fi
  -if test -n "$DJGPP"; then
  -	trnl='\012'
  -fi
  -if test X"$trnl" = X; then
  -	cat <<EOM >&2
  -
  -$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  -
  -EOM
  -	exit 1
  -fi
  -
   : Proper separator for the PATH environment variable
   p_=:
   : On OS/2 this directory should exist if this is not floppy only system :-]
  @@ -391,7 +364,6 @@ d_getservprotos=''
   d_getsbyname=''
   d_getsbyport=''
   d_gnulibc=''
  -i_arpainet=''
   d_htonl=''
   d_inetaton=''
   d_isascii=''
  @@ -540,6 +512,7 @@ dlsrc=''
   ld=''
   lddlflags=''
   usedl=''
  +ebcdic=''
   doublesize=''
   fpostype=''
   gidtype=''
  @@ -548,6 +521,7 @@ h_fcntl=''
   h_sysfile=''
   db_hashtype=''
   db_prefixtype=''
  +i_arpainet=''
   i_db=''
   i_dbm=''
   i_rpcsvcdbm=''
  @@ -633,6 +607,7 @@ libpth=''
   loclibpth=''
   plibpth=''
   xlibpth=''
  +ignore_versioned_solibs=''
   libs=''
   lns=''
   lseektype=''
  @@ -697,11 +672,13 @@ randbits=''
   installscript=''
   scriptdir=''
   scriptdirexp=''
  +selectminbits=''
   selecttype=''
   sh=''
   sig_name=''
   sig_name_init=''
   sig_num=''
  +sig_num_init=''
   installsitearch=''
   sitearch=''
   sitearchexp=''
  @@ -719,6 +696,7 @@ startperl=''
   startsh=''
   stdchar=''
   sysman=''
  +trnl=''
   uidtype=''
   nm_opt=''
   nm_so_opt=''
  @@ -733,7 +711,6 @@ mips_type=''
   usrinc=''
   defvoidused=''
   voidflags=''
  -ebcdic=''
   CONFIG=''
   
   define='define'
  @@ -836,6 +813,8 @@ plibpth=''
   
   : default library list
   libswanted=''
  +: some systems want only to use the non-versioned libso:s
  +ignore_versioned_solibs=''
   : Possible local include directories to search.
   : Set locincpth to "" in a hint file to defeat local include searches.
   locincpth="/usr/local/include /opt/local/include /usr/gnu/include"
  @@ -904,7 +883,7 @@ case "$sh" in
   $me:  Fatal Error:  I can't find a Bourne Shell anywhere.  
   
   Usually it's in /bin/sh.  How did you even get this far?
  -Please contact me (Andy Dougherty) at doughera@lafayette.edu and 
  +Please contact me (Jarkko Hietaniemi) at jhi@iki.fi and 
   we'll try to straighten this all out.
   EOM
   	exit 1
  @@ -1240,7 +1219,7 @@ cat >extract <<'EOS'
   CONFIG=true
   echo "Doing variable substitutions on .SH files..."
   if test -f $src/MANIFEST; then
  -	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH'`
  +	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH$'`
   else
   	echo "(Looking for .SH files under the source directory.)"
   	set x `(cd $src; find . -name "*.SH" -print)`
  @@ -1373,7 +1352,7 @@ THIS PACKAGE SEEMS TO BE INCOMPLETE.
   You have the option of continuing the configuration process, despite the
   distinct possibility that your kit is damaged, by typing 'y'es.  If you
   do, don't blame me if something goes wrong.  I advise you to type 'n'o
  -and contact the author (doughera@lafayette.edu).
  +and contact the author (jhi@iki.fi).
   
   EOM
   		echo $n "Continue? [n] $c" >&4
  @@ -1396,6 +1375,30 @@ else
   fi
   rm -f missing x??
   
  +echo " "
  +: Find the appropriate value for a newline for tr
  +if test -n "$DJGPP"; then
  +       trnl='\012'
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\n' x 2>/dev/null`" in
  +	foox) trnl='\n' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\012' x 2>/dev/null`" in
  +	foox) trnl='\012' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	cat <<EOM >&2
  +
  +$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  +
  +EOM
  +	exit 1
  +fi
  +
   : compute the number of columns on the terminal for proper question formatting
   case "$COLUMNS" in
   '') COLUMNS='80';;
  @@ -1574,7 +1577,7 @@ Much effort has been expended to ensure that this shell script will run on any
   Unix system.  If despite that it blows up on yours, your best bet is to edit
   Configure and run it again.  If you can't run Configure for some reason,
   you'll have to generate a config.sh file by hand.  Whatever problems you
  -have, let me (doughera@lafayette.edu) know how I blew it.
  +have, let me (jhi@iki.fi) know how I blew it.
   
   This installation script affects things in two ways:
   
  @@ -1841,14 +1844,14 @@ ABYZ)
   	    *C9D1*|*c9d1*)
   		echo "Hey, this might be EBCDIC." >&4
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
  +		    case "`echo IJ | $tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
   		    ij) up='[A-IJ-RS-Z]'
   		        low='[a-ij-rs-z]'
   			;;
   		    esac
   		fi
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
  +		    case "`echo IJ | $tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
   		    ij) up='A-IJ-RS-Z'
   		        low='a-ij-rs-z'
   			;;
  @@ -1941,7 +1944,7 @@ EOM
   	(cd $src/hints; ls -C *.sh) | $sed 's/\.sh/   /g' >&4
   	dflt=''
   	: Half the following guesses are probably wrong... If you have better
  -	: tests or hints, please send them to doughera@lafayette.edu
  +	: tests or hints, please send them to jhi@iki.fi
   	: The metaconfig authors would also appreciate a copy...
   	$test -f /irix && osname=irix
   	$test -f /xenix && osname=sco_xenix
  @@ -2025,7 +2028,7 @@ EOM
   			osvers="$3"
   			;;
   		dynixptx*) osname=dynixptx
  -			osvers="$3"
  +			osvers=`echo "$4" | $sed 's/^v//'`
   			;;
   		freebsd) osname=freebsd 
   			osvers="$3" ;;
  @@ -3454,7 +3457,11 @@ cat <<'EOT' >testcpp.c
   ABC.XYZ
   EOT
   cd ..
  +if test ! -f cppstdin; then
   echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
  +else
  +	echo "Keeping your $hint cppstdin wrapper."
  +fi
   chmod 755 cppstdin
   wrapper=`pwd`/cppstdin
   ok='false'
  @@ -3705,7 +3712,8 @@ case "$libswanted" in
   esac
   for thislib in $libswanted; do
   	
  -	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`; $test -f "$xxx"; then
  +	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`;
  +		$test -f "$xxx" -a "X$ignore_versioned_solibs" = "X"; then
   		echo "Found -l$thislib (shared)."
   		case " $dflt " in
   		*"-l$thislib "*);;
  @@ -3992,10 +4000,21 @@ rmlist="$rmlist pdp11"
   : coherency check
   echo " "
   echo "Checking your choice of C compiler and flags for coherency..." >&4
  +$cat > try.c <<'EOF'
  +#include <stdio.h>
  +main() { printf("Ok\n"); exit(0); }
  +EOF
   set X $cc $optimize $ccflags -o try $ldflags try.c $libs
   shift
  -$cat >try.msg <<EOM
  -I've tried to compile and run a simple program with:
  +$cat >try.msg <<'EOM'
  +I've tried to compile and run the following simple program:
  +
  +EOM
  +$cat try.c
  +
  +$cat >> try.msg <<EOM
  +
  +I used the command:
   
   	$*
   	./try
  @@ -4003,10 +4022,6 @@ I've tried to compile and run a simple program with:
   and I got the following output:
   
   EOM
  -$cat > try.c <<'EOF'
  -#include <stdio.h>
  -main() { printf("Ok\n"); exit(0); }
  -EOF
   dflt=y
   if sh -c "$cc $optimize $ccflags -o try $ldflags try.c $libs" >>try.msg 2>&1; then
   	if sh -c './try' >>try.msg 2>&1; then
  @@ -4043,7 +4058,7 @@ y)
   	$cat try.msg >&4
   	case "$knowitall" in
   	'')
  -		echo "(The supplied flags might be incorrect with this C compiler.)"
  +		echo "(The supplied flags or libraries might be incorrect.)"
   		;;
   	*) dflt=n;;
   	esac
  @@ -4161,9 +4176,8 @@ eval $inhdr
   : determine which malloc to compile in
   echo " "
   case "$usemymalloc" in
  -''|y*|true)	dflt='y' ;;
  -n*|false)	dflt='n' ;;
  -*)	dflt="$usemymalloc" ;;
  +''|[yY]*|true|$define)	dflt='y' ;;
  +*)	dflt='n' ;;
   esac
   rp="Do you wish to attempt to use the malloc that comes with $package?"
   . ./myread
  @@ -4265,7 +4279,7 @@ understands function prototypes.  Unfortunately, your C compiler
   	$cc $ccflags
   doesn't seem to understand them.  Sorry about that.
   
  -If GNU cc is avaiable for your system, perhaps you could try that instead.  
  +If GNU cc is available for your system, perhaps you could try that instead.  
   
   Eventually, we hope to support building Perl with pre-ANSI compilers.
   If you would like to help in that effort, please contact <perlbug@perl.org>.
  @@ -4320,32 +4334,6 @@ shift;
   $cc $optimize $ccflags $ldflags -o ${mc_file} $* ${mc_file}.c $libs;'
   
   echo " "
  -echo "Determining whether or not we are on an EBCDIC system..." >&4
  -cat >tebcdic.c <<EOM
  -int main()
  -{
  -  if ('M'==0xd4) return 0;
  -  return 1;
  -}
  -EOM
  -val=$undef
  -set tebcdic
  -if eval $compile_ok; then
  -	if ./tebcdic; then
  -		echo "You have EBCDIC." >&4
  -		val="$define"
  -	else
  -		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  -	fi
  -else
  -	echo "I'm unable to compile the test program." >&4
  -	echo "I'll asuume ASCII or some ISO Latin." >&4
  -fi
  -$rm -f tebcdic.c tebcdic
  -set ebcdic
  -eval $setvar
  -
  -echo " "
   echo "Checking for GNU C Library..." >&4
   cat >gnulibc.c <<EOM
   #include <stdio.h>
  @@ -5159,7 +5147,7 @@ case "$shrpdir" in
   *)	$cat >&4 <<EOM
   WARNING:  Use of the shrpdir variable for the installation location of
   the shared $libperl is not supported.  It was never documented and
  -will not work in this version.  Let me (doughera@lafayette.edu)
  +will not work in this version.  Let me (jhi@iki.fi)
   know of any problems this may cause.
   
   EOM
  @@ -6715,6 +6703,10 @@ eval $setvar
   set difftime d_difftime
   eval $inlibc
   
  +: see if sys/stat.h is available
  +set sys/stat.h i_sysstat
  +eval $inhdr
  +
   : see if this is a dirent system
   echo " "
   if xinc=`./findhdr dirent.h`; $test "$xinc"; then
  @@ -6783,6 +6775,23 @@ set d_dirnamlen
   eval $setvar
   $rm -f try.c
   
  +hasfield='varname=$1; struct=$2; field=$3; shift; shift; shift;
  +while $test $# -ge 2; do
  +	case "$1" in
  +	$define) echo "#include <$2>";;
  +	esac ;
  +    shift 2;
  +done > try.c;
  +echo "int main () { struct $struct foo; foo.$field = 0; }" >> try.c;
  +if eval $cc $optimize $ccflags -c try.c >/dev/null 2>&1; then
  +	val="$define";
  +else
  +	val="$undef";
  +fi;
  +set $varname;
  +eval $setvar;
  +$rm -f try.c try.o'
  +
   : see if dlerror exists
   xxx_runnm="$runnm"
   runnm=false
  @@ -7317,7 +7326,7 @@ esac
   set netinet/in.h i_niin sys/in.h i_sysin
   eval $inhdr
   
  -: see if this is an arpa/inet.h
  +: see if arpa/inet.h has to be included
   set arpa/inet.h i_arpainet
   eval $inhdr
   
  @@ -7643,6 +7652,27 @@ echo " "
   case "$d_msgctl$d_msgget$d_msgsnd$d_msgrcv" in
   *"$undef"*) h_msg=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID messages"*"not configured"*)
  +	echo "But your $osname does not have the msg*(2) configured." >&4
  +        h_msg=false
  +	val="$undef"
  +	set msgctl d_msgctl
  +	eval $setvar
  +	set msgget d_msgget
  +	eval $setvar
  +	set msgsnd d_msgsnd
  +	eval $setvar
  +	set msgrcv d_msgrcv
  +	eval $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_msg && $test `./findhdr sys/msg.h`; then
   	echo "You have the full msg*(2) library." >&4
  @@ -7671,7 +7701,7 @@ set poll d_poll
   eval $inlibc
   
   
  -: see whether the various POSIXish _yields exist within given cccmd
  +: see whether the various POSIXish _yields exist
   $cat >try.c <<EOP
   #include <pthread.h>
   main() {
  @@ -8125,6 +8155,25 @@ echo " "
   case "$d_semctl$d_semget$d_semop" in
   *"$undef"*) h_sem=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID messages"*"not configured"*)
  +	echo "But your $osname does not have the sem*(2) configured." >&4
  +        h_sem=false
  +	val="$undef"
  +	set semctl d_semctl
  +	eval $setvar
  +	set semget d_semget
  +	eval $setvar
  +	set semop d_semop
  +	eval $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_sem && $test `./findhdr sys/sem.h`; then
   	echo "You have the full sem*(2) library." >&4
  @@ -8161,6 +8210,31 @@ case "$d_sem" in
   $define)
       : see whether semctl IPC_STAT can use union semun
       echo " "
  +    $cat > try.h <<END
  +#ifndef S_IRUSR
  +#   ifdef S_IREAD
  +#	define S_IRUSR S_IREAD
  +#	define S_IWUSR S_IWRITE
  +#	define S_IXUSR S_IEXEC
  +#   else
  +#	define S_IRUSR 0400
  +#	define S_IWUSR 0200
  +#	define S_IXUSR 0100
  +#   endif
  +#   define S_IRGRP (S_IRUSR>>3)
  +#   define S_IWGRP (S_IWUSR>>3)
  +#   define S_IXGRP (S_IXUSR>>3)
  +#   define S_IROTH (S_IRUSR>>6)
  +#   define S_IWOTH (S_IWUSR>>6)
  +#   define S_IXOTH (S_IXUSR>>6)
  +#endif
  +#ifndef S_IRWXU
  +#   define S_IRWXU (S_IRUSR|S_IWUSR|S_IXUSR)
  +#   define S_IRWXG (S_IRGRP|S_IWGRP|S_IXGRP)
  +#   define S_IRWXO (S_IROTH|S_IWOTH|S_IXOTH)
  +#endif
  +END
  +
       $cat > try.c <<END
   #include <sys/types.h>
   #include <sys/ipc.h>
  @@ -8235,6 +8309,7 @@ END
   #include <sys/stat.h>
   #include <stdio.h>
   #include <errno.h>
  +#include "try.h"
   #ifndef errno
   extern int errno;
   #endif
  @@ -8281,6 +8356,7 @@ END
       *)  echo "You cannot use struct semid_ds * for semctl IPC_STAT." >&4
           ;;
       esac
  +    $rm -f try.h
       ;;
   *)  val="$undef"
   
  @@ -8471,6 +8547,27 @@ echo " "
   case "$d_shmctl$d_shmget$d_shmat$d_shmdt" in
   *"$undef"*) h_shm=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID shared memory"*"not configured"*)
  +	echo "But your $osname does not have the shm*(2) configured." >&4
  +        h_shm=false
  +	val="$undef"
  +	set shmctl d_shmctl
  +	evat $setvar
  +	set shmget d_shmget
  +	evat $setvar
  +	set shmat d_shmat
  +	evat $setvar
  +	set shmdt d_shmdt
  +	evat $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_shm && $test `./findhdr sys/shm.h`; then
   	echo "You have the full shm*(2) library." >&4
  @@ -8609,21 +8706,8 @@ eval $inlibc
   
   : see if stat knows about block sizes
   echo " "
  -xxx=`./findhdr sys/stat.h`
  -if $contains 'st_blocks;' "$xxx" >/dev/null 2>&1 ; then
  -	if $contains 'st_blksize;' "$xxx" >/dev/null 2>&1 ; then
  -		echo "Your stat() knows about block sizes." >&4
  -		val="$define"
  -	else
  -		echo "Your stat() doesn't know about block sizes." >&4
  -		val="$undef"
  -	fi
  -else
  -	echo "Your stat() doesn't know about block sizes." >&4
  -	val="$undef"
  -fi
  -set d_statblks
  -eval $setvar
  +set d_statblks stat st_blocks $i_sysstat sys/stat.h
  +eval $hasfield
   
   : see if _ptr and _cnt from stdio act std
   echo " "
  @@ -9567,6 +9651,32 @@ EOCP
   esac
   $rm -f try.c try
   
  +echo " "
  +echo "Determining whether or not we are on an EBCDIC system..." >&4
  +$cat >tebcdic.c <<EOM
  +int main()
  +{
  +  if ('M'==0xd4) return 0;
  +  return 1;
  +}
  +EOM
  +val=$undef
  +set tebcdic
  +if eval $compile_ok; then
  +	if ./tebcdic; then
  +		echo "You have EBCDIC." >&4
  +		val="$define"
  +	else
  +		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  +	fi
  +else
  +	echo "I'm unable to compile the test program." >&4
  +	echo "I'll assume ASCII or some ISO Latin." >&4
  +fi
  +$rm -f tebcdic.c tebcdic
  +set ebcdic
  +eval $setvar
  +
   : see what type file positions are declared as in the library
   rp="What is the type for file position used by fsetpos()?"
   set fpos_t fpostype long stdio.h sys/types.h
  @@ -10174,8 +10284,10 @@ EOM
   		: The first arg can be int, unsigned, or size_t
   		: The last arg may or may not be 'const'
   		val=''
  +		: void pointer has been seen but using that
  +		: breaks the selectminbits test
   		for xxx in 'fd_set *' 'int *'; do
  -			for nfd in 'int' 'size_t' 'unsigned' ; do
  +			for nfd in 'int' 'size_t' 'unsigned' 'unsigned long'; do
   				for tmo in 'struct timeval *' 'const struct timeval *'; do
   					case "$val" in
   					'')	try="extern select _(($nfd, $xxx, $xxx, $xxx, $tmo));"
  @@ -10207,6 +10319,100 @@ EOM
   	;;
   esac
   
  +: check for the select 'width'
  +case "$selectminbits" in
  +'') case "$d_select" in
  +	$define)
  +		$cat <<EOM
  +
  +Checking to see on how many bits at a time your select() operates...
  +EOM
  +		$cat >try.c <<EOCP
  +#include <sys/types.h>
  +#$i_time I_TIME
  +#$i_systime I_SYS_TIME
  +#$i_systimek I_SYS_TIME_KERNEL
  +#ifdef I_TIME
  +#   include <time.h>
  +#endif
  +#ifdef I_SYS_TIME
  +#   ifdef I_SYS_TIME_KERNEL
  +#	define KERNEL
  +#   endif
  +#   include <sys/time.h>
  +#   ifdef I_SYS_TIME_KERNEL
  +#	undef KERNEL
  +#   endif
  +#endif
  +#$i_sysselct I_SYS_SELECT
  +#ifdef I_SYS_SELECT
  +#include <sys/select.h>
  +#endif
  +#include <stdio.h>
  +$selecttype b;
  +#define S sizeof(*(b))
  +#define MINBITS	64
  +#define NBYTES (S * 8 > MINBITS ? S : MINBITS/8)
  +#define NBITS  (NBYTES * 8)
  +int main() {
  +    char s[NBYTES];
  +    struct timeval t;
  +    int i;
  +    FILE* fp;
  +    int fd;
  +
  +    fclose(stdin);
  +    fp = fopen("try.c", "r");
  +    if (fp == 0)
  +      exit(1);
  +    fd = fileno(fp);
  +    if (fd < 0)
  +      exit(2);
  +    b = ($selecttype)s;
  +    for (i = 0; i < NBITS; i++)
  +	FD_SET(i, b);
  +    t.tv_sec  = 0;
  +    t.tv_usec = 0;
  +    select(fd + 1, b, 0, 0, &t);
  +    for (i = NBITS - 1; i > fd && FD_ISSET(i, b); i--);
  +    printf("%d\n", i + 1);
  +    return 0;
  +}
  +EOCP
  +		set try
  +		if eval $compile_ok; then
  +			selectminbits=`./try`
  +			case "$selectminbits" in
  +			'')	cat >&4 <<EOM
  +Cannot figure out on how many bits at a time your select() operates.
  +I'll play safe and guess it is 32 bits.
  +EOM
  +				selectminbits=32
  +				bits="32 bits"
  +				;;
  +			1)	bits="1 bit" ;;
  +			*)	bits="$selectminbits bits" ;;
  +			esac
  +			echo "Your select() operates on $bits at a time." >&4
  +		else
  +			rp='What is the minimum number of bits your select() operates on?'
  +			case "$byteorder" in
  +			1234|12345678)	dflt=32 ;;
  +			*)		dflt=1	;;
  +			esac
  +			. ./myread
  +			val=$ans
  +			selectminbits="$val"
  +		fi
  +		$rm -f try.* try
  +		;;
  +	*)	: no select, so pick a harmless default
  +		selectminbits='32'
  +		;;
  +	esac
  +	;;
  +esac
  +
   : Trace out the files included by signal.h, then look for SIGxxx names.
   : Remove SIGARRAYSIZE used by HPUX.
   : Remove SIGTYP void lines used by OS2.
  @@ -10415,7 +10621,13 @@ $eunicefix signal_cmd
   : generate list of signal names
   echo " "
   case "$sig_name_init" in
  -'')
  +'') doinit=yes ;;
  +*)  case "$sig_num_init" in
  +    ''|*,*) doinit=yes ;;
  +    esac ;;
  +esac
  +case "$doinit" in
  +yes)
   	echo "Generating a list of signal names and numbers..." >&4
   	. ./signal_cmd
   	sig_name=`$awk '{printf "%s ", $1}' signal.lst`
  @@ -10423,7 +10635,9 @@ case "$sig_name_init" in
   	sig_name_init=`$awk 'BEGIN { printf "\"ZERO\", " }
   						{ printf "\"%s\", ", $1 }
   						END { printf "0\n" }' signal.lst`
  -	sig_num=`$awk 'BEGIN { printf "0, " }
  +	sig_num=`$awk '{printf "%d ", $2}' signal.lst`
  +	sig_num="0 $sig_num"
  +	sig_num_init=`$awk 'BEGIN { printf "0, " }
   					{ printf "%d, ", $2}
   					END { printf "0\n"}' signal.lst`
   	;;
  @@ -10787,7 +11001,13 @@ $rm -f try.c
   EOS
   chmod +x ccsym
   $eunicefix ccsym
  -./ccsym | $sort | $uniq >ccsym.raw
  +./ccsym > ccsym1.raw
  +if $test -s ccsym1.raw; then
  +       $sort ccsym1.raw | $uniq >ccsym.raw
  +else
  +       mv ccsym1.raw ccsym.raw
  +fi
  +
   $awk '/\=/ { print $0; next }
   	{ print $0"=1" }' ccsym.raw >ccsym.list
   $awk '{ print $0"=1" }' Cppsym.true >ccsym.true
  @@ -11012,10 +11232,6 @@ eval $inhdr
   set sys/resource.h i_sysresrc
   eval $inhdr
   
  -: see if sys/stat.h is available
  -set sys/stat.h i_sysstat
  -eval $inhdr
  -
   : see if this is a sys/un.h system
   set sys/un.h i_sysun
   eval $inhdr
  @@ -11152,6 +11368,7 @@ for xxx in $known_extensions ; do
   		esac
   		;;
   	IPC/SysV|ipc/sysv)
  +		: XXX Do we need a useipcsysv variable here
   		case "${d_msg}${d_sem}${d_shm}" in 
   		*"${define}"*) avail_ext="$avail_ext $xxx" ;;
   		esac
  @@ -11731,6 +11948,7 @@ i_values='$i_values'
   i_varargs='$i_varargs'
   i_varhdr='$i_varhdr'
   i_vfork='$i_vfork'
  +ignore_versioned_solibs='$ignore_versioned_solibs'
   incpath='$incpath'
   inews='$inews'
   installarchlib='$installarchlib'
  @@ -11839,6 +12057,7 @@ runnm='$runnm'
   scriptdir='$scriptdir'
   scriptdirexp='$scriptdirexp'
   sed='$sed'
  +selectminbits='$selectminbits'
   selecttype='$selecttype'
   sendmail='$sendmail'
   sh='$sh'
  @@ -11851,6 +12070,7 @@ shsharp='$shsharp'
   sig_name='$sig_name'
   sig_name_init='$sig_name_init'
   sig_num='$sig_num'
  +sig_num_init='$sig_num_init'
   signal_t='$signal_t'
   sitearch='$sitearch'
   sitearchexp='$sitearchexp'
  --- Makefile.SH
  +++ Makefile.SH
  @@ -644,3 +644,83 @@ case `pwd` in
       ;;
   esac
   $rm -f $firstmakefile
  +
  +# Now do any special processing required before building.
  +
  +case "$ebcdic" in
  +$define)
  +    xxx=''
  +    echo "This is an EBCDIC system, checking if any parser files need regenerating." >&4
  +case "$osname" in
  +os390)
  +    rm -f y.tab.c y.tab.h
  +    yacc -d perly.y >/dev/null 2>&1
  +    if cmp -s y.tab.c perly.c; then
  +        rm -f y.tab.c
  +    else
  +        echo "perly.y -> perly.c" >&2
  +        mv -f y.tab.c perly.c
  +        chmod u+w perly.c
  +        sed -e '/^#include "perl\.h"/a\
  +\
  +#define yydebug    PL_yydebug\
  +#define yynerrs    PL_yynerrs\
  +#define yyerrflag  PL_yyerrflag\
  +#define yychar     PL_yychar\
  +#define yyval      PL_yyval\
  +#define yylval     PL_yylval'				\
  +            -e '/YYSTYPE *yyval;/D'			\
  +            -e '/YYSTYPE *yylval;/D'			\
  +            -e '/int  yychar,/,/yynerrs;/D'		\
  +            -e 's/int yydebug = 0;/yydebug = 0;/'	\
  +            -e 's/[^_]realloc(/PerlMem_realloc(/g'	\
  +            -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +            -e 's/y\.tab/perly/g' perly.c >perly.tmp && mv perly.tmp perly.c
  +        xxx="$xxx perly.c"
  +    fi
  +    if cmp -s y.tab.h perly.h; then
  +        rm -f y.tab.h
  +    else
  +        echo "perly.y -> perly.h" >&2
  +        mv -f y.tab.h perly.h
  +        xxx="$xxx perly.h"
  +    fi
  +    if cd x2p
  +    then
  +        rm -f y.tab.c y.tab.h
  +        yacc a2p.y >/dev/null 2>&1
  +        if cmp -s y.tab.c a2p.c
  +        then
  +            rm -f y.tab.c
  +        else
  +            echo "a2p.y -> a2p.c" >&2
  +            mv -f y.tab.c a2p.c
  +            chmod u+w a2p.c
  +            sed -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +                -e 's/y\.tab/a2p/g' a2p.c >a2p.tmp && mv a2p.tmp a2p.c
  +            xxx="$xxx a2p.c"
  +        fi
  +        # In case somebody yacc -d:ed the a2p.y.
  +        if test -f y.tab.h
  +        then
  +            if cmp -s y.tab.h a2p.h
  +            then
  +                rm -f y.tab.h
  +            else
  +                echo "a2p.h -> a2p.h" >&2
  +                mv -f y.tab.h a2p.h
  +                xxx="$xxx a2p.h"
  +            fi
  +        fi
  +        cd ..
  +    fi
  +    ;;
  +*)
  +    echo "'$osname' is an EBCDIC system I don't know that well." >&4
  +    ;;
  +esac
  +    case "$xxx" in
  +    '') echo "No parser files were regenerated.  That's okay." >&2 ;;
  +    esac
  +    ;;
  +esac
  --- config_h.SH
  +++ config_h.SH
  @@ -1813,7 +1813,7 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
    *	the sig_name list.
    */
   #define SIG_NAME $sig_name_init		/**/
  -#define SIG_NUM  $sig_num			/**/
  +#define SIG_NUM  $sig_num_init		/**/
   
   /* VOIDFLAGS:
    *	This symbol indicates how much support of the void type is given by this
  @@ -1902,6 +1902,15 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
   #define PRIVLIB "$privlib"		/**/
   #define PRIVLIB_EXP "$privlibexp"		/**/
   
  +/* SELECT_MIN_BITS:
  + *	This symbol holds the minimum number of bits operated by select.
  + *	That is, if you do select(n, ...), how many bits at least will be
  + *	cleared in the masks if some activity is detected.  Usually this
  + *	is either n or 32*ceil(n/32), especially many little-endians do
  + *	the latter.  This is only useful if you have select(), naturally.
  + */
  +#define SELECT_MIN_BITS 	$selectminbits	/**/
  +
   /* SITEARCH:
    *	This symbol contains the name of the private library for this package.
    *	The library is private in the sense that it needn't be in anyone's
  --- pp_sys.c
  +++ pp_sys.c
  @@ -56,7 +56,10 @@ extern "C" int syscall(unsigned long,...);
   
   /* XXX Configure test needed.
      h_errno might not be a simple 'int', especially for multi-threaded
  -   applications.  HOST_NOT_FOUND is typically defined in <netdb.h>.
  +   applications, see "extern int errno in perl.h".  Creating such
  +   a test requires taking into account the differences between
  +   compiling multithreaded and singlethreaded ($ccflags et al).
  +   HOST_NOT_FOUND is typically defined in <netdb.h>.
   */
   #if defined(HOST_NOT_FOUND) && !defined(h_errno)
   extern int h_errno;
  @@ -753,12 +756,17 @@ PP(pp_sselect)
   	    maxlen = j;
       }
   
  +/* little endians can use vecs directly */
   #if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678
  -/* XXX Configure test needed. */
  -#if defined(__linux__) || defined(OS2) || defined(NeXT) || defined(__osf__)
  -    growsize = sizeof(fd_set);
  +#  if SELECT_MIN_BITS > 1
  +    /* If SELECT_MIN_BITS is greater than one we most probably will want
  +     * to align the sizes with SELECT_MIN_BITS/8 because for example
  +     * in many little-endian (Intel, Alpha) systems (Linux, OS/2, Digital
  +     * UNIX, Solaris, NeXT) the smallest quantum select() operates on
  +     * (sets bit) is 32 bits.  */
  +    growsize = maxlen + (SELECT_MIN_BITS/8 - (maxlen % (SELECT_MIN_BITS/8)));
   #else
  -    growsize = maxlen;		/* little endians can use vecs directly */
  +    growsize = sizeof(fd_set);
   #endif
   #else
   #ifdef NFDBITS
  END
  diff --git a/ext/Errno/Errno_pm.PL b/ext/Errno/Errno_pm.PL
  index df68dc3..8385048 100644
  --- ext/Errno/Errno_pm.PL
  +++ ext/Errno/Errno_pm.PL
  @@ -143,16 +143,26 @@ sub write_errno_pm {
   
       # invoke CPP and read the output
   
  +    my $inhibit_linemarkers = '';
  +    if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
  +        # GCC 5.0 interleaves expanded macros with line numbers breaking
  +        # each line into multiple lines. RT#123784
  +        $inhibit_linemarkers = ' -P';
  +    }
  +
       if ($^O eq 'VMS') {
  -	my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
  +  my $cpp = "$Config{cppstdin} $Config{cppflags}" .
  +    $inhibit_linemarkers . " $Config{cppminus}";
   	$cpp =~ s/sys\$input//i;
   	open(CPPO,"$cpp  errno.c |") or
             die "Cannot exec $Config{cppstdin}";
       } elsif ($^O eq 'MSWin32') {
  -	open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
  -	    die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
  +       my $cpp = "$Config{cpprun} $Config{cppflags}" .
  +         $inhibit_linemarkers;
  +       open(CPPO,"$cpp errno.c |") or
  +         die "Cannot run '$cpp errno.c'";
       } else {
  -	my $cpp = default_cpp();
  +	my $cpp = default_cpp() . $inhibit_linemarkers;
   	open(CPPO,"$cpp < errno.c |")
   	    or die "Cannot exec $cpp";
       }
  END
  diff --git a/ext/Errno/Errno_pm.PL b/ext/Errno/Errno_pm.PL
  index 3f2f3e0..d8fe44e 100644
  --- ext/Errno/Errno_pm.PL
  +++ ext/Errno/Errno_pm.PL
  @@ -172,16 +172,26 @@ sub write_errno_pm {
       unless ($^O eq 'MacOS') {	# trust what we have
       # invoke CPP and read the output
   
  +       my $inhibit_linemarkers = '';
  +       if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
  +           # GCC 5.0 interleaves expanded macros with line numbers breaking
  +           # each line into multiple lines. RT#123784
  +           $inhibit_linemarkers = ' -P';
  +       }
  +
   	if ($^O eq 'VMS') {
  -	    my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
  +	    my $cpp = "$Config{cppstdin} $Config{cppflags}" .
  +        $inhibit_linemarkers . " $Config{cppminus}";
   	    $cpp =~ s/sys\$input//i;
   	    open(CPPO,"$cpp  errno.c |") or
   		die "Cannot exec $Config{cppstdin}";
   	} elsif ($^O eq 'MSWin32') {
  -	    open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
  -		die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
  +           my $cpp = "$Config{cpprun} $Config{cppflags}" .
  +               $inhibit_linemarkers;
  +           open(CPPO,"$cpp errno.c |") or
  +               die "Cannot run '$cpp errno.c'";
   	} else {
  -	    my $cpp = default_cpp();
  +	    my $cpp = default_cpp() . $inhibit_linemarkers;
   	    open(CPPO,"$cpp < errno.c |")
   		or die "Cannot exec $cpp";
   	}
  END
  diff --git a/ext/Errno/Errno_pm.PL b/ext/Errno/Errno_pm.PL
  index 3f2f3e0..d8fe44e 100644
  --- ext/Errno/Errno_pm.PL
  +++ ext/Errno/Errno_pm.PL
  @@ -172,16 +172,26 @@ sub write_errno_pm {
       unless ($^O eq 'MacOS') {	# trust what we have
       # invoke CPP and read the output
   
  +       my $inhibit_linemarkers = '';
  +       if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
  +           # GCC 5.0 interleaves expanded macros with line numbers breaking
  +           # each line into multiple lines. RT#123784
  +           $inhibit_linemarkers = ' -P';
  +       }
  +
   	if ($^O eq 'VMS') {
  -	    my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
  +	    my $cpp = "$Config{cppstdin} $Config{cppflags}" .
  +        $inhibit_linemarkers . " $Config{cppminus}";
   	    $cpp =~ s/sys\$input//i;
   	    open(CPPO,"$cpp  errno.c |") or
   		die "Cannot exec $Config{cppstdin}";
   	} elsif ($^O eq 'MSWin32' || $^O eq 'NetWare') {
  -	    open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
  -		die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
  +           my $cpp = "$Config{cpprun} $Config{cppflags}" .
  +               $inhibit_linemarkers;
  +           open(CPPO,"$cpp errno.c |") or
  +               die "Cannot run '$cpp errno.c'";
   	} else {
  -	    my $cpp = default_cpp();
  +	    my $cpp = default_cpp() . $inhibit_linemarkers;
   	    open(CPPO,"$cpp < errno.c |")
   		or die "Cannot exec $cpp";
   	}
  END
  diff --git a/ext/Errno/Errno_pm.PL b/ext/Errno/Errno_pm.PL
  index d8a0ab3..796e2f1 100644
  --- ext/Errno/Errno_pm.PL
  +++ ext/Errno/Errno_pm.PL
  @@ -235,16 +235,26 @@ sub write_errno_pm {
       unless ($^O eq 'MacOS' || $^O eq 'beos') {	# trust what we have / get later
       # invoke CPP and read the output
   
  +       my $inhibit_linemarkers = '';
  +       if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
  +           # GCC 5.0 interleaves expanded macros with line numbers breaking
  +           # each line into multiple lines. RT#123784
  +           $inhibit_linemarkers = ' -P';
  +       }
  +
   	if ($^O eq 'VMS') {
  -	    my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
  +      my $cpp = "$Config{cppstdin} $Config{cppflags}" .
  +      $inhibit_linemarkers . " $Config{cppminus}";
   	    $cpp =~ s/sys\$input//i;
   	    open(CPPO,"$cpp  errno.c |") or
   		die "Cannot exec $Config{cppstdin}";
   	} elsif ($^O eq 'MSWin32' || $^O eq 'NetWare') {
  -	    open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
  -		die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
  +           my $cpp = "$Config{cpprun} $Config{cppflags}" .
  +               $inhibit_linemarkers;
  +           open(CPPO,"$cpp errno.c |") or
  +               die "Cannot run '$cpp errno.c'";
   	} else {
  -	    my $cpp = default_cpp();
  +	    my $cpp = default_cpp() . $inhibit_linemarkers;
   	    open(CPPO,"$cpp < errno.c |")
   		or die "Cannot exec $cpp";
   	}
  END
  diff --git a/ext/Errno/Errno_pm.PL b/ext/Errno/Errno_pm.PL
  index 3dadfce..c6bfa06 100644
  --- ext/Errno/Errno_pm.PL
  +++ ext/Errno/Errno_pm.PL
  @@ -215,20 +215,31 @@ sub write_errno_pm {
       {	# BeOS (support now removed) did not enter this block
       # invoke CPP and read the output
   
  +	my $inhibit_linemarkers = '';
  +	if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
  +	    # GCC 5.0 interleaves expanded macros with line numbers breaking
  +	    # each line into multiple lines. RT#123784
  +	    $inhibit_linemarkers = ' -P';
  +	}
  +
   	if ($^O eq 'VMS') {
  -	    my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
  +	    my $cpp = "$Config{cppstdin} $Config{cppflags}" .
  +		$inhibit_linemarkers . " $Config{cppminus}";
   	    $cpp =~ s/sys\$input//i;
   	    open(CPPO,"$cpp  errno.c |") or
   		die "Cannot exec $Config{cppstdin}";
   	} elsif ($IsMSWin32 || $^O eq 'NetWare') {
  -	    open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
  -		die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
  +	    my $cpp = "$Config{cpprun} $Config{cppflags}" .
  +		$inhibit_linemarkers;
  +	    open(CPPO,"$cpp errno.c |") or
  +		die "Cannot run '$cpp errno.c'";
   	} elsif ($IsSymbian) {
  -            my $cpp = "gcc -E -I$ENV{SDK}\\epoc32\\include\\libc -";
  +            my $cpp = "gcc -E -I$ENV{SDK}\\epoc32\\include\\libc" .
  +		$inhibit_linemarkers ." -";
   	    open(CPPO,"$cpp < errno.c |")
   		or die "Cannot exec $cpp";
           } else {
  -	    my $cpp = default_cpp();
  +	    my $cpp = default_cpp() . $inhibit_linemarkers;
   	    open(CPPO,"$cpp < errno.c |")
   		or die "Cannot exec $cpp";
   	}
  END
  diff --git a/dist/Time-HiRes/HiRes.pm b/dist/Time-HiRes/HiRes.pm
  index ad9a65c99d..a3ddd595b7 100644
  --- dist/Time-HiRes/HiRes.pm
  +++ dist/Time-HiRes/HiRes.pm
  @@ -23,12 +23,12 @@ our @EXPORT_OK = qw (usleep sleep ualarm alarm gettimeofday time tv_interval
   		 ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF
   		 TIMER_ABSTIME
   		 d_usleep d_ualarm d_gettimeofday d_getitimer d_setitimer
  -		 d_nanosleep d_clock_gettime d_clock_getres
  +		 d_nanosleep d_clock_gettime d_clock_getres d_hires_utime
   		 d_clock d_clock_nanosleep
  -		 stat lstat
  +		 stat lstat utime
   		);
   
  -our $VERSION = '1.9733';
  +our $VERSION = '1.9741';
   our $XS_VERSION = $VERSION;
   $VERSION = eval $VERSION;
   
  @@ -60,6 +60,7 @@ sub import {
   	    ($i eq 'clock'           && !&d_clock)           ||
   	    ($i eq 'nanosleep'       && !&d_nanosleep)       ||
   	    ($i eq 'usleep'          && !&d_usleep)          ||
  +	    ($i eq 'utime'           && !&d_hires_utime)     ||
   	    ($i eq 'ualarm'          && !&d_ualarm)) {
   	    require Carp;
   	    Carp::croak("Time::HiRes::$i(): unimplemented in this platform");
  @@ -92,7 +93,7 @@ Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers
   
     use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep
   		      clock_gettime clock_getres clock_nanosleep clock
  -                      stat lstat );
  +                      stat lstat utime);
   
     usleep ($microseconds);
     nanosleep ($nanoseconds);
  @@ -137,6 +138,9 @@ Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers
     my @stat = stat(FH);
     my @stat = lstat("file");
   
  +  use Time::HiRes qw( utime );
  +  utime $floating_seconds, $floating_seconds, file...;
  +
   =head1 DESCRIPTION
   
   The C<Time::HiRes> module implements a Perl interface to the
  @@ -446,6 +450,26 @@ if the operations are
   the access time stamp from t2 need not be greater-than the modify
   time stamp from t1: it may be equal or I<less>.
   
  +=item utime LIST
  +
  +As L<perlfunc/utime>
  +but with the ability to set the access/modify file timestamps
  +in subsecond resolution, if the operating system and the filesystem
  +both support such timestamps.  To override the standard utime():
  +
  +    use Time::HiRes qw(utime);
  +
  +Test for the value of &Time::HiRes::d_hires_utime to find out whether
  +the operating system supports setting subsecond file timestamps.
  +
  +As with CORE::utime(), passing undef as both the atime and mtime will
  +call the syscall with a NULL argument.
  +
  +The actual achievable subsecond resolution depends on the combination
  +of the operating system and the filesystem.
  +
  +Returns the number of files successfully changed.
  +
   =back
   
   =head1 EXAMPLES
  @@ -535,7 +559,7 @@ VMS have emulations for it.)
   Here is an example of using C<NVtime> from C:
   
     NV (*myNVtime)(); /* Returns -1 on failure. */
  -  SV **svp = hv_fetch(PL_modglobal, "Time::NVtime", 12, 0);
  +  SV **svp = hv_fetchs(PL_modglobal, "Time::NVtime", 0);
     if (!svp)         croak("Time::HiRes is required");
     if (!SvIOK(*svp)) croak("Time::NVtime isn't a function pointer");
     myNVtime = INT2PTR(NV(*)(), SvIV(*svp));
  @@ -586,9 +610,13 @@ might help in this (in case your system supports CLOCK_MONOTONIC).
   Some systems have APIs but not implementations: for example QNX and Haiku
   have the interval timer APIs but not the functionality.
   
  -In OS X clock_getres(), clock_gettime() and clock_nanosleep() are
  -emulated using the Mach timers; as a side effect of being emulated
  -the CLOCK_REALTIME and CLOCK_MONOTONIC are the same timer.
  +In pre-Sierra macOS (pre-10.12, OS X) clock_getres(), clock_gettime()
  +and clock_nanosleep() are emulated using the Mach timers; as a side
  +effect of being emulated the CLOCK_REALTIME and CLOCK_MONOTONIC are
  +the same timer.
  +
  +gnukfreebsd seems to have non-functional futimens() and utimensat()
  +(at least as of 10.1): therefore the hires utime() does not work.
   
   =head1 SEE ALSO
   
  diff --git a/dist/Time-HiRes/HiRes.xs b/dist/Time-HiRes/HiRes.xs
  index 38ca0dc320..6b0dba8e68 100644
  --- dist/Time-HiRes/HiRes.xs
  +++ dist/Time-HiRes/HiRes.xs
  @@ -87,6 +87,10 @@ extern "C" {
   #   undef ITIMER_REALPROF
   #endif
   
  +#ifndef TIME_HIRES_CLOCKID_T
  +typedef int clockid_t;
  +#endif
  +
   #if defined(TIME_HIRES_CLOCK_GETTIME) && defined(_STRUCT_ITIMERSPEC)
   
   /* HP-UX has CLOCK_XXX values but as enums, not as defines.
  @@ -747,21 +751,33 @@ hrstatns(UV *atime_nsec, UV *mtime_nsec, UV *ctime_nsec)
   #endif /* !TIME_HIRES_STAT */
   }
   
  -/* Until Apple implements clock_gettime() (ditto clock_getres())
  - * we will emulate it using Mach interfaces. */
  -#if defined(PERL_DARWIN) && !defined(CLOCK_REALTIME)
  -
  -#  include <mach/mach_time.h>
  +/* Until Apple implements clock_gettime()
  + * (ditto clock_getres() and clock_nanosleep())
  + * we will emulate them using the Mach kernel interfaces. */
  +#if defined(PERL_DARWIN) && \
  +  (defined(TIME_HIRES_CLOCK_GETTIME_EMULATION)   || \
  +   defined(TIME_HIRES_CLOCK_GETRES_EMULATION)    || \
  +   defined(TIME_HIRES_CLOCK_NANOSLEEP_EMULATION))
   
  +#ifndef CLOCK_REALTIME
   #  define CLOCK_REALTIME  0x01
   #  define CLOCK_MONOTONIC 0x02
  +#endif
   
  +#ifndef TIMER_ABSTIME
   #  define TIMER_ABSTIME   0x01
  +#endif
   
   #ifdef USE_ITHREADS
  +#  define PERL_DARWIN_MUTEX
  +#endif
  +
  +#ifdef PERL_DARWIN_MUTEX
   STATIC perl_mutex darwin_time_mutex;
   #endif
   
  +#include <mach/mach_time.h>
  +
   static uint64_t absolute_time_init;
   static mach_timebase_info_data_t timebase_info;
   static struct timespec timespec_init;
  @@ -769,7 +785,7 @@ static struct timespec timespec_init;
   static int darwin_time_init() {
     struct timeval tv;
     int success = 1;
  -#ifdef USE_ITHREADS
  +#ifdef PERL_DARWIN_MUTEX
     MUTEX_LOCK(&darwin_time_mutex);
   #endif
     if (absolute_time_init == 0) {
  @@ -784,13 +800,14 @@ static int darwin_time_init() {
         }
       }
     }
  -#ifdef USE_ITHREADS
  +#ifdef PERL_DARWIN_MUTEX
     MUTEX_UNLOCK(&darwin_time_mutex);
   #endif
     return success;
   }
   
  -static int clock_gettime(int clock_id, struct timespec *ts) {
  +#ifdef TIME_HIRES_CLOCK_GETTIME_EMULATION
  +static int th_clock_gettime(clockid_t clock_id, struct timespec *ts) {
     if (darwin_time_init() && timebase_info.denom) {
       switch (clock_id) {
         case CLOCK_REALTIME:
  @@ -822,7 +839,12 @@ static int clock_gettime(int clock_id, struct timespec *ts) {
     return -1;
   }
   
  -static int clock_getres(int clock_id, struct timespec *ts) {
  +#define clock_gettime(clock_id, ts) th_clock_gettime((clock_id), (ts))
  +
  +#endif /* TIME_HIRES_CLOCK_GETTIME_EMULATION */
  +
  +#ifdef TIME_HIRES_CLOCK_GETRES_EMULATION
  +static int th_clock_getres(clockid_t clock_id, struct timespec *ts) {
     if (darwin_time_init() && timebase_info.denom) {
       switch (clock_id) {
         case CLOCK_REALTIME:
  @@ -842,7 +864,11 @@ static int clock_getres(int clock_id, struct timespec *ts) {
     return -1;
   }
   
  -static int clock_nanosleep(int clock_id, int flags,
  +#define clock_getres(clock_id, ts) th_clock_getres((clock_id), (ts))
  +#endif /* TIME_HIRES_CLOCK_GETRES_EMULATION */
  +
  +#ifdef TIME_HIRES_CLOCK_NANOSLEEP_EMULATION
  +static int th_clock_nanosleep(clockid_t clock_id, int flags,
   			   const struct timespec *rqtp,
   			   struct timespec *rmtp) {
     if (darwin_time_init()) {
  @@ -880,6 +906,11 @@ static int clock_nanosleep(int clock_id, int flags,
     return -1;
   }
   
  +#define clock_nanosleep(clock_id, flags, rqtp, rmtp) \
  +  th_clock_nanosleep((clock_id), (flags), (rqtp), (rmtp))
  +
  +#endif /* TIME_HIRES_CLOCK_NANOSLEEP_EMULATION */
  +
   #endif /* PERL_DARWIN */
   
   #include "const-c.inc"
  @@ -921,6 +952,22 @@ nsec_without_unslept(struct timespec *sleepfor,
   
   #endif
   
  +/* In case Perl and/or Devel::PPPort are too old, minimally emulate
  + * IS_SAFE_PATHNAME() (which looks for zero bytes in the pathname). */
  +#ifndef IS_SAFE_PATHNAME
  +#if PERL_VERSION >= 12 /* Perl_ck_warner is 5.10.0 -> */
  +#ifdef WARN_SYSCALLS
  +#define WARNEMUCAT WARN_SYSCALLS /* 5.22.0 -> */
  +#else
  +#define WARNEMUCAT WARN_MISC
  +#endif
  +#define WARNEMU(opname) Perl_ck_warner(aTHX_ packWARN(WARNEMUCAT), "Invalid \\0 character in pathname for %s",opname)
  +#else
  +#define WARNEMU(opname) Perl_warn(aTHX_ "Invalid \\0 character in pathname for %s",opname)
  +#endif
  +#define IS_SAFE_PATHNAME(pv, len, opname) (((len)>1)&&memchr((pv), 0, (len)-1)?(SETERRNO(ENOENT, LIB_INVARG),WARNEMU(opname),FALSE):(TRUE))
  +#endif
  +
   MODULE = Time::HiRes            PACKAGE = Time::HiRes
   
   PROTOTYPES: ENABLE
  @@ -941,7 +988,7 @@ BOOT:
   #   endif
   #endif
   #if defined(PERL_DARWIN)
  -#  ifdef USE_ITHREADS
  +#  if defined(USE_ITHREADS) && defined(PERL_DARWIN_MUTEX)
     MUTEX_INIT(&darwin_time_mutex);
   #  endif
   #endif
  @@ -978,7 +1025,8 @@ usleep(useconds)
   		    useconds -= NV_1E6 * seconds;
   		}
   	    } else if (useconds < 0.0)
  -	        croak("Time::HiRes::usleep(%"NVgf"): negative time not invented yet", useconds);
  +	        croak("Time::HiRes::usleep(%" NVgf
  +                      "): negative time not invented yet", useconds);
   	    usleep((U32)useconds);
   	} else
   	    PerlProc_pause();
  @@ -1000,7 +1048,8 @@ nanosleep(nsec)
   	struct timespec sleepfor, unslept;
   	CODE:
   	if (nsec < 0.0)
  -	    croak("Time::HiRes::nanosleep(%"NVgf"): negative time not invented yet", nsec);
  +	    croak("Time::HiRes::nanosleep(%" NVgf
  +                  "): negative time not invented yet", nsec);
           nanosleep_init(nsec, &sleepfor, &unslept);
   	if (nanosleep(&sleepfor, &unslept) == 0) {
   	    RETVAL = nsec;
  @@ -1045,11 +1094,15 @@ sleep(...)
   		   useconds = -(IV)useconds;
   #endif /* #if defined(__sparc64__) && defined(__GNUC__) */
   		   if ((IV)useconds < 0)
  -		     croak("Time::HiRes::sleep(%"NVgf"): internal error: useconds < 0 (unsigned %"UVuf" signed %"IVdf")", seconds, useconds, (IV)useconds);
  +		     croak("Time::HiRes::sleep(%" NVgf
  +                           "): internal error: useconds < 0 (unsigned %" UVuf
  +                           " signed %" IVdf ")",
  +                           seconds, useconds, (IV)useconds);
   		 }
   		 usleep(useconds);
   	    } else
  -	        croak("Time::HiRes::sleep(%"NVgf"): negative time not invented yet", seconds);
  +	        croak("Time::HiRes::sleep(%" NVgf
  +                      "): negative time not invented yet", seconds);
   	} else
   	    PerlProc_pause();
   	gettimeofday(&Tb, NULL);
  @@ -1097,7 +1150,9 @@ ualarm(useconds,uinterval=0)
   	  }
   #else
   	if (useconds >= IV_1E6 || uinterval >= IV_1E6) 
  -		croak("Time::HiRes::ualarm(%d, %d): useconds or uinterval equal to or more than %"IVdf, useconds, uinterval, IV_1E6);
  +		croak("Time::HiRes::ualarm(%d, %d): useconds or uinterval"
  +                      " equal to or more than %" IVdf,
  +                      useconds, uinterval, IV_1E6);
   	RETVAL = ualarm(useconds, uinterval);
   #endif
   
  @@ -1110,7 +1165,8 @@ alarm(seconds,interval=0)
   	NV interval
   	CODE:
   	if (seconds < 0.0 || interval < 0.0)
  -	    croak("Time::HiRes::alarm(%"NVgf", %"NVgf"): negative time not invented yet", seconds, interval);
  +	    croak("Time::HiRes::alarm(%" NVgf ", %" NVgf
  +                  "): negative time not invented yet", seconds, interval);
   	{
   	  IV iseconds = (IV)seconds;
   	  IV iinterval = (IV)interval;
  @@ -1118,7 +1174,9 @@ alarm(seconds,interval=0)
   	  NV finterval = interval - iinterval;
   	  IV useconds, uinterval;
   	  if (fseconds >= 1.0 || finterval >= 1.0)
  -		croak("Time::HiRes::alarm(%"NVgf", %"NVgf"): seconds or interval too large to split correctly", seconds, interval);
  +		croak("Time::HiRes::alarm(%" NVgf ", %" NVgf
  +                      "): seconds or interval too large to split correctly",
  +                      seconds, interval);
   	  useconds = IV_1E6 * fseconds;
   	  uinterval = IV_1E6 * finterval;
   #if defined(HAS_SETITIMER) && defined(ITIMER_REAL)
  @@ -1138,7 +1196,9 @@ alarm(seconds,interval=0)
   	  }
   #else
   	  if (iseconds || iinterval)
  -		croak("Time::HiRes::alarm(%"NVgf", %"NVgf"): seconds or interval equal to or more than 1.0 ", seconds, interval);
  +		croak("Time::HiRes::alarm(%" NVgf ", %" NVgf
  +                      "): seconds or interval equal to or more than 1.0 ",
  +                      seconds, interval);
   	    RETVAL = (NV)ualarm( useconds, uinterval ) / NV_1E6;
   #endif
   	}
  @@ -1266,7 +1326,9 @@ setitimer(which, seconds, interval = 0)
   	struct itimerval oldit;
       PPCODE:
   	if (seconds < 0.0 || interval < 0.0)
  -	    croak("Time::HiRes::setitimer(%"IVdf", %"NVgf", %"NVgf"): negative time not invented yet", (IV)which, seconds, interval);
  +	    croak("Time::HiRes::setitimer(%" IVdf ", %" NVgf ", %" NVgf
  +                  "): negative time not invented yet",
  +                  (IV)which, seconds, interval);
   	newit.it_value.tv_sec  = (IV)seconds;
   	newit.it_value.tv_usec =
   	  (IV)((seconds  - (NV)newit.it_value.tv_sec)    * NV_1E6);
  @@ -1317,11 +1379,89 @@ getitimer(which)
   
   #endif /* #if defined(HAS_GETITIMER) && defined(HAS_SETITIMER) */
   
  +#if defined(TIME_HIRES_UTIME)
  +
  +I32
  +utime(accessed, modified, ...)
  +PROTOTYPE: $$@
  +    PREINIT:
  +	SV* accessed;
  +	SV* modified;
  +	SV* file;
  +
  +	struct timespec utbuf[2];
  +	struct timespec *utbufp = utbuf;
  +	int tot;
  +
  +    CODE:
  +	accessed = ST(0);
  +	modified = ST(1);
  +	items -= 2;
  +	tot = 0;
  +
  +	if ( accessed == &PL_sv_undef && modified == &PL_sv_undef )
  +		utbufp = NULL;
  +	else {
  +		if (SvNV(accessed) < 0.0 || SvNV(modified) < 0.0)
  +                    croak("Time::HiRes::utime(%" NVgf ", %" NVgf
  +                          "): negative time not invented yet",
  +                              SvNV(accessed), SvNV(modified));
  +		Zero(&utbuf, sizeof utbuf, char);
  +		utbuf[0].tv_sec = (Time_t)SvNV(accessed);  /* time accessed */
  +		utbuf[0].tv_nsec = (long)( ( SvNV(accessed) - utbuf[0].tv_sec ) * 1e9 );
  +		utbuf[1].tv_sec = (Time_t)SvNV(modified);  /* time modified */
  +		utbuf[1].tv_nsec = (long)( ( SvNV(modified) - utbuf[1].tv_sec ) * 1e9 );
  +	}
  +
  +	while (items > 0) {
  +		file = POPs; items--;
  +
  +		if (SvROK(file) && GvIO(SvRV(file)) && IoIFP(sv_2io(SvRV(file)))) {
  +			int fd =  PerlIO_fileno(IoIFP(sv_2io(file)));
  +			if (fd < 0)
  +				SETERRNO(EBADF,RMS_IFI);
  +			else 
  +#ifdef HAS_FUTIMENS
  +			if (futimens(fd, utbufp) == 0)
  +				tot++;
  +#else  /* HAS_FUTIMES */
  +				croak("futimens unimplemented in this platform");
  +#endif /* HAS_FUTIMES */
  +		}
  +		else {
  +#ifdef HAS_UTIMENSAT
  +			STRLEN len;
  +			char * name = SvPV(file, len);
  +			if (IS_SAFE_PATHNAME(name, len, "utime") &&
  +			    utimensat(AT_FDCWD, name, utbufp, 0) == 0)
  +				tot++;
  +#else  /* HAS_UTIMENSAT */
  +			croak("utimensat unimplemented in this platform");
  +#endif /* HAS_UTIMENSAT */
  +		}
  +	} /* while items */
  +	RETVAL = tot;
  +
  +    OUTPUT:
  +	RETVAL
  +
  +#else  /* #if defined(TIME_HIRES_UTIME) */
  +
  +I32
  +utime(accessed, modified, ...)
  +    CODE:
  +        croak("Time::HiRes::utime(): unimplemented in this platform");
  +        RETVAL = 0;
  +    OUTPUT:
  +	RETVAL
  +
  +#endif /* #if defined(TIME_HIRES_UTIME) */
  +
   #if defined(TIME_HIRES_CLOCK_GETTIME)
   
   NV
   clock_gettime(clock_id = CLOCK_REALTIME)
  -	int clock_id
  +	clockid_t clock_id
       PREINIT:
   	struct timespec ts;
   	int status = -1;
  @@ -1340,7 +1480,7 @@ clock_gettime(clock_id = CLOCK_REALTIME)
   
   NV
   clock_gettime(clock_id = 0)
  -	int clock_id
  +	clockid_t clock_id
       CODE:
   	PERL_UNUSED_ARG(clock_id);
           croak("Time::HiRes::clock_gettime(): unimplemented in this platform");
  @@ -1354,7 +1494,7 @@ clock_gettime(clock_id = 0)
   
   NV
   clock_getres(clock_id = CLOCK_REALTIME)
  -	int clock_id
  +	clockid_t clock_id
       PREINIT:
   	int status = -1;
   	struct timespec ts;
  @@ -1373,7 +1513,7 @@ clock_getres(clock_id = CLOCK_REALTIME)
   
   NV
   clock_getres(clock_id = 0)
  -	int clock_id
  +	clockid_t clock_id
       CODE:
   	PERL_UNUSED_ARG(clock_id);
           croak("Time::HiRes::clock_getres(): unimplemented in this platform");
  @@ -1387,14 +1527,15 @@ clock_getres(clock_id = 0)
   
   NV
   clock_nanosleep(clock_id, nsec, flags = 0)
  -	int clock_id
  +	clockid_t clock_id
   	NV  nsec
   	int flags
       PREINIT:
   	struct timespec sleepfor, unslept;
       CODE:
   	if (nsec < 0.0)
  -	    croak("Time::HiRes::clock_nanosleep(..., %"NVgf"): negative time not invented yet", nsec);
  +	    croak("Time::HiRes::clock_nanosleep(..., %" NVgf
  +                  "): negative time not invented yet", nsec);
           nanosleep_init(nsec, &sleepfor, &unslept);
   	if (clock_nanosleep(clock_id, flags, &sleepfor, &unslept) == 0) {
   	    RETVAL = nsec;
  @@ -1408,7 +1549,7 @@ clock_nanosleep(clock_id, nsec, flags = 0)
   
   NV
   clock_nanosleep(clock_id, nsec, flags = 0)
  -	int clock_id
  +	clockid_t clock_id
   	NV  nsec
   	int flags
       CODE:
  diff --git a/dist/Time-HiRes/Makefile.PL b/dist/Time-HiRes/Makefile.PL
  index 087ab79871..ccad6a3e6f 100644
  --- dist/Time-HiRes/Makefile.PL
  +++ dist/Time-HiRes/Makefile.PL
  @@ -88,7 +88,7 @@ sub try_compile_and_link {
       my $obj_ext = $Config{obj_ext} || ".o";
       unlink("$tmp.c", "$tmp$obj_ext");
   
  -    if (open(TMPC, ">$tmp.c")) {
  +    if (open(TMPC, '>', "$tmp.c")) {
   	print TMPC $c;
   	close(TMPC);
   
  @@ -132,7 +132,7 @@ __EOD__
   	    unless defined $cccmd;
   
          if ($^O eq 'VMS') {
  -	    open( CMDFILE, ">$tmp.com" );
  +	    open( CMDFILE, '>', "$tmp.com" );
   	    print CMDFILE "\$ SET MESSAGE/NOFACILITY/NOSEVERITY/NOIDENT/NOTEXT\n";
   	    print CMDFILE "\$ $cccmd\n";
   	    print CMDFILE "\$ IF \$SEVERITY .NE. 1 THEN EXIT 44\n"; # escalate
  @@ -290,6 +290,7 @@ sub has_clock_xxx_syscall {
   #include "EXTERN.h"
   #include "perl.h"
   #include "XSUB.h"
  +#include <time.h>
   #include <$SYSCALL_H>
   int main(int argc, char** argv)
   {
  @@ -309,6 +310,7 @@ sub has_clock_xxx {
   #include "EXTERN.h"
   #include "perl.h"
   #include "XSUB.h"
  +#include <time.h>
   int main(int argc, char** argv)
   {
       struct timespec ts;
  @@ -325,6 +327,7 @@ sub has_clock {
   #include "EXTERN.h"
   #include "perl.h"
   #include "XSUB.h"
  +#include <time.h>
   int main(int argc, char** argv)
   {
       clock_t tictoc;
  @@ -348,12 +351,63 @@ int main(int argc, char** argv)
       struct timespec ts2;
       ts1.tv_sec  = 0;
       ts1.tv_nsec = 750000000;;
  -    ret = clock_nanosleep(CLOCK_MONOTONIC, 0, &ts1, &ts2);
  +    /* All implementations are supposed to support CLOCK_REALTIME. */
  +    ret = clock_nanosleep(CLOCK_REALTIME, 0, &ts1, &ts2);
       ret == 0 ? exit(0) : exit(errno ? errno : -1);
   }
   EOM
   }
   
  +sub has_futimens {
  +    return 1 if
  +    try_compile_and_link(<<EOM);
  +#include "EXTERN.h"
  +#include "perl.h"
  +#include "XSUB.h"
  +#include <sys/stat.h>
  +int main(int argc, char** argv)
  +{
  +    int ret;
  +    struct timespec ts[2];
  +    ret = futimens(0, ts);
  +    ret == 0 ? exit(0) : exit(errno ? errno : -1);
  +}
  +EOM
  +}
  +
  +sub has_utimensat{
  +    return 1 if
  +    try_compile_and_link(<<EOM);
  +#include "EXTERN.h"
  +#include "perl.h"
  +#include "XSUB.h"
  +#include <sys/stat.h>
  +#include <fcntl.h>
  +int main(int argc, char** argv)
  +{
  +    int ret;
  +    struct timespec ts[2];
  +    ret = utimensat(AT_FDCWD, 0, ts, 0);
  +    ret == 0 ? exit(0) : exit(errno ? errno : -1);
  +}
  +EOM
  +}
  +
  +sub has_clockid_t{
  +    return 1 if
  +    try_compile_and_link(<<EOM);
  +#include "EXTERN.h"
  +#include "perl.h"
  +#include "XSUB.h"
  +#include <time.h>
  +int main(int argc, char** argv)
  +{
  +    clockid_t id = CLOCK_REALTIME;
  +    exit(id == CLOCK_REALTIME ? 1 : 0);
  +}
  +EOM
  +}
  +
   sub DEFINE {
       my ($def, $val) = @_;
       my $define = defined $val ? "$def=$val" : $def ;
  @@ -534,6 +588,16 @@ EOD
           print "(It would not be portable anyway.)\n";
       }
   
  +    print "Looking for clockid_t... ";
  +    my $has_clockid_t;
  +    if (has_clockid_t()) {
  +	print "found.\n";
  +        $has_clockid_t++;
  +	$DEFINE .= ' -DTIME_HIRES_CLOCKID_T';
  +    } else {
  +	print "NOT found, will use int.\n";
  +    }
  +
       print "Looking for clock_gettime()... ";
       my $has_clock_gettime;
       my $has_clock_gettime_emulation;
  @@ -548,7 +612,7 @@ EOD
       } elsif ($^O eq 'darwin') {
          $has_clock_gettime_emulation++;
          $has_clock_gettime++;
  -       $DEFINE .= ' -DTIME_HIRES_CLOCK_GETTIME';
  +       $DEFINE .= ' -DTIME_HIRES_CLOCK_GETTIME -DTIME_HIRES_CLOCK_GETTIME_EMULATION';
       }
   
       if ($has_clock_gettime) {
  @@ -577,7 +641,7 @@ EOD
       } elsif ($^O eq 'darwin') {
          $has_clock_getres_emulation++;
          $has_clock_getres++;
  -       $DEFINE .= ' -DTIME_HIRES_CLOCK_GETRES';
  +       $DEFINE .= ' -DTIME_HIRES_CLOCK_GETRES -DTIME_HIRES_CLOCK_GETRES_EMULATION';
       }
   
       if ($has_clock_getres) {
  @@ -603,7 +667,7 @@ EOD
       } elsif ($^O eq 'darwin') {
           $has_clock_nanosleep++;
           $has_clock_nanosleep_emulation++;
  -	$DEFINE .= ' -DTIME_HIRES_CLOCK_NANOSLEEP';
  +	$DEFINE .= ' -DTIME_HIRES_CLOCK_NANOSLEEP -DTIME_HIRES_CLOCK_NANOSLEEP_EMULATION';
       }
   
       if ($has_clock_nanosleep) {
  @@ -631,6 +695,36 @@ EOD
   	print "NOT found.\n";
       }
   
  +    print "Looking for futimens()... ";
  +    my $has_futimens;
  +    if (has_futimens()) {
  +        $has_futimens++;
  +	$DEFINE .= ' -DHAS_FUTIMENS';
  +    }
  +
  +    if ($has_futimens) {
  +        print "found.\n";
  +    } else {
  +	print "NOT found.\n";
  +    }
  +
  +    print "Looking for utimensat()... ";
  +    my $has_utimensat;
  +    if (has_utimensat()) {
  +        $has_utimensat++;
  +	$DEFINE .= ' -DHAS_UTIMENSAT';
  +    }
  +
  +    if ($has_utimensat) {
  +        print "found.\n";
  +    } else {
  +	print "NOT found.\n";
  +    }
  +
  +    if ($has_futimens or $has_utimensat) {
  +	$DEFINE .= ' -DTIME_HIRES_UTIME';
  +    }
  +
       print "Looking for stat() subsecond timestamps...\n";
   
       print "Trying struct stat st_atimespec.tv_nsec...";
  @@ -644,7 +738,7 @@ int main(int argc, char** argv) {
   }
   EOM
         $has_stat_st_xtimespec++;
  -      DEFINE('TIME_HIRES_STAT', 1);
  +      DEFINE('TIME_HIRES_STAT_ST_XTIMESPEC');  # 1
       }
   
       if ($has_stat_st_xtimespec) {
  @@ -664,7 +758,7 @@ int main(int argc, char** argv) {
   }
   EOM
         $has_stat_st_xtimensec++;
  -      DEFINE('TIME_HIRES_STAT', 2);
  +      DEFINE('TIME_HIRES_STAT_ST_XTIMENSEC');  # 2
       }
   
       if ($has_stat_st_xtimensec) {
  @@ -684,7 +778,7 @@ int main(int argc, char** argv) {
   }
   EOM
         $has_stat_st_xtime_n++;
  -      DEFINE('TIME_HIRES_STAT', 3);
  +      DEFINE('TIME_HIRES_STAT_ST_XTIME_N');  # 3
       }
   
       if ($has_stat_st_xtime_n) {
  @@ -704,7 +798,7 @@ int main(int argc, char** argv) {
   }
   EOM
         $has_stat_st_xtim++;
  -      DEFINE('TIME_HIRES_STAT', 4);
  +      DEFINE('TIME_HIRES_STAT_XTIM');  # 4
       }
   
       if ($has_stat_st_xtim) {
  @@ -724,7 +818,7 @@ int main(int argc, char** argv) {
   }
   EOM
         $has_stat_st_uxtime++;
  -      DEFINE('TIME_HIRES_STAT', 5);
  +      DEFINE('TIME_HIRES_STAT_ST_UXTIME');  # 5
       }
   
       if ($has_stat_st_uxtime) {
  @@ -733,6 +827,19 @@ EOM
   	print "NOT found.\n";
       }
   
  +    # See HiRes.xs hrstatns()
  +    if ($has_stat_st_xtimespec) {
  +        DEFINE('TIME_HIRES_STAT', 1);
  +    } elsif ($has_stat_st_xtimensec) {
  +        DEFINE('TIME_HIRES_STAT', 2);
  +    } elsif ($has_stat_st_xtime_n) {
  +        DEFINE('TIME_HIRES_STAT', 3);
  +    } elsif ($has_stat_st_xtim) {
  +        DEFINE('TIME_HIRES_STAT', 4);
  +    } elsif ($has_stat_st_uxtime) {
  +        DEFINE('TIME_HIRES_STAT', 5);
  +    }    
  +
      if ($DEFINE =~ /-DTIME_HIRES_STAT=\d+/) {
       print "You seem to have stat() subsecond timestamps.\n";
       print "(Your struct stat has them, but the filesystems must help.)\n";
  @@ -757,7 +864,7 @@ EOM
   
       if ($DEFINE) {
           $DEFINE =~ s/^\s+//;
  -        if (open(XDEFINE, ">xdefine")) {
  +        if (open(XDEFINE, '>', 'xdefine')) {
   	    print XDEFINE $DEFINE, "\n";
   	    close(XDEFINE);
           }
  @@ -791,7 +898,7 @@ sub doMakefile {
   	    'DynaLoader' => 0,
   	    'Exporter' => 0,
   	    'ExtUtils::MakeMaker' => 0,
  -	    'Test::More' => "0.82",
  +	    'Test::More' => 0,
   	    'strict' => 0,
   	},
   	'dist'      => {
  @@ -869,7 +976,8 @@ sub doConstants {
                         );
   	foreach (qw (d_usleep d_ualarm d_gettimeofday d_getitimer d_setitimer
   		     d_nanosleep d_clock_gettime d_clock_getres
  -		     d_clock d_clock_nanosleep d_hires_stat)) {
  +		     d_clock d_clock_nanosleep d_hires_stat
  +                     d_futimens d_utimensat d_hires_utime)) {
   	    my $macro = $_;
   	    if ($macro =~ /^(d_nanosleep|d_clock)$/) {
   		$macro =~ s/^d_(.+)/TIME_HIRES_\U$1/;
  @@ -879,6 +987,13 @@ sub doConstants {
   		push @names, {name => $_, macro => "TIME_HIRES_STAT", value => $d_hires_stat,
   			      default => ["IV", "0"]};
   		next;
  +	    } elsif ($macro =~ /^(d_hires_utime)$/) {
  +		my $d_hires_utime =
  +                    ($DEFINE =~ /-DHAS_FUTIMENS/ ||
  +                     $DEFINE =~ /-DHAS_UTIMENSAT/) ? 1 : 0;
  +		push @names, {name => $_, macro => "TIME_HIRES_UTIME", value => $d_hires_utime,
  +			      default => ["IV", "0"]};
  +		next;
   	    } elsif ($macro =~ /^(d_clock_gettime|d_clock_getres|d_clock_nanosleep)$/) {
   		$macro =~ s/^d_(.+)/TIME_HIRES_\U$1/;
   		my $val = ($DEFINE =~ /-D$macro\b/) ? 1 : 0;
  @@ -900,8 +1015,8 @@ sub doConstants {
   	foreach $file ('const-c.inc', 'const-xs.inc') {
   	    my $fallback = File::Spec->catfile('fallback', $file);
   	    local $/;
  -	    open IN, "<$fallback" or die "Can't open $fallback: $!";
  -	    open OUT, ">$file" or die "Can't open $file: $!";
  +	    open IN, '<', $fallback or die "Can't open $fallback: $!";
  +	    open OUT, '>', $file or die "Can't open $file: $!";
   	    print OUT <IN> or die $!;
   	    close OUT or die "Can't close $file: $!";
   	    close IN or die "Can't close $fallback: $!";
  @@ -920,7 +1035,7 @@ sub main {
   	    DEFINE('SELECT_IS_BROKEN');
   	    $LIBS = [];
   	    print "System is $^O, skipping full configure...\n";
  -	    open(XDEFINE, ">xdefine") or die "$0: Cannot create xdefine: $!\n";
  +	    open(XDEFINE, '>', 'xdefine') or die "$0: Cannot create xdefine: $!\n";
   	    close(XDEFINE);
   	} else {
   	    init();
  diff --git a/dist/Time-HiRes/fallback/const-c.inc b/dist/Time-HiRes/fallback/const-c.inc
  index a8626172af..524db169a9 100644
  --- dist/Time-HiRes/fallback/const-c.inc
  +++ dist/Time-HiRes/fallback/const-c.inc
  @@ -19,6 +19,7 @@ typedef double NV; /* 5.6 and later define NVTYPE, and typedef NV to it.  */
   #ifndef pTHX_
   #define pTHX_ /* 5.6 or later define this for threading support.  */
   #endif
  +
   static int
   constant_11 (pTHX_ const char *name, IV *iv_return) {
     /* When generated this function returned values for the list of names given
  @@ -86,6 +87,51 @@ constant_11 (pTHX_ const char *name, IV *iv_return) {
     return PERL_constant_NOTFOUND;
   }
   
  +static int
  +constant_13 (pTHX_ const char *name, IV *iv_return) {
  +  /* When generated this function returned values for the list of names given
  +     here.  However, subsequent manual editing may have added or removed some.
  +     CLOCK_HIGHRES TIMER_ABSTIME d_hires_utime */
  +  /* Offset 1 gives the best switch position.  */
  +  switch (name[1]) {
  +  case 'I':
  +    if (memEQ(name, "TIMER_ABSTIME", 13)) {
  +    /*                ^                  */
  +#ifdef TIMER_ABSTIME
  +      *iv_return = TIMER_ABSTIME;
  +      return PERL_constant_ISIV;
  +#else
  +      return PERL_constant_NOTDEF;
  +#endif
  +    }
  +    break;
  +  case 'L':
  +    if (memEQ(name, "CLOCK_HIGHRES", 13)) {
  +    /*                ^                  */
  +#ifdef CLOCK_HIGHRES
  +      *iv_return = CLOCK_HIGHRES;
  +      return PERL_constant_ISIV;
  +#else
  +      return PERL_constant_NOTDEF;
  +#endif
  +    }
  +    break;
  +  case '_':
  +    if (memEQ(name, "d_hires_utime", 13)) {
  +    /*                ^                  */
  +#ifdef TIME_HIRES_UTIME
  +      *iv_return = 1;
  +      return PERL_constant_ISIV;
  +#else
  +      *iv_return = 0;
  +      return PERL_constant_ISIV;
  +#endif
  +    }
  +    break;
  +  }
  +  return PERL_constant_NOTFOUND;
  +}
  +
   static int
   constant_14 (pTHX_ const char *name, IV *iv_return) {
     /* When generated this function returned values for the list of names given
  @@ -250,16 +296,17 @@ my @names = (qw(CLOCKS_PER_SEC CLOCK_HIGHRES CLOCK_MONOTONIC
               {name=>"d_getitimer", type=>"IV", macro=>"HAS_GETITIMER", value=>"1", default=>["IV", "0"]},
               {name=>"d_gettimeofday", type=>"IV", macro=>"HAS_GETTIMEOFDAY", value=>"1", default=>["IV", "0"]},
               {name=>"d_hires_stat", type=>"IV", macro=>"TIME_HIRES_STAT", value=>"1", default=>["IV", "0"]},
  +            {name=>"d_hires_utime", type=>"IV", macro=>"TIME_HIRES_UTIME", value=>"1", default=>["IV", "0"]},
               {name=>"d_nanosleep", type=>"IV", macro=>"TIME_HIRES_NANOSLEEP", value=>"1", default=>["IV", "0"]},
               {name=>"d_setitimer", type=>"IV", macro=>"HAS_SETITIMER", value=>"1", default=>["IV", "0"]},
               {name=>"d_ualarm", type=>"IV", macro=>"HAS_UALARM", value=>"1", default=>["IV", "0"]},
               {name=>"d_usleep", type=>"IV", macro=>"HAS_USLEEP", value=>"1", default=>["IV", "0"]});
   
  -print constant_types(); # macro defs
  +print constant_types(), "\n"; # macro defs
   foreach (C_constant ("Time::HiRes", 'constant', 'IV', $types, undef, 3, @names) ) {
       print $_, "\n"; # C constant subs
   }
  -print "#### XS Section:\n";
  +print "\n#### XS Section:\n";
   print XS_constant ("Time::HiRes", $types);
   __END__
      */
  @@ -322,33 +369,7 @@ __END__
       }
       break;
     case 13:
  -    /* Names all of length 13.  */
  -    /* CLOCK_HIGHRES TIMER_ABSTIME */
  -    /* Offset 2 gives the best switch position.  */
  -    switch (name[2]) {
  -    case 'M':
  -      if (memEQ(name, "TIMER_ABSTIME", 13)) {
  -      /*                 ^                 */
  -#ifdef TIMER_ABSTIME
  -        *iv_return = TIMER_ABSTIME;
  -        return PERL_constant_ISIV;
  -#else
  -        return PERL_constant_NOTDEF;
  -#endif
  -      }
  -      break;
  -    case 'O':
  -      if (memEQ(name, "CLOCK_HIGHRES", 13)) {
  -      /*                 ^                 */
  -#ifdef CLOCK_HIGHRES
  -        *iv_return = CLOCK_HIGHRES;
  -        return PERL_constant_ISIV;
  -#else
  -        return PERL_constant_NOTDEF;
  -#endif
  -      }
  -      break;
  -    }
  +    return constant_13 (aTHX_ name, iv_return);
       break;
     case 14:
       return constant_14 (aTHX_ name, iv_return);
  diff --git a/dist/Time-HiRes/t/Watchdog.pm b/dist/Time-HiRes/t/Watchdog.pm
  index 83e854396f..44ec8081de 100644
  --- dist/Time-HiRes/t/Watchdog.pm
  +++ dist/Time-HiRes/t/Watchdog.pm
  @@ -10,44 +10,44 @@ my $watchdog_pid;
   my $TheEnd;
   
   if ($Config{d_fork}) {
  -    note "I am the main process $$, starting the watchdog process...";
  +    print("# I am the main process $$, starting the watchdog process...\n");
       $watchdog_pid = fork();
       if (defined $watchdog_pid) {
   	if ($watchdog_pid == 0) { # We are the kid, set up the watchdog.
   	    my $ppid = getppid();
  -	    note "I am the watchdog process $$, sleeping for $waitfor seconds...";
  +	    print("# I am the watchdog process $$, sleeping for $waitfor seconds...\n");
   	    sleep($waitfor - 2);    # Workaround for perlbug #49073
   	    sleep(2);               # Wait for parent to exit
   	    if (kill(0, $ppid)) {   # Check if parent still exists
   		warn "\n$0: overall time allowed for tests (${waitfor}s) exceeded!\n";
  -		note "Terminating main process $ppid...";
  +		print("Terminating main process $ppid...\n");
   		kill('KILL', $ppid);
  -		note "This is the watchdog process $$, over and out.";
  +		print("# This is the watchdog process $$, over and out.\n");
   	    }
   	    exit(0);
   	} else {
  -	    note "The watchdog process $watchdog_pid launched, continuing testing...";
  +	    print("# The watchdog process $watchdog_pid launched, continuing testing...\n");
   	    $TheEnd = time() + $waitfor;
   	}
       } else {
   	warn "$0: fork failed: $!\n";
       }
   } else {
  -    note "No watchdog process (need fork)";
  +    print("# No watchdog process (need fork)\n");
   }
   
   END {
       if ($watchdog_pid) { # Only in the main process.
   	my $left = $TheEnd - time();
  -	note sprintf "I am the main process $$, terminating the watchdog process $watchdog_pid before it terminates me in %d seconds (testing took %d seconds).", $left, $waitfor - $left;
  +	printf("# I am the main process $$, terminating the watchdog process $watchdog_pid before it terminates me in %d seconds (testing took %d seconds).\n", $left, $waitfor - $left);
   	if (kill(0, $watchdog_pid)) {
   	    local $? = 0;
   	    my $kill = kill('KILL', $watchdog_pid); # We are done, the watchdog can go.
   	    wait();
  -	    note sprintf "kill KILL $watchdog_pid = %d", $kill;
  +	    printf("# kill KILL $watchdog_pid = %d\n", $kill);
   	}
   	unlink("ktrace.out"); # Used in BSD system call tracing.
  -	note "All done.";
  +	print("# All done.\n");
       }
   }
   
  diff --git a/dist/Time-HiRes/t/alarm.t b/dist/Time-HiRes/t/alarm.t
  index 841694f67c..4935410d36 100644
  --- dist/Time-HiRes/t/alarm.t
  +++ dist/Time-HiRes/t/alarm.t
  @@ -1,6 +1,6 @@
   use strict;
   
  -use Test::More 0.82 tests => 10;
  +use Test::More tests => 10;
   use t::Watchdog;
   
   BEGIN { require_ok "Time::HiRes"; }
  @@ -10,7 +10,7 @@ use Config;
   my $limit = 0.25; # 25% is acceptable slosh for testing timers
   
   my $xdefine = ''; 
  -if (open(XDEFINE, "xdefine")) {
  +if (open(XDEFINE, "<", "xdefine")) {
       chomp($xdefine = <XDEFINE> || "");
       close(XDEFINE);
   }
  @@ -29,12 +29,14 @@ SKIP: {
   
       my ($r, $i, $not, $ok);
   
  +    $not = "";
  +
       $r = [Time::HiRes::gettimeofday()];
       $i = 5;
       my $oldaction;
       if ($use_sigaction) {
   	$oldaction = new POSIX::SigAction;
  -	note sprintf "sigaction tick, ALRM = %d", &POSIX::SIGALRM;
  +	printf("# sigaction tick, ALRM = %d\n", &POSIX::SIGALRM);
   
   	# Perl's deferred signals may be too wimpy to break through
   	# a restartable select(), so use POSIX::sigaction if available.
  @@ -44,7 +46,7 @@ SKIP: {
   			 $oldaction)
   	    or die "Error setting SIGALRM handler with sigaction: $!\n";
       } else {
  -	note "SIG tick";
  +	print("# SIG tick\n");
   	$SIG{ALRM} = "tick";
       }
   
  @@ -56,8 +58,8 @@ SKIP: {
   	    Time::HiRes::alarm(0.3);
   	    select (undef, undef, undef, 3);
   	    my $ival = Time::HiRes::tv_interval ($r);
  -	    note "Select returned! $i $ival";
  -	    note abs($ival/3 - 1);
  +	    print("# Select returned! $i $ival\n");
  +	    printf("# %s\n", abs($ival/3 - 1));
   	    # Whether select() gets restarted after signals is
   	    # implementation dependent.  If it is restarted, we
   	    # will get about 3.3 seconds: 3 from the select, 0.3
  @@ -86,7 +88,7 @@ SKIP: {
       sub tick {
   	$i--;
   	my $ival = Time::HiRes::tv_interval ($r);
  -	note "Tick! $i $ival";
  +	print("# Tick! $i $ival\n");
   	my $exp = 0.3 * (5 - $i);
   	if ($exp == 0) {
   	    $not = "tick: divisor became zero";
  @@ -106,8 +108,8 @@ SKIP: {
   	Time::HiRes::alarm(0); # can't cancel usig %SIG
       }
   
  +    print("# $not\n");
       ok !$not;
  -    note $not || $ok;
   }
   
   SKIP: {
  @@ -126,7 +128,7 @@ SKIP: {
       # http://groups.google.com/group/perl.perl5.porters/browse_thread/thread/adaffaaf939b042e/20dafc298df737f0%2320dafc298df737f0?sa=X&oi=groupsr&start=0&num=3
       # Perl changes [18765] and [18770], perl bug [perl #20920]
   
  -    note "Finding delay loop...";
  +    print("# Finding delay loop...\n");
   
       my $T = 0.01;
       my $DelayN = 1024;
  @@ -137,7 +139,7 @@ SKIP: {
   	 for ($i = 0; $i < $DelayN; $i++) { }
   	 my $t1 = Time::HiRes::time();
   	 my $dt = $t1 - $t0;
  -	 note "N = $DelayN, t1 = $t1, t0 = $t0, dt = $dt";
  +	 print("# N = $DelayN, t1 = $t1, t0 = $t0, dt = $dt\n");
   	 last N if $dt > $T;
   	 $DelayN *= 2;
        } while (1);
  @@ -169,7 +171,7 @@ SKIP: {
   
       $SIG{ALRM} = sub {
   	$a++;
  -	note "Alarm $a - ", Time::HiRes::time();
  +	printf("# Alarm $a - %s\n", Time::HiRes::time());
   	Time::HiRes::alarm(0) if $a >= $A; # Disarm the alarm.
   	$Delay->(2); # Try burning CPU at least for 2T seconds.
       }; 
  @@ -204,18 +206,18 @@ SKIP: {
   	my $alrm = 0;
   	$SIG{ALRM} = sub { $alrm++ };
   	my $got = Time::HiRes::alarm(2.7);
  -	ok $got == 0 or note $got;
  +	ok $got == 0 or print("# $got\n");
   
   	my $t0 = Time::HiRes::time();
   	1 while Time::HiRes::time() - $t0 <= 1;
   
   	$got = Time::HiRes::alarm(0);
  -	ok $got > 0 && $got < 1.8 or note $got;
  +	ok $got > 0 && $got < 1.8 or print("# $got\n");
   
  -	ok $alrm == 0 or note $alrm;
  +	ok $alrm == 0 or print("# $alrm\n");
   
   	$got = Time::HiRes::alarm(0);
  -	ok $got == 0 or note $got;
  +	ok $got == 0 or print("# $got\n");
       }
   }
   
  diff --git a/dist/Time-HiRes/t/clock.t b/dist/Time-HiRes/t/clock.t
  index 6d11dd2ca0..346ca57fbf 100644
  --- dist/Time-HiRes/t/clock.t
  +++ dist/Time-HiRes/t/clock.t
  @@ -1,6 +1,6 @@
   use strict;
   
  -use Test::More 0.82 tests => 5;
  +use Test::More tests => 5;
   use t::Watchdog;
   
   BEGIN { require_ok "Time::HiRes"; }
  @@ -13,10 +13,10 @@ sub has_symbol {
       return $@ eq '';
   }
   
  -note sprintf "have_clock_gettime   = %d", &Time::HiRes::d_clock_gettime;
  -note sprintf "have_clock_getres    = %d", &Time::HiRes::d_clock_getres;
  -note sprintf "have_clock_nanosleep = %d", &Time::HiRes::d_clock_nanosleep;
  -note sprintf "have_clock           = %d", &Time::HiRes::d_clock;
  +printf("# have_clock_gettime   = %d\n", &Time::HiRes::d_clock_gettime);
  +printf("# have_clock_getres    = %d\n", &Time::HiRes::d_clock_getres);
  +printf("# have_clock_nanosleep = %d\n", &Time::HiRes::d_clock_nanosleep);
  +printf("# have_clock           = %d\n", &Time::HiRes::d_clock);
   
   # Ideally, we'd like to test that the timers are rather precise.
   # However, if the system is busy, there are no guarantees on how
  @@ -36,25 +36,25 @@ SKIP: {
       my $ok = 0;
    TRY: {
   	for my $try (1..3) {
  -	    note "CLOCK_REALTIME: try = $try";
  +	    print("# CLOCK_REALTIME: try = $try\n");
   	    my $t0 = Time::HiRes::clock_gettime(&CLOCK_REALTIME);
   	    my $T = 1.5;
   	    Time::HiRes::sleep($T);
   	    my $t1 = Time::HiRes::clock_gettime(&CLOCK_REALTIME);
   	    if ($t0 > 0 && $t1 > $t0) {
  -		note "t1 = $t1, t0 = $t0";
  +		print("# t1 = $t1, t0 = $t0\n");
   		my $dt = $t1 - $t0;
   		my $rt = abs(1 - $dt / $T);
  -		note "dt = $dt, rt = $rt";
  +		print("# dt = $dt, rt = $rt\n");
   		if ($rt <= 2 * $limit) {
   		    $ok = 1;
   		    last TRY;
   		}
   	    } else {
  -		note "Error: t0 = $t0, t1 = $t1";
  +		print("# Error: t0 = $t0, t1 = $t1\n");
   	    }
   	    my $r = rand() + rand();
  -	    note sprintf "Sleeping for %.6f seconds...\n", $r;
  +	    printf("# Sleeping for %.6f seconds...\n", $r);
   	    Time::HiRes::sleep($r);
   	}
       }
  @@ -64,7 +64,7 @@ SKIP: {
   SKIP: {
       skip "no clock_getres", 1 unless &Time::HiRes::d_clock_getres;
       my $tr = Time::HiRes::clock_getres();
  -    ok $tr > 0 or note "tr = $tr";
  +    ok $tr > 0 or print("# tr = $tr\n");
   }
   
   SKIP: {
  @@ -73,17 +73,17 @@ SKIP: {
       my $s = 1.5e9;
       my $t = Time::HiRes::clock_nanosleep(&CLOCK_REALTIME, $s);
       my $r = abs(1 - $t / $s);
  -    ok $r < 2 * $limit or note "t = $t, r = $r";
  +    ok $r < 2 * $limit or print("# t = $t, r = $r\n");
   }
   
   SKIP: {
       skip "no clock", 1 unless &Time::HiRes::d_clock;
       my @clock = Time::HiRes::clock();
  -    note "clock = @clock";
  +    print("# clock = @clock\n");
       for my $i (1..3) {
   	for (my $j = 0; $j < 1e6; $j++) { }
   	push @clock, Time::HiRes::clock();
  -	note "clock = @clock";
  +	print("# clock = @clock\n");
       }
       ok $clock[0] >= 0 &&
   	$clock[1] > $clock[0] &&
  diff --git a/dist/Time-HiRes/t/gettimeofday.t b/dist/Time-HiRes/t/gettimeofday.t
  index 8f7c5f3039..69defe8672 100644
  --- dist/Time-HiRes/t/gettimeofday.t
  +++ dist/Time-HiRes/t/gettimeofday.t
  @@ -8,26 +8,26 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 6;
  +use Test::More tests => 6;
   use t::Watchdog;
   
   my @one = Time::HiRes::gettimeofday();
  -note 'gettimeofday returned ', 0+@one, ' args';
  +printf("# gettimeofday returned %d args\n", 0+@one);
   ok @one == 2;
  -ok $one[0] > 850_000_000 or note "@one too small";
  +ok $one[0] > 850_000_000 or print("# @one too small\n");
   
   sleep 1;
   
   my @two = Time::HiRes::gettimeofday();
   ok $two[0] > $one[0] || ($two[0] == $one[0] && $two[1] > $one[1])
  -	or note "@two is not greater than @one";
  +	or print("# @two is not greater than @one\n");
   
   my $f = Time::HiRes::time();
  -ok $f > 850_000_000 or note "$f too small";
  -ok $f - $two[0] < 2 or note "$f - $two[0] >= 2";
  +ok $f > 850_000_000 or print("# $f too small\n");
  +ok $f - $two[0] < 2 or print("# $f - $two[0] >= 2\n");
   
   my $r = [Time::HiRes::gettimeofday()];
   my $g = Time::HiRes::tv_interval $r;
  -ok $g < 2 or note $g;
  +ok $g < 2 or print("# $g\n");
   
   1;
  diff --git a/dist/Time-HiRes/t/itimer.t b/dist/Time-HiRes/t/itimer.t
  index 9eb2b93f6f..31cdd674ae 100644
  --- dist/Time-HiRes/t/itimer.t
  +++ dist/Time-HiRes/t/itimer.t
  @@ -25,7 +25,7 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 2;
  +use Test::More tests => 2;
   use t::Watchdog;
   
   my $limit = 0.25; # 25% is acceptable slosh for testing timers
  @@ -35,11 +35,11 @@ my $r = [Time::HiRes::gettimeofday()];
   
   $SIG{VTALRM} = sub {
       $i ? $i-- : Time::HiRes::setitimer(&Time::HiRes::ITIMER_VIRTUAL, 0);
  -    note "Tick! $i ", Time::HiRes::tv_interval($r);
  +    printf("# Tick! $i %s\n", Time::HiRes::tv_interval($r));
   };	
   
  -note "setitimer: ", join(" ",
  -    Time::HiRes::setitimer(&Time::HiRes::ITIMER_VIRTUAL, 0.5, 0.4));
  +printf("# setitimer: %s\n", join(" ",
  +       Time::HiRes::setitimer(&Time::HiRes::ITIMER_VIRTUAL, 0.5, 0.4)));
   
   # Assume interval timer granularity of $limit * 0.5 seconds.  Too bold?
   my $virt = Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL);
  @@ -47,19 +47,19 @@ ok(defined $virt && abs($virt / 0.5) - 1 < $limit,
      "ITIMER_VIRTUAL defined with sufficient granularity")
      or diag "virt=" . (defined $virt ? $virt : 'undef');
   
  -note "getitimer: ", join(" ",
  -    Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL));
  +printf("# getitimer: %s\n", join(" ",
  +       Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL)));
   
   while (Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL)) {
       my $j;
       for (1..1000) { $j++ } # Can't be unbreakable, must test getitimer().
   }
   
  -note "getitimer: ", join(" ",
  -    Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL));
  +printf("# getitimer: %s\n", join(" ",
  +       Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL)));
   
   $virt = Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL);
  -note "at end, i=$i";
  +print("# at end, i=$i\n");
   is($virt, 0, "time left should be zero");
   
   $SIG{VTALRM} = 'DEFAULT';
  diff --git a/dist/Time-HiRes/t/nanosleep.t b/dist/Time-HiRes/t/nanosleep.t
  index aef9db6163..c17a7e4790 100644
  --- dist/Time-HiRes/t/nanosleep.t
  +++ dist/Time-HiRes/t/nanosleep.t
  @@ -8,7 +8,7 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 3;
  +use Test::More tests => 3;
   use t::Watchdog;
   
   eval { Time::HiRes::nanosleep(-5) };
  @@ -21,7 +21,7 @@ my $two = CORE::time;
   Time::HiRes::nanosleep(10_000_000);
   my $three = CORE::time;
   ok $one == $two || $two == $three
  -    or note "slept too long, $one $two $three";
  +    or print("# slept too long, $one $two $three\n");
   
   SKIP: {
       skip "no gettimeofday", 1 unless &Time::HiRes::d_gettimeofday;
  @@ -29,7 +29,7 @@ SKIP: {
       Time::HiRes::nanosleep(500_000_000);
       my $f2 = Time::HiRes::time();
       my $d = $f2 - $f;
  -    ok $d > 0.4 && $d < 0.9 or note "slept $d secs $f to $f2";
  +    ok $d > 0.4 && $d < 0.9 or print("# slept $d secs $f to $f2\n");
   }
   
   1;
  diff --git a/dist/Time-HiRes/t/sleep.t b/dist/Time-HiRes/t/sleep.t
  index e7cc6271a8..b84b4c6725 100644
  --- dist/Time-HiRes/t/sleep.t
  +++ dist/Time-HiRes/t/sleep.t
  @@ -1,6 +1,6 @@
   use strict;
   
  -use Test::More 0.82 tests => 4;
  +use Test::More tests => 4;
   use t::Watchdog;
   
   BEGIN { require_ok "Time::HiRes"; }
  @@ -8,7 +8,7 @@ BEGIN { require_ok "Time::HiRes"; }
   use Config;
   
   my $xdefine = ''; 
  -if (open(XDEFINE, "xdefine")) {
  +if (open(XDEFINE, "<", "xdefine")) {
       chomp($xdefine = <XDEFINE> || "");
       close(XDEFINE);
   }
  @@ -26,12 +26,12 @@ like $@, qr/::sleep\(-1\): negative time not invented yet/,
   SKIP: {
       skip "no subsecond alarm", 2 unless $can_subsecond_alarm;
       my $f = Time::HiRes::time; 
  -    note "time...$f";
  +    print("# time...$f\n");
       ok 1;
   
       my $r = [Time::HiRes::gettimeofday()];
       Time::HiRes::sleep (0.5);
  -    note "sleep...", Time::HiRes::tv_interval($r);
  +    printf("# sleep...%s\n", Time::HiRes::tv_interval($r));
       ok 1;
   }
   
  diff --git a/dist/Time-HiRes/t/stat.t b/dist/Time-HiRes/t/stat.t
  index 68a6fb6bbd..a59a342e20 100644
  --- dist/Time-HiRes/t/stat.t
  +++ dist/Time-HiRes/t/stat.t
  @@ -13,14 +13,14 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 43;
  +use Test::More tests => 43;
   use t::Watchdog;
   
   my @atime;
   my @mtime;
   for (1..5) {
       Time::HiRes::sleep(rand(0.1) + 0.1);
  -    open(X, ">$$");
  +    open(X, '>', $$);
       print X $$;
       close(X);
       my($a, $stat, $b) = ("a", [Time::HiRes::stat($$)], "b");
  @@ -33,7 +33,7 @@ for (1..5) {
       is $b, "b";
       is_deeply $lstat, $stat;
       Time::HiRes::sleep(rand(0.1) + 0.1);
  -    open(X, "<$$");
  +    open(X, '<', $$);
       <X>;
       close(X);
       $stat = [Time::HiRes::stat($$)];
  @@ -42,8 +42,8 @@ for (1..5) {
       is_deeply $lstat, $stat;
   }
   1 while unlink $$;
  -note "mtime = @mtime";
  -note "atime = @atime";
  +print("# mtime = @mtime\n");
  +print("# atime = @atime\n");
   my $ai = 0;
   my $mi = 0;
   my $ss = 0;
  @@ -63,7 +63,7 @@ for (my $i = 1; $i < @mtime; $i++) {
   	$ss++;
       }
   }
  -note "ai = $ai, mi = $mi, ss = $ss";
  +print("# ai = $ai, mi = $mi, ss = $ss\n");
   # Need at least 75% of monotonical increase and
   # 20% of subsecond results. Yes, this is guessing.
   SKIP: {
  @@ -75,7 +75,7 @@ SKIP: {
   my $targetname = "tgt$$";
   my $linkname = "link$$";
   SKIP: {
  -    open(X, ">$targetname");
  +    open(X, '>', $targetname);
       print X $$;
       close(X);
       eval { symlink $targetname, $linkname or die "can't symlink: $!"; };
  diff --git a/dist/Time-HiRes/t/time.t b/dist/Time-HiRes/t/time.t
  index feec4799d9..6f219f9e0c 100644
  --- dist/Time-HiRes/t/time.t
  +++ dist/Time-HiRes/t/time.t
  @@ -1,6 +1,6 @@
   use strict;
   
  -use Test::More 0.82 tests => 2;
  +use Test::More tests => 2;
   use t::Watchdog;
   
   BEGIN { require_ok "Time::HiRes"; }
  @@ -16,8 +16,8 @@ SKIP: {
       # (CORE::time() may be rounding down, up, or closest),
       # but allow 10% of slop.
       ok abs($s) / $n <= 1.10
  -	or note "Time::HiRes::time() not close to CORE::time()";
  -    note "s = $s, n = $n, s/n = ", abs($s)/$n;
  +	or print("# Time::HiRes::time() not close to CORE::time()\n");
  +    printf("# s = $s, n = $n, s/n = %s\n", abs($s)/$n);
   }
   
   1;
  diff --git a/dist/Time-HiRes/t/tv_interval.t b/dist/Time-HiRes/t/tv_interval.t
  index bffcf39ec1..8ac876daf3 100644
  --- dist/Time-HiRes/t/tv_interval.t
  +++ dist/Time-HiRes/t/tv_interval.t
  @@ -1,10 +1,10 @@
   use strict;
   
  -use Test::More 0.82 tests => 2;
  +use Test::More tests => 2;
   
   BEGIN { require_ok "Time::HiRes"; }
   
   my $f = Time::HiRes::tv_interval [5, 100_000], [10, 500_000];
  -ok abs($f - 5.4) < 0.001 or note $f;
  +ok abs($f - 5.4) < 0.001 or print("# $f\n");
   
   1;
  diff --git a/dist/Time-HiRes/t/ualarm.t b/dist/Time-HiRes/t/ualarm.t
  index 12ef4b52cc..b50a175f44 100644
  --- dist/Time-HiRes/t/ualarm.t
  +++ dist/Time-HiRes/t/ualarm.t
  @@ -8,7 +8,7 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 12;
  +use Test::More tests => 12;
   use t::Watchdog;
   
   use Config;
  @@ -24,13 +24,13 @@ SKIP: {
       $tick = 0; Time::HiRes::ualarm(10_000); while ($tick == 0) { }
       my $three = CORE::time;
       ok $one == $two || $two == $three
  -	or note "slept too long, $one $two $three";
  -    note "tick = $tick, one = $one, two = $two, three = $three";
  +	or print("# slept too long, $one $two $three\n");
  +    print("# tick = $tick, one = $one, two = $two, three = $three\n");
   
       $tick = 0; Time::HiRes::ualarm(10_000, 10_000); while ($tick < 3) { }
       ok 1;
       Time::HiRes::ualarm(0);
  -    note "tick = $tick, one = $one, two = $two, three = $three";
  +    print("# tick = $tick, one = $one, two = $two, three = $three\n");
   }
   
   eval { Time::HiRes::ualarm(-4) };
  @@ -59,24 +59,24 @@ for my $n (100_000, 1_100_000, 2_200_000, 4_300_000) {
   	my $alarmed = 0;
   	local $SIG{ ALRM } = sub { $alarmed++ };
   	my $t0 = Time::HiRes::time();
  -	note "t0 = $t0";
  -	note "ualarm($n)";
  +	print("# t0 = $t0\n");
  +	print("# ualarm($n)\n");
   	Time::HiRes::ualarm($n); 1 while $alarmed == 0;
   	my $t1 = Time::HiRes::time();
  -	note "t1 = $t1";
  +	print("# t1 = $t1\n");
   	my $dt = $t1 - $t0;
  -	note "dt = $dt";
  +	print("# dt = $dt\n");
   	my $r = $dt / ($n/1e6);
  -	note "r = $r";
  +	print("# r = $r\n");
   	$ok =
   	    ($n < 1_000_000 || # Too much noise.
   	     ($r >= 0.8 && $r <= 1.6));
   	last if $ok;
   	my $nap = bellish(3, 15);
  -	note sprintf "Retrying in %.1f seconds...\n", $nap;
  +	printf("# Retrying in %.1f seconds...\n", $nap);
   	Time::HiRes::sleep($nap);
       }
  -    ok $ok or note "ualarm($n) close enough";
  +    ok $ok or print("# ualarm($n) close enough\n");
   }
   
   {
  @@ -93,12 +93,12 @@ for my $n (100_000, 1_100_000, 2_200_000, 4_300_000) {
       } while $t1 - $t0 <= 0.3;
       my $got1 = Time::HiRes::ualarm(0);
   
  -    note "t0 = $t0";
  -    note "got0 = $got0";
  -    note "t1 = $t1";
  -    note "t1 - t0 = ", ($t1 - $t0);
  -    note "got1 = $got1";
  -    ok $got0 == 0 or note $got0;
  +    print("# t0 = $t0\n");
  +    print("# got0 = $got0\n");
  +    print("# t1 = $t1\n");
  +    printf("# t1 - t0 = %s\n", ($t1 - $t0));
  +    print("# got1 = $got1\n");
  +    ok $got0 == 0 or print("# $got0\n");
       SKIP: {
   	skip "alarm interval exceeded", 2 if $t1 - $t0 >= 0.5;
   	ok $got1 > 0;
  @@ -106,7 +106,7 @@ for my $n (100_000, 1_100_000, 2_200_000, 4_300_000) {
       }
       ok $got1 < 300_000;
       my $got2 = Time::HiRes::ualarm(0);
  -    ok $got2 == 0 or note $got2;
  +    ok $got2 == 0 or print("# $got2\n");
   }
   
   1;
  diff --git a/dist/Time-HiRes/t/usleep.t b/dist/Time-HiRes/t/usleep.t
  index 0d6bacfac3..bdf372bd16 100644
  --- dist/Time-HiRes/t/usleep.t
  +++ dist/Time-HiRes/t/usleep.t
  @@ -8,7 +8,7 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 6;
  +use Test::More tests => 6;
   use t::Watchdog;
   
   eval { Time::HiRes::usleep(-2) };
  @@ -23,7 +23,7 @@ my $two = CORE::time;
   Time::HiRes::usleep(10_000);
   my $three = CORE::time;
   ok $one == $two || $two == $three
  -or note "slept too long, $one $two $three";
  +or print("# slept too long, $one $two $three\n");
   
   SKIP: {
       skip "no gettimeofday", 1 unless &Time::HiRes::d_gettimeofday;
  @@ -31,7 +31,7 @@ SKIP: {
       Time::HiRes::usleep(500_000);
       my $f2 = Time::HiRes::time();
       my $d = $f2 - $f;
  -    ok $d > 0.4 && $d < 0.9 or note "slept $d secs $f to $f2";
  +    ok $d > 0.4 && $d < 0.9 or print("# slept $d secs $f to $f2\n");
   }
   
   SKIP: {
  @@ -39,7 +39,7 @@ SKIP: {
       my $r = [ Time::HiRes::gettimeofday() ];
       Time::HiRes::sleep( 0.5 );
       my $f = Time::HiRes::tv_interval $r;
  -    ok $f > 0.4 && $f < 0.9 or note "slept $f instead of 0.5 secs.";
  +    ok $f > 0.4 && $f < 0.9 or print("# slept $f instead of 0.5 secs.\n");
   }
   
   SKIP: {
  @@ -59,7 +59,7 @@ SKIP: {
   
       SKIP: {
   	skip $msg, 1 unless $td < $sleep * (1 + $limit);
  -	ok $a < $limit or note $msg;
  +	ok $a < $limit or print("# $msg\n");
       }
   
       $t0 = Time::HiRes::gettimeofday();
  @@ -71,7 +71,7 @@ SKIP: {
   
       SKIP: {
   	skip $msg, 1 unless $td < $sleep * (1 + $limit);
  -	ok $a < $limit or note $msg;
  +	ok $a < $limit or print("# $msg\n");
       }
   }
   
  diff --git a/dist/Time-HiRes/typemap b/dist/Time-HiRes/typemap
  index 1124eb6483..3fa91f3a0b 100644
  --- dist/Time-HiRes/typemap
  +++ dist/Time-HiRes/typemap
  @@ -28,6 +28,8 @@ AV *			T_AVREF
   HV *			T_HVREF
   CV *			T_CVREF
   
  +clockid_t               T_IV
  +
   IV			T_IV
   UV			T_UV
   NV                      T_NV
  END
  diff --git a/Configure b/Configure
  index e12c8bb..1a8088f 100755
  --- Configure
  +++ Configure
  @@ -25151,6 +25151,8 @@ zcat='\$zcat'
   zip='\$zip'
   EOT
   
  +echo "BuiltWithPatchPerl='$dpv'" >>config.sh
  +
   : add special variables
   \$test -f \$src/patchlevel.h && \
   awk '/^#define[ 	]+PERL_/ {printf "\%s=\%s\\n",\$2,\$3}' \$src/patchlevel.h >>config.sh
  END
DEVEL_PATCHPERL

$fatpacked{"Devel/PatchPerl/Hints.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_PATCHPERL_HINTS';
  package Devel::PatchPerl::Hints;$Devel::PatchPerl::Hints::VERSION='1.48';use strict;use warnings;use MIME::Base64 qw[decode_base64];use File::Spec;our@ISA=qw[Exporter];our@EXPORT_OK=qw[hint_file hints];my%hints=('bitrig'=>'IyBoaW50cy9vcGVuYnNkLnNoCiMKIyBoaW50cyBmaWxlIGZvciBPcGVuQlNEOyBUb2RkIE1pbGxl
  ciA8bWlsbGVydEBvcGVuYnNkLm9yZz4KIyBFZGl0ZWQgdG8gYWxsb3cgQ29uZmlndXJlIGNvbW1h
  bmQtbGluZSBvdmVycmlkZXMgYnkKIyAgQW5keSBEb3VnaGVydHkgPGRvdWdoZXJhQGxhZmF5ZXR0
  ZS5lZHU+CiMKIyBUbyBidWlsZCB3aXRoIGRpc3RyaWJ1dGlvbiBwYXRocywgdXNlOgojCS4vQ29u
  ZmlndXJlIC1kZXMgLURvcGVuYnNkX2Rpc3RyaWJ1dGlvbj1kZWZpbmVkCiMKCiMgT3BlbkJTRCBo
  YXMgYSBiZXR0ZXIgbWFsbG9jIHRoYW4gcGVybC4uLgp0ZXN0ICIkdXNlbXltYWxsb2MiIHx8IHVz
  ZW15bWFsbG9jPSduJwoKIyBDdXJyZW50bHksIHZmb3JrKDIpIGlzIG5vdCBhIHJlYWwgd2luIG92
  ZXIgZm9yaygyKS4KdXNldmZvcms9IiR1bmRlZiIKCiMKIyBOb3QgYWxsIHBsYXRmb3JtcyBzdXBw
  b3J0IGR5bmFtaWMgbG9hZGluZy4uLgojIEZvciB0aGUgY2FzZSBvZiAiJG9wZW5ic2RfZGlzdHJp
  YnV0aW9uIiwgdGhlIGhpbnRzIGZpbGUKIyBuZWVkcyB0byBrbm93IHdoZXRoZXIgd2UgYXJlIHVz
  aW5nIGR5bmFtaWMgbG9hZGluZyBzbyB0aGF0CiMgaXQgY2FuIHNldCB0aGUgbGlicGVybCBuYW1l
  IGFwcHJvcHJpYXRlbHkuCiMgQWxsb3cgY29tbWFuZCBsaW5lIG92ZXJyaWRlcy4KIwojQVJDSD1g
  YXJjaCB8IHNlZCAncy9eT3BlbkJTRC4vLydgCkFSQ0g9YGFyY2ggfCBzZWQgJ3MvXkJpdHJpZy4v
  LydgCmNhc2UgIiR7QVJDSH0tJHtvc3ZlcnN9IiBpbgoqKQoJdGVzdCAteiAiJHVzZWRsIiAmJiB1
  c2VkbD0kZGVmaW5lCgkjIFdlIHVzZSAtZlBJQyBoZXJlIGJlY2F1c2UgLWZwaWMgaXMgKk5PVCog
  ZW5vdWdoIGZvciBzb21lIG9mIHRoZQoJIyBleHRlbnNpb25zIGxpa2UgVGsgb24gc29tZSBPcGVu
  QlNEIHBsYXRmb3JtcyAoaWU6IHNwYXJjKQoJY2NjZGxmbGFncz0iLURQSUMgLWZQSUMgJGNjY2Rs
  ZmxhZ3MiCgljYXNlICIkb3N2ZXJzIiBpbgoJKikgIyBmcm9tIDMuMSBvbndhcmRzCgkJbGQ9JHtj
  YzotY2N9CgkJbGRkbGZsYWdzPSItc2hhcmVkIC1mUElDICRsZGRsZmxhZ3MiCgkJbGlic3dhbnRl
  ZD1gZWNobyAkbGlic3dhbnRlZCB8IHNlZCAncy8gZGwgLyAvJ2AKCQk7OwoJZXNhYwoKCSMgV2Ug
  bmVlZCB0byBmb3JjZSBsZCB0byBleHBvcnQgc3ltYm9scyBvbiBFTEYgcGxhdGZvcm1zLgoJIyBX
  aXRob3V0IHRoaXMsIGRsb3BlbigpIGlzIGNyaXBwbGVkLgoJRUxGPWAke2NjOi1jY30gLWRNIC1F
  IC0gPC9kZXYvbnVsbCB8IGdyZXAgX19FTEZfX2AKCXRlc3QgLW4gIiRFTEYiICYmIGxkZmxhZ3M9
  Ii1XbCwtRSAkbGRmbGFncyIKCTs7CmVzYWMKCiMgbWFsbG9jIHdyYXAgY2F1c2VzIHByb2JsZW1z
  IG9uIG02OGsKaWYgWyBYIiR1c2VtYWxsb2N3cmFwIiA9IFgiIiBdOyB0aGVuCgljYXNlICIke0FS
  Q0h9IiBpbgoJKikgICAgdXNlbWFsbG9jd3JhcD0iZGVmaW5lIiA7OwoJZXNhYwpmaQoKIyBPcGVu
  QlNEIGRvZXNuJ3QgbmVlZCBsaWJjcnlwdCBidXQgbWFueSBmb2xrcyBrZWVwIGEgc3R1YiBsaWIK
  IyBhcm91bmQgZm9yIG9sZCBOZXRCU0QgYmluYXJpZXMuCmxpYnN3YW50ZWQ9YGVjaG8gJGxpYnN3
  YW50ZWQgfCBzZWQgJ3MvIGNyeXB0IC8gLydgCgojIENvbmZpZ3VyZSBjYW4ndCBmaWd1cmUgdGhp
  cyBvdXQgbm9uLWludGVyYWN0aXZlbHkKZF9zdWlkc2FmZT0kZGVmaW5lCgojIGNjIGlzIGdjYyBz
  byB3ZSBjYW4gZG8gYmV0dGVyIHRoYW4gLU8KIyBBbGxvdyBhIGNvbW1hbmQtbGluZSBvdmVycmlk
  ZSwgc3VjaCBhcyAtRG9wdGltaXplPS1nCmNhc2UgIiR7QVJDSH0tJHtvc3ZlcnN9IiBpbgoqKQog
  ICB0ZXN0ICIkb3B0aW1pemUiIHx8IG9wdGltaXplPSctTzInCiAgIDs7CmVzYWMKCiMgVGhpcyBz
  Y3JpcHQgVVUvdXNldGhyZWFkcy5jYnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1
  cmUgCiMgYWZ0ZXIgaXQgaGFzIHByb21wdGVkIHRoZSB1c2VyIGZvciB3aGV0aGVyIHRvIHVzZSB0
  aHJlYWRzLgpjYXQgPiBVVS91c2V0aHJlYWRzLmNidSA8PCdFT0NCVScKY2FzZSAiJHVzZXRocmVh
  ZHMiIGluCiRkZWZpbmV8dHJ1ZXxbeVldKikKCSMgYW55IG9wZW5ic2QgdmVyc2lvbiBkZXBlbmRl
  bmNpZXMgd2l0aCBwdGhyZWFkcz8KCWNjZmxhZ3M9Ii1wdGhyZWFkICRjY2ZsYWdzIgoJbGRmbGFn
  cz0iLXB0aHJlYWQgJGxkZmxhZ3MiCmVzYWMKRU9DQlUKCiMgV2hlbiBidWlsZGluZyBpbiB0aGUg
  T3BlbkJTRCB0cmVlIHdlIHVzZSBkaWZmZXJlbnQgcGF0aHMKIyBUaGlzIGlzIG9ubHkgcGFydCBv
  ZiB0aGUgc3RvcnksIHRoZSByZXN0IGNvbWVzIGZyb20gY29uZmlnLm92ZXIKY2FzZSAiJG9wZW5i
  c2RfZGlzdHJpYnV0aW9uIiBpbgonJ3wkdW5kZWZ8ZmFsc2UpIDs7CiopCgkjIFdlIHB1dCB0aGlu
  Z3MgaW4gL3Vzciwgbm90IC91c3IvbG9jYWwKCXByZWZpeD0nL3VzcicKCXByZWZpeGV4cD0nL3Vz
  cicKCXN5c21hbj0nL3Vzci9zaGFyZS9tYW4vbWFuMScKCWxpYnB0aD0nL3Vzci9saWInCglnbGli
  cHRoPScvdXNyL2xpYicKCSMgTG9jYWwgdGhpbmdzLCBob3dldmVyLCBkbyBnbyBpbiAvdXNyL2xv
  Y2FsCglzaXRlcHJlZml4PScvdXNyL2xvY2FsJwoJc2l0ZXByZWZpeGV4cD0nL3Vzci9sb2NhbCcK
  CSMgUG9ydHMgaW5zdGFsbHMgbm9uLXN0ZCBsaWJzIGluIC91c3IvbG9jYWwvbGliIHNvIGxvb2sg
  dGhlcmUgdG9vCglsb2NpbmNwdGg9Jy91c3IvbG9jYWwvaW5jbHVkZScKCWxvY2xpYnB0aD0nL3Vz
  ci9sb2NhbC9saWInCgkjIExpbmsgcGVybCB3aXRoIHNoYXJlZCBsaWJwZXJsCglpZiBbICIkdXNl
  ZGwiID0gIiRkZWZpbmUiIC1hIC1yICRzcmMvc2hsaWJfdmVyc2lvbiBdOyB0aGVuCgkJdXNlc2hy
  cGxpYj10cnVlCgkJbGlicGVybD1gLiAkc3JjL3NobGliX3ZlcnNpb247IGVjaG8gbGlicGVybC5z
  by4ke21ham9yfS4ke21pbm9yfWAKCWZpCgk7Owplc2FjCgojIGVuZAo=','cygwin'=>'IyEgL2Jpbi9zaAojIGN5Z3dpbi5zaCAtIGhpbnRzIGZvciBidWlsZGluZyBwZXJsIHVzaW5nIHRo
  ZSBDeWd3aW4gZW52aXJvbm1lbnQgZm9yIFdpbjMyCiMKCiMgbm90IG90aGVyd2lzZSBzZXR0YWJs
  ZQpleGVfZXh0PScuZXhlJwpmaXJzdG1ha2VmaWxlPSdHTlVtYWtlZmlsZScKY2FzZSAiJGxkbGli
  cHRobmFtZSIgaW4KJycpIGxkbGlicHRobmFtZT1QQVRIIDs7CmVzYWMKYXJjaG9ianM9J2N5Z3dp
  bi5vJwoKIyBtYW5kYXRvcnkgKG92ZXJyaWRlcyBpbmNvcnJlY3QgZGVmYXVsdHMpCnRlc3QgLXog
  IiRjYyIgJiYgY2M9J2djYycKaWYgdGVzdCAteiAiJHBsaWJwdGgiCnRoZW4KICAgIHBsaWJwdGg9
  YGdjYyAtcHJpbnQtZmlsZS1uYW1lPWxpYmMuYWAKICAgIHBsaWJwdGg9YGRpcm5hbWUgJHBsaWJw
  dGhgCiAgICBwbGlicHRoPWBjZCAkcGxpYnB0aCAmJiBwd2RgCmZpCnNvPSdkbGwnCiMgLSBlbGlt
  aW5hdGUgLWxjLCBpbXBsaWVkIGJ5IGdjYyBhbmQgYSBzeW1saW5rIHRvIGxpYmN5Z3dpbi5hCmxp
  YnN3YW50ZWQ9YGVjaG8gIiAkbGlic3dhbnRlZCAiIHwgc2VkIC1lICdzLyBjIC8gL2cnYAojIC0g
  ZWxpbWluYXRlIC1sbSwgc3ltbGluayB0byBsaWJjeWd3aW4uYQpsaWJzd2FudGVkPWBlY2hvICIg
  JGxpYnN3YW50ZWQgIiB8IHNlZCAtZSAncy8gbSAvIC9nJ2AKIyAtIGVsaW1pbmF0ZSAtbHV0aWws
  IHN5bWJvbHMgYXJlIGFsbCBpbiBsaWJjeWd3aW4uYQpsaWJzd2FudGVkPWBlY2hvICIgJGxpYnN3
  YW50ZWQgIiB8IHNlZCAtZSAncy8gdXRpbCAvIC9nJ2AKIyAtIGFkZCBsaWJnZGJtX2NvbXBhdCAk
  bGlic3dhbnRlZApsaWJzd2FudGVkPSIkbGlic3dhbnRlZCBnZGJtX2NvbXBhdCIKdGVzdCAteiAi
  JG9wdGltaXplIiAmJiBvcHRpbWl6ZT0nLU8zJwptYW4zZXh0PSczcG0nCnRlc3QgLXogIiR1c2U2
  NGJpdGludCIgJiYgdXNlNjRiaXRpbnQ9J2RlZmluZScKdGVzdCAteiAiJHVzZWl0aHJlYWRzIiAm
  JiB1c2VpdGhyZWFkcz0nZGVmaW5lJwpjY2ZsYWdzPSIkY2NmbGFncyAtRFBFUkxfVVNFX1NBRkVf
  UFVURU5WIC1VX19TVFJJQ1RfQU5TSV9fIgojIC0gb3RoZXJ3aXNlIGk2ODYtY3lnd2luCmFyY2hu
  YW1lPSdjeWd3aW4nCgojIGR5bmFtaWMgbG9hZGluZwojIC0gb3RoZXJ3aXNlIC1mcGljCmNjY2Rs
  ZmxhZ3M9JyAnCmxkZGxmbGFncz0nIC0tc2hhcmVkJwp0ZXN0IC16ICIkbGQiICYmIGxkPSdnKysn
  CgpjYXNlICIkb3N2ZXJzIiBpbgogICAgIyBDb25maWd1cmUgZ2V0cyB0aGVzZSB3cm9uZyBpZiB0
  aGUgSVBDIHNlcnZlciBpc24ndCB5ZXQgcnVubmluZzoKICAgICMgb25seSB1c2UgZm9yIDEuNS43
  IGFuZCBvbndhcmRzCiAgICBbMi05XSp8MS5bNi05XSp8MS5bMS01XVswLTldKnwxLjUuWzctOV0q
  fDEuNS5bMS02XVswLTldKikKICAgICAgICBkX3NlbWN0bF9zZW1pZF9kcz0nZGVmaW5lJwogICAg
  ICAgIGRfc2VtY3RsX3NlbXVuPSdkZWZpbmUnCiAgICAgICAgOzsKZXNhYwoKY2FzZSAiJG9zdmVy
  cyIgaW4KICAgIFsyLTldKnwxLls2LTldKikKICAgICAgICAjIElQdjYgb25seSBzaW5jZSAxLjcK
  ICAgICAgICBkX2luZXRudG9wPSdkZWZpbmUnCiAgICAgICAgZF9pbmV0cHRvbj0nZGVmaW5lJwog
  ICAgICAgIDs7CiAgICAqKQogICAgICAgICMgSVB2NiBub3QgaW1wbGVtZW50ZWQgYmVmb3JlIGN5
  Z3dpbi0xLjcKICAgICAgICBkX2luZXRudG9wPSd1bmRlZicKICAgICAgICBkX2luZXRwdG9uPSd1
  bmRlZicKZXNhYwoKIyBjb21waWxlIFdpbjMyQ09SRSAibW9kdWxlIiBhcyBzdGF0aWMuIHRyeSB0
  byBhdm9pZCB0aGUgc3BhY2UuCmlmIHRlc3QgLXogIiRzdGF0aWNfZXh0IjsgdGhlbgogIHN0YXRp
  Y19leHQ9IldpbjMyQ09SRSIKZWxzZQogIHN0YXRpY19leHQ9IiRzdGF0aWNfZXh0IFdpbjMyQ09S
  RSIKZmkKCiMgV2luOXggcHJvYmxlbSB3aXRoIG5vbi1ibG9ja2luZyByZWFkIGZyb20gYSBjbG9z
  ZWQgcGlwZQpkX2VvZm5ibGs9J2RlZmluZScKCiMgc3VwcHJlc3MgYXV0by1pbXBvcnQgd2Fybmlu
  Z3MKbGRmbGFncz0iJGxkZmxhZ3MgLVdsLC0tZW5hYmxlLWF1dG8taW1wb3J0IC1XbCwtLWV4cG9y
  dC1hbGwtc3ltYm9scyAtV2wsLS1lbmFibGUtYXV0by1pbWFnZS1iYXNlIgpsZGRsZmxhZ3M9IiRs
  ZGRsZmxhZ3MgJGxkZmxhZ3MiCgojIHN0cmlwIGV4ZSdzIGFuZCBkbGwncywgYmV0dGVyIGRvIGl0
  IGFmdGVyd2FyZHMKI2xkZmxhZ3M9IiRsZGZsYWdzIC1zIgojY2NkbGZsYWdzPSIkY2NkbGZsYWdz
  IC1zIgojbGRkbGZsYWdzPSIkbGRkbGZsYWdzIC1zIgo=','darwin'=>'IyMKIyBEYXJ3aW4gKE1hYyBPUykgaGludHMKIyBXaWxmcmVkbyBTYW5jaGV6IDx3c2FuY2hlekB3
  c2FuY2hlei5uZXQ+CiMjCgojIwojIFBhdGhzCiMjCgojIENvbmZpZ3VyZSBoYXNuJ3QgZmlndXJl
  ZCBvdXQgdGhlIHZlcnNpb24gbnVtYmVyIHlldC4gIEJ1bW1lci4KcGVybF9yZXZpc2lvbj1gYXdr
  ICcvZGVmaW5lWyAJXStQRVJMX1JFVklTSU9OLyB7cHJpbnQgJDN9JyAkc3JjL3BhdGNobGV2ZWwu
  aGAKcGVybF92ZXJzaW9uPWBhd2sgJy9kZWZpbmVbIAldK1BFUkxfVkVSU0lPTi8ge3ByaW50ICQz
  fScgJHNyYy9wYXRjaGxldmVsLmhgCnBlcmxfc3VidmVyc2lvbj1gYXdrICcvZGVmaW5lWyAJXStQ
  RVJMX1NVQlZFUlNJT04vIHtwcmludCAkM30nICRzcmMvcGF0Y2hsZXZlbC5oYAp2ZXJzaW9uPSIk
  e3BlcmxfcmV2aXNpb259LiR7cGVybF92ZXJzaW9ufS4ke3Blcmxfc3VidmVyc2lvbn0iCgojIFBy
  ZXRlbmQgdGhhdCBEYXJ3aW4gZG9lc24ndCBrbm93IGFib3V0IHRob3NlIHN5c3RlbSBjYWxscyBp
  biBUaWdlcgojICgxMC40L2RhcndpbiA4KSBhbmQgZWFybGllciBbcGVybCAjMjQxMjJdCmNhc2Ug
  IiRvc3ZlcnMiIGluClsxLThdLiopCiAgICBkX3NldHJlZ2lkPSd1bmRlZicKICAgIGRfc2V0cmV1
  aWQ9J3VuZGVmJwogICAgZF9zZXRyZ2lkPSd1bmRlZicKICAgIGRfc2V0cnVpZD0ndW5kZWYnCiAg
  ICA7Owplc2FjCgojIGZpbml0ZSgpIGRlcHJlY2F0ZWQgaW4gMTAuOSwgdXNlIGlzZmluaXRlKCkg
  aW5zdGVhZC4KY2FzZSAiJG9zdmVycyIgaW4KWzEtOF0uKikgOzsKKikgZF9maW5pdGU9J3VuZGVm
  JyA7Owplc2FjCgojIFRoaXMgd2FzIHByZXZpb3VzbHkgdXNlZCBpbiBhbGwgYnV0IGNhdXNlcyB0
  aHJlZSBjYXNlcwojIChubyAtRGRwcmVmaXg9LCAtRHByZWZpeD0vdXNyLCAtRHByZWZpeD0vc29t
  ZS90aGluZy9lbHNlKQojIGJ1dCB0aGF0IGNhdXNlZCB0b28gbXVjaCBncmllZi4KIyB2ZW5kb3Js
  aWI9Ii9TeXN0ZW0vTGlicmFyeS9QZXJsLyR7dmVyc2lvbn0iOyAjIEFwcGxlLXN1cHBsaWVkIG1v
  ZHVsZXMKCmNhc2UgIiRkYXJ3aW5fZGlzdHJpYnV0aW9uIiBpbgokZGVmaW5lKSAjIFdlIGFyZSBi
  dWlsZGluZy9yZXBsYWNpbmcgdGhlIGJ1aWx0LWluIHBlcmwKCXByZWZpeD0nL3Vzcic7CglpbnN0
  YWxscHJlZml4PScvdXNyJzsKCWJpbj0nL3Vzci9iaW4nOwoJc2l0ZXByZWZpeD0nL3Vzci9sb2Nh
  bCc7CgkjIFdlIGRvbid0IHdhbnQgL3Vzci9iaW4vSEVBRCBpc3N1ZXMuCglzaXRlYmluPScvdXNy
  L2xvY2FsL2Jpbic7CglzaXRlc2NyaXB0PScvdXNyL2xvY2FsL2Jpbic7CglpbnN0YWxsdXNyYmlu
  cGVybD0nZGVmaW5lJzsgIyBZb3Uga25ldyB3aGF0IHlvdSB3ZXJlIGRvaW5nLgoJcHJpdmxpYj0i
  L1N5c3RlbS9MaWJyYXJ5L1BlcmwvJHt2ZXJzaW9ufSI7CglzaXRlbGliPSIvTGlicmFyeS9QZXJs
  LyR7dmVyc2lvbn0iOwoJdmVuZG9ycHJlZml4PScvJzsKCXVzZXZlbmRvcnByZWZpeD0nZGVmaW5l
  JzsKCXZlbmRvcmJpbj0nL3Vzci9iaW4nOwoJdmVuZG9yc2NyaXB0PScvdXNyL2Jpbic7Cgl2ZW5k
  b3JsaWI9Ii9OZXR3b3JrL0xpYnJhcnkvUGVybC8ke3ZlcnNpb259IjsKCSMgNEJTRCB1c2VzICR7
  cHJlZml4fS9zaGFyZS9tYW4sIG5vdCAke3ByZWZpeH0vbWFuLgoJbWFuMWRpcj0nL3Vzci9zaGFy
  ZS9tYW4vbWFuMSc7CgltYW4zZGlyPScvdXNyL3NoYXJlL21hbi9tYW4zJzsKCSMgQnV0IHVzZXJz
  JyBpbnN0YWxscyBzaG91bGRuJ3QgdG91Y2ggdGhlIHN5c3RlbSBtYW4gcGFnZXMuCgkjIFRyYW5z
  aWVudCBvYnNvbGV0ZWQgc3R5bGUuCglzaXRlbWFuMT0nL3Vzci9sb2NhbC9zaGFyZS9tYW4vbWFu
  MSc7CglzaXRlbWFuMz0nL3Vzci9sb2NhbC9zaGFyZS9tYW4vbWFuMyc7CgkjIE5ldyBzdHlsZS4K
  CXNpdGVtYW4xZGlyPScvdXNyL2xvY2FsL3NoYXJlL21hbi9tYW4xJzsKCXNpdGVtYW4zZGlyPScv
  dXNyL2xvY2FsL3NoYXJlL21hbi9tYW4zJzsKCTs7CmVzYWMKCiMjCiMgVG9vbCBjaGFpbiBzZXR0
  aW5ncwojIwoKIyBTaW5jZSB3ZSBjYW4gYnVpbGQgZmF0LCB0aGUgYXJjaG5hbWUgZG9lc24ndCBu
  ZWVkIHRoZSBwcm9jZXNzb3IgdHlwZQphcmNobmFtZT0nZGFyd2luJzsKCiMgbm0gaXNuJ3Qga25v
  d24gdG8gd29yayBhZnRlciBTbm93IExlb3BhcmQgYW5kIFhDb2RlIDQ7IHRlc3Rpbmcgd2l0aCBP
  UyBYIDEwLjUKIyBhbmQgWGNvZGUgMyBzaG93cyBhIHdvcmtpbmcgbm0sIGJ1dCBwcmV0ZW5kaW5n
  IGl0IGRvZXNuJ3Qgd29yayBwcm9kdWNlcyBubwojIHByb2JsZW1zLgp1c2VubT0nZmFsc2UnOwoK
  Y2FzZSAiJG9wdGltaXplIiBpbgonJykKIyAgICBPcHRpbWl6aW5nIGZvciBzaXplIGFsc28gbWVh
  biBsZXNzIHJlc2lkZW50IG1lbW9yeSB1c2FnZSBvbiB0aGUgcGFydAojIG9mIFBlcmwuICBBcHBs
  ZSBhc3NlcnRzIHRoYXQgdGhpcyBpcyBhIG1vcmUgaW1wb3J0YW50IG9wdGltaXphdGlvbiB0aGFu
  CiMgc2F2aW5nIG9uIENQVSBjeWNsZXMuICBHaXZlbiB0aGF0IG1lbW9yeSBzcGVlZCBoYXMgbm90
  IGluY3JlYXNlZCBhdAojIHBhY2Ugd2l0aCBDUFUgc3BlZWQgb3ZlciB0aW1lIChvbiBhbnkgcGxh
  dGZvcm0pLCB0aGlzIGlzIHByb2JhYmx5IGEKIyByZWFzb25hYmxlIGFzc2VydGlvbi4KaWYgWyAt
  eiAiJHtvcHRpbWl6ZX0iIF07IHRoZW4KICBjYXNlICJgJHtjYzotZ2NjfSAtdiAyPiYxYCIgaW4K
  ICAgICoiZ2NjIHZlcnNpb24gMy4iKikgb3B0aW1pemU9Jy1PcycgOzsKICAgICopIG9wdGltaXpl
  PSctTzMnIDs7CiAgZXNhYwplbHNlCiAgb3B0aW1pemU9Jy1PMycKZmkKOzsKZXNhYwoKIyAtZm5v
  LWNvbW1vbiBiZWNhdXNlIGNvbW1vbiBzeW1ib2xzIGFyZSBub3QgYWxsb3dlZCBpbiBNSF9EWUxJ
  QgojIC1EUEVSTF9EQVJXSU46IGFwcGFyZW50bHkgdGhlIF9fQVBQTEVfXyBpcyBub3Qgc2FuY3Rp
  b25lZCBieSBBcHBsZQojIGFzIHRoZSB3YXkgdG8gZGlmZmVyZW50aWF0ZSBNYWMgT1MgWC4gIChU
  aGUgb2ZmaWNpYWwgbGluZSBpcyB0aGF0CiMgKm5vKiBjcHAgc3ltYm9sIGRvZXMgZGlmZmVyZW50
  aWF0ZSBNYWMgT1MgWC4pCmNjZmxhZ3M9IiR7Y2NmbGFnc30gLWZuby1jb21tb24gLURQRVJMX0RB
  UldJTiIKCiMgQXQgbGVhc3Qgb24gRGFyd2luIDEuMy54OgojCiMgIyBkZWZpbmUgSU5UMzJfTUlO
  IC0yMTQ3NDgzNjQ4CiMgaW50IG1haW4gKCkgewojICBkb3VibGUgYSA9IElOVDMyX01JTjsKIyAg
  cHJpbnRmICgiSU5UMzJfTUlOPSVnXG4iLCBhKTsKIyAgcmV0dXJuIDA7CiMgfQojIHdpbGwgb3V0
  cHV0OgojIElOVDMyX01JTj0yLjE0NzQ4ZSswOQojIE5vdGUgdGhhdCB0aGUgSU5UMzJfTUlOIGhh
  cyBiZWNvbWUgcG9zaXRpdmUuCiMgSU5UMzJfTUlOIGlzIHNldCBpbiAvdXNyL2luY2x1ZGUvc3Rk
  aW50LmggYnk6CiMgI2RlZmluZSBJTlQzMl9NSU4gICAgICAgIC0yMTQ3NDgzNjQ4CiMgd2hpY2gg
  c2VlbXMgdG8gYnJlYWsgdGhlIGdjYy4gIERlZmluaW5nIElOVDMyX01JTiBhcyAoLTIxNDc0ODM2
  NDctMSkKIyBzZWVtcyB0byB3b3JrLiAgSU5UNjRfTUlOIHNlZW1zIHRvIGJlIHNpbWlsYXJseSBi
  cm9rZW4uCiMgLS0gTmljaG9sYXMgQ2xhcmssIEtlbiBXaWxsaWFtcywgYW5kIEVkd2FyZCBNb3kK
  IwojIFRoaXMgc2VlbXMgdG8gaGF2ZSBiZWVuIGZpeGVkIHNpbmNlIGF0IGxlYXN0IE1hYyBPUyBY
  IDEwLjEuMywKIyBzdGRpbnQuaCBkZWZpbmluZyBJTlQzMl9NSU4gYXMgKC1JTlQzMl9NQVgtMSkK
  IyAtLSBFZHdhcmQgTW95CiMKaWYgdGVzdCAtZiAvdXNyL2luY2x1ZGUvc3RkaW50Lmg7IHRoZW4K
  ICBjYXNlICIkKGdyZXAgJ14jZGVmaW5lIElOVDMyX01JTicgL3Vzci9pbmNsdWRlL3N0ZGludC5o
  KSIgaW4KICAqLTIxNDc0ODM2NDgpIGNjZmxhZ3M9IiR7Y2NmbGFnc30gLURJTlQzMl9NSU5fQlJP
  S0VOIC1ESU5UNjRfTUlOX0JST0tFTiIgOzsKICBlc2FjCmZpCgojIEF2b2lkIEFwcGxlJ3MgY3Bw
  IHByZWNvbXBpbGVyLCBiZXR0ZXIgZm9yIGV4dGVuc2lvbnMKaWYgWyAiWGBlY2hvIHwgJHtjY30g
  LW5vLWNwcC1wcmVjb21wIC1FIC0gMj4mMSA+L2Rldi9udWxsYCIgPSAiWCIgXTsgdGhlbgogICAg
  Y3BwZmxhZ3M9IiR7Y3BwZmxhZ3N9IC1uby1jcHAtcHJlY29tcCIKCiAgICAjIFRoaXMgaXMgbmVj
  ZXNzYXJ5IGJlY2F1c2UgcGVybCdzIGJ1aWxkIHN5c3RlbSBkb2Vzbid0CiAgICAjIGFwcGx5IGNw
  cGZsYWdzIHRvIGNjIGNvbXBpbGUgbGluZXMgYXMgaXQgc2hvdWxkLgogICAgY2NmbGFncz0iJHtj
  Y2ZsYWdzfSAke2NwcGZsYWdzfSIKZmkKCiMgS25vd24gb3B0aW1pemVyIHByb2JsZW1zLgpjYXNl
  ICJgY2MgLXYgMj4mMWAiIGluCiAgKiIzLjEgMjAwMjAxMDUiKikgdG9rZV9jZmxhZ3M9J29wdGlt
  aXplPSIiJyA7Owplc2FjCgojIFNoYXJlZCBsaWJyYXJ5IGV4dGVuc2lvbiBpcyAuZHlsaWIuCiMg
  QnVuZGxlIGV4dGVuc2lvbiBpcyAuYnVuZGxlLgpzbz0nZHlsaWInOwpkbGV4dD0nYnVuZGxlJzsK
  dXNlZGw9J2RlZmluZSc7CgojIDEwLjQgY2FuIHVzZSBkbG9wZW4uCiMgMTAuNCBicm9rZSBwb2xs
  KCkuCmNhc2UgIiRvc3ZlcnMiIGluClsxLTddLiopCiAgICBkbHNyYz0nZGxfZHlsZC54cyc7CiAg
  ICA7OwoqKQogICAgZGxzcmM9J2RsX2Rsb3Blbi54cyc7CiAgICBkX3BvbGw9J3VuZGVmJzsKICAg
  IGlfcG9sbD0ndW5kZWYnOwogICAgOzsKZXNhYwoKY2FzZSAiJGNjZGxmbGFncyIgaW4JCSMgSWYg
  cGFzc2VkIGluIGZyb20gY29tbWFuZCBsaW5lLCBwcmVzdW1lIHVzZXIga25vd3MgYmVzdAonJykK
  ICAgY2NjZGxmbGFncz0nICc7ICMgc3BhY2UsIG5vdCBlbXB0eSwgYmVjYXVzZSBvdGhlcndpc2Ug
  d2UgZ2V0IC1mcGljCjs7CmVzYWMKCiMgQWxsb3cgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgbGQsIGJ1
  dCBtb2RpZnkgaXQgYXMgbmVjZXNzYXJ5IGJlbG93CmNhc2UgIiRsZCIgaW4KICAgICcnKSBjYXNl
  ICIkY2MiIGluCiAgICAgICAgIyBJZiB0aGUgY2MgaXMgZXhwbGljaXRseSBzb21ldGhpbmcgZWxz
  ZSB0aGFuIGNjIChvciBlbXB0eSksCiAgICAgICAgIyBzZXQgdGhlIGxkIHRvIGJlIHRoYXQgZXhw
  bGljaXRseSBzb21ldGhpbmcgZWxzZS4gIENvbnZlcnNlbHksCiAgICAgICAgIyBpZiB0aGUgY2Mg
  aXMgJ2NjJyAob3IgZW1wdHkpLCBzZXQgdGhlIGxkIHRvIGJlICdjYycuCiAgICAgICAgY2N8Jycp
  IGxkPSdjYyc7OwogICAgICAgICopIGxkPSIkY2MiIDs7CiAgICAgICAgZXNhYwogICAgICAgIDs7
  CmVzYWMKCiMgRnJvbSBodHRwOi8vZnRwLm5ldGJzZC5vcmcvcHViL3BrZ3NyYy9jdXJyZW50L3Br
  Z3NyYy9tay9wbGF0Zm9ybS9EYXJ3aW4ubWsKIyBhbmQgaHR0cHM6Ly90cmFjLm1hY3BvcnRzLm9y
  Zy93aWtpL1hjb2RlVmVyc2lvbkluZm8KIyBhbmQgaHR0cHM6Ly90cmFjLm1hY3BvcnRzLm9yZy93
  aWtpL1VzaW5nVGhlUmlnaHRDb21waWxlcgojIGFuZCBodHRwczovL2dpc3QuZ2l0aHViLmNvbS95
  YW1heWEvMjkyNDI5MgojIGFuZCBodHRwOi8vb3BlbnNvdXJjZS5hcHBsZS5jb20vc291cmNlL2Ns
  YW5nLwojCiMgTm90ZSB0aGF0IFhjb2RlIGdldHMgdXBkYXRlcyBvbiBvbGRlciBzeXN0ZW1zIHNv
  bWV0aW1lcywgYW5kIGluCiMgZ2VuZXJhbCB0aGF0IHRoZSBPUyBsZXZlbHMgYW5kIFhDb2RlIGxl
  dmVscyBhcmUgbm90IHN5bmNocm9uaXplZAojIHNpbmNlIG5ldyByZWxlYXNlcyBvZiBYQ29kZSB1
  c3VhbGx5IHN1cHBvcnQgYm90aCBzb21lIG5ldyBhbmQgc29tZQojIG9sZCBPUyByZWxlYXNlcy4K
  IwojIE5vdGUgdGhhdCBBcHBsZSBoaWphY2tzIHRoZSBjbGFuZyBwcmVwcm9jZXNzb3Igc3ltYm9s
  cyBfX2NsYW5nX21ham9yX18KIyBhbmQgX19jbGFuZ19taW5vcl9fIHNvIHRoZXkgY2Fubm90IGJl
  IHVzZWQgKGVhc2lseSkgdG8gZGV0ZWN0IHRoZQojIGFjdHVhbCBjbGFuZyByZWxlYXNlLiAgRm9y
  IGV4YW1wbGU6CiMKIyAiWW9zZW1pdGUgMTAuMTAueCAxNC54LnkgNi4zIChjbGFuZyAzLjYgYXMg
  Ni4xLzYwMi4wLjQ5KSIKIwojIG1lYW5zIHRoYXQgdGhlIFhjb2RlIDYuMyBwcm92aWRlZCB0aGUg
  Y2xhbmcgNi4zIGJ1dCBjYWxsZWQgaXQgNi4xCiMgKF9fY2xhbmdfbWFqb3JfXywgX19jbGFuZ19t
  aW5vcl9fKSBhbmQgaW4gYWRkaXRpb24gdGhlIHByZXByb2Nlc3NvcgojIHN5bWJvbCBfX2FwcGxl
  X2J1aWxkX3ZlcnNpb25fXyB3YXMgNjAyMDA0OS4KIwojIENvZGVuYW1lICAgICAgICBPUyAgICAg
  IEtlcm5lbCAgWGNvZGUKIwojIENoZWV0YWggICAgICAgICAxMC4wLnggIDEuMy4xCiMgUHVtYSAg
  ICAgICAgICAgIDEwLjEgICAgMS40LjEKIyAgICAgICAgICAgICAgICAgMTAuMS54ICA1LngueQoj
  IEphZ3VhciAgICAgICAgICAxMC4yLnggIDYueC55CiMgUGFudGhlciAgICAgICAgIDEwLjMueCAg
  Ny54LnkKIyBUaWdlciAgICAgICAgICAgMTAuNC54ICA4LngueSAgIDIuMCAgIChnY2M0IDQuMC4w
  KQojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMi4yICAgKGdjYzQgNC4wLjEpCiMg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyLjIuMSAoZ2NjIDMuMykKIyAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgICAgIDIuNSA/CiMgTGVvcGFyZCAgICAgICAgIDEwLjUueCAg
  OS54LnkgICAzLjAgICAoZ2NjIDQuMC4xIGRlZmF1bHQpCiMgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAgICAzLjEgICAoZ2NjIDQuMi4xKQojIFNub3cgTGVvcGFyZCAgICAxMC42LnggIDEw
  LngueSAgMy4yICAgKGxsdm0gZ2NjIDQuMiwgY2xhbmcgMi4zIGFzIDEuMCkKIyAgICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgIDMuMi4xIChjbGFuZyAxLjAuMSBhcyAxLjAuMS8yNCkKIyAg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMuMi4yIChjbGFuZyAxLjAuMiBhcyAxLjAu
  Mi8zMikKIyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMuMi4zIChjbGFuZyAxLjUg
  YXMgMS41LzYwKQojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNC4wLjEgKGNsYW5n
  IDIuOSBhcyAyLjAvMTM4KQojIExpb24gICAgICAgICAgICAxMC43LnggIDExLngueSAgNC4xICAg
  KGxsdm0gZ2NjIDQuMi4xLCBjbGFuZyAzLjAgYXMgMi4xLzE2My43LjEpCiMgICAgICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICA0LjIgICAoY2xhbmcgMy4wIGFzIDMuMC8yMTEuMTAuMSkKIyAg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQuMy4zIChjbGFuZyAzLjEgYXMgMy4xLzMx
  OC4wLjYxKQojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNC40ICAgKGNsYW5nIDMu
  MSBhcyA0LjAvNDIxLjAuNTcpCiMgTW91bnRhaW4gTGlvbiAgIDEwLjgueCAgMTIueC55ICA0LjUg
  ICAoY2xhbmcgMy4xIGFzIDQuMS80MjEuMTEuNjUsIHJlYWwgZ2NjIHJlbW92ZWQsIHRoZXJlIGlz
  IGdjYyBidXQgaXQncyByZWFsbHkgY2xhbmcpCiMgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgICA0LjYgICAoY2xhbmcgMy4yIGFzIDQuMi80MjUuMC4yNCkKIyAgICAgICAgICAgICAgICAg
  ICAgICAgICAgICAgICAgIDUuMCAgIChjbGFuZyAzLjMgYXMgNS4wLzUwMC4yLjc1KQojICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgNS4xICAgKGNsYW5nIDMuNCBhcyA1LjEvNTAzLjAu
  MzgpCiMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA1LjEuMSAoY2xhbmcgMy40IGFz
  IDUuMS81MDMuMC40MCkKIyBNYXZlcmlja3MgICAgICAgMTAuOS54ICAxMy54LnkgIDYuMC4xIChj
  bGFuZyAzLjUgYXMgNi4wLzYwMC4wLjUxKQojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgNi4xICAgKGNsYW5nIDMuNSBhcyA2LjAvNjAwLjAuNTQpCiMgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAgICAgICA2LjEuMSAoY2xhbmcgMy41IGFzIDYuMC82MDAuMC41NikKIyAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgICAgIDYuMiAgIChjbGFuZyAzLjUgYXMgNi4wLzYwMC4wLjU3
  KQojIFlvc2VtaXRlICAgICAgICAxMC4xMC54IDE0LngueSAgNi4zICAgKGNsYW5nIDMuNiBhcyA2
  LjEvNjAyLjAuNDkpCiMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2LjMuMSAoY2xh
  bmcgMy42IGFzIDYuMS82MDIuMC40OSkKIyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  IDYuMy4yIChjbGFuZyAzLjYgYXMgNi4xLzYwMi4wLjUzKQojIEVsIENhcGl0YW4gICAgICAxMC4x
  MS54IDE1LngueSAgNy4wICAgKGNsYW5nIDMuNyBhcyA3LjAvNzAwLjAuNzIpCiMgICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgICA3LjEgICAoY2xhbmcgMy43IGFzIDcuMC83MDAuMS43NikK
  IyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcuMiAgIChjbGFuZyAzLjcgYXMgNy4w
  LjIvNzAwLjEuODEpCiMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3LjIuMSAoY2xh
  bmcgMy43IGFzIDcuMC4yLzcwMC4xLjgxKQojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgNy4zICAgKGNsYW5nIDMuOCBhcyA3LjMuMC83MDMuMC4yOSkKIyBTaWVycmEgICAgICAgICAg
  MTAuMTIueCAxNi54LnkgIDguMC4wIChjbGFuZyAzLjggYXMgOC4wLzgwMC4wLjM4KQojCgojIFBy
  b2Nlc3NvcnMgU3VwcG9ydGVkCiMKIyBQb3dlclBDIChQUEMpOiAgICAgICAxMC4wLnggLSAxMC41
  LjggKGZpbmFsIDEwLjUueCkKIyBQb3dlclBDIHZpYSBSb3NldHRhOiAxMC40LjQgLSAxMC42Ljgg
  KGZpbmFsIDEwLjYueCkKIyBJQS0zMjogICAgICAgICAgICAgICAxMC40LjQgLSAxMC42LjggKHRo
  b3VnaCBzdGlsbCBzdXBwb3J0ZWQgb24geDg2LTY0KQojIHg4Ni02NDogICAgICAgICAgICAgIDEw
  LjQuNyAtIGN1cnJlbnQKCiMgTUFDT1NYX0RFUExPWU1FTlRfVEFSR0VUIHNlbGVjdHMgdGhlIG1p
  bmltdW0gT1MgbGV2ZWwgd2Ugd2FudCB0byBzdXBwb3J0CiMKIyBJdCBpcyBuZWVkZWQgZm9yIE9T
  IHJlbGVhc2VzIGJlZm9yZSAxMC42LgojCiMgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xp
  YnJhcnkvbWFjL2RvY3VtZW50YXRpb24vRGV2ZWxvcGVyVG9vbHMvQ29uY2VwdHVhbC9jcm9zc19k
  ZXZlbG9wbWVudC9Db25maWd1cmluZy9jb25maWd1cmluZy5odG1sCiMKIyBJZiBpdCBpcyBzZXQs
  IHdlIGFsc28gcHJvcGFnYXRlIGl0cyB2YWx1ZSB0byBjY2ZsYWdzIGFuZCBsZGZsYWdzCiMgdXNp
  bmcgdGhlIC1tbWFjb3N4LXZlcnNpb24tbWluIGZsYWcuICBJZiBpdCBpcyBub3Qgc2V0LCB3ZSB1
  c2UKIyB0aGUgT1MgWCByZWxlYXNlIGFzIHRoZSBtaW4gdmFsdWUgZm9yIHRoZSBmbGFnLgoKIyBB
  ZGRzICItbW1hY29zeC12ZXJzaW9uLW1pbj0kMiIgdG8gIiQxIiB1bmxlc3MgaXQgYWxyZWFkeSBp
  cyB0aGVyZS4KYWRkX21hY29zeF92ZXJzaW9uX21pbiAoKSB7CiAgbG9jYWwgdgogIGV2YWwgInY9
  XCQkMSIKICBjYXNlICIgJHYgIiBpbgogICoiLW1tYWNvc3gtdmVyc2lvbi1taW4iKikKICAgICBl
  Y2hvICJOT1QgYWRkaW5nIC1tbWFjb3N4LXZlcnNpb24tbWluPSQyIHRvICQxICgkdikiID4mNAog
  ICAgIDs7CiAgKikgZWNobyAiQWRkaW5nIC1tbWFjb3N4LXZlcnNpb24tbWluPSQyIHRvICQxIiA+
  JjQKICAgICBldmFsICIkMT0nJHYgLW1tYWNvc3gtdmVyc2lvbi1taW49JDInIgogICAgIDs7CiAg
  ZXNhYwp9CgojIFBlcmwgYnVuZGxlcyBkbyBub3QgZXhwZWN0IHR3by1sZXZlbCBuYW1lc3BhY2Us
  IGFkZGVkIGluIERhcndpbiAxLjQuCiMgQnV0IHN0YXJ0aW5nIGZyb20gcGVybCA1LjguMS9EYXJ3
  aW4gNyB0aGUgZGVmYXVsdCBpcyB0aGUgdHdvLWxldmVsLgpjYXNlICIkb3N2ZXJzIiBpbiAgIyBO
  b3RlOiBvc3ZlcnMgaXMgdGhlIGtlcm5lbCB2ZXJzaW9uLCBub3QgdGhlIDEwLngKMS5bMC0zXS4q
  KSAjIE9TIFggMTAuMC54CiAgIGxkZGxmbGFncz0iJHtsZGZsYWdzfSAtYnVuZGxlIC11bmRlZmlu
  ZWQgc3VwcHJlc3MiCiAgIDs7CjEuKikgICAgICAgIyBPUyBYIDEwLjEKICAgbGRmbGFncz0iJHts
  ZGZsYWdzfSAtZmxhdF9uYW1lc3BhY2UiCiAgIGxkZGxmbGFncz0iJHtsZGZsYWdzfSAtYnVuZGxl
  IC11bmRlZmluZWQgc3VwcHJlc3MiCiAgIDs7ClsyLTZdLiopICAgIyBPUyBYIDEwLjEueCAtIDEw
  LjIueCAodGhvdWdoIFsyLTRdIG5ldmVyIGV4aXN0ZWQgcHVibGljbHkpCiAgIGxkZmxhZ3M9IiR7
  bGRmbGFnc30gLWZsYXRfbmFtZXNwYWNlIgogICBsZGRsZmxhZ3M9IiR7bGRmbGFnc30gLWJ1bmRs
  ZSAtdW5kZWZpbmVkIHN1cHByZXNzIgogICA7OwpbNy05XS4qKSAgICMgT1MgWCAxMC4zLnggLSAx
  MC41LngKICAgbGRkbGZsYWdzPSIke2xkZmxhZ3N9IC1idW5kbGUgLXVuZGVmaW5lZCBkeW5hbWlj
  X2xvb2t1cCIKICAgY2FzZSAiJGxkIiBpbgogICAgICAgKk1BQ09TWF9ERVBMT1lNRU5UX1RBUkdF
  VCopIDs7CiAgICAgICAqKSBsZD0iZW52IE1BQ09TWF9ERVBMT1lNRU5UX1RBUkdFVD0xMC4zICR7
  bGR9IiA7OwogICBlc2FjCiAgIDs7CiopICAgICAgICAjIE9TIFggMTAuNi54IC0gY3VycmVudAog
  ICAjIFRoZSBNQUNPU1hfREVQTE9ZTUVOVF9UQVJHRVQgaXMgbm90IG5lZWRlZCwKICAgIyBidXQg
  dGhlIC1tbWFjb3N4LXZlcnNpb24tbWluIG9wdGlvbiBpcyBhbHdheXMgdXNlZC4KCiAgICMgV2Ug
  bm93IHVzZSBNQUNPU1hfREVQTE9ZTUVOVF9UQVJHRVQsIGlmIHNldCwgYXMgYW4gb3ZlcnJpZGUg
  YnkKICAgIyBjYXB0dXJpbmcgaXRzIHZhbHVlIGFuZCBhZGRpbmcgaXQgdG8gdGhlIGZsYWdzLgog
  ICAgY2FzZSAiJE1BQ09TWF9ERVBMT1lNRU5UX1RBUkdFVCIgaW4KICAgIDEwLiopCiAgICAgIGFk
  ZF9tYWNvc3hfdmVyc2lvbl9taW4gY2NmbGFncyAkTUFDT1NYX0RFUExPWU1FTlRfVEFSR0VUCiAg
  ICAgIGFkZF9tYWNvc3hfdmVyc2lvbl9taW4gbGRmbGFncyAkTUFDT1NYX0RFUExPWU1FTlRfVEFS
  R0VUCiAgICAgIDs7CiAgICAnJykKICAgICAgIyBFbXB0eSBNQUNPU1hfREVQTE9ZTUVOVF9UQVJH
  RVQgaXMgb2theS4KICAgICAgOzsKICAgICopCiAgICAgIGNhdCA8PEVPTSA+JjQKCioqKiBVbmV4
  cGVjdGVkIE1BQ09TWF9ERVBMT1lNRU5UX1RBUkdFVD0kTUFDT1NYX0RFUExPWU1FTlRfVEFSR0VU
  CioqKgoqKiogUGxlYXNlIGVpdGhlciBzZXQgaXQgdG8gMTAuc29tZXRoaW5nLCBvciB0byBlbXB0
  eS4KCkVPTQogICAgICBleGl0IDEKICAgICAgOzsKICAgIGVzYWMKCiAgICAjIEtlZXAgdGhlIHBy
  b2R2ZXJzIGxlYWRpbmcgd2hpdGVzcGFjZSAoQ29uZmlndXJlIG1hZ2ljKS4KICAgICMgQ2Fubm90
  IHVzZSAkb3N2ZXJzIGhlcmUgc2luY2UgdGhhdCBpcyB0aGUga2VybmVsIHZlcnNpb24uCiAgICAj
  IHN3X3ZlcnMgb3V0cHV0ICAgICAgICAgICAgICAgICB3aGF0IHdlIHdhbnQKICAgICMgIlByb2R1
  Y3RWZXJzaW9uOiAgICAxMC4xMC41IiAgICIxMC4xMCIKICAgICMgIlByb2R1Y3RWZXJzaW9uOiAg
  ICAxMC4xMSIgICAgICIxMC4xMSIKICAgICAgICBwcm9kdmVycz1gc3dfdmVyc3xhd2sgJy9eUHJv
  ZHVjdFZlcnNpb246L3twcmludCAkMn0nfGF3ayAtRi4gJ3twcmludCAkMSIuIiQyfSdgCiAgICBj
  YXNlICIkcHJvZHZlcnMiIGluCiAgICAxMC4qKQogICAgICBhZGRfbWFjb3N4X3ZlcnNpb25fbWlu
  IGNjZmxhZ3MgJHByb2R2ZXJzCiAgICAgIGFkZF9tYWNvc3hfdmVyc2lvbl9taW4gbGRmbGFncyAk
  cHJvZHZlcnMKICAgICAgOzsKICAgICopCiAgICAgIGNhdCA8PEVPTSA+JjQKCioqKiBVbmV4cGVj
  dGVkIHByb2R1Y3QgdmVyc2lvbiAkcHJvZHZlcnMuCioqKgoqKiogVHJ5IHJ1bm5pbmcgc3dfdmVy
  cyBhbmQgc2VlIHdoYXQgaXRzIFByb2R1Y3RWZXJzaW9uIHNheXMuCgpFT00KICAgICAgZXhpdCAx
  CiAgICBlc2FjCgogICAgIyBUaGUgWCBpbiAxMC5YCiAgICBwcm9kdmVyc19taW5vcj0kKGVjaG8g
  JHByb2R2ZXJzfGF3ayAtRi4gJ3twcmludCAkMn0nKQoKICAgICMgbWFjT1MgKDEwLjEyKSBkZXBy
  ZWNhdGVkIHN5c2NhbGwoKS4KICAgIGlmIFsgIiRwcm9kdmVyc19taW5vciIgLWdlIDEyIF07IHRo
  ZW4KICAgICAgICBkX3N5c2NhbGw9J3VuZGVmJwogICAgZmkKCiAgIGxkZGxmbGFncz0iJHtsZGZs
  YWdzfSAtYnVuZGxlIC11bmRlZmluZWQgZHluYW1pY19sb29rdXAiCiAgIDs7CmVzYWMKCmxkbGli
  cHRobmFtZT0nRFlMRF9MSUJSQVJZX1BBVEgnOwoKIyB1c2VzaHJwbGliPXRydWUgcmVzdWx0cyBp
  biBtdWNoIHNsb3dlciBzdGFydHVwIHRpbWVzLgojICdmYWxzZScgaXMgdGhlIGRlZmF1bHQgdmFs
  dWUuICBVc2UgQ29uZmlndXJlIC1EdXNlc2hycGxpYiB0byBvdmVycmlkZS4KCmNhdCA+IFVVL2Fy
  Y2huYW1lLmNidSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS9hcmNobmFtZS5jYnUgd2lsbCBn
  ZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUgCiMgYWZ0ZXIgaXQgaGFzIG90aGVyd2lzZSBk
  ZXRlcm1pbmVkIHRoZSBhcmNoaXRlY3R1cmUgbmFtZS4KY2FzZSAiJGxkZmxhZ3MiIGluCioiLWZs
  YXRfbmFtZXNwYWNlIiopIDs7ICMgQmFja3dhcmQgY29tcGF0LCBiZSBmbGF0LgojIElmIHdlIGFy
  ZSB1c2luZyB0d28tbGV2ZWwgbmFtZXNwYWNlLCB3ZSB3aWxsIG11bmdlIHRoZSBhcmNobmFtZSB0
  byBzaG93IGl0LgoqKSBhcmNobmFtZT0iJHthcmNobmFtZX0tMmxldmVsIiA7Owplc2FjCkVPQ0JV
  CgojIDY0LWJpdCBhZGRyZXNzaW5nIHN1cHBvcnQuIEN1cnJlbnRseSBzdHJpY3RseSBleHBlcmlt
  ZW50YWwuIERGRCAyMDA1LTA2LTA2CmNhc2UgIiR1c2U2NGJpdGFsbCIgaW4KJGRlZmluZXx0cnVl
  fFt5WV0qKQpjYXNlICIkb3N2ZXJzIiBpbgpbMS03XS4qKQogICAgIGNhdCA8PEVPTSA+JjQKCgoK
  KioqIDY0LWJpdCBhZGRyZXNzaW5nIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE1hYyBPUyBYIHZlcnNp
  b25zCioqKiBiZWxvdyAxMC40ICgiVGlnZXIiKSBvciBEYXJ3aW4gdmVyc2lvbnMgYmVsb3cgOC4g
  UGxlYXNlIHRyeQoqKiogYWdhaW4gd2l0aG91dCAtRHVzZTY0Yml0YWxsLiAoLUR1c2U2NGJpdGlu
  dCB3aWxsIHdvcmssIGhvd2V2ZXIuKQoKRU9NCiAgICAgZXhpdCAxCiAgOzsKKikKICAgIGNhc2Ug
  IiRvc3ZlcnMiIGluCiAgICA4LiopCiAgICAgICAgY2F0IDw8RU9NID4mNAoKCgoqKiogUGVybCA2
  NC1iaXQgYWRkcmVzc2luZyBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbCBmb3IgTWFjIE9TIFgKKioq
  IDEwLjQgKCJUaWdlciIpIGFuZCBEYXJ3aW4gdmVyc2lvbiA4LiBTeXN0ZW0gViBJUEMgaXMgZGlz
  YWJsZWQKKioqIGR1ZSB0byBwcm9ibGVtcyB3aXRoIHRoZSA2NC1iaXQgdmVyc2lvbnMgb2YgbXNn
  Y3RsLCBzZW1jdGwsCioqKiBhbmQgc2htY3RsLiBZb3Ugc2hvdWxkIGFsc28gZXhwZWN0IHRoZSBm
  b2xsb3dpbmcgdGVzdCBmYWlsdXJlczoKKioqCioqKiAgICBleHQvdGhyZWFkcy1zaGFyZWQvdC93
  YWl0ICh0aHJlYWRlZCBidWlsZHMgb25seSkKCkVPTQoKICAgICAgICBbICIkZF9tc2djdGwiIF0g
  fHwgZF9tc2djdGw9J3VuZGVmJwogICAgICAgIFsgIiRkX3NlbWN0bCIgXSB8fCBkX3NlbWN0bD0n
  dW5kZWYnCiAgICAgICAgWyAiJGRfc2htY3RsIiBdIHx8IGRfc2htY3RsPSd1bmRlZicKICAgIDs7
  CiAgICBlc2FjCgogICAgY2FzZSBgdW5hbWUgLXBgIGluIAogICAgcG93ZXJwYykgYXJjaD1wcGM2
  NCA7OwogICAgaTM4NikgYXJjaD14ODZfNjQgOzsKICAgICopIGNhdCA8PEVPTSA+JjQKCioqKiBE
  b24ndCByZWNvZ25pemUgcHJvY2Vzc29yLCBjYW4ndCBzcGVjaWZ5IDY0IGJpdCBjb21waWxhdGlv
  bi4KCkVPTQogICAgOzsKICAgIGVzYWMKICAgIGZvciB2YXIgaW4gY2NmbGFncyBjcHBmbGFncyBs
  ZCBsZGZsYWdzCiAgICBkbwogICAgICAgZXZhbCAkdmFyPSJcJCR7dmFyfVwgLWFyY2hcICRhcmNo
  IgogICAgZG9uZQoKICAgIDs7CmVzYWMKOzsKZXNhYwoKIyMKIyBTeXN0ZW0gbGlicmFyaWVzCiMj
  CgojIHZmb3JrIHdvcmtzCnVzZXZmb3JrPSd0cnVlJzsKCiMgbWFsbG9jIHdyYXAgd29ya3MKY2Fz
  ZSAiJHVzZW1hbGxvY3dyYXAiIGluCicnKSB1c2VtYWxsb2N3cmFwPSdkZWZpbmUnIDs7CmVzYWMK
  CiMgb3VyIG1hbGxvYyB3b3JrcyAoYnV0IGFsbG93IHVzZXJzIHRvIG92ZXJyaWRlKQpjYXNlICIk
  dXNlbXltYWxsb2MiIGluCicnKSB1c2VteW1hbGxvYz0nbicgOzsKZXNhYwojIEhvd2V2ZXIgc2Jy
  aygpIHJldHVybnMgLTEgKGZhaWx1cmUpIHNvbWV3aGVyZSBpbiBsaWIvdW5pY29yZS9ta3RhYmxl
  cyBhdAojIGFyb3VuZCAxNE0sIHNvIHdlIG5lZWQgdG8gdXNlIHN5c3RlbSBtYWxsb2MoKSBhcyBv
  dXIgc2JyaygpCiMKIyBzYnJrKCkgaW4gRGFyd2luIGRlcHJlY2F0ZWQgc2luY2UgTWF2ZXJpY2tz
  ICgxMC45KSwgaXQgc3RpbGwgZXhpc3RzCiMgaW4gWW9zZW1pdGUgKDEwLjEwKSBidXQgdGhhdCBp
  cyBqdXN0IGFuIGVtdWxhdGlvbiwgYW5kIGZhaWxzIGZvcgojIGFsbG9jYXRpb25zIGJleW9uZCA0
  TUIuICBPbmUgc2hvdWxkIHVzZSBlLmcuIG1tYXAgaW5zdGVhZCAob3Igc3lzdGVtCiMgbWFsbG9j
  LCBhcyBzdWdnZXN0ZWQgYWJvdmUsIHRoYXQgYnV0IGlzIGtpbmQgb2YgYmFja3dhcmQpLgptYWxs
  b2NfY2ZsYWdzPSdjY2ZsYWdzPSItRFVTRV9QRVJMX1NCUksgLURQRVJMX1NCUktfVklBX01BTExP
  QyAkY2NmbGFncyInCgojIExvY2FsZXMgYXJlbid0IGZlZWxpbmcgd2VsbC4KTENfQUxMPUM7IGV4
  cG9ydCBMQ19BTEw7CkxBTkc9QzsgZXhwb3J0IExBTkc7CgojCiMgVGhlIGxpYnJhcmllcyBhcmUg
  bm90IHRocmVhZHNhZmUgYXMgb2YgT1MgWCAxMC4xLgojCiMgRml4IHdoZW4gQXBwbGUgZml4ZXMg
  bGliYy4KIwpjYXNlICIkdXNldGhyZWFkcyR1c2VpdGhyZWFkcyIgaW4KICAqZGVmaW5lKikKICBj
  YXNlICIkb3N2ZXJzIiBpbgogICAgWzEyMzQ1XS4qKSAgICAgY2F0IDw8RU9NID4mNAoKCgoqKiog
  V2FybmluZywgdGhlcmUgbWlnaHQgYmUgcHJvYmxlbXMgd2l0aCB5b3VyIGxpYnJhcmllcyB3aXRo
  CioqKiByZWdhcmRzIHRvIHRocmVhZGluZy4gIFRoZSB0ZXN0IGV4dC90aHJlYWRzL3QvbGliYy50
  IGlzIGxpa2VseQoqKiogdG8gZmFpbC4KCkVPTQogICAgOzsKICAgICopIHVzZXJlZW50cmFudD0n
  ZGVmaW5lJzs7CiAgZXNhYwoKZXNhYwoKIyBGaW5rIGNhbiBpbnN0YWxsIGEgR0RCTSBsaWJyYXJ5
  IHRoYXQgY2xhaW1zIHRvIGhhdmUgdGhlIE9EQk0gaW50ZXJmYWNlcwojIGJ1dCBQZXJsIGR5bmFs
  b2FkZXIgY2Fubm90IGZvciBzb21lIHJlYXNvbiB1c2UgdGhhdCBsaWJyYXJ5LiAgV2UgZG9uJ3QK
  IyByZWFsbHkgbmVlZCBPREJNX0ZJbGUsIHRob3VnaCwgc28gbGV0J3MganVzdCBoaW50IE9EQk0g
  YXdheS4KaV9kYm09dW5kZWY7CgojIENvbmZpZ3VyZSBkb2Vzbid0IGRldGVjdCByYW5saWIgb24g
  VGlnZXIgcHJvcGVybHkuCiMgTmVpbFcgc2F5cyB0aGlzIHNob3VsZCBiZSBhY2NlcHRhYmxlIG9u
  IGFsbCBkYXJ3aW4gdmVyc2lvbnMuCnJhbmxpYj0ncmFubGliJwoKIyBDYXRjaCBNYWNQb3J0cyBn
  Y2MvZysrIGV4dHJhIGxpYmRpcgpjYXNlICIkKCRjYyAtdiAyPiYxKSIgaW4KKiJNYWNQb3J0cyBn
  Y2MiKikgbG9jbGlicHRoPSIkbG9jbGlicHRoIC9vcHQvbG9jYWwvbGliL2xpYmdjYyIgOzsKZXNh
  YwoKIyMKIyBCdWlsZCBwcm9jZXNzCiMjCgojIENhc2UtaW5zZW5zaXRpdmUgZmlsZXN5c3RlbXMg
  ZG9uJ3QgZ2V0IGFsb25nIHdpdGggTWFrZWZpbGUgYW5kCiMgbWFrZWZpbGUgaW4gdGhlIHNhbWUg
  cGxhY2UuICBTaW5jZSBEYXJ3aW4gdXNlcyBHTlUgbWFrZSwgdGhpcyBkb2RnZXMKIyB0aGUgcHJv
  YmxlbS4KZmlyc3RtYWtlZmlsZT1HTlVtYWtlZmlsZTsKCiMgUGFydHMgb2YgdGhlIHN5c3RlbSBj
  YWxsIHNldGVudigpLCBpbiBwYXJ0aWN1bGFyIGluIGFuIGF0Zm9yayBoYW5kbGVyLgojIFRoaXMg
  Y2F1c2VzIHByb2JsZW1zIHdoZW4gdGhlIGNoaWxkIHRyaWVzIHRvIGNsZWFuIHVwIGVudmlyb25b
  XSwgc28KIyBsZXQgbGliYyBtYW5hZ2UgZW52aXJvbltdLgpjYXQgPj4gY29uZmlnLm92ZXIgPDwn
  RU9PVkVSJwppZiB0ZXN0ICIkZF91bnNldGVudiIgPSAiJGRlZmluZSIgLWEgXAogICAgYGV4cHIg
  IiRjY2ZsYWdzIiA6ICcuKi1EUEVSTF9VU0VfU0FGRV9QVVRFTlYnYCAtZXEgMDsgdGhlbgogICAg
  ICAgIGNjZmxhZ3M9IiRjY2ZsYWdzIC1EUEVSTF9VU0VfU0FGRV9QVVRFTlYiCmZpCkVPT1ZFUgo=','dragonfly'=>'IyBoaW50cy9kcmFnb25mbHkuc2gKIwojIFRoaXMgZmlsZSBpcyBtb3N0bHkgY29waWVkIGZyb20g
  aGludHMvZnJlZWJzZC5zaCB3aXRoIHRoZSBPUyB2ZXJzaW9uCiMgaW5mb3JtYXRpb24gdGFrZW4g
  b3V0IGFuZCBvbmx5IHRoZSBGcmVlQlNELTQgaW5mb3JtYXRpb24gaW50YWN0LgojIFBsZWFzZSBj
  aGVjayB3aXRoIFRvZGQgV2lsbGV5IDx4dG9kZHhAZ21haWwuY29tPiBiZWZvcmUgbWFraW5nCiMg
  bW9kaWZpY2F0aW9ucyB0byB0aGlzIGZpbGUuIFNlZSBodHRwOi8vd3d3LmRyYWdvbmZseWJzZC5v
  cmcvCgpjYXNlICIkb3N2ZXJzIiBpbgoqKSAgdXNldmZvcms9J3RydWUnCiAgICBjYXNlICIkdXNl
  bXltYWxsb2MiIGluCgkiIikgdXNlbXltYWxsb2M9J24nCgkgICAgOzsKICAgIGVzYWMKICAgIGxp
  YnN3YW50ZWQ9YGVjaG8gJGxpYnN3YW50ZWQgfCBzZWQgJ3MvIG1hbGxvYyAvIC8nYAogICAgOzsK
  ZXNhYwoKIyBEeW5hbWljIExvYWRpbmcgZmxhZ3MgaGF2ZSBub3QgY2hhbmdlZCBtdWNoLCBzbyB0
  aGV5IGFyZSBzZXBhcmF0ZWQKIyBvdXQgaGVyZSB0byBhdm9pZCBkdXBsaWNhdGluZyB0aGVtIGV2
  ZXJ5d2hlcmUuCmNhc2UgIiRvc3ZlcnMiIGluCiopICBvYmpmb3JtYXQ9YC91c3IvYmluL29iamZv
  cm1hdGAKICAgIGxpYnB0aD0iL3Vzci9saWIgL3Vzci9sb2NhbC9saWIiCiAgICBnbGlicHRoPSIv
  dXNyL2xpYiAvdXNyL2xvY2FsL2xpYiIKICAgIGxkZmxhZ3M9Ii1XbCwtRSAiCiAgICBsZGRsZmxh
  Z3M9Ii1zaGFyZWQgIgogICAgY2NjZGxmbGFncz0nLURQSUMgLWZQSUMnCiAgICA7Owplc2FjCgpj
  YXNlICIkb3N2ZXJzIiBpbgoqKSAgY2NmbGFncz0iJHtjY2ZsYWdzfSAtREhBU19GUFNFVE1BU0sg
  LURIQVNfRkxPQVRJTkdQT0lOVF9IIgogICAgaWYgL3Vzci9iaW4vZmlsZSAtTCAvdXNyL2xpYi9s
  aWJjLnNvIHwgL3Vzci9iaW4vZ3JlcCAtdnEgIm5vdCBzdHJpcHBlZCIgOyB0aGVuCgl1c2VubT1m
  YWxzZQogICAgZmkKICAgIDs7CmVzYWMKCmNhdCA8PCdFT00nID4mNAoKU29tZSB1c2VycyBoYXZl
  IHJlcG9ydGVkIHRoYXQgQ29uZmlndXJlIGhhbHRzIHdoZW4gdGVzdGluZyBmb3IKdGhlIE9fTk9O
  QkxPQ0sgc3ltYm9sIHdpdGggYSBzeW50YXggZXJyb3IuICBUaGlzIGlzIGFwcGFyZW50bHkgYQpz
  aCBlcnJvci4gIFJlcnVubmluZyBDb25maWd1cmUgd2l0aCBrc2ggYXBwYXJlbnRseSBmaXhlcyB0
  aGUKcHJvYmxlbS4gIFRyeQogICAgICAga3NoIENvbmZpZ3VyZSBbeW91ciBvcHRpb25zXQoKRU9N
  CgojIEZyb206IEFudG9uIEJlcmV6aW4gPHRvYmV6QHBsYWIua3UuZGs+CiMgVG86IHBlcmw1LXBv
  cnRlcnNAcGVybC5vcmcKIyBTdWJqZWN0OiBbUEFUQ0ggNS4wMDVfNTRdIENvbmZpZ3VyZSAtIGhp
  bnRzL2ZyZWVic2Quc2ggc2lnbmFsIGhhbmRsZXIgdHlwZQojIERhdGU6IDMwIE5vdiAxOTk4IDE5
  OjQ2OjI0ICswMTAwCiMgTWVzc2FnZS1JRDogPDg2NHNyaGh2Y3YuZnNmQGxpb24ucGxhYi5rdS5k
  az4KCnNpZ25hbF90PSd2b2lkJwpkX3ZvaWRzaWc9J2RlZmluZScKCiMgVGhpcyBzY3JpcHQgVVUv
  dXNldGhyZWFkcy5jYnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUKIyBhZnRl
  ciBpdCBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9yIHdoZXRoZXIgdG8gdXNlIHRocmVhZHMuCmNh
  dCA+IFVVL3VzZXRocmVhZHMuY2J1IDw8J0VPQ0JVJwpjYXNlICIkdXNldGhyZWFkcyIgaW4KJGRl
  ZmluZXx0cnVlfFt5WV0qKQogICAgY2FzZSAiJG9zdmVycyIgaW4KICAgICopICBsZGZsYWdzPSIt
  cHRocmVhZCAkbGRmbGFncyIKCgkjIEJvdGggaW4gNC54IGFuZCA1LnggZ2V0aG9zdGJ5YWRkcl9y
  IGV4aXN0cyBidXQKCSMgaXQgaXMgIlRlbXBvcmFyeSBmdW5jdGlvbiwgbm90IHRocmVhZHNhZmUi
  Li4uCgkjIFByZXN1bWFibHkgZWFybGllciBpdCBkaWRuJ3QgZXZlbiBleGlzdC4KCWRfZ2V0aG9z
  dGJ5YWRkcl9yPSJ1bmRlZiIKCWRfZ2V0aG9zdGJ5YWRkcl9yX3Byb3RvPSIwIgoKCTs7CiAgICBl
  c2FjCmVzYWMKRU9DQlUKCiMgbWFsbG9jIHdyYXAgd29ya3MKY2FzZSAiJHVzZW1hbGxvY3dyYXAi
  IGluCicnKSB1c2VtYWxsb2N3cmFwPSdkZWZpbmUnIDs7CmVzYWMK','freebsd'=>'IyBPcmlnaW5hbCBiYXNlZCBvbiBpbmZvIGZyb20KIyBDYXJsIE0uIEZvbmdoZWlzZXIgPGNtZkBp
  bnMuaW5mb25ldC5uZXQ+CiMgRGF0ZTogVGh1LCAyOCBKdWwgMTk5NCAxOToxNzowNSAtMDUwMCAo
  Q0RUKQojCiMgQWRkaXRpb25hbCAxLjEuNSBkZWZpbmVzIGZyb20gCiMgT2xsaXZpZXIgUm9iZXJ0
  IDxPbGxpdmllci5Sb2JlcnRAa2VsdGlhLmZybXVnLmZyLm5ldD4KIyBEYXRlOiBXZWQsIDI4IFNl
  cCAxOTk0IDAwOjM3OjQ2ICswMTAwIChNRVQpCiMKIyBBZGRpdGlvbmFsIDIuKiBkZWZpbmVzIGZy
  b20KIyBPbGxpdmllciBSb2JlcnQgPE9sbGl2aWVyLlJvYmVydEBrZWx0aWEuZnJtdWcuZnIubmV0
  PgojIERhdGU6IFNhdCwgOCBBcHIgMTk5NSAyMDo1Mzo0MSArMDIwMCAoTUVUIERTVCkKIwojIEFk
  ZGl0aW9uYWwgMi4wLjUgYW5kIDIuMSBkZWZpbmVkIGZyb20KIyBPbGxpdmllciBSb2JlcnQgPE9s
  bGl2aWVyLlJvYmVydEBrZWx0aWEuZnJtdWcuZnIubmV0PgojIERhdGU6IEZyaSwgMTIgTWF5IDE5
  OTUgMTQ6MzA6MzggKzAyMDAgKE1FVCBEU1QpCiMKIyBBZGRpdGlvbmFsIDIuMiBkZWZpbmVzIGZy
  b20KIyBNYXJrIE11cnJheSA8bWFya0Bncm9uZGFyLnphPgojIERhdGU6IFdlZCwgNiBOb3YgMTk5
  NiAwOTo0NDo1OCArMDIwMCAoTUVUKQojCiMgTW9kaWZpZWQgdG8gZW5zdXJlIHdlIHJlcGxhY2Ug
  LWxjIHdpdGggLWxjX3IsIGFuZAojIHRvIHB1dCBpbiBwbGFjZS1ob2xkZXJzIGZvciB2YXJpb3Vz
  IHNwZWNpZmljIGhpbnRzLgojIEFuZHkgRG91Z2hlcnR5IDxkb3VnaGVyYUBsYWZheWV0dGUuZWR1
  PgojIERhdGU6IFR1ZSBNYXIgMTAgMTY6MDc6MDAgRVNUIDE5OTgKIwojIFN1cHBvcnQgZm9yIEZy
  ZWVCU0QvRUxGCiMgT2xsaXZpZXIgUm9iZXJ0IDxyb2JlcnRvQGtlbHRpYS5mcmVlbml4LmZyPgoj
  IERhdGU6IFdlZCBTZXAgIDIgMTY6MjI6MTIgQ0VTVCAxOTk4CiMKIyBUaGUgdHdvIGZsYWdzICIt
  ZnBpYyAtRFBJQyIgYXJlIHVzZWQgdG8gaW5kaWNhdGUgYQojIHdpbGwtYmUtc2hhcmVkIG9iamVj
  dC4gIENvbmZpZ3VyZSB3aWxsIGd1ZXNzIHRoZSAtZnBpYywgKGFuZCB0aGUKIyAtRFBJQyBpcyBu
  b3QgdXNlZCBieSBwZXJsIHByb3BlcikgYnV0IHRoZSBmdWxsIGRlZmluZSBpcyBpbmNsdWRlZCB0
  byAKIyBiZSBjb25zaXN0ZW50IHdpdGggdGhlIEZyZWVCU0QgZ2VuZXJhbCBzaGFyZWQgbGlicyBi
  dWlsZGluZyBwcm9jZXNzLgojCiMgc2V0cmV1aWQgYW5kIGZyaWVuZHMgYXJlIGluaGVyZW50bHkg
  YnJva2VuIGluIGFsbCB2ZXJzaW9ucyBvZiBGcmVlQlNECiMgYmVmb3JlIDIuMS1jdXJyZW50IChi
  ZWZvcmUgYXBwcm94IGRhdGUgNC8xNS85NSkuIEl0IGlzIGZpeGVkIGluIDIuMC41CiMgYW5kIHdo
  YXQtd2lsbC1iZS0yLjEKIwoKY2FzZSAiJG9zdmVycyIgaW4KMC4qfDEuMCopCgl1c2VkbD0iJHVu
  ZGVmIgoJOzsKMS4xKikKCW1hbGxvY3R5cGU9J3ZvaWQgKicKCWdyb3Vwc3R5cGU9J2ludCcKCWRf
  c2V0cmVnaWQ9J3VuZGVmJwoJZF9zZXRyZXVpZD0ndW5kZWYnCglkX3NldHJnaWQ9J3VuZGVmJwoJ
  ZF9zZXRydWlkPSd1bmRlZicKCTs7CjIuMC1yZWxlYXNlKikKCWRfc2V0cmVnaWQ9J3VuZGVmJwoJ
  ZF9zZXRyZXVpZD0ndW5kZWYnCglkX3NldHJnaWQ9J3VuZGVmJwoJZF9zZXRydWlkPSd1bmRlZicK
  CTs7CiMKIyBUcnlpbmcgdG8gY292ZXIgMi4wLjUsIDIuMS1jdXJyZW50IGFuZCBmdXR1cmUgMi4x
  LzIuMgojIEl0IGRvZXMgbm90IGNvdmVydCBhbGwgMi4xLWN1cnJlbnQgdmVyc2lvbnMgYXMgdGhl
  IG91dHB1dCBvZiB1bmFtZQojIGNoYW5nZWQgYSBmZXcgdGltZXMuCiMKIyBFdmVuIHRob3VnaCBz
  ZXRldWlkL3NldGVnaWQgYXJlIGF2YWlsYWJsZSwgdGhleSd2ZSBiZWVuIHR1cm5lZCBvZmYKIyBi
  ZWNhdXNlIHBlcmwgaXNuJ3QgY29kZWQgd2l0aCBzYXZlZCBzZXRbdWddaWQgdmFyaWFibGVzIGlu
  IG1pbmQuCiMgSW4gYWRkaXRpb24sIGEgc21hbGwgcGF0Y2ggaXMgcmVxdWlyZWQgdG8gc3VpZHBl
  cmwgdG8gYXZvaWQgYSBzZWN1cml0eQojIHByb2JsZW0gd2l0aCBGcmVlQlNELgojCjIuMC41Knwy
  LjAtYnVpbHQqfDIuMSopCiAJdXNldmZvcms9J3RydWUnCgljYXNlICIkdXNlbXltYWxsb2MiIGlu
  CgkgICAgIiIpIHVzZW15bWFsbG9jPSduJwoJICAgICAgICA7OwoJZXNhYwoJZF9zZXRyZWdpZD0n
  ZGVmaW5lJwoJZF9zZXRyZXVpZD0nZGVmaW5lJwoJZF9zZXRlZ2lkPSd1bmRlZicKCWRfc2V0ZXVp
  ZD0ndW5kZWYnCgl0ZXN0IC1yIC4vYnJva2VuLWRiLm1zZyAmJiAuIC4vYnJva2VuLWRiLm1zZwoJ
  OzsKIwojIDIuMiBhbmQgYWJvdmUgaGF2ZSBwaGttYWxsb2MoMykuCiMgZG9uJ3QgdXNlIC1sbWFs
  bG9jIChtYXliZSB0aGVyZSdzIGFuIG9sZCBvbmUgZnJvbSAxLjEuNS4xIGZsb2F0aW5nIGFyb3Vu
  ZCkKMi4yKikKIAl1c2V2Zm9yaz0ndHJ1ZScKCWNhc2UgIiR1c2VteW1hbGxvYyIgaW4KCSAgICAi
  IikgdXNlbXltYWxsb2M9J24nCgkgICAgICAgIDs7Cgllc2FjCglsaWJzd2FudGVkPWBlY2hvICRs
  aWJzd2FudGVkIHwgc2VkICdzLyBtYWxsb2MgLyAvJ2AKCWxpYnN3YW50ZWQ9YGVjaG8gJGxpYnN3
  YW50ZWQgfCBzZWQgJ3MvIGJpbmQgLyAvJ2AKCSMgaWNvbnYgZ29uZSBpbiBQZXJsIDUuOC4xLCBi
  dXQgaWYgc29tZW9uZSBjb21waWxlcyA1LjguMCBvciBlYXJsaWVyLgoJbGlic3dhbnRlZD1gZWNo
  byAkbGlic3dhbnRlZCB8IHNlZCAncy8gaWNvbnYgLyAvJ2AKCWRfc2V0cmVnaWQ9J2RlZmluZScK
  CWRfc2V0cmV1aWQ9J2RlZmluZScKCWRfc2V0ZWdpZD0nZGVmaW5lJwoJZF9zZXRldWlkPSdkZWZp
  bmUnCgkjIGRfZG9zdWlkPSdkZWZpbmUnICMgT2Jzb2xldGUuCgk7OwoqKQl1c2V2Zm9yaz0ndHJ1
  ZScKCWNhc2UgIiR1c2VteW1hbGxvYyIgaW4KCSAgICAiIikgdXNlbXltYWxsb2M9J24nCgkgICAg
  ICAgIDs7Cgllc2FjCglsaWJzd2FudGVkPWBlY2hvICRsaWJzd2FudGVkIHwgc2VkICdzLyBtYWxs
  b2MgLyAvJ2AKCTs7CmVzYWMKCmNhc2UgIiRvc3ZlcnMiIGluCjEwLiopCgkjIGR0cmFjZSBvbiAx
  MC54IG5lZWRzIGxpYmVsZiBzeW1ib2xzLCBidXQgd2UgZG9uJ3Qga25vdyBpZiB0aGUKCSMgdXNl
  ciBpcyBnb2luZyB0byByZXF1ZXN0IHVzZWR0cmFjZSBhbmQgdGhlcmUncyBubyAuY2J1IGZvciB1
  c2VkdHJhY2UKCWxpYnN3YW50ZWQ9IiRsaWJzd2FudGVkIGVsZiIKCTs7CmVzYWMKCiMgRHluYW1p
  YyBMb2FkaW5nIGZsYWdzIGhhdmUgbm90IGNoYW5nZWQgbXVjaCwgc28gdGhleSBhcmUgc2VwYXJh
  dGVkCiMgb3V0IGhlcmUgdG8gYXZvaWQgZHVwbGljYXRpbmcgdGhlbSBldmVyeXdoZXJlLgpjYXNl
  ICIkb3N2ZXJzIiBpbgowLip8MS4wKikgOzsKCjEuKnwyLiopCgljY2NkbGZsYWdzPSctRFBJQyAt
  ZnBpYycKCWxkZGxmbGFncz0iLUJzaGFyZWFibGUgJGxkZGxmbGFncyIKCTs7CgozKnw0Knw1Knw2
  KikKICAgICAgICBvYmpmb3JtYXQ9YC91c3IvYmluL29iamZvcm1hdGAKICAgICAgICBpZiBbIHgk
  b2JqZm9ybWF0ID0geGFvdXQgXTsgdGhlbgogICAgICAgICAgICBpZiBbIC1lIC91c3IvbGliL2Fv
  dXQgXTsgdGhlbgogICAgICAgICAgICAgICAgbGlicHRoPSIvdXNyL2xpYi9hb3V0IC91c3IvbG9j
  YWwvbGliIC91c3IvbGliIgogICAgICAgICAgICAgICAgZ2xpYnB0aD0iL3Vzci9saWIvYW91dCAv
  dXNyL2xvY2FsL2xpYiAvdXNyL2xpYiIKICAgICAgICAgICAgZmkKICAgICAgICAgICAgbGRkbGZs
  YWdzPSctQnNoYXJlYWJsZScKICAgICAgICBlbHNlCiAgICAgICAgICAgIGxpYnB0aD0iL3Vzci9s
  aWIgL3Vzci9sb2NhbC9saWIiCiAgICAgICAgICAgIGdsaWJwdGg9Ii91c3IvbGliIC91c3IvbG9j
  YWwvbGliIgogICAgICAgICAgICBsZGZsYWdzPSItV2wsLUUgIgogICAgICAgICAgICBsZGRsZmxh
  Z3M9Ii1zaGFyZWQgIgogICAgICAgIGZpCiAgICAgICAgY2NjZGxmbGFncz0nLURQSUMgLWZQSUMn
  CiAgICAgICAgOzsKKikKICAgICAgIGxpYnB0aD0iL3Vzci9saWIgL3Vzci9sb2NhbC9saWIiCiAg
  ICAgICBnbGlicHRoPSIvdXNyL2xpYiAvdXNyL2xvY2FsL2xpYiIKICAgICAgIGxkZmxhZ3M9Ii1X
  bCwtRSAiCiAgICAgICAgbGRkbGZsYWdzPSItc2hhcmVkICIKICAgICAgICBjY2NkbGZsYWdzPSct
  RFBJQyAtZlBJQycKICAgICAgIDs7CmVzYWMKCmNhc2UgIiRvc3ZlcnMiIGluCjAuKnwxLip8Mi4q
  fDMuKikgOzsKCiopCgljY2ZsYWdzPSIke2NjZmxhZ3N9IC1ESEFTX0ZQU0VUTUFTSyAtREhBU19G
  TE9BVElOR1BPSU5UX0giCglpZiAvdXNyL2Jpbi9maWxlIC1MIC91c3IvbGliL2xpYmMuc28gfCAv
  dXNyL2Jpbi9ncmVwIC12cSAibm90IHN0cmlwcGVkIiA7IHRoZW4KCSAgICB1c2VubT1mYWxzZQoJ
  ZmkKICAgICAgICA7Owplc2FjCgpjYXQgPDwnRU9NJyA+JjQKClNvbWUgdXNlcnMgaGF2ZSByZXBv
  cnRlZCB0aGF0IENvbmZpZ3VyZSBoYWx0cyB3aGVuIHRlc3RpbmcgZm9yCnRoZSBPX05PTkJMT0NL
  IHN5bWJvbCB3aXRoIGEgc3ludGF4IGVycm9yLiAgVGhpcyBpcyBhcHBhcmVudGx5IGEKc2ggZXJy
  b3IuICBSZXJ1bm5pbmcgQ29uZmlndXJlIHdpdGgga3NoIGFwcGFyZW50bHkgZml4ZXMgdGhlCnBy
  b2JsZW0uICBUcnkKCWtzaCBDb25maWd1cmUgW3lvdXIgb3B0aW9uc10KCkVPTQoKIyBGcm9tOiBB
  bnRvbiBCZXJlemluIDx0b2JlekBwbGFiLmt1LmRrPgojIFRvOiBwZXJsNS1wb3J0ZXJzQHBlcmwu
  b3JnCiMgU3ViamVjdDogW1BBVENIIDUuMDA1XzU0XSBDb25maWd1cmUgLSBoaW50cy9mcmVlYnNk
  LnNoIHNpZ25hbCBoYW5kbGVyIHR5cGUKIyBEYXRlOiAzMCBOb3YgMTk5OCAxOTo0NjoyNCArMDEw
  MAojIE1lc3NhZ2UtSUQ6IDw4NjRzcmhodmN2LmZzZkBsaW9uLnBsYWIua3UuZGs+CgpzaWduYWxf
  dD0ndm9pZCcKZF92b2lkc2lnPSdkZWZpbmUnCgojIHNldCBsaWJwZXJsLnNvLlguWCBmb3IgMi4y
  LlgKY2FzZSAiJG9zdmVycyIgaW4KMi4yKikKICAgICMgdW5mb3J0dW5hdGVseSB0aGlzIGNvZGUg
  Z2V0cyBleGVjdXRlZCBiZWZvcmUKICAgICMgdGhlIGVxdWl2YWxlbnQgaW4gdGhlIG1haW4gQ29u
  ZmlndXJlIHNvIHdlIGNvcHkgYSBsaXR0bGUKICAgICMgZnJvbSBDb25maWd1cmUgWFhYIENvbmZp
  Z3VyZSBzaG91bGQgYmUgZml4ZWQuCiAgICBpZiAkdGVzdCAtciAkc3JjL3BhdGNobGV2ZWwuaDt0
  aGVuCiAgICAgICBwYXRjaGxldmVsPWBhd2sgJy9kZWZpbmVbIAldK1BFUkxfVkVSU0lPTi8ge3By
  aW50ICQzfScgJHNyYy9wYXRjaGxldmVsLmhgCiAgICAgICBzdWJ2ZXJzaW9uPWBhd2sgJy9kZWZp
  bmVbIAldK1BFUkxfU1VCVkVSU0lPTi8ge3ByaW50ICQzfScgJHNyYy9wYXRjaGxldmVsLmhgCiAg
  ICBlbHNlCiAgICAgICBwYXRjaGxldmVsPTAKICAgICAgIHN1YnZlcnNpb249MAogICAgZmkKICAg
  IGxpYnBlcmw9ImxpYnBlcmwuc28uJHBhdGNobGV2ZWwuJHN1YnZlcnNpb24iCiAgICB1bnNldCBw
  YXRjaGxldmVsCiAgICB1bnNldCBzdWJ2ZXJzaW9uCiAgICA7Owplc2FjCgojIFRoaXMgc2NyaXB0
  IFVVL3VzZXRocmVhZHMuY2J1IHdpbGwgZ2V0ICdjYWxsZWQtYmFjaycgYnkgQ29uZmlndXJlIAoj
  IGFmdGVyIGl0IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgdGhyZWFk
  cy4KY2F0ID4gVVUvdXNldGhyZWFkcy5jYnUgPDwnRU9DQlUnCmNhc2UgIiR1c2V0aHJlYWRzIiBp
  bgokZGVmaW5lfHRydWV8W3lZXSopCiAgICAgICAgbGNfcj1gL3NiaW4vbGRjb25maWcgLXJ8Z3Jl
  cCAnOi1sY19yJ3xhd2sgJ3twcmludCAkTkZ9J3xzZWQgLW4gJyRwJ2AKICAgICAgICBjYXNlICIk
  b3N2ZXJzIiBpbiAgCgkwLip8MS4qfDIuMCp8Mi4xKikgICBjYXQgPDxFT00gPiY0CkkgZGlkIG5v
  dCBrbm93IHRoYXQgRnJlZUJTRCAkb3N2ZXJzIHN1cHBvcnRzIFBPU0lYIHRocmVhZHMuCgpGZWVs
  IGZyZWUgdG8gdGVsbCBwZXJsYnVnQHBlcmwub3JnIG90aGVyd2lzZS4KRU9NCgkgICAgICBleGl0
  IDEKCSAgICAgIDs7CgogICAgICAgIDIuMi5bMC03XSopCiAgICAgICAgICAgICAgY2F0IDw8RU9N
  ID4mNApQT1NJWCB0aHJlYWRzIGFyZSBub3Qgc3VwcG9ydGVkIHdlbGwgYnkgRnJlZUJTRCAkb3N2
  ZXJzLgoKUGxlYXNlIGNvbnNpZGVyIHVwZ3JhZGluZyB0byBhdCBsZWFzdCBGcmVlQlNEIDIuMi44
  LApvciBwcmVmZXJhYmx5IHRvIHRoZSBtb3N0IHJlY2VudCAtUkVMRUFTRSBvciAtU1RBQkxFCnZl
  cnNpb24gKHNlZSBodHRwOi8vd3d3LmZyZWVic2Qub3JnL3JlbGVhc2VzLykuCgooV2hpbGUgMi4y
  LjcgZG9lcyBoYXZlIHB0aHJlYWRzLCBpdCBoYXMgc29tZSBwcm9ibGVtcwogd2l0aCB0aGUgY29t
  YmluYXRpb24gb2YgdGhyZWFkcyBhbmQgcGlwZXMgYW5kIHRoZXJlZm9yZQogbWFueSBQZXJsIHRl
  c3RzIHdpbGwgZWl0aGVyIGhhbmcgb3IgZmFpbC4pCkVPTQoJICAgICAgZXhpdCAxCgkgICAgICA7
  OwoKCVszLTVdLiopCgkgICAgICBpZiBbICEgLXIgIiRsY19yIiBdOyB0aGVuCgkgICAgICBjYXQg
  PDxFT00gPiY0ClBPU0lYIHRocmVhZHMgc2hvdWxkIGJlIHN1cHBvcnRlZCBieSBGcmVlQlNEICRv
  c3ZlcnMgLS0KYnV0IHlvdXIgc3lzdGVtIGlzIG1pc3NpbmcgdGhlIHNoYXJlZCBsaWJjX3IuCigv
  c2Jpbi9sZGNvbmZpZyAtciBkb2Vzbid0IGZpbmQgYW55KS4KCkNvbnNpZGVyIHVzaW5nIHRoZSBs
  YXRlc3QgU1RBQkxFIHJlbGVhc2UuCkVPTQoJCSBleGl0IDEKCSAgICAgIGZpCgkgICAgICAjIDUw
  MDAxNiBpcyB0aGUgZmlyc3Qgb3NyZWxkYXRlIGluIHdoaWNoIG9uZSBjb3VsZAoJICAgICAgIyBq
  dXN0IGxpbmsgYWdhaW5zdCBsaWJjX3Igd2l0aG91dCBkaXNwb3Npbmcgb2YgbGliYwoJICAgICAg
  IyBhdCB0aGUgc2FtZSB0aW1lLiAgNTAwMDE2IC4uLiB1cCB0byB3aGF0ZXZlciBpdCB3YXMKCSAg
  ICAgICMgb24gdGhlIDMxc3Qgb2YgQXVndXN0IDIwMDMgY2FuIHN0aWxsIGJlIHVzZWQgd2l0aCAt
  cHRocmVhZCwKCSAgICAgICMgYnV0IGl0IGlzIG5vdCBuZWNlc3NhcnkuCgoJICAgICAgIyBBbnRv
  biBCZXJlemluIHNheXMgdGhhdCBwb3N0IDUwMHNvbWV0aGluZyB3ZSdyZSB3cm9uZyB0byBiZQoJ
  ICAgICAgIyB0byBiZSB1c2luZyAtbGNfciwgYW5kIHNob3VsZCBqdXN0IGJlIHVzaW5nIC1wdGhy
  ZWFkIG9uIHRoZQoJICAgICAgIyBsaW5rZXIgbGluZS4KCSAgICAgICMgU28gcHJlc3VtYWJseSBy
  ZWFsbHkgd2Ugc2hvdWxkIGJlIGNoZWNraW5nIHRoYXQgJG9zdmVyIGlzIDUuKikKCSAgICAgICMg
  YW5kIHRoYXQgYC9zYmluL3N5c2N0bCAtbiBrZXJuLm9zcmVsZGF0ZWAgLWdlIDUwMDAxNgoJICAg
  ICAgIyBvciAtbHQgNTAwc29tZXRoaW5nIGFuZCBvbmx5IGluIHRoYXQgcmFuZ2Ugbm90IGRvaW5n
  IHRoaXM6CgkgICAgICBsZGZsYWdzPSItcHRocmVhZCAkbGRmbGFncyIKCgkgICAgICAjIEJvdGgg
  aW4gNC54IGFuZCA1LnggZ2V0aG9zdGJ5YWRkcl9yIGV4aXN0cyBidXQKCSAgICAgICMgaXQgaXMg
  IlRlbXBvcmFyeSBmdW5jdGlvbiwgbm90IHRocmVhZHNhZmUiLi4uCgkgICAgICAjIFByZXN1bWFi
  bHkgZWFybGllciBpdCBkaWRuJ3QgZXZlbiBleGlzdC4KCSAgICAgIGRfZ2V0aG9zdGJ5YWRkcl9y
  PSJ1bmRlZiIKCSAgICAgIGRfZ2V0aG9zdGJ5YWRkcl9yX3Byb3RvPSIwIgoJICAgICAgOzsKCgkq
  KQoJICAgICAgIyA3LnggZG9lc24ndCBpbnN0YWxsIGxpYmNfciBieSBkZWZhdWx0LCBhbmQgQ29u
  ZmlndXJlCgkgICAgICAjIHdvdWxkIGZhaWwgaW4gdGhlIGNvZGUgZm9sbG93aW5nCgkgICAgICAj
  CgkgICAgICAjIGdldGhvc3RieWFkZHJfcigpIGFwcGVhcnMgdG8gaGF2ZSBiZWVuIGltcGxlbWVu
  dGVkIGluIDYueCsKCSAgICAgIGxkZmxhZ3M9Ii1wdGhyZWFkICRsZGZsYWdzIgoJICAgICAgOzsK
  Cgllc2FjCgogICAgICAgIGNhc2UgIiRvc3ZlcnMiIGluCiAgICAgICAgWzEtNF0qKQoJICAgIHNl
  dCBgZWNobyBYICIkbGlic3dhbnRlZCAifCBzZWQgLWUgJ3MvIGMgLyBjX3IgLydgCgkgICAgc2hp
  ZnQKCSAgICBsaWJzd2FudGVkPSIkKiIKCSAgICA7OwogICAgICAgICopCgkgICAgc2V0IGBlY2hv
  IFggIiRsaWJzd2FudGVkICJ8IHNlZCAtZSAncy8gYyAvLydgCgkgICAgc2hpZnQKCSAgICBsaWJz
  d2FudGVkPSIkKiIKCSAgICA7OwoJZXNhYwoJICAgIAoJIyBDb25maWd1cmUgd2lsbCBwcm9iYWJs
  eSBwaWNrIHRoZSB3cm9uZyBsaWJjIHRvIHVzZSBmb3Igbm0gc2Nhbi4KCSMgVGhlIHNhZmVzdCBx
  dWljay1maXggaXMganVzdCB0byBub3QgdXNlIG5tIGF0IGFsbC4uLgoJdXNlbm09ZmFsc2UKCiAg
  ICAgICAgY2FzZSAiJG9zdmVycyIgaW4KICAgICAgICAyLjIuOCopCiAgICAgICAgICAgICMgLi4u
  IGJ1dCB0aGlzIGRvZXMgbm90IGFwcGx5IGZvciAyLjIuOCAtIHdlIGtub3cgaXQncyBzYWZlCiAg
  ICAgICAgICAgIGxpYmM9IiRsY19yIgogICAgICAgICAgICB1c2VubT10cnVlCiAgICAgICAgICAg
  OzsKICAgICAgICBlc2FjCgogICAgICAgIHVuc2V0IGxjX3IKCgkjIEV2ZW4gd2l0aCB0aGUgbWFs
  bG9jIG11dGV4ZXMgdGhlIFBlcmwgbWFsbG9jIGRvZXMgbm90CgkjIHNlZW0gdG8gYmUgdGhyZWFk
  c2FmZSBpbiBGcmVlQlNEPwoJY2FzZSAiJHVzZW15bWFsbG9jIiBpbgoJJycpIHVzZW15bWFsbG9j
  PW4gOzsKCWVzYWMKZXNhYwpFT0NCVQoKIyBtYWxsb2Mgd3JhcCB3b3JrcwpjYXNlICIkdXNlbWFs
  bG9jd3JhcCIgaW4KJycpIHVzZW1hbGxvY3dyYXA9J2RlZmluZScgOzsKZXNhYwoKIyBYWFggVW5k
  ZXIgRnJlZUJTRCA2LjAgKGFuZCBwcm9iYWJseSBtb3N0IG90aGVyIHNpbWlsYXIgdmVyc2lvbnMp
  CiMgUGVybF9kaWUoTlVMTCkgZ2VuZXJhdGVzIGEgd2FybmluZzoKIyAgICBwcF9zeXMuYzo0OTE6
  IHdhcm5pbmc6IG51bGwgZm9ybWF0IHN0cmluZwojIENvbmZpZ3VyZSBzdXBwb3NlZGx5IHRlc3Rz
  IGZvciB0aGlzLCBidXQgYXBwYXJlbnRseSB0aGUgdGVzdCBkb2Vzbid0CiMgd29yay4gIFZvbHVu
  dGVlcnMgd2l0aCBGcmVlQlNEIGFyZSBuZWVkZWQgdG8gaW1wcm92aW5nIHRoZSBDb25maWd1cmUg
  dGVzdC4KIyBNZWFud2hpbGUsIHRoZSBmb2xsb3dpbmcgd29ya2Fyb3VuZCBzaG91bGQgYmUgc2Fm
  ZSBvbiBhbGwgdmVyc2lvbnMKIyBvZiBGcmVlQlNELgpkX3ByaW50Zl9mb3JtYXRfbnVsbD0ndW5k
  ZWYnCgojIEFzIG9mIDEwLjMtUkVMRUFTRSBGcmVlQlNELiAgU2VlIFtwZXJsICMxMjg4NjddCmRf
  dXNlbG9jYWxlPSd1bmRlZicK','gnu'=>'IyBoaW50cy9nbnUuc2gKIyBPcmlnaW5hbGx5IGNvbnRyaWJ1dGVkIGJ5OiAgTWFyayBLZXR0ZW5p
  cyA8a2V0dGVuaXNAcGh5cy51dmEubmw+IERlYyAxMCAxOTk4CgojIGxpYm5zbCBpcyB1bnVzYWJs
  ZSBvbiB0aGUgSHVyZC4KIyBYWFggcmVtb3ZlIHRoaXMgb25jZSBTVU5SUEMgaXMgaW1wbGVtZW50
  ZWQuCnNldCBgZWNobyBYICIkbGlic3dhbnRlZCAifCBzZWQgLWUgJ3MvIGJzZCAvIC8nIC1lICdz
  LyBuc2wgLyAvJyAtZSAncy8gYyAvIHB0aHJlYWQgLydgCnNoaWZ0CmxpYnN3YW50ZWQ9IiQqIgoK
  IyBEZWJpYW4gNC4wIHB1dHMgbmRibSBpbiB0aGUgLWxnZGJtX2NvbXBhdCBsaWJyYXJ5LgpsaWJz
  d2FudGVkPSIkbGlic3dhbnRlZCBnZGJtX2NvbXBhdCIKCiMgbWFsbG9jIHdyYXAgd29ya3MKY2Fz
  ZSAiJHVzZW1hbGxvY3dyYXAiIGluCicnKSB1c2VtYWxsb2N3cmFwPSdkZWZpbmUnIDs7CmVzYWMK
  CiMgVGhlIHN5c3RlbSBtYWxsb2MoKSBpcyBhYm91dCBhcyBmYXN0IGFuZCBhcyBmcnVnYWwgYXMg
  cGVybCdzLgojIFNpbmNlIHRoZSBzeXN0ZW0gbWFsbG9jKCkgaGFzIGJlZW4gdGhlIGRlZmF1bHQg
  c2luY2UgYXQgbGVhc3QKIyA1LjAwMSwgd2UgbWlnaHQgYXMgd2VsbCBsZWF2ZSBpdCB0aGF0IHdh
  eS4gIC0tQUQgIDEwIEphbiAyMDAyCmNhc2UgIiR1c2VteW1hbGxvYyIgaW4KJycpIHVzZW15bWFs
  bG9jPSduJyA7Owplc2FjCgpjYXNlICIkb3B0aW1pemUiIGluCicnKSBvcHRpbWl6ZT0nLU8yJyA7
  Owplc2FjCgpjYXNlICIkcGxpYnB0aCIgaW4KJycpIHBsaWJwdGg9YGdjYyAtcHJpbnQtc2VhcmNo
  LWRpcnMgfCBncmVwIGxpYnJhcmllcyB8CiAgICAgICAgY3V0IC1mMi0gLWQ9IHwgdHIgJzonICR0
  cm5sIHwgZ3JlcCAtdiAnZ2NjJyB8IHNlZCAtZSAnczovJDo6J2AKICAgIHNldCBYICRwbGlicHRo
  ICMgQ29sbGFwc2UgYWxsIGVudHJpZXMgb24gb25lIGxpbmUKICAgIHNoaWZ0CiAgICBwbGlicHRo
  PSIkKiIKICAgIDs7CmVzYWMKCmNhc2UgIiRsaWJjIiBpbgonJykKIyBJZiB5b3UgaGF2ZSBnbGli
  YywgdGhlbiByZXBvcnQgdGhlIHZlcnNpb24gZm9yIC4vbXljb25maWcgYnVnIHJlcG9ydGluZy4K
  IyAoQ29uZmlndXJlIGRvZXNuJ3QgbmVlZCB0byBrbm93IHRoZSBzcGVjaWZpYyB2ZXJzaW9uIHNp
  bmNlIGl0IGp1c3QgdXNlcwojIGdjYyB0byBsb2FkIHRoZSBsaWJyYXJ5IGZvciBhbGwgdGVzdHMu
  KQojIFdlIGRvbid0IHVzZSBfX0dMSUJDX18gYW5kICBfX0dMSUJDX01JTk9SX18gYmVjYXVzZSB0
  aGV5CiMgYXJlIGluc3VmZmljaWVudGx5IHByZWNpc2UgdG8gZGlzdGluZ3Vpc2ggdGhpbmdzIGxp
  a2UKIyBsaWJjLTIuMC42IGFuZCBsaWJjLTIuMC43LgogICAgZm9yIHAgaW4gJHBsaWJwdGgKICAg
  IGRvCiAgICAgICAgZm9yIHRyeWxpYiBpbiBsaWJjLnNvLjAuMyBsaWJjLnNvCiAgICAgICAgZG8K
  ICAgICAgICAgICAgaWYgJHRlc3QgLWUgJHAvJHRyeWxpYjsgdGhlbgogICAgICAgICAgICAgICAg
  bGliYz1gbHMgLWwgJHAvJHRyeWxpYiB8IGF3ayAne3ByaW50ICRORn0nYAogICAgICAgICAgICAg
  ICAgaWYgJHRlc3QgIlgkbGliYyIgIT0gWDsgdGhlbgogICAgICAgICAgICAgICAgICAgIGJyZWFr
  CiAgICAgICAgICAgICAgICBmaQogICAgICAgICAgICBmaQogICAgICAgIGRvbmUKICAgICAgICBp
  ZiAkdGVzdCAiWCRsaWJjIiAhPSBYOyB0aGVuCiAgICAgICAgICAgIGJyZWFrCiAgICAgICAgZmkK
  ICAgIGRvbmUKICAgIDs7CmVzYWMKCiMgRmxhZ3MgbmVlZGVkIHRvIHByb2R1Y2Ugc2hhcmVkIGxp
  YnJhcmllcy4KbGRkbGZsYWdzPSctc2hhcmVkJwoKIyBGbGFncyBuZWVkZWQgYnkgcHJvZ3JhbXMg
  dGhhdCB1c2UgZHluYW1pYyBsaW5raW5nLgpjY2RsZmxhZ3M9Jy1XbCwtRScKCiMgVGhpcyBzY3Jp
  cHQgVVUvdXNldGhyZWFkcy5jYnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUK
  IyBhZnRlciBpdCBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9yIHdoZXRoZXIgdG8gdXNlIHRocmVh
  ZHMuCmNhdCA+IFVVL3VzZXRocmVhZHMuY2J1IDw8J0VPQ0JVJwpjYXNlICIkdXNldGhyZWFkcyIg
  aW4KJGRlZmluZXx0cnVlfFt5WV0qKQogICAgICAgIGNjZmxhZ3M9Ii1EX1JFRU5UUkFOVCAtRF9H
  TlVfU09VUkNFICRjY2ZsYWdzIgogICAgICAgIGlmIGVjaG8gJGxpYnN3YW50ZWQgfCBncmVwIC12
  IHB0aHJlYWQgPi9kZXYvbnVsbAogICAgICAgIHRoZW4KICAgICAgICAgICAgc2V0IGBlY2hvIFgg
  IiRsaWJzd2FudGVkICJ8IHNlZCAtZSAncy8gYyAvIHB0aHJlYWQgYyAvJ2AKICAgICAgICAgICAg
  c2hpZnQKICAgICAgICAgICAgbGlic3dhbnRlZD0iJCoiCiAgICAgICAgZmkKCgkjIFNvbWVob3cg
  YXQgbGVhc3QgaW4gRGViaWFuIDIuMiB0aGVzZSBtYW5hZ2UgdG8gZXNjYXBlCgkjIHRoZSAjZGVm
  aW5lIGZvcmVzdCBvZiA8ZmVhdHVyZXMuaD4gYW5kIDx0aW1lLmg+IHNvIHRoYXQKCSMgdGhlIGhh
  c3Byb3RvIG1hY3JvIG9mIENvbmZpZ3VyZSBkb2Vzbid0IHNlZSB0aGVzZSBwcm90b3MsCgkjIGV2
  ZW4gd2l0aCB0aGUgLURfR05VX1NPVVJDRS4KCglkX2FzY3RpbWVfcl9wcm90bz0iJGRlZmluZSIK
  CWRfY3J5cHRfcl9wcm90bz0iJGRlZmluZSIKCWRfY3RpbWVfcl9wcm90bz0iJGRlZmluZSIKCWRf
  Z210aW1lX3JfcHJvdG89IiRkZWZpbmUiCglkX2xvY2FsdGltZV9yX3Byb3RvPSIkZGVmaW5lIgoJ
  ZF9yYW5kb21fcl9wcm90bz0iJGRlZmluZSIKCgk7Owplc2FjCkVPQ0JVCgpjYXQgPiBVVS91c2Vs
  YXJnZWZpbGVzLmNidSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS91c2VsYXJnZWZpbGVzLmNi
  dSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZQojIGFmdGVyIGl0IGhhcyBwcm9t
  cHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgbGFyZ2UgZmlsZXMuCmNhc2UgIiR1c2Vs
  YXJnZWZpbGVzIiBpbgonJ3wkZGVmaW5lfHRydWV8W3lZXSopCiMgS2VlcCB0aGlzIGluIHRoZSBs
  ZWZ0IG1hcmdpbi4KY2NmbGFnc191c2VsYXJnZWZpbGVzPSItRF9MQVJHRUZJTEVfU09VUkNFIC1E
  X0ZJTEVfT0ZGU0VUX0JJVFM9NjQiCgoJY2NmbGFncz0iJGNjZmxhZ3MgJGNjZmxhZ3NfdXNlbGFy
  Z2VmaWxlcyIKCTs7CmVzYWMKRU9DQlUKCiMgVGhlIGZvbGxvd2luZyByb3V0aW5lcyBhcmUgb25s
  eSBhdmFpbGFibGUgYXMgc3R1YnMgaW4gR05VIGxpYmMuCiMgWFhYIHJlbW92ZSB0aGlzIG9uY2Ug
  bWV0YWNvbmYgZGV0ZWN0cyB0aGUgR05VIGxpYmMgc3R1YnMuCmRfbXNnY3RsPSd1bmRlZicKZF9t
  c2dnZXQ9J3VuZGVmJwpkX21zZ3Jjdj0ndW5kZWYnCmRfbXNnc25kPSd1bmRlZicKZF9zZW1jdGw9
  J3VuZGVmJwpkX3NlbWdldD0ndW5kZWYnCmRfc2Vtb3A9J3VuZGVmJwpkX3NobWF0PSd1bmRlZicK
  ZF9zaG1jdGw9J3VuZGVmJwpkX3NobWR0PSd1bmRlZicKZF9zaG1nZXQ9J3VuZGVmJwo=','gnukfreebsd'=>'IyEgL2Jpbi9zaAoKIyBTdXBwb3J0IGZvciBEZWJpYW4gR05VL2tGcmVlQlNEIChrZnJlZWJzZC1n
  bnUpCiMgQSBwb3J0IG9mIHRoZSBEZWJpYW4gR05VIHN5c3RlbSB1c2luZyB0aGUgRnJlZUJTRCBr
  ZXJuZWwuCgouIC4vaGludHMvbGludXguc2gKCg==','hpux'=>'IyEvdXNyL2Jpbi9zaAoKIyMjIFNZU1RFTSBBUkNISVRFQ1RVUkUKCiMgRGV0ZXJtaW5lIHRoZSBh
  cmNoaXRlY3R1cmUgdHlwZSBvZiB0aGlzIHN5c3RlbS4KIyBLZWVwIGxlYWRpbmcgdGFiIGJlbG93
  IC0tIENvbmZpZ3VyZSBCbGFjayBNYWdpYyAtLSBSQU0sIDAzLzAyLzk3Cgl4eE9zUmV2TWFqb3I9
  YHVuYW1lIC1yIHwgc2VkIC1lICdzL15bXjAtOV0qLy8nIHwgY3V0IC1kLiAtZjFgOwoJeHhPc1Jl
  dk1pbm9yPWB1bmFtZSAtciB8IHNlZCAtZSAncy9eW14wLTldKi8vJyB8IGN1dCAtZC4gLWYyYDsK
  CXh4T3NSZXY9YGV4cHIgMTAwIFwqICR4eE9zUmV2TWFqb3IgKyAkeHhPc1Jldk1pbm9yYAppZiBb
  ICIkeHhPc1Jldk1ham9yIiAtZ2UgMTAgXTsgdGhlbgogICAgIyBUaGlzIHN5c3RlbSBpcyBydW5u
  aW5nID49IDEwLngKCiAgICAjIFRlc3RlZCBvbiAxMC4wMSBQQTEueCBhbmQgMTAuMjAgUEFbMTJd
  LnguCiAgICAjIElkZWE6IFNjYW4gL3Vzci9pbmNsdWRlL3N5cy91bmlzdGQuaCBmb3IgbWF0Y2hl
  cyB3aXRoCiAgICAjICIjZGVmaW5lIENQVV8qIGBnZXRjb25mICMgQ1BVX1ZFUlNJT05gIiB0byBk
  ZXRlcm1pbmUgQ1BVIHR5cGUuCiAgICAjIE5vdGUgdGhlIHRleHQgZm9sbG93aW5nICJDUFVfIiBp
  cyB1c2VkLCAqTk9UKiB0aGUgY29tbWVudC4KICAgICMKICAgICMgQVNTVU1QVElPTlM6IE51bWJl
  cnMgd2lsbCBjb250aW51ZSB0byBiZSBkZWZpbmVkIGluIGhleCAtLSBhbmQgaW4KICAgICMgL3Vz
  ci9pbmNsdWRlL3N5cy91bmlzdGQuaCAtLSBhbmQgdGhlIENQVV8qICNkZWZpbmVzIHdpbGwgYmUg
  a2VwdAogICAgIyB1cCB0byBkYXRlIHdpdGggbmV3IENQVS9PUyByZWxlYXNlcy4KICAgIHh4Y3B1
  PWBnZXRjb25mIENQVV9WRVJTSU9OYDsgIyBHZXQgdGhlIG51bWJlci4KICAgIHh4Y3B1PWBwcmlu
  dGYgJzB4JXgnICR4eGNwdWA7ICMgY29udmVydCB0byBoZXgKICAgIGFyY2huYW1lPWBzZWQgLW4g
  LWUgInMvXiNbWzpzcGFjZTpdXSpkZWZpbmVbWzpzcGFjZTpdXSpDUFVfLy9wIiAvdXNyL2luY2x1
  ZGUvc3lzL3VuaXN0ZC5oIHwKCXNlZCAtbiAtZSAicy9bWzpzcGFjZTpdXSokeHhjcHVbWzpzcGFj
  ZTpdXS4qLy9wIiB8CglzZWQgLWUgcy9fUklTQy8tUklTQy8gLWUgcy9IUF8vLyAtZSBzL18vLi8g
  LWUgInMvW1s6c3BhY2U6XV0qLy9nImA7CmVsc2UKICAgICMgVGhpcyBzeXN0ZW0gaXMgcnVubmlu
  ZyA8PSA5LngKICAgICMgVGVzdGVkIG9uIDkuMFs1N10gUEEgYW5kIFs3OF0uMCBNQzY4MFsyM10w
  LiAgSWRlYTogQWZ0ZXIgcmVtb3ZpbmcKICAgICMgTUM2ODg4WzEyXSBmcm9tIGNvbnRleHQgc3Ry
  aW5nLCB1c2UgZmlyc3QgQ1BVIGlkZW50aWZpZXIuCiAgICAjCiAgICAjIEFTU1VNUFRJT046IE9u
  bHkgQ1BVIGlkZW50aWZpZXJzIGNvbnRhaW4gbm8gbG93ZXJjYXNlIGxldHRlcnMuCiAgICBhcmNo
  bmFtZT1gZ2V0Y29udGV4dCB8IHRyICcgJyAnXDAxMicgfCBncmVwIC12ICdbYS16XScgfCBncmVw
  IC12IE1DNjg4IHwKCXNlZCAtZSAncy9IUC0vLycgLWUgMXFgOwogICAgc2VsZWN0dHlwZT0naW50
  IConCiAgICBmaQoKIyBGb3Igc29tZSBzdHJhbmdlIHJlYXNvbiwgdGhlIHUzMmFsaWduIHRlc3Qg
  ZnJvbSBDb25maWd1cmUgaGFuZ3MgaW4KIyBIUC1VWCAxMC4yMCBzaW5jZSB0aGUgRGVjZW1iZXIg
  MjAwMSBwYXRjaGVzLiAgU28gaGludCBpdCB0byBhdm9pZAojIHRoZSB0ZXN0LgppZiBbICIkeHhP
  c1Jldk1ham9yIiAtbGUgMTAgXTsgdGhlbgogICAgZF91MzJhbGlnbj0kZGVmaW5lCiAgICBmaQoK
  ZWNobyAiQXJjaG5hbWUgaXMgJGFyY2huYW1lIgoKIyBGaXggWFNsaWIgKENQQU4pIGNvbmZ1c2lv
  biB3aGVuIHJlLXVzaW5nIGEgcHJlZml4IGJ1dCBjaGFuZ2luZyBmcm9tIElMUDMyCiMgdG8gTFA2
  NCBidWlsZHMuICBUaGV5J3JlIE5PVCBiaW5hcnkgY29tcGF0aWJsZSwgc28gcXVpdCBjbGFpbWlu
  ZyB0aGV5IGFyZS4KYXJjaG5hbWU2ND1MUDY0CgoKIyMjIEhQLVVYIE9TIHNwZWNpZmljIGJlaGF2
  aW91cgoKIyAtbGRibSBpcyBvYnNvbGV0ZSBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkCiMgLWxCU0Qg
  Y29udGFpbnMgQlNELXN0eWxlIGR1cGxpY2F0ZXMgb2YgU1ZSNCByb3V0aW5lcyB0aGF0IGNhdXNl
  IGNvbmZ1c2lvbgojIC1sUFcgaXMgb2Jzb2xldGUgYW5kIHNob3VsZCBub3QgYmUgdXNlZAojIFRo
  ZSBsaWJyYXJpZXMgY3J5cHQsIG1hbGxvYywgbmRpciwgYW5kIG5ldCBhcmUgZW1wdHkuCnNldCBg
  ZWNobyAiWCAkbGlic3dhbnRlZCAiIHwgc2VkIC1lICdzLyBsZCAvIC8nIC1lICdzLyBkYm0gLyAv
  JyAtZSAncy8gQlNEIC8gLycgLWUgJ3MvIFBXIC8gLydgCnNoaWZ0CmxpYnN3YW50ZWQ9IiQqIgoK
  Y2M9JHtjYzotY2N9CmFyPS91c3IvYmluL2FyCSMgWWVzLCB0cnVseSBvdmVycmlkZS4gIFdlIGRv
  IG5vdCB3YW50IHRoZSBHTlUgYXIuCmZ1bGxfYXI9JGFyCSMgSSByZXBlYXQsIG5vIEdOVSBhci4g
  IGFycnIuCgpzZXQgYGVjaG8gIlggJGNjZmxhZ3MgIiB8IHNlZCAtZSAncy8gLUFbZWFdIC8gLycg
  LWUgJ3MvIC1EX0hQVVhfU09VUkNFIC8gLydgCnNoaWZ0CgljY19jcHBmbGFncz0iJCogLURfSFBV
  WF9TT1VSQ0UiCmNwcGZsYWdzPSItQWEgLURfX1NURENfRVhUX18gJGNjX2NwcGZsYWdzIgoKY2Fz
  ZSAiJHByZWZpeCIgaW4KICAgICIiKSBwcmVmaXg9Jy9vcHQvcGVybDUnIDs7CiAgICBlc2FjCgog
  ICAgZ251X2FzPW5vCiAgICBnbnVfbGQ9bm8KY2FzZSBgJGNjIC12IDI+JjFgIiIgaW4KICAgICpn
  Y2MqKSAgY2Npc2djYz0iJGRlZmluZSIKCSAgICBjY2ZsYWdzPSIkY2NfY3BwZmxhZ3MiCgkgICAg
  aWYgWyAiWCRnY2N2ZXJzaW9uIiA9ICJYIiBdOyB0aGVuCgkJIyBEb25lIHRvbyBsYXRlIGluIENv
  bmZpZ3VyZSBpZiBoaW50ZWQKCQlnY2N2ZXJzaW9uPWAkY2MgLWR1bXB2ZXJzaW9uYAoJCWZpCgkg
  ICAgY2FzZSAiJGdjY3ZlcnNpb24iIGluCgkJWzAxMl0qKSAjIEhQLVVYIGFuZCBnY2MtMi4qIGJy
  ZWFrIFVJTlQzMl9NQVggOi0oCgkJCWNjZmxhZ3M9IiRjY2ZsYWdzIC1EVUlOVDMyX01BWF9CUk9L
  RU4iCgkJCTs7CgkJWzM0XSopICMgR0NDIChib3RoIDMyYml0IGFuZCA2NGJpdCkgd2lsbCBkZWZp
  bmUgX19TVERDX0VYVF9fCiAgICAgICAgICAgICAgICAgICAgICAgIyBieSBkZWZhdWx0IHdoZW4g
  dXNpbmcgR0NDIDMuMCBhbmQgbmV3ZXIgdmVyc2lvbnMgb2YKICAgICAgICAgICAgICAgICAgICAg
  ICAjIHRoZSBjb21waWxlci4KICAgICAgICAgICAgICAgICAgICAgICBjcHBmbGFncz0iJGNjX2Nw
  cGZsYWdzIgogICAgICAgICAgICAgICAgICAgICAgIDs7CgkJZXNhYwoJICAgIGNhc2UgImBnZXRj
  b25mIEtFUk5FTF9CSVRTIDI+L2Rldi9udWxsYCIgaW4KCQkqNjQqKQoJCSAgICBlY2hvICJtYWlu
  KCl7fSI+dHJ5LmMKCQkgICAgY2FzZSAiJGdjY3ZlcnNpb24iIGluCgkJCVszNF0qKQoJCQkgICAg
  Y2FzZSAiJGFyY2huYW1lIiBpbgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUEEtUklT
  QyopCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAiJGNjZmxhZ3MiIGlu
  CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICotbXBhLXJpc2MqKSA7Owog
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKSBjY2ZsYWdzPSIkY2NmbGFn
  cyAtbXBhLXJpc2MtMi0wIiA7OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICBlc2FjCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOzsKCQkJCWVzYWMKCQkJ
  ICAgIDs7CgkJCSopICAjIGdjYyB3aXRoIGdhcyB3aWxsIG5vdCBhY2NlcHQgK0RBMi4wCgkJCSAg
  ICBjYXNlICJgJGNjIC1jIC1XYSwrREEyLjAgdHJ5LmMgMj4mMWAiIGluCgkJCQkqIitEQTIuMCIq
  KQkJIyBnYXMKCQkJCSAgICBnbnVfYXM9eWVzCgkJCQkgICAgOzsKCQkJCSopCQkJIyBIUGFzCgkJ
  CQkgICAgY2NmbGFncz0iJGNjZmxhZ3MgLVdhLCtEQTIuMCIKCQkJCSAgICA7OwoJCQkJZXNhYwoJ
  CQkgICAgOzsKCQkJZXNhYwoJCSAgICAjIGdjYyB3aXRoIGdsZCB3aWxsIG5vdCBhY2NlcHQgK3Zu
  b2NvbXBhdHdhcm5pbmdzCgkJICAgIGNhc2UgImAkY2MgLW8gdHJ5IC1XbCwrdm5vY29tcGF0d2Fy
  bmluZ3MgdHJ5LmMgMj4mMWAiIGluCgkJCSoiK3Zub2NvbXBhdCIqKQkJIyBnbGQKCQkJICAgIGdu
  dV9sZD15ZXMKCQkJICAgIDs7CgkJCSopCQkJIyBIUGxkCgkJCSAgIGNhc2UgIiRnY2N2ZXJzaW9u
  IiBpbgoJCQkgICAgICAgWzEyXSopCgkJCQkgICAjIFdoeSBub3QgMyBhcyB3ZWxsIGhlcmU/CgkJ
  CQkgICAjIFNpbmNlIG5vdCByZWxldmFudCB0byBJQTY0LCBub3QgY2hhbmdlZC4KCQkJCSAgIGxk
  ZmxhZ3M9IiRsZGZsYWdzIC1XbCwrdm5vY29tcGF0d2FybmluZ3MiCgkJCQkgICBjY2ZsYWdzPSIk
  Y2NmbGFncyAtV2wsK3Zub2NvbXBhdHdhcm5pbmdzIgoJCQkJICAgOzsKCQkJICAgICAgIGVzYWMK
  CQkJICAgIDs7CgkJCWVzYWMKCQkgICAgcm0gLWYgdHJ5LmMKCQkgICAgOzsKCQllc2FjCgkgICAg
  OzsKICAgICopICAgICAgY2Npc2djYz0nJwoJICAgICMgV2hhdCBjYW5ub3QgYmUgdXNlIGluIGNv
  bWJpbmF0aW9uIHdpdGggY2NhY2hlIGxpbmtzIDooCgkgICAgY2NfZm91bmQ9IiIKCSAgICBmb3Ig
  cCBpbiBgZWNobyAkUEFUSCB8IHRyIDogJyAnJ2AgOyBkbwoJCXg9IiRwL2NjIgoJCWlmIFsgLWYg
  JHggXSAmJiBbIC14ICR4IF07IHRoZW4KCQkgICAgaWYgWyAtaCAkeCBdOyB0aGVuCgkJCWw9YGxz
  IC1sICR4IHwgc2VkICdzLC4qLT4gLCwnYAoJCQljYXNlICRsIGluCgkJCSAgICAvKikgeD0kbAkJ
  OzsKCQkJICAgICopICB4PSIkcC8kbCIJOzsKCQkJICAgIGVzYWMKCQkJZmkKCQkgICAgeD1gZWNo
  byAkeCB8IHNlZCAncywvXC4vLC8sZydgCgkJICAgIGNhc2UgJHggaW4KCQkJKmNjYWNoZSopIDs7
  CgkJCSopIFsgLXogIiRjY19mb3VuZCIgXSAmJiBjY19mb3VuZD0keCA7OwoJCQllc2FjCgkJICAg
  IGZpCgkJZG9uZQoJICAgIFsgLXogIiRjY19mb3VuZCIgXSAmJiBjY19mb3VuZD1gd2hpY2ggY2Ng
  CgkgICAgd2hhdCAkY2NfZm91bmQgPiY0CgkgICAgY2N2ZXJzaW9uPWB3aGF0ICRjY19mb3VuZCB8
  IGF3ayAnL0NvbXBpbGVyL3twcmludCAkMn0vSXRhbml1bS97cHJpbnQgJDYsJDd9L2ZvciBJbnRl
  Z3JpdHkve3ByaW50ICQ2LCQ3fSdgCgkgICAgY2FzZSAiJGNjZmxhZ3MiIGluCiAgICAgICAgICAg
  ICAgICItQWUgIiopIDs7CgkJKikgIGNjZmxhZ3M9Ii1BZSAkY2NfY3BwZmxhZ3MiCgkJICAgICMg
  K3Zub2NvbXBhdHdhcm5pbmdzIG5vdCBrbm93biBpbiAxMC4xMCBhbmQgb2xkZXIKCQkgICAgaWYg
  WyAkeHhPc1JldiAtZ2UgMTAyMCBdOyB0aGVuCgkJCWNjZmxhZ3M9IiRjY2ZsYWdzIC1XbCwrdm5v
  Y29tcGF0d2FybmluZ3MiCgkJCWZpCgkJICAgIDs7CiAgICAgICAgICAgICAgIGVzYWMKCSAgICAj
  IE5lZWRlZCBiZWNhdXNlIGNwcCBkb2VzIG9ubHkgc3VwcG9ydCAtQWEgKG5vdCAtQWUpCgkgICAg
  Y3BwbGFzdD0nLScKCSAgICBjcHBtaW51cz0nLScKCSAgICBjcHBzdGRpbj0nY2MgLUUgLUFhIC1E
  X19TVERDX0VYVF9fJwoJICAgIGNwcHJ1bj0kY3Bwc3RkaW4KIwkgICAgY2FzZSAiJGRfY2FzdGkz
  MiIgaW4KIwkJIiIpIGRfY2FzdGkzMj0ndW5kZWYnIDs7CiMJCWVzYWMKCSAgICA7OwogICAgZXNh
  YwoKIyBXaGVuIEhQLVVYIHJ1bnMgYSBzY3JpcHQgd2l0aCAiIyEiLCBpdCBzZXRzIGFyZ3ZbMF0g
  dG8gdGhlIHNjcmlwdCBuYW1lLgp0b2tlX2NmbGFncz0nY2NmbGFncz0iJGNjZmxhZ3MgLURBUkdf
  WkVST19JU19TQ1JJUFQiJwoKIyMjIDY0IEJJVE5FU1MKCiMgU29tZSBnY2MgdmVyc2lvbnMgZG8g
  bmF0aXZlIDY0IGJpdCBsb25nIChlLmcuIDIuOS1ocHBhLTAwMDMxMCBhbmQgZ2NjLTMuMCkKIyBX
  ZSBoYXZlIHRvIGZvcmNlIDY0Yml0bmVzcyB0byBnbyBzZWFyY2ggdGhlIHJpZ2h0IGxpYnJhcmll
  cwogICAgZ2NjXzY0bmF0aXZlPW5vCmNhc2UgIiRjY2lzZ2NjIiBpbgogICAgJGRlZmluZXx0cnVl
  fFtZeV0pCgllY2hvICcjaW5jbHVkZSA8c3RkaW8uaD5cbmludCBtYWluKCl7bG9uZyBsO3ByaW50
  ZigiJWRcXG4iLHNpemVvZihsKSk7fSc+dHJ5LmMKCSRjYyAtbyB0cnkgJGNjZmxhZ3MgJGxkZmxh
  Z3MgdHJ5LmMKCWlmIFsgImB0cnlgIiA9ICI4IiBdOyB0aGVuCgkgICAgY2FzZSAiJHVzZTY0Yml0
  YWxsIiBpbgoJCSRkZWZpbmV8dHJ1ZXxbWXldKSA7OwoJCSopICBjYXQgPDxFT00gPiY0CgoqKiog
  VGhpcyB2ZXJzaW9uIG9mIGdjYyB1c2VzIDY0IGJpdCBsb25ncy4gLUR1c2U2NGJpdGFsbCBpcwoq
  KiogaW1wbGljaXRseSBzZXQgdG8gZW5hYmxlIGNvbnRpbnVhdGlvbgpFT00KCQllc2FjCgkgICAg
  dXNlNjRiaXRhbGw9JGRlZmluZQoJICAgIGdjY182NG5hdGl2ZT15ZXMKCSAgICBmaQoJOzsKICAg
  IGVzYWMKCmNhc2UgIiR1c2U2NGJpdGFsbCIgaW4KICAgICRkZWZpbmV8dHJ1ZXxbeVldKikgdXNl
  NjRiaXRpbnQ9IiRkZWZpbmUiIDs7CiAgICBlc2FjCgpjYXNlICIkdXNlbW9yZWJpdHMiIGluCiAg
  ICAkZGVmaW5lfHRydWV8W3lZXSopIHVzZTY0Yml0aW50PSIkZGVmaW5lIjsgdXNlbG9uZ2RvdWJs
  ZT0iJGRlZmluZSIgOzsKICAgIGVzYWMKCiMgVGhlcmUgaXMgYSB3ZWlyZCBwcmUtQzk5IGxvbmcg
  ZG91YmxlIChhIHN0cnVjdCBvZiBmb3VyIHVpbjMyX3QpCiMgaW4gSFAtVVggMTAuMjAgYnV0IGJl
  eW9uZCBzdHJ0b2xkKCkgdGhlcmUncyBubyBzdXBwb3J0IGZvciB0aGVtCiMgZm9yIGV4YW1wbGUg
  aW4gPG1hdGguaD4uCmNhc2UgIiR1c2Vsb25nZG91YmxlIiBpbgogICAgJGRlZmluZXx0cnVlfFt5
  WV0qKQoJaWYgWyAiJHh4T3NSZXZNYWpvciIgLWx0IDExIF07IHRoZW4KCSAgICBjYXQgPDxFT00g
  PiY0CgoqKiogdXNlbG9uZ2RvdWJsZSAob3IgdXNlbW9yZWJpdHMpIGlzIG5vdCBzdXBwb3J0ZWQg
  b24gSFAtVVggJHh4T3NSZXZNYWpvci4KKioqIFlvdSBuZWVkIGF0IGxlYXN0IEhQLVVYIDExLjAu
  CioqKiBDYW5ub3QgY29udGludWUsIGFib3J0aW5nLgpFT00KCSAgICBleGl0IDEKCWZpCgk7Owog
  ICAgZXNhYwoKIyBDb25maWd1cmUgbG9uZyBkb3VibGUgc2NhbiB3aWxsIGRldGVjdCB0aGUgSFAt
  VVggMTAuMjAgImxvbmcgZG91YmxlIgojIChhIHN0cnVjdCBvZiBmb3VyIHVpbjMyX3QpIGFuZCB0
  aGluayBpdCBpcyBJRUVFIHF1YWQuICBNYWtlIGl0IG5vdCBzby4KaWYgWyAiJHh4T3NSZXZNYWpv
  ciIgLWx0IDExIF07IHRoZW4KICAgIGRfbG9uZ2RibD0iJHVuZGVmIgogICAgbG9uZ2RibHNpemU9
  OCAjIE1ha2UgaXQgZG91YmxlLgpmaQoKY2FzZSAiJGFyY2huYW1lIiBpbgogICAgSUE2NCopCgkj
  IFdoaWxlIGhlcmUsIG92ZXJyaWRlIHNvPXNsIGF1dG8tZGV0ZWN0aW9uCglzbz0nc28nCgk7Owog
  ICAgZXNhYwoKY2FzZSAiJHVzZTY0Yml0YWxsIiBpbgogICAgJGRlZmluZXx0cnVlfFtZeV0pCgoJ
  aWYgWyAiJHh4T3NSZXZNYWpvciIgLWx0IDExIF07IHRoZW4KCSAgICBjYXQgPDxFT00gPiY0Cgoq
  KiogNjQtYml0IGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgb24gSFAtVVggJHh4T3NSZXZN
  YWpvci4KKioqIFlvdSBuZWVkIGF0IGxlYXN0IEhQLVVYIDExLjAuCioqKiBDYW5ub3QgY29udGlu
  dWUsIGFib3J0aW5nLgpFT00KCSAgICBleGl0IDEKCSAgICBmaQoKCWlmIFsgJHh4T3NSZXYgLWVx
  IDExMDAgXTsgdGhlbgoJICAgICMgSFAtVVggMTEuMDAgdXNlcyBvbmx5IDQ4IGJpdHMgaW50ZXJu
  YWxseSBpbiA2NGJpdCBtb2RlLCBub3QgNjQKCSAgICAjIGZvcmNlIG1pbi9tYXggdG8gMioqNDct
  MQoJICAgIHNHTVRJTUVfbWF4PTE0MDczNzQ4ODM1NTMyNwoJICAgIHNHTVRJTUVfbWluPS02MjE2
  NzIxOTIwMAoJICAgIHNMT0NBTFRJTUVfbWF4PTE0MDczNzQ4ODM1NTMyNwoJICAgIHNMT0NBTFRJ
  TUVfbWluPS02MjE2NzIxOTIwMAoJICAgIGZpCgoJIyBTZXQgbGliYyBhbmQgdGhlIGxpYnJhcnkg
  cGF0aHMKCWNhc2UgIiRhcmNobmFtZSIgaW4KCSAgICBQQS1SSVNDKikKCQlsb2NsaWJwdGg9IiRs
  b2NsaWJwdGggL2xpYi9wYTIwXzY0IgoJCWxpYmM9Jy9saWIvcGEyMF82NC9saWJjLnNsJyA7OwoJ
  ICAgIElBNjQqKQoJCWxvY2xpYnB0aD0iJGxvY2xpYnB0aCAvdXNyL2xpYi9ocHV4NjQiCgkJbGli
  Yz0nL3Vzci9saWIvaHB1eDY0L2xpYmMuc28nIDs7CgkgICAgZXNhYwoJaWYgWyAhIC1mICIkbGli
  YyIgXTsgdGhlbgoJICAgIGNhdCA8PEVPTSA+JjQKCioqKiBZb3UgZG8gbm90IHNlZW0gdG8gaGF2
  ZSB0aGUgNjQtYml0IGxpYmMuCioqKiBJIGNhbm5vdCBmaW5kIHRoZSBmaWxlICRsaWJjLgoqKiog
  Q2Fubm90IGNvbnRpbnVlLCBhYm9ydGluZy4KRU9NCgkgICAgZXhpdCAxCgkgICAgZmkKCgljYXNl
  ICIkY2Npc2djYyIgaW4KCSAgICAkZGVmaW5lfHRydWV8W1l5XSkKCQkjIFRoZSBmaXhlZCBzb2Nr
  ZXQuaCBoZWFkZXIgZmlsZSBpcyB3cm9uZyBmb3IgZ2NjLTQueAoJCSMgb24gUEEtUklTQzIuMFcs
  IHNvIFNvY2tfdHlwZV90IGlzIHNpemVfdCB3aGljaCBpcwoJCSMgdW5zaWduZWQgbG9uZyB3aGlj
  aCBpcyA2NGJpdCB3aGljaCBpcyB0b28gbG9uZwoJCWNhc2UgIiRnY2N2ZXJzaW9uIiBpbgoJCSAg
  ICA0KikgY2FzZSAiJGFyY2huYW1lIiBpbgoJCQkgICAgUEEtUklTQyopIHNvY2tzaXpldHlwZT1p
  bnQgOzsKCQkJICAgIGVzYWMKCQkJOzsKCQkgICAgZXNhYwoKCQkjIEZvciB0aGUgbW9tZW50LCBk
  b24ndCBjYXJlIHRoYXQgaXQgYWluJ3Qgc3VwcG9ydGVkICh5ZXQpCgkJIyBieSBnY2MgKHVwIHRv
  IGFuZCBpbmNsdWRpbmcgMi45NS4zKSwgY2F1c2UgaXQnbGwgY3Jhc2gKCQkjIGFueXdheS4gRXhw
  ZWN0IGF1dG8tZGV0ZWN0aW9uIG9mIDY0LWJpdCBlbmFibGVkIGdjYyBvbgoJCSMgSFAtVVggc29v
  biwgaW5jbHVkaW5nIGEgdXNlci1mcmllbmRseSBleGl0CgkJY2FzZSAkZ2NjXzY0bmF0aXZlIGlu
  CgkJICAgIG5vKSBjYXNlICIkZ2NjdmVyc2lvbiIgaW4KCQkJICAgIFsxMjM0XSopCgkJCQljY2Zs
  YWdzPSIkY2NmbGFncyAtbWxwNjQiCgkJCQljYXNlICIkYXJjaG5hbWUiIGluCgkJCQkgICAgUEEt
  UklTQyopCgkJCQkJbGRmbGFncz0iJGxkZmxhZ3MgLVdsLCtERDY0IgoJCQkJCTs7CgkJCQkgICAg
  SUE2NCopCgkJCQkJbGRmbGFncz0iJGxkZmxhZ3MgLW1scDY0IgoJCQkJCTs7CgkJCQkgICAgZXNh
  YwoJCQkJOzsKCQkJICAgIGVzYWMKCQkJOzsKCQkgICAgZXNhYwoJCTs7CgkgICAgKikKCQljYXNl
  ICIkdXNlNjRiaXRhbGwiIGluCgkJICAgICRkZWZpbmV8dHJ1ZXxbeVldKikKCQkJY2NmbGFncz0i
  JGNjZmxhZ3MgK0RENjQiCgkJCWxkZmxhZ3M9IiRsZGZsYWdzICtERDY0IgoJCQk7OwoJCSAgICBl
  c2FjCgkJOzsKCSAgICBlc2FjCgoJIyBSZXNldCB0aGUgbGlicmFyeSBjaGVja2VyIHRvIG1ha2Ug
  c3VyZSBsaWJyYXJpZXMKCSMgYXJlIHRoZSByaWdodCB0eXBlCgkjIChOT1RFOiBvbiBJQTY0LCB0
  aGlzIGRvZXNuJ3Qgd29yayB3aXRoIC5hIGZpbGVzLikKCWxpYnNjaGVjaz0nY2FzZSAiYC91c3Iv
  YmluL2ZpbGUgJHh4eGAiIGluCgkJICAgICAgICpFTEYtNjQqfCpMUDY0KnwqUEEtUklTQzIuMCop
  IDs7CgkJICAgICAgICopIHh4eD0vbm8vNjQtYml0JHh4eCA7OwoJCSAgICAgICBlc2FjJwoKCTs7
  CgogICAgKikJIyBOb3QgaW4gNjQtYml0IG1vZGUKCgljYXNlICIkYXJjaG5hbWUiIGluCgkgICAg
  UEEtUklTQyopCgkJbGliYz0nL2xpYi9saWJjLnNsJyA7OwoJICAgIElBNjQqKQoJCWxvY2xpYnB0
  aD0iJGxvY2xpYnB0aCAvdXNyL2xpYi9ocHV4MzIiCgkJbGliYz0nL3Vzci9saWIvaHB1eDMyL2xp
  YmMuc28nIDs7CgkgICAgZXNhYwoJOzsKICAgIGVzYWMKCiMgQnkgc2V0dGluZyB0aGUgZGVmZXJy
  ZWQgZmxhZyBiZWxvdywgdGhpcyBtZWFucyB0aGF0IGlmIHlvdSBydW4gcGVybAojIG9uIGEgc3lz
  dGVtIHRoYXQgZG9lcyBub3QgaGF2ZSB0aGUgcmVxdWlyZWQgc2hhcmVkIGxpYnJhcnkgdGhhdCB5
  b3UKIyBsaW5rZWQgaXQgd2l0aCwgaXQgd2lsbCBkaWUgd2hlbiB5b3UgdHJ5IHRvIGFjY2VzcyBh
  IHN5bWJvbCBpbiB0aGUKIyAobWlzc2luZykgc2hhcmVkIGxpYnJhcnkuICBJZiB5b3Ugd291bGQg
  cmF0aGVyIGtub3cgYXQgcGVybCBzdGFydHVwCiMgdGltZSB0aGF0IHlvdSBhcmUgbWlzc2luZyBh
  biBpbXBvcnRhbnQgc2hhcmVkIGxpYnJhcnksIHN3aXRjaCB0aGUKIyBjb21tZW50cyBzbyB0aGF0
  IGltbWVkaWF0ZSwgcmF0aGVyIHRoYW4gZGVmZXJyZWQgbG9hZGluZyBpcwojIHBlcmZvcm1lZC4g
  IEV2ZW4gd2l0aCBpbW1lZGlhdGUgbG9hZGluZywgeW91IGNhbiBwb3N0cG9uZSBlcnJvcnMgZm9y
  CiMgdW5kZWZpbmVkIChvciBtdWx0aXBseSBkZWZpbmVkKSByb3V0aW5lcyB1bnRpbCBhY3R1YWwg
  YWNjZXNzIGJ5CiMgYWRkaW5nIHRoZSAibm9uZmF0YWwiIG9wdGlvbi4KIyBjY2RsZmxhZ3M9Ii1X
  bCwtRSAtV2wsLUIsaW1tZWRpYXRlICRjY2RsZmxhZ3MiCiMgY2NkbGZsYWdzPSItV2wsLUUgLVds
  LC1CLGltbWVkaWF0ZSwtQixub25mYXRhbCAkY2NkbGZsYWdzIgppZiBbICIkZ251X2xkIiA9ICJ5
  ZXMiIF07IHRoZW4KICAgIGNjZGxmbGFncz0iLVdsLC1FICRjY2RsZmxhZ3MiCmVsc2UKICAgIGNj
  ZGxmbGFncz0iLVdsLC1FIC1XbCwtQixkZWZlcnJlZCAkY2NkbGZsYWdzIgogICAgZmkKCgojIyMg
  Q09NUElMRVIgU1BFQ0lGSUNTCgojIyBMb2NhbCByZXN0cmljdGlvbnMgKHBvaW50IHRvIFJFQURN
  RS5ocHV4IHRvIGxpZnQgdGhlc2UpCgojIyBPcHRpbWl6YXRpb24gbGltaXRzCmNhdCA+dHJ5LmMg
  PDxFT0YKI2luY2x1ZGUgPHN0ZGlvLmg+CiNpbmNsdWRlIDxzeXMvcmVzb3VyY2UuaD4KCmludCBt
  YWluICgpCnsKICAgIHN0cnVjdCBybGltaXQgcmw7CiAgICBpbnQgaSA9IGdldHJsaW1pdCAoUkxJ
  TUlUX0RBVEEsICZybCk7CiAgICBwcmludGYgKCIlZFxuIiwgKGludCkocmwucmxpbV9jdXIgLyAo
  MTAyNCAqIDEwMjQpKSk7CiAgICB9IC8qIG1haW4gKi8KRU9GCiRjYyAtbyB0cnkgJGNjZmxhZ3Mg
  JGxkZmxhZ3MgdHJ5LmMKCW1heGRzaXo9YHRyeWAKcm0gLWYgdHJ5IHRyeS5jIGNvcmUKaWYgWyAk
  bWF4ZHNpeiAtbGUgNjQgXTsgdGhlbgogICAgIyA2NCBNYiBpcyBwcm9iYWJseSBub3QgZW5vdWdo
  IHRvIG9wdGltaXplIHRva2UuYwogICAgIyBhbmQgcmVnZXhwLmMgd2l0aCAtTzIKICAgIGNhdCA8
  PEVPTSA+JjQKWW91ciBrZXJuZWwgbGltaXRzIHRoZSBkYXRhIHNlY3Rpb24gb2YgeW91ciBwcm9n
  cmFtcyB0byAkbWF4ZHNpeiBNYiwKd2hpY2ggaXMgKHNhZGx5KSBub3QgZW5vdWdoIHRvIGZ1bGx5
  IG9wdGltaXplIHNvbWUgcGFydHMgb2YgdGhlCnBlcmwgYmluYXJ5LiBJJ2xsIHRyeSB0byB1c2Ug
  YSBsb3dlciBvcHRpbWl6YXRpb24gbGV2ZWwgZm9yCnRob3NlIHBhcnRzLiBJZiB5b3UgYXJlIGEg
  c3lzYWRtaW4sIGFuZCB5b3UgKmRvKiB3YW50IGZ1bGwKb3B0aW1pemF0aW9uLCByYWlzZSB0aGUg
  J21heGRzaXonIGtlcm5lbCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcgp0byBhdCBsZWFzdCAweDA4
  MDAwMDAwICgxMjggTWIpIGFuZCByZWJ1aWxkIHlvdXIga2VybmVsLgpFT00KcmVnZXhlY19jZmxh
  Z3M9JycKZG9vcF9jZmxhZ3M9JycKb3BfY2ZsYWdzPScnCm9wbWluaV9jZmxhZ3M9JycKcGVybG1h
  aW5fY2ZsYWdzPScnCiAgICBmaQoKY2FzZSAiJGNjaXNnY2MiIGluCiAgICAkZGVmaW5lfHRydWV8
  W1l5XSkKCgljYXNlICIkb3B0aW1pemUiIGluCgkgICAgIiIpICAgICAgICAgICBvcHRpbWl6ZT0i
  LWcgLU8iIDs7CgkgICAgKk9bMzQ1Njc4OV0qKSBvcHRpbWl6ZT1gZWNobyAiJG9wdGltaXplIiB8
  IHNlZCAtZSAncy9PWzMtOV0vTzIvJ2AgOzsKCSAgICBlc2FjCgkjbGQ9IiRjYyIKCWxkPS91c3Iv
  YmluL2xkCgljY2NkbGZsYWdzPSctZlBJQycKCSNsZGRsZmxhZ3M9Jy1zaGFyZWQnCglsZGRsZmxh
  Z3M9Jy1iJwoJY2FzZSAiJG9wdGltaXplIiBpbgoJICAgICotZyotTyp8Ki1PKi1nKikKCQkjIGdj
  YyB3aXRob3V0IGdhcyB3aWxsIG5vdCBhY2NlcHQgLWcKCQllY2hvICJtYWluKCl7fSI+dHJ5LmMK
  CQljYXNlICJgJGNjICRvcHRpbWl6ZSAtYyB0cnkuYyAyPiYxYCIgaW4KCQkgICAgKiItZyBvcHRp
  b24gZGlzYWJsZWQiKikKCQkJc2V0IGBlY2hvICJYICRvcHRpbWl6ZSAiIHwgc2VkIC1lICdzLyAt
  ZyAvIC8nYAoJCQlzaGlmdAoJCQlvcHRpbWl6ZT0iJCoiCgkJCTs7CgkJICAgIGVzYWMKCQk7OwoJ
  ICAgIGVzYWMKCWlmIFsgJG1heGRzaXogLWxlIDY0IF07IHRoZW4KCSAgICBjYXNlICIkb3B0aW1p
  emUiIGluCgkJKk8yKikJb3B0PWBlY2hvICIkb3B0aW1pemUiIHwgc2VkIC1lICdzL08yL08xLydg
  CgkJCXRva2VfY2ZsYWdzPSIkdG9rZV9jZmxhZ3M7b3B0aW1pemU9XCIkb3B0XCIiCgkJCXJlZ2V4
  ZWNfY2ZsYWdzPSJvcHRpbWl6ZT1cIiRvcHRcIiIKCQkJOzsKCQllc2FjCgkgICAgZmkKCTs7Cgog
  ICAgKikKCWNhc2UgIiRvcHRpbWl6ZSIgaW4KCSAgICAiIikgICAgICAgICAgIG9wdGltaXplPSIr
  TzIgK09ub2xpbWl0IiA7OwoJICAgICpPWzM0NTY3ODldKikgb3B0aW1pemU9YGVjaG8gIiRvcHRp
  bWl6ZSIgfCBzZWQgLWUgJ3MvT1szLTldL08yLydgIDs7CgkgICAgZXNhYwoJY2FzZSAiJG9wdGlt
  aXplIiBpbgoJICAgICotTyp8XAoJICAgICpPMiopICAgb3B0PWBlY2hvICIkb3B0aW1pemUiIHwg
  c2VkIC1lICdzLy1PLytPMi8nIC1lICdzL08yL08xLycgLWUgJ3MvICorT25vbGltaXQvLydgCgkJ
  ICAgIDs7CgkgICAgKikgICAgICBvcHQ9IiRvcHRpbWl6ZSIKCQkgICAgOzsKCSAgICBlc2FjCglj
  YXNlICIkYXJjaG5hbWUiIGluCgkgICAgUEEtUklTQzIuMCkKCQljYXNlICIkY2N2ZXJzaW9uIiBp
  bgoJCSAgICBCLjExLjExLiopCgkJCSMgb3BtaW5pLmMgYW5kIG9wLmMgd2l0aCArTzIgbWFrZXMg
  dGhlIGNvbXBpbGVyIGRpZQoJCQkjIG9mIGludGVybmFsIGVycm9yLCBmb3IgcGVybG1haW4uYyBv
  bmx5ICtPMCAobm8gb3B0KQogICAgICAgICAgICAgICAgICAgICAgICAjIHdvcmtzLgoJCQljYXNl
  ICIkb3B0aW1pemUiIGluCgkJCSpPMiopCW9wdD1gZWNobyAiJG9wdGltaXplIiB8IHNlZCAtZSAn
  cy9PMi9PMS8nYAoJCQkJb3BtaW5pX2NmbGFncz0ib3B0aW1pemU9XCIkb3B0XCIiCgkJCQlvcF9j
  ZmxhZ3M9Im9wdGltaXplPVwiJG9wdFwiIgoJCQkJcGVybG1haW5fY2ZsYWdzPSJvcHRpbWl6ZT1c
  IlwiIgoJCQkJOzsKCQkJZXNhYwoJCSAgICBlc2FjCgkJOzsKCSAgICBJQTY0KikKCQljYXNlICIk
  Y2N2ZXJzaW9uIiBpbgoJCSAgICBCMzkxMEIqQS4wNi4wWzEyMzQ1XSkKCQkJIyA+IGNjIC0tdmVy
  c2lvbgoJCQkjIGNjOiBIUCBhQysrL0FOU0kgQyBCMzkxMEIgQS4wNi4wNSBbSnVsIDI1IDIwMDVd
  CgkJCSMgSGFzIG9wdGltaXppbmcgcHJvYmxlbXMgd2l0aCAtTzIgYW5kIHVwIGZvciBib3RoCgkJ
  CSMgbWFpbnQgKDUuOC44KykgYW5kIGJsZWFkICg1LjkuMyspCgkJCSMgLU8xLytPMSBwYXNzZWQg
  YWxsIHRlc3RzIChtKScwNSBbIDEwIEphbiAyMDA1IF0KCQkJb3B0aW1pemU9IiRvcHQiCQkJOzsK
  CQkJQjM5MTBCKkEuMDYuMTUpCgkJCSMgPiBjYyAtLXZlcnNpb24KCQkJIyBjYzogSFAgQy9hQysr
  IEIzOTEwQiBBLjA2LjE1IFtNYXkgMTYgMjAwN10KCQkJIyBIYXMgb3B0aW1pemluZyBwcm9ibGVt
  cyB3aXRoICtPMiBmb3IgYmxlYWQgKDUuMTcuNCksCgkJCSMgc2VlIGh0dHBzOi8vcnQucGVybC5v
  cmc6NDQzL3J0My9UaWNrZXQvRGlzcGxheS5odG1sP2lkPTEwMzY2OC4KCQkJIwoJCQkjICtPMiAr
  T25vbGltaXQgK09ub3Byb2NlbGltICArT3N0b3JlX29yZGVyaW5nIFwKCQkJIyArT25vbGliY2Fs
  bHM9c3RyY21wCgkJCSMgcGFzc2VzIGFsbCB0ZXN0cyAod2l0aC93aXRob3V0IC1EREVCVUdHSU5H
  KSBbTm92IDE3IDIwMTFdCgkJCWNhc2UgIiRvcHRpbWl6ZSIgaW4KCQkJCSpPMiopIG9wdGltaXpl
  PSIkb3B0aW1pemUgK09ub3Byb2NlbGltICtPc3RvcmVfb3JkZXJpbmcgK09ub2xpYmNhbGxzPXN0
  cmNtcCIgOzsKCQkJCWVzYWMKCQkJOzsKCQkgICAgKikgIGRvb3BfY2ZsYWdzPSJvcHRpbWl6ZT1c
  IiRvcHRcIiIKCQkJb3BfY2ZsYWdzPSJvcHRpbWl6ZT1cIiRvcHRcIiIJOzsKCQkgICAgZXNhYwoJ
  CTs7CgkgICAgZXNhYwoJaWYgWyAkbWF4ZHNpeiAtbGUgNjQgXTsgdGhlbgoJICAgIHRva2VfY2Zs
  YWdzPSIkdG9rZV9jZmxhZ3M7b3B0aW1pemU9XCIkb3B0XCIiCgkgICAgcmVnZXhlY19jZmxhZ3M9
  Im9wdGltaXplPVwiJG9wdFwiIgoJICAgIGZpCglsZD0vdXNyL2Jpbi9sZAoJY2NjZGxmbGFncz0n
  K1onCglsZGRsZmxhZ3M9Jy1iICt2bm9jb21wYXR3YXJuaW5ncycKCTs7CiAgICBlc2FjCgojIyBM
  QVJHRUZJTEVTCmlmIFsgJHh4T3NSZXYgLWx0IDEwMjAgXTsgdGhlbgogICAgdXNlbGFyZ2VmaWxl
  cz0iJHVuZGVmIgogICAgZmkKCiNjYXNlICIkdXNlbGFyZ2VmaWxlcy0kY2Npc2djYyIgaW4KIyAg
  ICAiJGRlZmluZS0kZGVmaW5lInwnLWRlZmluZScpCiMJY2F0IDw8RU9NID4mNAojCiMqKiogSSdt
  IGlnbm9yaW5nIGxhcmdlIGZpbGVzIGZvciB0aGlzIGJ1aWxkIGJlY2F1c2UKIyoqKiBJIGRvbid0
  IGtub3cgaG93IHRvIGRvIHVzZSBsYXJnZSBmaWxlcyBpbiBIUC1VWCB1c2luZyBnY2MuCiMKI0VP
  TQojCXVzZWxhcmdlZmlsZXM9IiR1bmRlZiIKIwk7OwojICAgIGVzYWMKCiMgT25jZSB3ZSBoYXZl
  IHRoZSBjb21waWxlciBmbGFncyBkZWZpbmVkLCBDb25maWd1cmUgd2lsbAojIGV4ZWN1dGUgdGhl
  IGZvbGxvd2luZyBjYWxsLWJhY2sgc2NyaXB0LiBTZWUgaGludHMvUkVBRE1FLmhpbnRzCiMgZm9y
  IGRldGFpbHMuCmNhdCA+IFVVL2NjLmNidSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS9jYy5j
  YnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUgYWZ0ZXIgaXQKIyBoYXMgcHJv
  bXB0ZWQgdGhlIHVzZXIgZm9yIHRoZSBDIGNvbXBpbGVyIHRvIHVzZS4KCiMgQ29tcGlsZSBhbmQg
  cnVuIHRoZSBhIHRlc3QgY2FzZSB0byBzZWUgaWYgYSBjZXJ0YWluIGdjYyBidWcgaXMKIyBwcmVz
  ZW50LiBJZiBzbywgbG93ZXIgdGhlIG9wdGltaXphdGlvbiBsZXZlbCB3aGVuIGNvbXBpbGluZwoj
  IHBwX3BhY2suYy4gIFRoaXMgd29ya3MgYXJvdW5kIGEgYnVnIGluIHVucGFjay4KCmlmIHRlc3Qg
  LXogIiRjY2lzZ2NjIiAtYSAteiAiJGdjY3ZlcnNpb24iOyB0aGVuCiAgICA6IG5vIHRlc3RzIG5l
  ZWRlZCBmb3IgSFBjCmVsc2UKICAgIGVjaG8gIiAiCiAgICBlY2hvICJUZXN0aW5nIGZvciBhIGNl
  cnRhaW4gZ2NjIGJ1ZyBpcyBmaXhlZCBpbiB5b3VyIGNvbXBpbGVyLi4uIgoKICAgICMgVHJ5IGNv
  bXBpbGluZyB0aGUgdGVzdCBjYXNlLgogICAgaWYgJGNjIC1vIHQwMDEgLU8gJGNjZmxhZ3MgJGxk
  ZmxhZ3MgLWxtIC4uL2hpbnRzL3QwMDEuYzsgdGhlbgogICAgICAgZ2NjYnVnPWAkcnVuIC4vdDAw
  MWAKICAgICAgIGNhc2UgIiRnY2NidWciIGluCiAgICAgICAgICAgKmZhaWxzKikKICAgICAgICAg
  ICAgICAgY2F0ID4mNCA8PEVPRgpUaGlzIEMgY29tcGlsZXIgKCRnY2N2ZXJzaW9uKSBpcyBrbm93
  biB0byBoYXZlIG9wdGltaXplcgpwcm9ibGVtcyB3aGVuIGNvbXBpbGluZyBwcF9wYWNrLmMuCgpE
  aXNhYmxpbmcgb3B0aW1pemF0aW9uIGZvciBwcF9wYWNrLmMuCkVPRgogICAgICAgICAgICAgICBj
  YXNlICIkcHBfcGFja19jZmxhZ3MiIGluCiAgICAgICAgICAgICAgICAgICAnJykgcHBfcGFja19j
  ZmxhZ3M9J29wdGltaXplPScKICAgICAgICAgICAgICAgICAgICAgICBlY2hvICJwcF9wYWNrX2Nm
  bGFncz0nb3B0aW1pemU9XCJcIiciID4+IGNvbmZpZy5zaCA7OwogICAgICAgICAgICAgICAgICAg
  KikgIGVjaG8gIllvdSBzcGVjaWZpZWQgcHBfcGFja19jZmxhZ3MgeW91cnNlbGYsIHNvIHdlJ2xs
  IGdvIHdpdGggeW91ciB2YWx1ZS4iID4mNCA7OwogICAgICAgICAgICAgICAgICAgZXNhYwogICAg
  ICAgICAgICAgICA7OwogICAgICAgICAgICopICBlY2hvICJZb3VyIGNvbXBpbGVyIGlzIG9rLiIg
  PiY0CiAgICAgICAgICAgICAgIDs7CiAgICAgICAgICAgZXNhYwogICAgZWxzZQogICAgICAgZWNo
  byAiICIKICAgICAgIGVjaG8gIioqKiBXSE9BIFRIRVJFISEhICoqKiIgPiY0CiAgICAgICBlY2hv
  ICIgICAgWW91ciBDIGNvbXBpbGVyIFwiJGNjXCIgZG9lc24ndCBzZWVtIHRvIGJlIHdvcmtpbmch
  IiA+JjQKICAgICAgIGNhc2UgIiRrbm93aXRhbGwiIGluCiAgICAgICAgICAgJycpIGVjaG8gIiAg
  ICBZb3UnZCBiZXR0ZXIgc3RhcnQgaHVudGluZyBmb3Igb25lIGFuZCBsZXQgbWUga25vdyBhYm91
  dCBpdC4iID4mNAogICAgICAgICAgICAgICBleGl0IDEKICAgICAgICAgICAgICAgOzsKICAgICAg
  ICAgICBlc2FjCiAgICAgICBmaQoKICAgIHJtIC1mIHQwMDEkX28gdDAwMSRfZXhlCiAgICBmaQpF
  T0NCVQoKY2F0ID5jb25maWcuYXJjaCA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS9jb25maWcu
  YXJjaCB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZSBhZnRlcgojIGFsbCBvdGhl
  ciBjb25maWd1cmF0aW9ucyBhcmUgZG9uZSBqdXN0IGJlZm9yZSBjb25maWcuaCBpcyBnZW5lcmF0
  ZWQKY2FzZSAiJGFyY2huYW1lOiRvcHRpbWl6ZSIgaW4KICBQQSo6Ki1nKlstK11PKnxQQSo6Klst
  K11PKi1nKikKICAgIGNhc2UgIiRjY2ZsYWdzIiBpbgogICAgICAqREQ2NCopIDs7CiAgICAgICop
  IGNhc2UgIiRjY3ZlcnNpb24iIGluCgkgICMgT25seSBvbiBQQS1SSVNDLiBCMzkxMEIgKGFDQykg
  aXMgbm90IGZhdWx0eQoJICAjIEIuMTEuKiBhbmQgQS4xMC4qIGFyZQoJICBbQUJdLjEqKQoJICAg
  ICAgIyBjYzogZXJyb3IgMTQxNDogQ2FuJ3QgaGFuZGxlIHByZXByb2Nlc3NlZCBmaWxlIGZvby5p
  IGlmIC1nIGFuZCAtTyBzcGVjaWZpZWQuCgkgICAgICBlY2hvICJIUC1VWCBDLUFOU0ktQyBvbiBQ
  QS1SSVNDIGRvZXMgbm90IGFjY2VwdCBib3RoIC1nIGFuZCAtTyBvbiBwcmVwcm9jZXNzZWQgZmls
  ZXMiID4mNAoJICAgICAgZWNobyAid2hlbiBjb21waWxpbmcgaW4gMzJiaXQgbW9kZS4gVGhlIG9w
  dGltaXplciB3aWxsIGJlIGRpc2FibGVkLiIgPiY0CgkgICAgICBvcHRpbWl6ZT1gZWNobyAiJG9w
  dGltaXplIiB8IHNlZCAtZSAncy9bLStdT1swLTldKi8vJyAtZSAncy8rT25vbGltaXQvLycgLWUg
  J3MvXiAqLy8nYAoJICAgICAgOzsKCSAgZXNhYwogICAgICBlc2FjCiAgZXNhYwpFT0NCVQoKY2F0
  ID5VVS91c2VsYXJnZWZpbGVzLmNidSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS91c2VsYXJn
  ZWZpbGVzLmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZQojIGFmdGVyIGl0
  IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgbGFyZ2UgZmlsZXMuCgpj
  YXNlICIkYXJjaG5hbWU6JHVzZTY0Yml0YWxsOiR1c2U2NGJpdGludCIgaW4KICAgICotTFA2NCo6
  dW5kZWY6ZGVmaW5lKQoJYXJjaG5hbWU9YGVjaG8gIiRhcmNobmFtZSIgfCBzZWQgJ3MvLUxQNjQv
  LTY0aW50LydgCgllY2hvICJBcmNobmFtZSBjaGFuZ2VkIHRvICRhcmNobmFtZSIKCTs7CiAgICBl
  c2FjCgpjYXNlICIkdXNlbGFyZ2VmaWxlcyIgaW4KICAgICIifCRkZWZpbmV8dHJ1ZXxbeVldKikK
  CSMgdGhlcmUgYXJlIGxhcmdlZmlsZSBmbGFncyBhdmFpbGFibGUgdmlhIGdldGNvbmYoMSkKCSMg
  YnV0IHdlIGNoZWF0IGZvciBub3cuICAoS2VlcCB0aGF0IGluIHRoZSBsZWZ0IG1hcmdpbi4pCmNj
  ZmxhZ3NfdXNlbGFyZ2VmaWxlcz0iLURfTEFSR0VGSUxFX1NPVVJDRSAtRF9GSUxFX09GRlNFVF9C
  SVRTPTY0IgoKCWNhc2UgIiAkY2NmbGFncyAiIGluCgkqIiAkY2NmbGFnc191c2VsYXJnZWZpbGVz
  ICIqKSA7OwoJKikgY2NmbGFncz0iJGNjZmxhZ3MgJGNjZmxhZ3NfdXNlbGFyZ2VmaWxlcyIgOzsK
  CWVzYWMKCglpZiB0ZXN0IC16ICIkY2Npc2djYyIgLWEgLXogIiRnY2N2ZXJzaW9uIjsgdGhlbgoJ
  ICAgICMgVGhlIHN0cmljdCBBTlNJIG1vZGUgKC1BYSkgZG9lc24ndCBsaWtlIGxhcmdlIGZpbGVz
  LgoJICAgIGNjZmxhZ3M9YGVjaG8gIiAkY2NmbGFncyAifHNlZCAnc0AgLUFhIEAgQGcnYAoJICAg
  IGNhc2UgIiRjY2ZsYWdzIiBpbgoJCSotQWUqKSA7OwoJCSopICAgICBjY2ZsYWdzPSIkY2NmbGFn
  cyAtQWUiIDs7CgkJZXNhYwoJICAgIGZpCgk7OwogICAgZXNhYwpFT0NCVQoKIyBUSFJFQURJTkcK
  CiMgVGhpcyBzY3JpcHQgVVUvdXNldGhyZWFkcy5jYnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBi
  eSBDb25maWd1cmUKIyBhZnRlciBpdCBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9yIHdoZXRoZXIg
  dG8gdXNlIHRocmVhZHMuCmNhdCA+VVUvdXNldGhyZWFkcy5jYnUgPDwnRU9DQlUnCmNhc2UgIiR1
  c2V0aHJlYWRzIiBpbgogICAgJGRlZmluZXx0cnVlfFt5WV0qKQoJaWYgWyAiJHh4T3NSZXZNYWpv
  ciIgLWx0IDEwIF07IHRoZW4KCSAgICBjYXQgPDxFT00gPiY0CgpIUC1VWCAkeHhPc1Jldk1ham9y
  IGNhbm5vdCBzdXBwb3J0IFBPU0lYIHRocmVhZHMuCkNvbnNpZGVyIHVwZ3JhZGluZyB0byBhdCBs
  ZWFzdCBIUC1VWCAxMS4KQ2Fubm90IGNvbnRpbnVlLCBhYm9ydGluZy4KRU9NCgkgICAgZXhpdCAx
  CgkgICAgZmkKCglpZiBbICIkeHhPc1Jldk1ham9yIiAtZXEgMTAgXTsgdGhlbgoJICAgICMgVW5k
  ZXIgMTAuWCwgYSB0aHJlYWRlZCBwZXJsIGNhbiBiZSBidWlsdAoJICAgIGlmIFsgLWYgL3Vzci9p
  bmNsdWRlL3B0aHJlYWQuaCBdOyB0aGVuCgkJaWYgWyAtZiAvdXNyL2xpYi9saWJjbWEuc2wgXTsg
  dGhlbgoJCSAgICAjIERDRSAoZnJvbSBDb3JlIE9TIENEKSBpcyBpbnN0YWxsZWQKCgkJICAgIyBD
  aGVjayBpZiBpdCBpcyBwcmlzdGluZSwgb3IgcGF0Y2hlZAoJCSAgIGNtYXZzbj1gd2hhdCAvdXNy
  L2xpYi9saWJjbWEuc2wgMj4mMSB8IGdyZXAgMTk5NmAKCQkgICBpZiBbICEgLXogIiRjbWF2c24i
  IF07IHRoZW4KCQkgICAgICAgY2F0IDw8RU9NID4mNAoHCioqKioqKioqKioqKioqKioqKioqKioq
  KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKgoKUGVy
  bCB3aWxsIHN1cHBvcnQgdGhyZWFkaW5nIHRocm91Z2ggL3Vzci9saWIvbGliY21hLnNsIGZyb20K
  dGhlIEhQIERDRSBwYWNrYWdlLCBidXQgdGhlIHZlcnNpb24gZm91bmQgaXMgdG9vIG9sZCB0byBi
  ZQpyZWxpYWJsZS4KCklmIHlvdSBhcmUgbm90IGRlcGVuZGluZyBvbiB0aGlzIHNwZWNpZmljIHZl
  cnNpb24gb2YgdGhlIGxpYnJhcnksCmNvbnNpZGVyIHRvIHVwZ3JhZGUgdXNpbmcgcGF0Y2ggUEhT
  U18yMzY3MiAocmVhZCBSRUFETUUuaHB1eCkKCioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
  KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKgoKKHNsZWVwaW5n
  IGZvciAxMCBzZWNvbmRzLi4uKQpFT00KCQkgICAgICAgc2xlZXAgMTAKCQkgICAgICAgZmkKCgkJ
  ICAgICMgSXQgbmVlZHMgIyBsaWJjbWEgYW5kIE9MRF9QVEhSRUFEU19BUEkuIEFsc28KCQkgICAg
  IyA8cHRocmVhZC5oPiBuZWVkcyB0byBiZSAjaW5jbHVkZWQgYmVmb3JlIGFueQoJCSAgICAjIG90
  aGVyIGluY2x1ZGVzIChpbiBwZXJsLmgpCgoJCSAgICAjIEhQLVVYIDEwLlggdXNlcyB0aGUgb2xk
  IHB0aHJlYWRzIEFQSQoJCSAgICBkX29sZHB0aHJlYWRzPSIkZGVmaW5lIgoKCQkgICAgIyBpbmNs
  dWRlIGxpYmNtYSBiZWZvcmUgYWxsIHRoZSBvdGhlcnMKCQkgICAgbGlic3dhbnRlZD0iY21hICRs
  aWJzd2FudGVkIgoKCQkgICAgIyB0ZWxsIHBlcmwuaCB0byBpbmNsdWRlIDxwdGhyZWFkLmg+IGJl
  Zm9yZSBvdGhlcgoJCSAgICAjIGluY2x1ZGUgZmlsZXMKCQkgICAgY2NmbGFncz0iJGNjZmxhZ3Mg
  LURQVEhSRUFEX0hfRklSU1QiCiMgRmlyc3QgY29sdW1uIG9uIHB1cnBvc2U6CiMgdGhpcyBpcyBu
  b3QgYSBzdGFuZGFyZCBDb25maWd1cmUgdmFyaWFibGUKIyBidXQgd2UgbmVlZCB0byBnZXQgdGhp
  cyBub3RpY2VkLgpwdGhyZWFkX2hfZmlyc3Q9IiRkZWZpbmUiCgoJCSAgICAjIEhQLVVYIDEwLlgg
  c2VlbXMgdG8gaGF2ZSBubyBlYXN5CgkJICAgICMgd2F5IG9mIGRldGVjdGluZyB0aGVzZSAqdGlt
  ZV9yIHByb3Rvcy4KCQkgICAgZF9nbXRpbWVfcl9wcm90bz0nZGVmaW5lJwoJCSAgICBnbXRpbWVf
  cl9wcm90bz0nUkVFTlRSQU5UX1BST1RPX0lfVFMnCgkJICAgIGRfbG9jYWx0aW1lX3JfcHJvdG89
  J2RlZmluZScKCQkgICAgbG9jYWx0aW1lX3JfcHJvdG89J1JFRU5UUkFOVF9QUk9UT19JX1RTJwoK
  CQkgICAgIyBBdm9pZCB0aGUgcG9pc29ub3VzIGNvbmZsaWN0aW5nIChhbmQgaXJyZWxldmFudCkK
  CQkgICAgIyBwcm90b3R5cGVzIG9mIHNldGtleSAoKS4KCQkgICAgaV9jcnlwdD0iJHVuZGVmIgoK
  CQkgICAgIyBDTUEgcmVkZWZpbmVzIHNlbGVjdCB0byBjbWFfc2VsZWN0LCBhbmQgY21hX3NlbGVj
  dAoJCSAgICAjIGV4cGVjdHMgaW50ICogaW5zdGVhZCBvZiBmZF9zZXQgKiAoanVzdCBsaWtlIDku
  WCkKCQkgICAgc2VsZWN0dHlwZT0naW50IConCgoJCWVsaWYgWyAtZiAvdXNyL2xpYi9saWJwdGhy
  ZWFkLnNsIF07IHRoZW4KCQkgICAgIyBQVEggcGFja2FnZSBpcyBpbnN0YWxsZWQKCQkgICAgbGli
  c3dhbnRlZD0icHRocmVhZCAkbGlic3dhbnRlZCIKCQllbHNlCgkJICAgIGxpYnN3YW50ZWQ9Im5v
  X3RocmVhZHNfYXZhaWxhYmxlIgoJCSAgICBmaQoJICAgIGVsc2UKCQlsaWJzd2FudGVkPSJub190
  aHJlYWRzX2F2YWlsYWJsZSIKCQlmaQoKCSAgICBpZiBbICRsaWJzd2FudGVkID0gIm5vX3RocmVh
  ZHNfYXZhaWxhYmxlIiBdOyB0aGVuCgkJY2F0IDw8RU9NID4mNAoKSW4gSFAtVVggMTAuWCBmb3Ig
  UE9TSVggdGhyZWFkcyB5b3UgbmVlZCBib3RoIG9mIHRoZSBmaWxlcwovdXNyL2luY2x1ZGUvcHRo
  cmVhZC5oIGFuZCBlaXRoZXIgL3Vzci9saWIvbGliY21hLnNsIG9yIC91c3IvbGliL2xpYnB0aHJl
  YWQuc2wuCkVpdGhlciB5b3UgbXVzdCB1cGdyYWRlIHRvIEhQLVVYIDExIG9yIGluc3RhbGwgYSBw
  b3NpeCB0aHJlYWQgbGlicmFyeToKCiAgICBEQ0UtQ29yZVRvb2xzIGZyb20gSFAtVVggMTAuMjAg
  SGFyZHdhcmUgRXh0ZW5zaW9ucyAzLjAgQ0QgKEIzOTIwLTEzOTQxKQoKb3IKCiAgICBQVEggcGFj
  a2FnZSBmcm9tIGUuZy4gaHR0cDovL2hwdXguY29ubmVjdC5vcmcudWsvaHBwZC9ocHV4L0dudS9w
  dGgtMi4wLjcvCgpDYW5ub3QgY29udGludWUsIGFib3J0aW5nLgpFT00KCQlleGl0IDEKCQlmaQoJ
  ZWxzZQoJICAgICMgMTIgbWF5IHdhbnQgdXBwaW5nIHRoZSBfUE9TSVhfQ19TT1VSQ0UgZGF0ZXN0
  YW1wLi4uCgkgICAgY2NmbGFncz0iIC1EX1BPU0lYX0NfU09VUkNFPTE5OTUwNkwgLURfUkVFTlRS
  QU5UICRjY2ZsYWdzIgoJICAgIHNldCBgZWNobyBYICIkbGlic3dhbnRlZCAifCBzZWQgLWUgJ3Mv
  IGMgLyBwdGhyZWFkIGMgLydgCgkgICAgc2hpZnQKCSAgICBsaWJzd2FudGVkPSIkKiIKCgkgICAg
  IyBIUC1VWCAxMS5YIHNlZW1zIHRvIGhhdmUgbm8gZWFzeQoJICAgICMgd2F5IG9mIGRldGVjdGlu
  ZyB0aGVzZSAqdGltZV9yIHByb3Rvcy4KCSAgICBkX2dtdGltZV9yX3Byb3RvPSdkZWZpbmUnCgkg
  ICAgZ210aW1lX3JfcHJvdG89J1JFRU5UUkFOVF9QUk9UT19TX1RTJwoJICAgIGRfbG9jYWx0aW1l
  X3JfcHJvdG89J2RlZmluZScKCSAgICBsb2NhbHRpbWVfcl9wcm90bz0nUkVFTlRSQU5UX1BST1RP
  X1NfVFMnCgkgICAgZmkKCTs7CiAgICBlc2FjCkVPQ0JVCgojIFRoZXJlIHVzZWQgdG8gYmU6CiMg
  IFRoZSBteXN0ZXJpb3VzIGlvX3hzIG1lbW9yeSBjb3JydXB0aW9uIGluIDExLjAwIDMyYml0IHNl
  ZW1zIHRvIGdldAojICBmaXhlZCBieSBub3QgdXNpbmcgUGVybCdzIG1hbGxvYy4gIEZsaXAgc2lk
  ZSBpcyBwZXJmb3JtYW5jZSBsb3NzLgojICBTbyB3ZSB3YW50IG15bWFsbG9jIGZvciBhbGwgc2l0
  dWF0aW9ucyBwb3NzaWJsZQojIFRoYXQgc2V0IHVzZW15bWFsbG9jIHRvICduJyBmb3IgdGhyZWFk
  ZWQgYnVpbGRzIGFuZCBub24tZ2NjIDMyYml0CiMgIG5vbi1kZWJ1Z2dpbmcgYnVpbGRzIGFuZCAn
  eScgZm9yIGFsbCBvdGhlcnMKCnVzZW15bWFsbG9jPSduJwpjYXNlICIkdXNlcGVybGlvIiBpbgog
  ICAgJHVuZGVmfGZhbHNlfFtuTl0qKSB1c2VteW1hbGxvYz0neScgOzsKICAgIGVzYWMKCiMgbWFs
  bG9jIHdyYXAgd29ya3MKY2FzZSAiJHVzZW1hbGxvY3dyYXAiIGluCiAgICAnJykgdXNlbWFsbG9j
  d3JhcD0nZGVmaW5lJyA7OwogICAgZXNhYwoKIyBjdGltZV9yICgpIGFuZCBhc2N0aW1lX3IgKCkg
  c2VlbSB0byBoYXZlIGlzc3VlcyBmb3IgdmVyc2lvbnMgYmVmb3JlCiMgSFAtVVggMTEKaWYgWyAk
  eHhPc1Jldk1ham9yIC1sdCAxMSBdOyB0aGVuCiAgICBkX2N0aW1lX3I9IiR1bmRlZiIKICAgIGRf
  YXNjdGltZV9yPSIkdW5kZWYiCiAgICBmaQoKIyBmcGNsYXNzaWZ5ICgpIGlzIGEgbWFjcm8sIHRo
  ZSBsaWJyYXJ5IGNhbGwgaXMgRnBjbGFzc2lmeQojIFNpbWlsYXJseSB3aXRoIHRoZSBvdGhlcnMg
  YmVsb3cuCmRfZnBjbGFzc2lmeT0nZGVmaW5lJwpkX2lzbmFuPSdkZWZpbmUnCmRfaXNpbmY9J2Rl
  ZmluZScKZF9pc2Zpbml0ZT0nZGVmaW5lJwpkX3Vub3JkZXJlZD0nZGVmaW5lJwojIE5leHQgb25l
  KHMpIG5lZWQgdGhlIGxlYWRpbmcgdGFiLiAgVGhlc2UgYXJlIHNwZWNpYWwgJ2hpbnQnIHN5bWJv
  bHMgdGhhdAojIGFyZSBub3QgdG8gYmUgcHJvcGFnYXRlZCB0byBjb25maWcuc2gsIGFsbCByZWxh
  dGVkIHRvIHB0aHJlYWRzIGRyYWZ0IDQKIyBpbnRlcmZhY2VzLgpjYXNlICIkZF9vbGRwdGhyZWFk
  cyIgaW4KICAgICcnfCR1bmRlZikKCWRfY3J5cHRfcl9wcm90bz0ndW5kZWYnCglkX2dldGdyZW50
  X3JfcHJvdG89J3VuZGVmJwoJZF9nZXRwd2VudF9yX3Byb3RvPSd1bmRlZicKCWRfc3RyZXJyb3Jf
  cl9wcm90bz0ndW5kZWYnCgk7OwogICAgZXNhYwoKIyBILk1lcmlqbiBzYXlzIGl0J3Mgbm90IDE5
  OTggYW55bW9yZTogT0RCTSBpcyBub3QgbmVlZGVkLAojIGFuZCBpdCBzZWVtcyB0byBiZSBidWdn
  eSBpbiBIUC1VWCBhbnl3YXkuCmlfZGJtPXVuZGVmCgojIEluIEhQLVVYZXMgcHJpb3IgdG8gMTEu
  MjMgc3RydG9sZCgpIHJldHVybmVkIGEgSFAtVVgKIyBzcGVjaWZpYyB1bmlvbiBjYWxsZWQgbG9u
  Z19kb3VibGUsIG5vdCBhIEM5OSBsb25nIGRvdWJsZS4KY2FzZSAiYGdyZXAgJ2RvdWJsZSBzdHJ0
  b2xkLmNvbnN0JyAvdXNyL2luY2x1ZGUvc3RkbGliLmhgIiBpbgoqImxvbmcgZG91YmxlIHN0cnRv
  bGQiKikgOzsgIyBzdHJ0b2xkIHNob3VsZCBiZSBzYWZlLgoqKSBlY2hvICJMb29rcyBsaWtlIHlv
  dXIgc3RydG9sZCgpIGlzIG5vbi1zdGFuZGFyZC4uLiIgPiY0CiAgIGRfc3RydG9sZD11bmRlZiA7
  Owplc2FjCgojIEluIHByZS0xMSBIUC1VWGVzIHRoZXJlIHJlYWxseSBpc24ndCBpc2Zpbml0ZSgp
  LCBkZXNwaXRlIHdoYXQKIyBDb25maWd1cmUgbWlnaHQgdGhpbmsuIChUaGVyZSBpcyBmaW5pdGUo
  KSwgdGhvdWdoLikKY2FzZSAiYGdyZXAgJ2lzZmluaXRlJyAvdXNyL2luY2x1ZGUvbWF0aC5oYCIg
  aW4KKiJpc2Zpbml0ZSIqKSA7OwoqKSBkX2lzZmluaXRlPXVuZGVmIDs7CmVzYWMK','linux'=>'IyBoaW50cy9saW51eC5zaAojIE9yaWdpbmFsIHZlcnNpb24gYnkgcnNhbmRlcnMKIyBBZGRpdGlv
  bmFsIHN1cHBvcnQgYnkgS2VubmV0aCBBbGJhbm93c2tpIDxramFoZHNAa2phaGRzLmNvbT4KIwoj
  IEVMRiBzdXBwb3J0IGJ5IEguSi4gTHUgPGhqbEBueW5leHN0LmNvbT4KIyBBZGRpdGlvbmFsIGlu
  Zm8gZnJvbSBOaWdlbCBIZWFkIDxuaGVhZEBFU09DLmJpdG5ldD4KIyBhbmQgS2VubmV0aCBBbGJh
  bm93c2tpIDxramFoZHNAa2phaGRzLmNvbT4KIwojIENvbnNvbGlkYXRlZCBieSBBbmR5IERvdWdo
  ZXJ0eSA8ZG91Z2hlcmFAbGFmYXlldHRlLmVkdT4KIwojIFVwZGF0ZWQgVGh1IEZlYiAgOCAxMTo1
  NjoxMCBFU1QgMTk5NgoKIyBVcGRhdGVkIFRodSBNYXkgMzAgMTA6NTA6MjIgRURUIDE5OTYgYnkg
  PGRvdWdoZXJhQGxhZmF5ZXR0ZS5lZHU+CgojIFVwZGF0ZWQgRnJpIEp1biAyMSAxMTowNzo1NCBF
  RFQgMTk5NgojIE5EQk0gc3VwcG9ydCBmb3IgRUxGIHJlLWVuYWJsZWQgYnkgPGtqYWhkc0BramFo
  ZHMuY29tPgoKIyBObyB2ZXJzaW9uIG9mIExpbnV4IHN1cHBvcnRzIHNldHVpZCBzY3JpcHRzLgpk
  X3N1aWRzYWZlPSd1bmRlZicKCiMgTm8gdmVyc2lvbiBvZiBMaW51eCBuZWVkcyBsaWJ1dGlsIGZv
  ciBwZXJsLgppX2xpYnV0aWw9J3VuZGVmJwoKIyBEZWJpYW4gYW5kIFJlZCBIYXQsIGFuZCBwZXJo
  YXBzIG90aGVyIHZlbmRvcnMsIHByb3ZpZGUgYm90aCBydW50aW1lIGFuZAojIGRldmVsb3BtZW50
  IHBhY2thZ2VzIGZvciBzb21lIGxpYnJhcmllcy4gIFRoZSBydW50aW1lIHBhY2thZ2VzIGNvbnRh
  aW4gc2hhcmVkCiMgbGlicmFyaWVzIHdpdGggdmVyc2lvbiBpbmZvcm1hdGlvbiBpbiB0aGVpciBu
  YW1lcyAoZS5nLiwgbGliZ2RibS5zby4xLjcuMyk7CiMgdGhlIGRldmVsb3BtZW50IHBhY2thZ2Vz
  IHN1cHBsZW1lbnQgdGhpcyB3aXRoIHZlcnNpb25sZXNzIHNoYXJlZCBsaWJyYXJpZXMKIyAoZS5n
  LiwgbGliZ2RibS5zbykuCiMKIyBJZiB5b3Ugd2FudCB0byBsaW5rIGFnYWluc3Qgc3VjaCBhIGxp
  YnJhcnksIHlvdSBtdXN0IGluc3RhbGwgdGhlIGRldmVsb3BtZW50CiMgdmVyc2lvbiBvZiB0aGUg
  cGFja2FnZS4KIwojIFRoZXNlIHBhY2thZ2VzIHVzZSBhIC1kZXYgbmFtaW5nIGNvbnZlbnRpb24g
  aW4gYm90aCBEZWJpYW4gYW5kIFJlZCBIYXQ6CiMgICBsaWJnZGJtZzEgIChub24tZGV2ZWxvcG1l
  bnQgdmVyc2lvbiBvZiBHTlUgbGliYyAyLWxpbmtlZCBHREJNIGxpYnJhcnkpCiMgICBsaWJnZGJt
  ZzEtZGV2IChkZXZlbG9wbWVudCB2ZXJzaW9uIG9mIEdOVSBsaWJjIDItbGlua2VkIEdEQk0gbGli
  cmFyeSkKIyBTbyBtYWtlIHN1cmUgdGhhdCBmb3IgYW55IGxpYnJhcmllcyB5b3Ugd2lzaCB0byBs
  aW5rIFBlcmwgd2l0aCB1bmRlcgojIERlYmlhbiBvciBSZWQgSGF0IHlvdSBoYXZlIHRoZSAtZGV2
  IHBhY2thZ2VzIGluc3RhbGxlZC4KCiMgU3VTRSBMaW51eCBjYW4gYmUgdXNlZCBhcyBjcm9zcy1j
  b21waWxhdGlvbiBob3N0IGZvciBDcmF5IFhUNCBDYXRhbW91bnQvUWsuCmlmIHRlc3QgLWQgL29w
  dC94dC1wZQp0aGVuCiAgY2FzZSAiYCR7Y2M6LWNjfSAtViAyPiYxYCIgaW4KICAqY2F0YW1vdW50
  KikgLiBoaW50cy9jYXRhbW91bnQuc2g7IHJldHVybiA7OwogIGVzYWMKZmkKCiMgU29tZSBvcGVy
  YXRpbmcgc3lzdGVtcyAoZS5nLiwgU29sYXJpcyAyLjYpIHdpbGwgbGluayB0byBhIHZlcnNpb25l
  ZCBzaGFyZWQKIyBsaWJyYXJ5IGltcGxpY2l0bHkuICBGb3IgZXhhbXBsZSwgb24gU29sYXJpcywg
  YGxkIGZvby5vIC1sZ2RibScgd2lsbCBmaW5kIGFuCiMgYXBwcm9wcmlhdGUgdmVyc2lvbiBvZiBs
  aWJnZGJtLCBpZiBvbmUgaXMgYXZhaWxhYmxlOyBMaW51eCwgaG93ZXZlciwgZG9lc24ndAojIGRv
  IHRoZSBpbXBsaWNpdCBtYXBwaW5nLgppZ25vcmVfdmVyc2lvbmVkX3NvbGlicz0neScKCiMgQlNE
  IGNvbXBhdGliaWxpdHkgbGlicmFyeSBubyBsb25nZXIgbmVlZGVkCiMgJ2thZmZlJyBoYXMgYSAv
  dXNyL2xpYi9saWJuZXQuc28gd2hpY2ggaXMgbm90IGF0IGFsbCByZWxldmFudCBmb3IgcGVybC4K
  IyBiaW5kIGNhdXNlcyBpc3N1ZXMgd2l0aCBzZXZlcmFsIHJlZW50cmFudCBmdW5jdGlvbnMKc2V0
  IGBlY2hvIFggIiRsaWJzd2FudGVkICJ8IHNlZCAtZSAncy8gYnNkIC8gLycgLWUgJ3MvIG5ldCAv
  IC8nIC1lICdzLyBiaW5kIC8gLydgCnNoaWZ0CmxpYnN3YW50ZWQ9IiQqIgoKIyBEZWJpYW4gNC4w
  IHB1dHMgbmRibSBpbiB0aGUgLWxnZGJtX2NvbXBhdCBsaWJyYXJ5LgplY2hvICRsaWJzCmlmIGVj
  aG8gIiAkbGlic3dhbnRlZCAiIHwgZ3JlcCAtcSAnIGdkYm0gJzsgdGhlbgogICAgIyBPbmx5IGFk
  ZCBpZiBnZGJtIGlzIGluIGxpYnN3YW50ZWQuCiAgICBsaWJzd2FudGVkPSIkbGlic3dhbnRlZCBn
  ZGJtX2NvbXBhdCIKZmkKCiMgQ29uZmlndXJlIG1heSBmYWlsIHRvIGZpbmQgbHN0YXQoKSBzaW5j
  ZSBpdCdzIGEgc3RhdGljL2lubGluZQojIGZ1bmN0aW9uIGluIDxzeXMvc3RhdC5oPi4KZF9sc3Rh
  dD1kZWZpbmUKCiMgbWFsbG9jIHdyYXAgd29ya3MKY2FzZSAiJHVzZW1hbGxvY3dyYXAiIGluCicn
  KSB1c2VtYWxsb2N3cmFwPSdkZWZpbmUnIDs7CmVzYWMKCiMgVGhlIHN5c3RlbSBtYWxsb2MoKSBp
  cyBhYm91dCBhcyBmYXN0IGFuZCBhcyBmcnVnYWwgYXMgcGVybCdzLgojIFNpbmNlIHRoZSBzeXN0
  ZW0gbWFsbG9jKCkgaGFzIGJlZW4gdGhlIGRlZmF1bHQgc2luY2UgYXQgbGVhc3QKIyA1LjAwMSwg
  d2UgbWlnaHQgYXMgd2VsbCBsZWF2ZSBpdCB0aGF0IHdheS4gIC0tQUQgIDEwIEphbiAyMDAyCmNh
  c2UgIiR1c2VteW1hbGxvYyIgaW4KJycpIHVzZW15bWFsbG9jPSduJyA7Owplc2FjCgp1bmFtZV9t
  aW51c19tPSJgJHJ1biB1bmFtZSAtbSAyPi9kZXYvbnVsbGAiCnVuYW1lX21pbnVzX209IiR7dW5h
  bWVfbWludXNfbTotIiR0YXJnZXRhcmNoIn0iCgojIENoZWNrIGlmIHdlJ3JlIGFib3V0IHRvIHVz
  ZSBJbnRlbCdzIElDQyBjb21waWxlcgpjYXNlICJgJHtjYzotY2N9IC1WIDI+JjFgIiBpbgoqIklu
  dGVsKFIpIEMrKyBDb21waWxlciIqfCoiSW50ZWwoUikgQyBDb21waWxlciIqKQogICAgIyByZWNv
  cmQgdGhlIHZlcnNpb24sIGZvcm1hdHM6CiAgICAjIGljYyAoSUNDKSAxMC4xIDIwMDgwODAxCiAg
  ICAjIGljcGMgKElDQykgMTAuMSAyMDA4MDgwMQogICAgIyBmb2xsb3dlZCBieSBhIGNvcHlyaWdo
  dCBvbiB0aGUgc2Vjb25kIGxpbmUKICAgIGNjdmVyc2lvbj1gJHtjYzotY2N9IC0tdmVyc2lvbiB8
  IHNlZCAtbiAtZSAncy9eaWNwXD9jIFwoKElDQykgXClcPy8vcCdgCiAgICAjIFRoaXMgaXMgbmVl
  ZGVkIGZvciBDb25maWd1cmUncyBwcm90b3R5cGUgY2hlY2tzIHRvIHdvcmsgY29ycmVjdGx5CiAg
  ICAjIFRoZSAtbXAgZmxhZyBpcyBuZWVkZWQgdG8gcGFzcyB2YXJpb3VzIGZsb2F0aW5nIHBvaW50
  IHJlbGF0ZWQgdGVzdHMKICAgICMgVGhlIC1uby1nY2MgZmxhZyBpcyBuZWVkZWQgb3RoZXJ3aXNl
  LCBpY2MgcHJldGVuZHMgKHBvb3JseSkgdG8gYmUgZ2NjCiAgICBjY2ZsYWdzPSItd2UxNDcgLW1w
  IC1uby1nY2MgJGNjZmxhZ3MiCiAgICAjIFByZXZlbnQgcmVsb2NhdGlvbiBlcnJvcnMgb24gNjRi
  aXRzIGFyY2gKICAgIGNhc2UgIiR1bmFtZV9taW51c19tIiBpbgoJKmlhNjQqfCp4ODZfNjQqKQoJ
  ICAgIGNjY2RsZmxhZ3M9Jy1mUElDJwoJOzsKICAgIGVzYWMKICAgICMgSWYgd2UncmUgdXNpbmcg
  SUNDLCB3ZSB1c3VhbGx5IHdhbnQgdGhlIGJlc3QgcGVyZm9ybWFuY2UKICAgIGNhc2UgIiRvcHRp
  bWl6ZSIgaW4KICAgICcnKSBvcHRpbWl6ZT0nLU8zJyA7OwogICAgZXNhYwogICAgOzsKKiIgU3Vu
  ICIqIkMiKikKICAgICMgU3VuJ3MgQyBjb21waWxlciwgd2hpY2ggbWlnaHQgaGF2ZSBhICd0YWcn
  IG5hbWUgYmV0d2VlbgogICAgIyAnU3VuJyBhbmQgdGhlICdDJzogIEV4YW1wbGVzOgogICAgIyBj
  YzogU3VuIEMgNS45IExpbnV4X2kzODYgUGF0Y2ggMTI0ODcxLTAxIDIwMDcvMDcvMzEKICAgICMg
  Y2M6IFN1biBDZXJlcyBDIDUuMTAgTGludXhfaTM4NiAyMDA4LzA3LzEwCiAgICB0ZXN0ICIkb3B0
  aW1pemUiIHx8IG9wdGltaXplPScteE8yJwogICAgY2NjZGxmbGFncz0nLUtQSUMnCiAgICBsZGRs
  ZmxhZ3M9Jy1HIC1CZHluYW1pYycKICAgICMgU3VuIEMgZG9lc24ndCBzdXBwb3J0IGdjYyBhdHRy
  aWJ1dGVzLCBidXQsIGluIG1hbnkgY2FzZXMsIGRvZXNuJ3QKICAgICMgY29tcGxhaW4gZWl0aGVy
  LiAgTm90IGFsbCBjYXNlcywgdGhvdWdoLgogICAgZF9hdHRyaWJ1dGVfZm9ybWF0PSd1bmRlZicK
  ICAgIGRfYXR0cmlidXRlX21hbGxvYz0ndW5kZWYnCiAgICBkX2F0dHJpYnV0ZV9ub25udWxsPSd1
  bmRlZicKICAgIGRfYXR0cmlidXRlX25vcmV0dXJuPSd1bmRlZicKICAgIGRfYXR0cmlidXRlX3B1
  cmU9J3VuZGVmJwogICAgZF9hdHRyaWJ1dGVfdW51c2VkPSd1bmRlZicKICAgIGRfYXR0cmlidXRl
  X3dhcm5fdW51c2VkX3Jlc3VsdD0ndW5kZWYnCiAgICA7Owplc2FjCgpjYXNlICIkb3B0aW1pemUi
  IGluCiMgdXNlIC1PMiBieSBkZWZhdWx0IDsgLU8zIGRvZXNuJ3Qgc2VlbSB0byBicmluZyBzaWdu
  aWZpY2FudCBiZW5lZml0cyB3aXRoIGdjYwonJykKICAgIG9wdGltaXplPSctTzInCiAgICBjYXNl
  ICIkdW5hbWVfbWludXNfbSIgaW4KICAgICAgICBwcGMqKQogICAgICAgICAgICAjIG9uIHBwYywg
  aXQgc2VlbXMgdGhhdCBnY2MgKGF0IGxlYXN0IGdjYyAzLjMuMikgaXNuJ3QgaGFwcHkKICAgICAg
  ICAgICAgIyB3aXRoIC1PMiA7IHNvIGRvd25ncmFkZSB0byAtTzEuCiAgICAgICAgICAgIG9wdGlt
  aXplPSctTzEnCiAgICAgICAgOzsKICAgICAgICBpYTY0KikKICAgICAgICAgICAgIyBUaGlzIGFy
  Y2hpdGVjdHVyZSBoYXMgaGFkIHZhcmlvdXMgcHJvYmxlbXMgd2l0aCBnY2MncwogICAgICAgICAg
  ICAjIGluIHRoZSAzLjIsIDMuMywgYW5kIDMuNCByZWxlYXNlcyB3aGVuIG9wdGltaXplZCB0byAt
  TzIuICBTZWUKICAgICAgICAgICAgIyBSVCAjMzcxNTYgZm9yIGEgZGlzY3Vzc2lvbiBvZiB0aGUg
  cHJvYmxlbS4KICAgICAgICAgICAgY2FzZSAiYCR7Y2M6LWdjY30gLXYgMj4mMWAiIGluCiAgICAg
  ICAgICAgICoidmVyc2lvbiAzLjIiKnwqInZlcnNpb24gMy4zIip8KiJ2ZXJzaW9uIDMuNCIqKQog
  ICAgICAgICAgICAgICAgY2NmbGFncz0iLWZuby1kZWxldGUtbnVsbC1wb2ludGVyLWNoZWNrcyAk
  Y2NmbGFncyIKICAgICAgICAgICAgOzsKICAgICAgICAgICAgZXNhYwogICAgICAgIDs7CiAgICBl
  c2FjCiAgICA7Owplc2FjCgojIFVidW50dSAxMS4wNCAoYW5kIGxhdGVyLCBwcmVzdW1hYmx5KSBk
  b2Vzbid0IGtlZXAgbW9zdCBsaWJyYXJpZXMKIyAoc3VjaCBhcyAtbG0pIGluIC9saWIgb3IgL3Vz
  ci9saWIuICBTbyB3ZSBoYXZlIHRvIGFzayBnY2MgdG8gdGVsbCB1cwojIHdoZXJlIHRvIGxvb2su
  ICBXZSBkb24ndCB3YW50IGdjYydzIG93biBsaWJyYXJpZXMsIGhvd2V2ZXIsIHNvIHdlCiMgZmls
  dGVyIHRob3NlIG91dC4KIyBUaGlzIGNvdWxkIGJlIGNvbmRpdGlvbmFsIG9uIFVuYnVudHUsIGJ1
  dCBvdGhlciBkaXN0cmlidXRpb25zIG1heQojIGZvbGxvdyBzdWl0LCBhbmQgdGhpcyBzY2hlbWUg
  c2VlbXMgdG8gd29yayBldmVuIG9uIHJhdGhlciBvbGQgZ2NjJ3MuCiMgVGhpcyB1bmNvbmRpdGlv
  bmFsbHkgdXNlcyBnY2MgYmVjYXVzZSBldmVuIGlmIHRoZSB1c2VyIGlzIHVzaW5nIGFub3RoZXIK
  IyBjb21waWxlciwgd2Ugc3RpbGwgbmVlZCB0byBmaW5kIHRoZSBtYXRoIGxpYnJhcnkgYW5kIGZy
  aWVuZHMsIGFuZCBJIGRvbid0CiMga25vdyBob3cgb3RoZXIgY29tcGlsZXJzIHdpbGwgY29wZSB3
  aXRoIHRoYXQgc2l0dWF0aW9uLgojIE1vcmV2ZXIsIGlmIHRoZSB1c2VyIGhhcyB0aGVpciBvd24g
  Z2NjIGVhcmxpZXIgaW4gJFBBVEggdGhhbiB0aGUgc3lzdGVtIGdjYywKIyB3ZSBkb24ndCB3YW50
  IGl0cyBsaWJyYXJpZXMuIFNvIHdlIHRyeSB0byBwcmVmZXIgdGhlIHN5c3RlbSBnY2MKIyBTdGls
  bCwgYXMgYW4gZXNjYXBlIGhhdGNoLCBhbGxvdyBDb25maWd1cmUgY29tbWFuZCBsaW5lIG92ZXJy
  aWRlcyB0bwojIHBsaWJwdGggdG8gYnlwYXNzIHRoaXMgY2hlY2suCmlmIFsgLXggL3Vzci9iaW4v
  Z2NjIF0gOyB0aGVuCiAgICBnY2M9L3Vzci9iaW4vZ2NjCmVsc2UKICAgIGdjYz1nY2MKZmkKCmNh
  c2UgIiRwbGlicHRoIiBpbgonJykgcGxpYnB0aD1gTEFORz1DIExDX0FMTD1DICRnY2MgJGNjZmxh
  Z3MgJGxkZmxhZ3MgLXByaW50LXNlYXJjaC1kaXJzIHwgZ3JlcCBsaWJyYXJpZXMgfAoJY3V0IC1m
  Mi0gLWQ9IHwgdHIgJzonICR0cm5sIHwgZ3JlcCAtdiAnZ2NjJyB8IHNlZCAtZSAnczovJDo6J2AK
  ICAgIHNldCBYICRwbGlicHRoICMgQ29sbGFwc2UgYWxsIGVudHJpZXMgb24gb25lIGxpbmUKICAg
  IHNoaWZ0CiAgICBwbGlicHRoPSIkKiIKICAgIDs7CmVzYWMKCiMgbGlicXVhZG1hdGggaXMgc29t
  ZXRpbWVzIGluc3RhbGxlZCBhcyBnY2MgaW50ZXJuYWwgbGlicmFyeSwKIyBzbyBjb250cmFyeSB0
  byBvdXIgdXN1YWwgcG9saWN5IG9mICpub3QqIGxvb2tpbmcgYXQgZ2NjIGludGVybmFsCiMgZGly
  ZWN0b3JpZXMgd2Ugbm93ICpkbyogbG9vayBhdCB0aGVtLCBpbiBjYXNlIHRoZXkgY29udGFpbgoj
  IHRoZSBxdWFkbWF0aCBsaWJyYXJ5LgojIFhYWCBUaGlzIG1heSBhcHBseSB0byBvdGhlciBnY2Mg
  aW50ZXJuYWwgbGlicmFyaWVzLCBpZiBzdWNoIGV4aXN0LgojIFhYWCBUaGlzIGNvdWxkIGJlIGF0
  IENvbmZpZ3VyZSBsZXZlbCwgYnV0IHRoZW4gdGhlICRnY2MgaXMgbWVzc3kuCmNhc2UgIiR1c2Vx
  dWFkbWF0aCIgaW4KIiRkZWZpbmUiKQogIGZvciBkIGluIGBMQU5HPUMgTENfQUxMPUMgJGdjYyAk
  Y2NmbGFncyAkbGRmbGFncyAtcHJpbnQtc2VhcmNoLWRpcnMgfCBncmVwIGxpYnJhcmllcyB8IGN1
  dCAtZjItIC1kPSB8IHRyICc6JyAkdHJubCB8IGdyZXAgJ2djYycgfCBzZWQgLWUgJ3M6LyQ6Oidg
  CiAgZG8KICAgIGNhc2UgYGxzICRkLypsaWJxdWFkbWF0aCokc28qIDI+L2Rldi9udWxsYCBpbgog
  ICAgJGQvKmxpYnF1YWRtYXRoKiRzbyopIHhsaWJwdGg9IiR4bGlicHRoICRkIiA7OwogICAgZXNh
  YwogIGRvbmUKICA7Owplc2FjCgpjYXNlICIkbGliYyIgaW4KJycpCiMgSWYgeW91IGhhdmUgZ2xp
  YmMsIHRoZW4gcmVwb3J0IHRoZSB2ZXJzaW9uIGZvciAuL215Y29uZmlnIGJ1ZyByZXBvcnRpbmcu
  CiMgKENvbmZpZ3VyZSBkb2Vzbid0IG5lZWQgdG8ga25vdyB0aGUgc3BlY2lmaWMgdmVyc2lvbiBz
  aW5jZSBpdCBqdXN0IHVzZXMKIyBnY2MgdG8gbG9hZCB0aGUgbGlicmFyeSBmb3IgYWxsIHRlc3Rz
  LikKIyBXZSBkb24ndCB1c2UgX19HTElCQ19fIGFuZCAgX19HTElCQ19NSU5PUl9fIGJlY2F1c2Ug
  dGhleQojIGFyZSBpbnN1ZmZpY2llbnRseSBwcmVjaXNlIHRvIGRpc3Rpbmd1aXNoIHRoaW5ncyBs
  aWtlCiMgbGliYy0yLjAuNiBhbmQgbGliYy0yLjAuNy4KICAgIGZvciBwIGluICRwbGlicHRoCiAg
  ICBkbwogICAgICAgIGZvciB0cnlsaWIgaW4gbGliYy5zby42IGxpYmMuc28KICAgICAgICBkbwog
  ICAgICAgICAgICBpZiAkdGVzdCAtZSAkcC8kdHJ5bGliOyB0aGVuCiAgICAgICAgICAgICAgICBs
  aWJjPWBscyAtbCAkcC8kdHJ5bGliIHwgYXdrICd7cHJpbnQgJE5GfSdgCiAgICAgICAgICAgICAg
  ICBpZiAkdGVzdCAiWCRsaWJjIiAhPSBYOyB0aGVuCiAgICAgICAgICAgICAgICAgICAgYnJlYWsK
  ICAgICAgICAgICAgICAgIGZpCiAgICAgICAgICAgIGZpCiAgICAgICAgZG9uZQogICAgICAgIGlm
  ICR0ZXN0ICJYJGxpYmMiICE9IFg7IHRoZW4KICAgICAgICAgICAgYnJlYWsKICAgICAgICBmaQog
  ICAgZG9uZQogICAgOzsKZXNhYwoKaWYgJHtzaDotL2Jpbi9zaH0gLWMgZXhpdDsgdGhlbgogIGVj
  aG8gJycKICBlY2hvICdZb3UgYXBwZWFyIHRvIGhhdmUgYSB3b3JraW5nIGJhc2guICBHb29kLicK
  ZWxzZQogIGNhdCA8PCAnRU9NJyA+JjQKCioqKioqKioqKioqKioqKioqKioqKioqIFdhcm5pbmch
  ICoqKioqKioqKioqKioqKioqKioqKgpJdCB3b3VsZCBhcHBlYXIgeW91IGhhdmUgYSBkZWZlY3Rp
  dmUgYmFzaCBzaGVsbCBpbnN0YWxsZWQuIFRoaXMgaXMgbGlrZWx5IHRvCmdpdmUgeW91IGEgZmFp
  bHVyZSBvZiBvcC9leGVjIHRlc3QgIzUgZHVyaW5nIHRoZSB0ZXN0IHBoYXNlIG9mIHRoZSBidWls
  ZCwKVXBncmFkaW5nIHRvIGEgcmVjZW50IHZlcnNpb24gKDEuMTQuNCBvciBsYXRlcikgc2hvdWxk
  IGZpeCB0aGUgcHJvYmxlbS4KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
  KioqKioqKioqKioqKioqCkVPTQoKZmkKCiMgT24gU1BBUkNsaW51eCwKIyBUaGUgZm9sbG93aW5n
  IGNzaCBjb25zaXN0ZW50bHkgY29yZWR1bXBlZCBpbiB0aGUgdGVzdCBkaXJlY3RvcnkKIyAiL2hv
  bWUvbWlrZWRsci9wZXJsNS4wMDNfOTQvdCIsIHRob3VnaCBub3QgbW9zdCBvdGhlciBkaXJlY3Rv
  cmllcy4KCiNOYW1lICAgICAgICA6IGNzaCAgICAgICAgICAgICAgICAgICAgRGlzdHJpYnV0aW9u
  OiBSZWQgSGF0IExpbnV4IChSZW1icmFuZHQpCiNWZXJzaW9uICAgICA6IDUuMi42ICAgICAgICAg
  ICAgICAgICAgICAgICAgVmVuZG9yOiBSZWQgSGF0IFNvZnR3YXJlCiNSZWxlYXNlICAgICA6IDMg
  ICAgICAgICAgICAgICAgICAgICAgICBCdWlsZCBEYXRlOiBGcmkgTWF5IDI0IDE5OjQyOjE0IDE5
  OTYKI0luc3RhbGwgZGF0ZTogVGh1IEp1bCAxMSAxNjoyMDoxNCAxOTk2IEJ1aWxkIEhvc3Q6IGl0
  Y2h5LnJlZGhhdC5jb20KI0dyb3VwICAgICAgIDogU2hlbGxzICAgICAgICAgICAgICAgICAgIFNv
  dXJjZSBSUE06IGNzaC01LjIuNi0zLnNyYy5ycG0KI1NpemUgICAgICAgIDogMTg0NDE3CiNEZXNj
  cmlwdGlvbiA6IEJTRCBjLXNoZWxsCgojIEZvciB0aGlzIHJlYXNvbiBJIHN1Z2dlc3QgdXNpbmcg
  dGhlIG11Y2ggYnVnLWZpeGVkIHRjc2ggZm9yIGdsb2JiaW5nCiMgd2hlcmUgYXZhaWxhYmxlLgoK
  IyBOb3ZlbWJlciAyMDAxOiAgVGhhdCB3YXJuaW5nJ3MgcHJldHR5IG9sZCBub3cgYW5kIHByb2Jh
  Ymx5IG5vdCBzbwojIHJlbGV2YW50LCBlc3BlY2lhbGx5IHNpbmNlIHBlcmwgbm93IHVzZXMgRmls
  ZTo6R2xvYiBmb3IgZ2xvYmJpbmcuCiMgV2UnbGwgc3RpbGwgbG9vayBmb3IgdGNzaCwgYnV0IHRv
  bmUgZG93biB0aGUgd2FybmluZ3MuCiMgQW5keSBEb3VnaGVydHksIE5vdi4gNiwgMjAwMQppZiAk
  Y3NoIC1jICdlY2hvICR2ZXJzaW9uJyA+L2Rldi9udWxsIDI+JjE7IHRoZW4KICAgIGVjaG8gJ1lv
  dXIgY3NoIGlzIHJlYWxseSB0Y3NoLiAgR29vZC4nCmVsc2UKICAgIGlmIHh4eD1gLi9VVS9sb2Mg
  dGNzaCBibHVyZmwgJHB0aGA7ICR0ZXN0IC1mICIkeHh4IjsgdGhlbgoJZWNobyAiRm91bmQgdGNz
  aC4gIEknbGwgdXNlIGl0IGZvciBnbG9iYmluZy4iCgkjIFdlIGNhbid0IGNoYW5nZSBDb25maWd1
  cmUncyBzZXR0aW5nIG9mICRjc2gsIGR1ZSB0byB0aGUgd2F5CgkjIENvbmZpZ3VyZSBoYW5kbGVz
  ICRkX3BvcnRhYmxlIGFuZCBjb21tYW5kcyBmb3VuZCBpbiAkbG9jbGlzdC4KCSMgV2UgY2FuIHNl
  dCB0aGUgdmFsdWUgZm9yIENTSCBpbiBjb25maWcuaCBieSBzZXR0aW5nIGZ1bGxfY3NoLgoJZnVs
  bF9jc2g9JHh4eAogICAgZWxpZiBbIC1mICIkY3NoIiBdOyB0aGVuCgllY2hvICJDb3VsZG4ndCBm
  aW5kIHRjc2guICBDc2gtYmFzZWQgZ2xvYmJpbmcgbWlnaHQgYmUgYnJva2VuLiIKICAgIGZpCmZp
  CgojIFNoaW1wZWkgWWFtYXNoaXRhIDxzaGltcGVpQHNvY3JhdGVzLnBhdG5ldC5jYWx0ZWNoLmVk
  dT4KIyBNZXNzYWdlLUlkOiA8MzNFRjE2MzQuQjM2QjY1MDBAcG9ib3guY29tPgojCiMgVGhlIERS
  MiBvZiBNa0xpbnV4IChvc25hbWU9bGludXgsYXJjaG5hbWU9cHBjLWxpbnV4KSBtYXkgbmVlZAoj
  IHNwZWNpYWwgZmxhZ3MgcGFzc2VkIGluIG9yZGVyIGZvciBkeW5hbWljIGxvYWRpbmcgdG8gd29y
  ay4KIyBpbnN0ZWFkIG9mIHRoZSByZWNvbW1lbmRlZDoKIwojIGNjZGxmbGFncz0nLXJkeW5hbWlj
  JwojCiMgaXQgc2hvdWxkIGJlOgojIGNjZGxmbGFncz0nLVdsLC1FJwojCiMgU28gaWYgeW91ciBE
  UjIgKERSMyBjYW1lIG91dCBzdW1tZXIgMTk5OCwgY29uc2lkZXIgdXBncmFkaW5nKQojIGhhcyBw
  cm9ibGVtcyB3aXRoIGR5bmFtaWMgbG9hZGluZywgdW5jb21tZW50IHRoZQojIGZvbGxvd2luZyB0
  aHJlZSBsaW5lcywgbWFrZSBkaXN0Y2xlYW4sIGFuZCByZS1Db25maWd1cmU6CiNjYXNlICJgdW5h
  bWUgLXIgfCBzZWQgJ3MvXlswLTkuLV0qLy8nYGBhcmNoYCIgaW4KIydvc2ZtYWNoM3BwYycpIGNj
  ZGxmbGFncz0nLVdsLC1FJyA7OwojZXNhYwoKY2FzZSAiJHVuYW1lX21pbnVzX20iIGluCnNwYXJj
  KikKCWNhc2UgIiRjY2NkbGZsYWdzIiBpbgoJKi1mcGljKikgY2NjZGxmbGFncz0iYGVjaG8gJGNj
  Y2RsZmxhZ3N8c2VkICdzLy1mcGljLy1mUElDLydgIiA7OwoJKi1mUElDKikgOzsKCSopCSBjY2Nk
  bGZsYWdzPSIkY2NjZGxmbGFncyAtZlBJQyIgOzsKCWVzYWMKCTs7CmVzYWMKCiMgU3VTRTguMiBo
  YXMgL3Vzci9saWIvbGlibmRibSogd2hpY2ggYXJlIGxkIHNjcmlwdHMgcmF0aGVyIHRoYW4KIyB0
  cnVlIGxpYnJhcmllcy4gVGhlIHNjcmlwdHMgY2F1c2UgYmluZGluZyBhZ2FpbnN0IHN0YXRpYwoj
  IHZlcnNpb24gb2YgLWxnZGJtIHdoaWNoIGlzIGEgYmFkIGlkZWEuIFNvIGlmIHdlIGhhdmUgJ25t
  JwojIG1ha2Ugc3VyZSBpdCBjYW4gcmVhZCB0aGUgZmlsZQojIE5JLVMgMjAwMy8wOC8wNwpjYXNl
  ICIkbm0iIGluCiAgICAnJykgOzsKICAgICopCiAgICBmb3IgcCBpbiAkcGxpYnB0aAogICAgZG8K
  ICAgICAgICBpZiAkdGVzdCAtciAkcC9saWJuZGJtLnNvOyB0aGVuCiAgICAgICAgICAgIGlmICRu
  bSAkcC9saWJuZGJtLnNvID4vZGV2L251bGwgMj4mMSA7IHRoZW4KICAgICAgICAgICAgICAgIGVj
  aG8gJ1lvdXIgc2hhcmVkIC1sbmRibSBzZWVtcyB0byBiZSBhIHJlYWwgbGlicmFyeS4nCiAgICAg
  ICAgICAgICAgICBfbGlibmRibV9yZWFsPTEKICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAg
  ICAgIGZpCiAgICAgICAgZmkKICAgIGRvbmUKICAgIGlmICR0ZXN0ICJYJF9saWJuZGJtX3JlYWwi
  ID0gWDsgdGhlbgogICAgICAgIGVjaG8gJ1lvdXIgc2hhcmVkIC1sbmRibSBpcyBub3QgYSByZWFs
  IGxpYnJhcnkuJwogICAgICAgIHNldCBgZWNobyBYICIkbGlic3dhbnRlZCAifCBzZWQgLWUgJ3Mv
  IG5kYm0gLyAvJ2AKICAgICAgICBzaGlmdAogICAgICAgIGxpYnN3YW50ZWQ9IiQqIgogICAgZmkK
  ICAgIDs7CmVzYWMKCiMgTGludXggb24gU3lub2xvZ3kuCmlmIFsgLWYgL2V0Yy9zeW5vaW5mby5j
  b25mIC1hIC1kIC91c3Ivc3lubyBdOyB0aGVuCiAgICAjIFRlc3RlZCBvbiBTeW5vbG9neSBEUzIx
  MyBhbmQgRFM0MTMKICAgICMgIE9TIHZlcnNpb24gaW5mbyBpbiAvZXRjLmRlZmF1bHRzL1ZFUlNJ
  T04KICAgICMgIGh0dHA6Ly9mb3J1bS5zeW5vbG9neS5jb20vd2lraS9pbmRleC5waHAvV2hhdF9r
  aW5kX29mX0NQVV9kb2VzX215X05BU19oYXZlCiAgICAjIFN5bm9sb2d5IERTMjEzIHJ1bm5pbmcg
  RFNNIDQuMy0zODEwLTAgKDIwMTMtMTEtMDYpCiAgICAjICBDUFUgbW9kZWwgTWFydmVsbCBLaXJr
  d29vZCBtdjYyODIgQVJNdjV0ZQogICAgIyAgTGludXggMi42LjMyLjEyICMzODEwIFdlZCBOb3Yg
  NiAwNToxMzo0MSBDU1QgMjAxMyBhcm12NXRlbCBHTlUvTGludXgKICAgICMgU3lub2xvZ3kgRFM0
  MTMgcnVubmluZyBEU00gNC4zLTM4MTAtMCAoMjAxMy0xMS0wNikKICAgICMgIENQVSBtb2RlbCBG
  cmVlc2NhbGUgUW9ySVEgUDEwMjIgcHBjIChlNTAwdjIpCiAgICAjICBsaW51eCAyLjYuMzIuMTIg
  IzM4MTAgcHBjIEdOVS9MaW51eAogICAgIyBBbGwgZGV2ZWxvcG1lbnQgc3R1ZmYgaW5zdGFsbGVk
  IHdpdGggaXBrZyBpcyBpbiAvb3B0CiAgICBpZiBbICIkTEFORyIgPSAiIiAtbyAiJExBTkciID0g
  IkMiIF07IHRoZW4KCWVjaG8gJ1lvdXIgTEFORyBpcyBzYWZlJwogICAgZWxzZQoJZWNobyAnUGxl
  YXNlIHNldCAkTEFORyB0byAiQyIuIEFsbCBvdGhlciAkTEFORyBzZXR0aW5ncyB3aWxsIGNhdXNl
  IGhhdm9jJyA+JjQKCUxBTkc9QwogICAgZmkKICAgIGVjaG8gJ1NldHRpbmcgdXAgdG8gdXNlIC9v
  cHQvKicgPiY0CiAgICBsb2NpbmNwdGg9Ii9vcHQvaW5jbHVkZSAkbG9jaW5jcHRoIgogICAgbGli
  cHRoPSIvb3B0L2xpYiAkbGlicHRoIgogICAgbGlic3B0aD0iL29wdC9saWIgJGxpYnNwdGgiCiAg
  ICBsb2NsaWJwdGg9Ii9vcHQvbGliICRsb2NsaWJwdGgiCiAgICAjIFBPU0lYIHdpbGwgbm90IGxp
  bmsgd2l0aG91dCB0aGUgcHRocmVhZCBsaWIKICAgIGxpYnN3YW50ZWQ9IiRsaWJzd2FudGVkIHB0
  aHJlYWQiCiAgICBlY2hvICIkbGlic3dhbnRlZCIgPiY0CmZpCgojIFRoaXMgc2NyaXB0IFVVL3Vz
  ZXRocmVhZHMuY2J1IHdpbGwgZ2V0ICdjYWxsZWQtYmFjaycgYnkgQ29uZmlndXJlCiMgYWZ0ZXIg
  aXQgaGFzIHByb21wdGVkIHRoZSB1c2VyIGZvciB3aGV0aGVyIHRvIHVzZSB0aHJlYWRzLgpjYXQg
  PiBVVS91c2V0aHJlYWRzLmNidSA8PCdFT0NCVScKY2FzZSAiJHVzZXRocmVhZHMiIGluCiRkZWZp
  bmV8dHJ1ZXxbeVldKikKICAgICAgICBjY2ZsYWdzPSItRF9SRUVOVFJBTlQgLURfR05VX1NPVVJD
  RSAkY2NmbGFncyIKICAgICAgICBpZiBlY2hvICRsaWJzd2FudGVkIHwgZ3JlcCAtdiBwdGhyZWFk
  ID4vZGV2L251bGwKICAgICAgICB0aGVuCiAgICAgICAgICAgIHNldCBgZWNobyBYICIkbGlic3dh
  bnRlZCAifCBzZWQgLWUgJ3MvIGMgLyBwdGhyZWFkIGMgLydgCiAgICAgICAgICAgIHNoaWZ0CiAg
  ICAgICAgICAgIGxpYnN3YW50ZWQ9IiQqIgogICAgICAgIGZpCgoJIyBTb21laG93IGF0IGxlYXN0
  IGluIERlYmlhbiAyLjIgdGhlc2UgbWFuYWdlIHRvIGVzY2FwZQoJIyB0aGUgI2RlZmluZSBmb3Jl
  c3Qgb2YgPGZlYXR1cmVzLmg+IGFuZCA8dGltZS5oPiBzbyB0aGF0CgkjIHRoZSBoYXNwcm90byBt
  YWNybyBvZiBDb25maWd1cmUgZG9lc24ndCBzZWUgdGhlc2UgcHJvdG9zLAoJIyBldmVuIHdpdGgg
  dGhlIC1EX0dOVV9TT1VSQ0UuCgoJZF9hc2N0aW1lX3JfcHJvdG89IiRkZWZpbmUiCglkX2NyeXB0
  X3JfcHJvdG89IiRkZWZpbmUiCglkX2N0aW1lX3JfcHJvdG89IiRkZWZpbmUiCglkX2dtdGltZV9y
  X3Byb3RvPSIkZGVmaW5lIgoJZF9sb2NhbHRpbWVfcl9wcm90bz0iJGRlZmluZSIKCWRfcmFuZG9t
  X3JfcHJvdG89IiRkZWZpbmUiCgoJOzsKZXNhYwpFT0NCVQoKY2F0ID4gVVUvdXNlbGFyZ2VmaWxl
  cy5jYnUgPDwnRU9DQlUnCiMgVGhpcyBzY3JpcHQgVVUvdXNlbGFyZ2VmaWxlcy5jYnUgd2lsbCBn
  ZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUKIyBhZnRlciBpdCBoYXMgcHJvbXB0ZWQgdGhl
  IHVzZXIgZm9yIHdoZXRoZXIgdG8gdXNlIGxhcmdlIGZpbGVzLgpjYXNlICIkdXNlbGFyZ2VmaWxl
  cyIgaW4KJyd8JGRlZmluZXx0cnVlfFt5WV0qKQojIEtlZXAgdGhpcyBpbiB0aGUgbGVmdCBtYXJn
  aW4uCmNjZmxhZ3NfdXNlbGFyZ2VmaWxlcz0iLURfTEFSR0VGSUxFX1NPVVJDRSAtRF9GSUxFX09G
  RlNFVF9CSVRTPTY0IgoKCWNjZmxhZ3M9IiRjY2ZsYWdzICRjY2ZsYWdzX3VzZWxhcmdlZmlsZXMi
  Cgk7Owplc2FjCkVPQ0JVCgojIFB1cmlmeSBmYWlscyB0byBsaW5rIFBlcmwgaWYgYSAiLWxjIiBp
  cyBwYXNzZWQgaW50byBpdHMgbGlua2VyCiMgZHVlIHRvIGR1cGxpY2F0ZSBzeW1ib2xzLgpjYXNl
  ICIkUFVSSUZZIiBpbgokZGVmaW5lfHRydWV8W3lZXSopCiAgICBzZXQgYGVjaG8gWCAiJGxpYnN3
  YW50ZWQgInwgc2VkIC1lICdzLyBjIC8gLydgCiAgICBzaGlmdAogICAgbGlic3dhbnRlZD0iJCoi
  CiAgICA7Owplc2FjCgojIElmIHVzaW5nIGcrKywgdGhlIENvbmZpZ3VyZSBzY2FuIGZvciBkbG9w
  ZW4oKSBhbmQgKGVzcGVjaWFsbHkpCiMgZGxlcnJvcigpIG1pZ2h0IGZhaWwsIGVhc2llciBqdXN0
  IHRvIGZvcmNpYmx5IGhpbnQgdGhlbSBpbi4KY2FzZSAiJGNjIiBpbgoqZysrKikKICBkX2Rsb3Bl
  bj0nZGVmaW5lJwogIGRfZGxlcnJvcj0nZGVmaW5lJwogIDs7CmVzYWMKCiMgVW5kZXIgc29tZSBj
  aXJjdW1zdGFuY2VzIGxpYmRiIGNhbiBnZXQgYnVpbHQgaW4gc3VjaCBhIHdheSBhcyB0bwojIG5l
  ZWQgcHRocmVhZCBleHBsaWNpdGx5IGxpbmtlZC4KCmxpYmRiX25lZWRzX3B0aHJlYWQ9Ik4iCgpp
  ZiBlY2hvICIgJGxpYnN3YW50ZWQgIiB8IGdyZXAgLXYgIiBwdGhyZWFkICIgPi9kZXYvbnVsbAp0
  aGVuCiAgIGlmIGVjaG8gIiAkbGlic3dhbnRlZCAiIHwgZ3JlcCAiIGRiICIgPi9kZXYvbnVsbAog
  ICB0aGVuCiAgICAgZm9yIERCRElSIGluICRnbGlicHRoCiAgICAgZG8KICAgICAgIERCTElCPSIk
  REJESVIvbGliZGIuc28iCiAgICAgICBpZiBbIC1mICREQkxJQiBdCiAgICAgICB0aGVuCiAgICAg
  ICAgIGlmICR7bm06LW5tfSAtdSAkREJMSUIgMj4vZGV2L251bGwgfCBncmVwIHB0aHJlYWQgPi9k
  ZXYvbnVsbAogICAgICAgICB0aGVuCiAgICAgICAgICAgaWYgbGRkICREQkxJQiB8IGdyZXAgcHRo
  cmVhZCA+L2Rldi9udWxsCiAgICAgICAgICAgdGhlbgogICAgICAgICAgICAgbGliZGJfbmVlZHNf
  cHRocmVhZD0iTiIKICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICBsaWJkYl9uZWVkc19wdGhy
  ZWFkPSJZIgogICAgICAgICAgIGZpCiAgICAgICAgIGZpCiAgICAgICBmaQogICAgIGRvbmUKICAg
  ZmkKZmkKCmNhc2UgIiRsaWJkYl9uZWVkc19wdGhyZWFkIiBpbgogICJZIikKICAgIGxpYnN3YW50
  ZWQ9IiRsaWJzd2FudGVkIHB0aHJlYWQiCiAgICA7Owplc2FjCg==','midnightbsd'=>'dXNldmZvcms9J3RydWUnCmNhc2UgIiR1c2VteW1hbGxvYyIgaW4KICAgICIiKSB1c2VteW1hbGxv
  Yz0nbicKICAgICAgICA7Owplc2FjCmxpYnN3YW50ZWQ9YGVjaG8gJGxpYnN3YW50ZWQgfCBzZWQg
  J3MvIG1hbGxvYyAvIC8nYAoKb2JqZm9ybWF0PWAvdXNyL2Jpbi9vYmpmb3JtYXRgCmlmIFsgeCRv
  Ympmb3JtYXQgPSB4YW91dCBdOyB0aGVuCiAgICBpZiBbIC1lIC91c3IvbGliL2FvdXQgXTsgdGhl
  bgogICAgICAgIGxpYnB0aD0iL3Vzci9saWIvYW91dCAvdXNyL2xvY2FsL2xpYiAvdXNyL2xpYiIK
  ICAgICAgICBnbGlicHRoPSIvdXNyL2xpYi9hb3V0IC91c3IvbG9jYWwvbGliIC91c3IvbGliIgog
  ICAgZmkKICAgIGxkZGxmbGFncz0nLUJzaGFyZWFibGUnCmVsc2UKICAgIGxpYnB0aD0iL3Vzci9s
  aWIgL3Vzci9sb2NhbC9saWIiCiAgICBnbGlicHRoPSIvdXNyL2xpYiAvdXNyL2xvY2FsL2xpYiIK
  ICAgIGxkZmxhZ3M9Ii1XbCwtRSAiCiAgICBsZGRsZmxhZ3M9Ii1zaGFyZWQgIgpmaQpjY2NkbGZs
  YWdzPSctRFBJQyAtZlBJQycKCmNjZmxhZ3M9IiR7Y2NmbGFnc30gLURIQVNfRlBTRVRNQVNLIC1E
  SEFTX0ZMT0FUSU5HUE9JTlRfSCIKaWYgL3Vzci9iaW4vZmlsZSAtTCAvdXNyL2xpYi9saWJjLnNv
  IHwgL3Vzci9iaW4vZ3JlcCAtdnEgIm5vdCBzdHJpcHBlZCIgOyB0aGVuCiAgICB1c2VubT1mYWxz
  ZQpmaQoKc2lnbmFsX3Q9J3ZvaWQnCmRfdm9pZHNpZz0nZGVmaW5lJwoKIyBUaGlzIHNjcmlwdCBV
  VS91c2V0aHJlYWRzLmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZSAKIyBh
  ZnRlciBpdCBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9yIHdoZXRoZXIgdG8gdXNlIHRocmVhZHMu
  CmNhdCA+IFVVL3VzZXRocmVhZHMuY2J1IDw8J0VPQ0JVJwpjYXNlICIkdXNldGhyZWFkcyIgaW4K
  JGRlZmluZXx0cnVlfFt5WV0qKQoJbGRmbGFncz0iLXB0aHJlYWQgJGxkZmxhZ3MiCglzZXQgYGVj
  aG8gWCAiJGxpYnN3YW50ZWQgInwgc2VkIC1lICdzLyBjIC8vJ2AKCXNoaWZ0CglsaWJzd2FudGVk
  PSIkKiIKCSMgQ29uZmlndXJlIHdpbGwgcHJvYmFibHkgcGljayB0aGUgd3JvbmcgbGliYyB0byB1
  c2UgZm9yIG5tIHNjYW4uCgkjIFRoZSBzYWZlc3QgcXVpY2stZml4IGlzIGp1c3QgdG8gbm90IHVz
  ZSBubSBhdCBhbGwuLi4KCXVzZW5tPWZhbHNlCgogICAgICAgIHVuc2V0IGxjX3IKCgkjIEV2ZW4g
  d2l0aCB0aGUgbWFsbG9jIG11dGV4ZXMgdGhlIFBlcmwgbWFsbG9jIGRvZXMgbm90CgkjIHNlZW0g
  dG8gYmUgdGhyZWFkc2FmZSBpbiBNaWRuaWdodEJTRD8KCWNhc2UgIiR1c2VteW1hbGxvYyIgaW4K
  CScnKSB1c2VteW1hbGxvYz1uIDs7Cgllc2FjCmVzYWMKRU9DQlUKCiMgbWFsbG9jIHdyYXAgd29y
  a3MKY2FzZSAiJHVzZW1hbGxvY3dyYXAiIGluCicnKSB1c2VtYWxsb2N3cmFwPSdkZWZpbmUnIDs7
  CmVzYWMK','netbsd'=>'IyBoaW50cy9uZXRic2Quc2gKIwojIFBsZWFzZSBjaGVjayB3aXRoIHBhY2thZ2VzQG5ldGJzZC5v
  cmcgYmVmb3JlIG1ha2luZyBtb2RpZmljYXRpb25zCiMgdG8gdGhpcyBmaWxlLgoKY2FzZSAiJGFy
  Y2huYW1lIiBpbgonJykKICAgIGFyY2huYW1lPWB1bmFtZSAtbWAtJHtvc25hbWV9CiAgICA7Owpl
  c2FjCgojIE5ldEJTRCBrZWVwcyBkeW5hbWljIGxvYWRpbmcgZGwqKCkgZnVuY3Rpb25zIGluIC91
  c3IvbGliL2NydDAubywKIyBzbyBDb25maWd1cmUgZG9lc24ndCBmaW5kIHRoZW0gKHVubGVzcyB5
  b3UgYWJhbmRvbiB0aGUgbm0gc2NhbikuCiMgQWxzbywgTmV0QlNEIDAuOWEgd2FzIHRoZSBmaXJz
  dCByZWxlYXNlIHRvIGludHJvZHVjZSBzaGFyZWQKIyBsaWJyYXJpZXMuCiMKY2FzZSAiJG9zdmVy
  cyIgaW4KMC45fDAuOCopCgl1c2VkbD0iJHVuZGVmIgoJOzsKKikKCWNhc2UgYHVuYW1lIC1tYCBp
  bgoJcG1heCkKCQkjIE5ldEJTRCAxLjMgYW5kIDEuMy4xIG9uIHBtYXggc2hpcHBlZCBhbiBgb2xk
  JyBsZC5zbywKCQkjIHdoaWNoIHdpbGwgbm90IHdvcmsuCgkJY2FzZSAiJG9zdmVycyIgaW4KCQkx
  LjN8MS4zLjEpCgkJCWRfZGxvcGVuPSR1bmRlZgoJCQk7OwoJCWVzYWMKCQk7OwoJZXNhYwoJaWYg
  dGVzdCAtZiAvdXNyL2xpYmV4ZWMvbGQuZWxmX3NvOyB0aGVuCgkJIyBFTEYKCQlkX2Rsb3Blbj0k
  ZGVmaW5lCgkJZF9kbGVycm9yPSRkZWZpbmUKCQljY2NkbGZsYWdzPSItRFBJQyAtZlBJQyAkY2Nj
  ZGxmbGFncyIKCQlsZGRsZmxhZ3M9Ii1zaGFyZWQgJGxkZGxmbGFncyIKCQljYXQgPlVVL2NjLmNi
  dSA8PCdFT0NCVScKIyBnY2MgNC42IGRvZXNuJ3Qgc3VwcG9ydCAtLXdob2xlLWFyY2hpdmUsIGJ1
  dCBpdCdzIHJlcXVpcmVkIGZvciB0aGUKIyBzeXN0ZW0gZ2NjIHRvIGJ1aWxkIGNvcnJlY3RseSwg
  c28gY2hlY2sgZm9yIGl0CmVjaG8gJ2ludCBmKHZvaWQpIHsgcmV0dXJuIDA7IH0nID50cnkuYwpp
  ZiAke2NjOi1jY30gJGNjY2RsZmxhZ3MgLWMgdHJ5LmMgLW90cnkubyAyPiYxICYmCiAgICR7Y2M6
  LWNjfSAtLXdob2xlLWFyY2hpdmUgJGxkZGxmbGFncyB0cnkubyAtb3RyeS5zbyAyPiYxIDsgdGhl
  bgogICAgbGRkbGZsYWdzPSItLXdob2xlLWFyY2hpdmUgJGxkZGxmbGFncyIKZmkKcm0gdHJ5LmMg
  dHJ5Lm8gdHJ5LnNvIDI+L2Rldi9udWxsCkVPQ0JVCgkJcnBhdGhmbGFnPSItV2wsLXJwYXRoLCIK
  CQljYXNlICIkb3N2ZXJzIiBpbgoJCTEuWzAtNV0qKQoJCQkjCgkJCSMgSW5jbHVkZSB0aGUgd2hv
  bGUgbGliZ2NjLmEgaW50byB0aGUgcGVybCBleGVjdXRhYmxlCgkJCSMgc28gdGhhdCBjZXJ0YWlu
  IHN5bWJvbHMgbmVlZGVkIGJ5IGxvYWRhYmxlIG1vZHVsZXMKCQkJIyBidWlsdCBhcyBDKysgb2Jq
  ZWN0cyAoX19laF9hbGxvYywgX19wdXJlX3ZpcnR1YWwsCgkJCSMgZXRjLikgd2lsbCBhbHdheXMg
  YmUgZGVmaW5lZC4KCQkJIwoJCQljY2RsZmxhZ3M9Ii1XbCwtd2hvbGUtYXJjaGl2ZSAtbGdjYyBc
  CgkJCQktV2wsLW5vLXdob2xlLWFyY2hpdmUgLVdsLC1FICRjY2RsZmxhZ3MiCgkJCTs7CgkJKikK
  CQkJY2NkbGZsYWdzPSItV2wsLUUgJGNjZGxmbGFncyIKCQkJOzsKCQllc2FjCgllbGlmIHRlc3Qg
  LWYgL3Vzci9saWJleGVjL2xkLnNvOyB0aGVuCgkJIyBhLm91dAoJCWRfZGxvcGVuPSRkZWZpbmUK
  CQlkX2RsZXJyb3I9JGRlZmluZQoJCWNjY2RsZmxhZ3M9Ii1EUElDIC1mUElDICRjY2NkbGZsYWdz
  IgoJCWxkZGxmbGFncz0iLUJzaGFyZWFibGUgJGxkZGxmbGFncyIKCQlycGF0aGZsYWc9Ii1SIgoJ
  ZWxzZQoJCWRfZGxvcGVuPSR1bmRlZgoJCXJwYXRoZmxhZz0KCWZpCgk7Owplc2FjCgojIG5ldGJz
  ZCBoYWQgdGhlc2UgYnV0IHRoZXkgZG9uJ3QgcmVhbGx5IHdvcmsgYXMgYWR2ZXJ0aXNlZCwgaW4g
  dGhlCiMgdmVyc2lvbnMgbGlzdGVkIGJlbG93LiAgaWYgdGhleSBhcmUgZGVmaW5lZCwgdGhlbiB0
  aGVyZSBpc24ndCBhCiMgd2F5IHRvIG1ha2UgcGVybCBjYWxsIHNldHVpZCgpIG9yIHNldGdpZCgp
  LiAgaWYgdGhleSBhcmVuJ3QsIHRoZW4KIyAoJDwsICQ+KSA9ICgkdSwgJHUpOyB3aWxsIHdvcmsg
  KHNhbWUgZm9yICQoLyQpKS4gIHRoaXMgaXMgYmVjYXVzZQojIHlvdSBjYW4gbm90IGNoYW5nZSB0
  aGUgcmVhbCB1c2VyaWQgb2YgYSBwcm9jZXNzIHVuZGVyIDQuNEJTRC4KIyBuZXRic2QgZml4ZWQg
  dGhpcyBpbiAxLjMuMi4KY2FzZSAiJG9zdmVycyIgaW4KMC45KnwxLlswMTJdKnwxLjN8MS4zLjEp
  CglkX3NldHJlZ2lkPSIkdW5kZWYiCglkX3NldHJldWlkPSIkdW5kZWYiCgk7Owplc2FjCmNhc2Ug
  IiRvc3ZlcnMiIGluCjAuOCopCgk7OwoqKQoJZF9nZXRwcm90b2VudF9yPSIkdW5kZWYiCglkX2dl
  dHByb3RvYnluYW1lX3I9IiR1bmRlZiIKCWRfZ2V0cHJvdG9ieW51bWJlcl9yPSIkdW5kZWYiCglk
  X3NldHByb3RvZW50X3I9IiR1bmRlZiIKCWRfZW5kcHJvdG9lbnRfcj0iJHVuZGVmIgoJZF9nZXRz
  ZXJ2ZW50X3I9IiR1bmRlZiIKCWRfZ2V0c2VydmJ5bmFtZV9yPSIkdW5kZWYiCglkX2dldHNlcnZi
  eXBvcnRfcj0iJHVuZGVmIgoJZF9zZXRzZXJ2ZW50X3I9IiR1bmRlZiIKCWRfZW5kc2VydmVudF9y
  PSIkdW5kZWYiCglkX2dldGhvc3RieW5hbWVfcj0iJHVuZGVmIgoJZF9nZXRob3N0YnlhZGRyMl9y
  PSIkdW5kZWYiCglkX2dldGhvc3RieWFkZHJfcj0iJHVuZGVmIgoJZF9zZXRob3N0ZW50X3I9IiR1
  bmRlZiIKCWRfZ2V0aG9zdGVudF9yPSIkdW5kZWYiCglkX2VuZGhvc3RlbnRfcj0iJHVuZGVmIgoJ
  ZF9nZXRwcm90b2VudF9yX3Byb3RvPSIwIgoJZF9nZXRwcm90b2J5bmFtZV9yX3Byb3RvPSIwIgoJ
  ZF9nZXRwcm90b2J5bnVtYmVyX3JfcHJvdG89IjAiCglkX3NldHByb3RvZW50X3JfcHJvdG89IjAi
  CglkX2VuZHByb3RvZW50X3JfcHJvdG89IjAiCglkX2dldHNlcnZlbnRfcl9wcm90bz0iMCIKCWRf
  Z2V0c2VydmJ5bmFtZV9yX3Byb3RvPSIwIgoJZF9nZXRzZXJ2Ynlwb3J0X3JfcHJvdG89IjAiCglk
  X3NldHNlcnZlbnRfcl9wcm90bz0iMCIKCWRfZW5kc2VydmVudF9yX3Byb3RvPSIwIgoJZF9nZXRo
  b3N0YnluYW1lX3JfcHJvdG89IjAiCglkX2dldGhvc3RieWFkZHIyX3JfcHJvdG89IjAiCglkX2dl
  dGhvc3RieWFkZHJfcl9wcm90bz0iMCIKCWRfc2V0aG9zdGVudF9yX3Byb3RvPSIwIgoJZF9lbmRo
  b3N0ZW50X3JfcHJvdG89IjAiCglkX2dldGhvc3RlbnRfcl9wcm90bz0iMCIKCTs7CmVzYWMKCiMg
  VGhlc2UgYXJlIG9ic29sZXRlIGluIGFueSBuZXRic2QuCmRfc2V0cmdpZD0iJHVuZGVmIgpkX3Nl
  dHJ1aWQ9IiR1bmRlZiIKCiMgdGhlcmUncyBubyBwcm9ibGVtIHdpdGggdmZvcmsuCnVzZXZmb3Jr
  PXRydWUKCiMgVGhpcyBpcyB0aGVyZSBidXQgaW4gbWFjaGluZS9pZWVlZnBfaC4KaWVlZWZwX2g9
  ImRlZmluZSIKCiMgVGhpcyBzY3JpcHQgVVUvdXNldGhyZWFkcy5jYnUgd2lsbCBnZXQgJ2NhbGxl
  ZC1iYWNrJyBieSBDb25maWd1cmUKIyBhZnRlciBpdCBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9y
  IHdoZXRoZXIgdG8gdXNlIHRocmVhZHMuCmNhdCA+IFVVL3VzZXRocmVhZHMuY2J1IDw8J0VPQ0JV
  JwpjYXNlICIkdXNldGhyZWFkcyIgaW4KJGRlZmluZXx0cnVlfFt5WV0qKQoJbHB0aHJlYWQ9Cglm
  b3IgeHh4IGluIHB0aHJlYWQ7IGRvCgkJZm9yIHl5eSBpbiAkbG9jbGlicHRoICRwbGlicHRoICRn
  bGlicHRoIGR1bW15OyBkbwoJCQl6eno9JHl5eS9saWIkeHh4LmEKCQkJaWYgdGVzdCAtZiAiJHp6
  eiI7IHRoZW4KCQkJCWxwdGhyZWFkPSR4eHgKCQkJCWJyZWFrOwoJCQlmaQoJCQl6eno9JHl5eS9s
  aWIkeHh4LnNvCgkJCWlmIHRlc3QgLWYgIiR6enoiOyB0aGVuCgkJCQlscHRocmVhZD0keHh4CgkJ
  CQlicmVhazsKCQkJZmkKCQkJenp6PWBscyAkeXl5L2xpYiR4eHguc28uKiAyPi9kZXYvbnVsbGAK
  CQkJaWYgdGVzdCAiWCR6enoiICE9IFg7IHRoZW4KCQkJCWxwdGhyZWFkPSR4eHgKCQkJCWJyZWFr
  OwoJCQlmaQoJCWRvbmUKCQlpZiB0ZXN0ICJYJGxwdGhyZWFkIiAhPSBYOyB0aGVuCgkJCWJyZWFr
  OwoJCWZpCglkb25lCglpZiB0ZXN0ICJYJGxwdGhyZWFkIiAhPSBYOyB0aGVuCgkJIyBBZGQgLWxw
  dGhyZWFkLgoJCWxpYnN3YW50ZWQ9IiRsaWJzd2FudGVkICRscHRocmVhZCIKCQkjIFRoZXJlIGlz
  IG5vIGxpYmNfciBhcyBvZiBOZXRCU0QgMS41LjIsIHNvIG5vIGMgLT4gY19yLgoJCSMgVGhpcyB3
  aWxsIGJlIHJldmlzaXRlZCB3aGVuIE5ldEJTRCBnYWlucyBhIG5hdGl2ZSBwdGhyZWFkcwoJCSMg
  aW1wbGVtZW50YXRpb24uCgllbHNlCgkJZWNobyAiJDA6IE5vIFBPU0lYIHRocmVhZHMgbGlicmFy
  eSAoLWxwdGhyZWFkKSBmb3VuZC4gICIgXAoJCSAgICAgIllvdSBtYXkgd2FudCB0byBpbnN0YWxs
  IEdOVSBwdGguICBBYm9ydGluZy4iID4mNAoJCWV4aXQgMQoJZmkKCXVuc2V0IGxwdGhyZWFkCgoJ
  IyBzZXZlcmFsIHJlZW50cmFudCBmdW5jdGlvbnMgYXJlIGVtYmVkZGVkIGluIGxpYmMsIGJ1dCBo
  YXZlbid0CgkjIGJlZW4gYWRkZWQgdG8gdGhlIGhlYWRlciBmaWxlcyB5ZXQuICBMZXQncyBob2xk
  IG9mZiBvbiB1c2luZwoJIyB0aGVtIHVudGlsIHRoZXkgYXJlIGEgdmFsaWQgcGFydCBvZiB0aGUg
  QVBJCgljYXNlICIkb3N2ZXJzIiBpbgoJWzAxMl0uKnwzLlswLTFdKQoJCWRfZ2V0cHJvdG9ieW5h
  bWVfcj0kdW5kZWYKCQlkX2dldHByb3RvYnludW1iZXJfcj0kdW5kZWYKCQlkX2dldHByb3RvZW50
  X3I9JHVuZGVmCgkJZF9nZXRzZXJ2YnluYW1lX3I9JHVuZGVmCgkJZF9nZXRzZXJ2Ynlwb3J0X3I9
  JHVuZGVmCgkJZF9nZXRzZXJ2ZW50X3I9JHVuZGVmCgkJZF9zZXRwcm90b2VudF9yPSR1bmRlZgoJ
  CWRfc2V0c2VydmVudF9yPSR1bmRlZgoJCWRfZW5kcHJvdG9lbnRfcj0kdW5kZWYKCQlkX2VuZHNl
  cnZlbnRfcj0kdW5kZWYgOzsKCWVzYWMKCTs7Cgplc2FjCkVPQ0JVCgojIFNldCBzZW5zaWJsZSBk
  ZWZhdWx0cyBmb3IgTmV0QlNEOiBsb29rIGZvciBsb2NhbCBzb2Z0d2FyZSBpbgojIC91c3IvcGtn
  IChOZXRCU0QgUGFja2FnZXMgQ29sbGVjdGlvbikgYW5kIGluIC91c3IvbG9jYWwuCiMKbG9jbGli
  cHRoPSIvdXNyL3BrZy9saWIgL3Vzci9sb2NhbC9saWIiCmxvY2luY3B0aD0iL3Vzci9wa2cvaW5j
  bHVkZSAvdXNyL2xvY2FsL2luY2x1ZGUiCmNhc2UgIiRycGF0aGZsYWciIGluCicnKQoJbGRmbGFn
  cz0KCTs7CiopCglsZGZsYWdzPQoJZm9yIHl5eSBpbiAkbG9jbGlicHRoOyBkbwoJCWxkZmxhZ3M9
  IiRsZGZsYWdzICRycGF0aGZsYWckeXl5IgoJZG9uZQoJOzsKZXNhYwoKY2FzZSBgdW5hbWUgLW1g
  IGluCmFscGhhKQogICAgZWNobyAnaW50IG1haW4oKSB7fScgPiB0cnkuYwogICAgZ2NjPWAke2Nj
  Oi1jY30gLXYgLWMgdHJ5LmMgMj4mMXxncmVwICdnY2MgdmVyc2lvbiBlZ2NzLTInYAogICAgY2Fz
  ZSAiJGdjYyIgaW4KICAgICcnIHwgImdjYyB2ZXJzaW9uIGVnY3MtMi45NS4iWzMtOV0qKSA7OyAj
  IDIuOTUuMyBvciBiZXR0ZXIgb2theQogICAgKikJY2F0ID4mNCA8PEVPRgoqKioKKioqIFlvdXIg
  Z2NjICgkZ2NjKSBpcyBrbm93biB0byBiZQoqKiogdG9vIGJ1Z2d5IG9uIG5ldGJzZC9hbHBoYSB0
  byBjb21waWxlIFBlcmwgd2l0aCBvcHRpbWl6YXRpb24uCioqKiBJdCBpcyBzdWdnZXN0ZWQgeW91
  IGluc3RhbGwgdGhlIGxhbmcvZ2NjIHBhY2thZ2Ugd2hpY2ggc2hvdWxkCioqKiBoYXZlIGF0IGxl
  YXN0IGdjYyAyLjk1LjMgd2hpY2ggc2hvdWxkIHdvcmsgb2theTogdXNlIGZvciBleGFtcGxlCioq
  KiBDb25maWd1cmUgLURjYz0vdXNyL3BrZy9nY2MtMi45NS4zL2Jpbi9jYy4gIFlvdSBjb3VsZCBh
  bHNvCioqKiBDb25maWd1cmUgLURvcHRpbWl6ZT0tTzAgdG8gY29tcGlsZSBQZXJsIHdpdGhvdXQg
  YW55IG9wdGltaXphdGlvbgoqKiogYnV0IHRoYXQgaXMgbm90IHJlY29tbWVuZGVkLgoqKioKRU9G
  CglleGl0IDEKCTs7CiAgICBlc2FjCiAgICBybSAtZiB0cnkuKgogICAgOzsKZXNhYwoKIyBOZXRC
  U0Qvc3BhcmMgMS41LjMvMS42LjEgZHVtcHMgY29yZSBpbiB0aGUgc2VtaWRfZHMgdGVzdCBvZiBD
  b25maWd1cmUuCmNhc2UgYHVuYW1lIC1tYCBpbgpzcGFyYykgZF9zZW1jdGxfc2VtaWRfZHM9dW5k
  ZWYgOzsKZXNhYwoKIyBtYWxsb2Mgd3JhcCB3b3JrcwpjYXNlICIkdXNlbWFsbG9jd3JhcCIgaW4K
  JycpIHVzZW1hbGxvY3dyYXA9J2RlZmluZScgOzsKZXNhYwoKIyBkb24ndCB1c2UgcGVybCBtYWxs
  b2MgYnkgZGVmYXVsdApjYXNlICIkdXNlbXltYWxsb2MiIGluCicnKSB1c2VteW1hbGxvYz1uIDs7
  CmVzYWMK','openbsd'=>'IyBoaW50cy9vcGVuYnNkLnNoCiMKIyBoaW50cyBmaWxlIGZvciBPcGVuQlNEOyBUb2RkIE1pbGxl
  ciA8bWlsbGVydEBvcGVuYnNkLm9yZz4KIyBFZGl0ZWQgdG8gYWxsb3cgQ29uZmlndXJlIGNvbW1h
  bmQtbGluZSBvdmVycmlkZXMgYnkKIyAgQW5keSBEb3VnaGVydHkgPGRvdWdoZXJhQGxhZmF5ZXR0
  ZS5lZHU+CiMKIyBUbyBidWlsZCB3aXRoIGRpc3RyaWJ1dGlvbiBwYXRocywgdXNlOgojCS4vQ29u
  ZmlndXJlIC1kZXMgLURvcGVuYnNkX2Rpc3RyaWJ1dGlvbj1kZWZpbmVkCiMKCiMgT3BlbkJTRCBo
  YXMgYSBiZXR0ZXIgbWFsbG9jIHRoYW4gcGVybC4uLgp0ZXN0ICIkdXNlbXltYWxsb2MiIHx8IHVz
  ZW15bWFsbG9jPSduJwoKIyBtYWxsb2Mgd3JhcCB3b3JrcwpjYXNlICIkdXNlbWFsbG9jd3JhcCIg
  aW4KJycpIHVzZW1hbGxvY3dyYXA9J2RlZmluZScgOzsKZXNhYwoKIyBDdXJyZW50bHksIHZmb3Jr
  KDIpIGlzIG5vdCBhIHJlYWwgd2luIG92ZXIgZm9yaygyKS4KdXNldmZvcms9IiR1bmRlZiIKCiMg
  SW4gT3BlbkJTRCA8IDMuMywgdGhlIHNldHJlP1t1Z11pZCgpIGFyZSBlbXVsYXRlZCB1c2luZyB0
  aGUKIyBfUE9TSVhfU0FWRURfSURTIGZ1bmN0aW9uYWxpdHkgd2hpY2ggZG9lcyBub3QgaGF2ZSB0
  aGUgc2FtZQojIHNlbWFudGljcyBhcyA0LjNCU0QuICBTdGFydGluZyB3aXRoIE9wZW5CU0QgMy4z
  LCB0aGUgb3JpZ2luYWwKIyBzZW1hbnRpY3MgaGF2ZSBiZWVuIHJlc3RvcmVkLgpjYXNlICIkb3N2
  ZXJzIiBpbgpbMC0yXS4qfDMuWzAtMl0pCglkX3NldHJlZ2lkPSR1bmRlZgoJZF9zZXRyZXVpZD0k
  dW5kZWYKCWRfc2V0cmdpZD0kdW5kZWYKCWRfc2V0cnVpZD0kdW5kZWYKZXNhYwoKIwojIE5vdCBh
  bGwgcGxhdGZvcm1zIHN1cHBvcnQgZHluYW1pYyBsb2FkaW5nLi4uCiMgRm9yIHRoZSBjYXNlIG9m
  ICIkb3BlbmJzZF9kaXN0cmlidXRpb24iLCB0aGUgaGludHMgZmlsZQojIG5lZWRzIHRvIGtub3cg
  d2hldGhlciB3ZSBhcmUgdXNpbmcgZHluYW1pYyBsb2FkaW5nIHNvIHRoYXQKIyBpdCBjYW4gc2V0
  IHRoZSBsaWJwZXJsIG5hbWUgYXBwcm9wcmlhdGVseS4KIyBBbGxvdyBjb21tYW5kIGxpbmUgb3Zl
  cnJpZGVzLgojCkFSQ0g9YGFyY2ggfCBzZWQgJ3MvXk9wZW5CU0QuLy8nYApjYXNlICIke0FSQ0h9
  LSR7b3N2ZXJzfSIgaW4KYWxwaGEtMi5bMC04XXxtaXBzLTIuWzAtOF18cG93ZXJwYy0yLlswLTdd
  fG04OGstWzItNF0uKnxtODhrLTUuWzAtMl18aHBwYS0zLlswLTVdfHZheC0qKQoJdGVzdCAteiAi
  JHVzZWRsIiAmJiB1c2VkbD0kdW5kZWYKCTs7CiopCgl0ZXN0IC16ICIkdXNlZGwiICYmIHVzZWRs
  PSRkZWZpbmUKCSMgV2UgdXNlIC1mUElDIGhlcmUgYmVjYXVzZSAtZnBpYyBpcyAqTk9UKiBlbm91
  Z2ggZm9yIHNvbWUgb2YgdGhlCgkjIGV4dGVuc2lvbnMgbGlrZSBUayBvbiBzb21lIE9wZW5CU0Qg
  cGxhdGZvcm1zIChpZTogc3BhcmMpCgljY2NkbGZsYWdzPSItRFBJQyAtZlBJQyAkY2NjZGxmbGFn
  cyIKCWNhc2UgIiRvc3ZlcnMiIGluCglbMDFdLip8Mi5bMC03XXwyLlswLTddLiopCgkJbGRkbGZs
  YWdzPSItQnNoYXJlYWJsZSAkbGRkbGZsYWdzIgoJCTs7CgkyLls4LTldfDMuMCkKCQlsZD0ke2Nj
  Oi1jY30KCQlsZGRsZmxhZ3M9Ii1zaGFyZWQgLWZQSUMgJGxkZGxmbGFncyIKCQk7OwoJKikgIyBm
  cm9tIDMuMSBvbndhcmRzCgkJbGQ9JHtjYzotY2N9CgkJbGRkbGZsYWdzPSItc2hhcmVkIC1mUElD
  ICRsZGRsZmxhZ3MiCgkJbGlic3dhbnRlZD1gZWNobyAkbGlic3dhbnRlZCB8IHNlZCAncy8gZGwg
  LyAvJ2AKCQk7OwoJZXNhYwoKCSMgV2UgbmVlZCB0byBmb3JjZSBsZCB0byBleHBvcnQgc3ltYm9s
  cyBvbiBFTEYgcGxhdGZvcm1zLgoJIyBXaXRob3V0IHRoaXMsIGRsb3BlbigpIGlzIGNyaXBwbGVk
  LgoJRUxGPWAke2NjOi1jY30gLWRNIC1FIC0gPC9kZXYvbnVsbCB8IGdyZXAgX19FTEZfX2AKCXRl
  c3QgLW4gIiRFTEYiICYmIGxkZmxhZ3M9Ii1XbCwtRSAkbGRmbGFncyIKCTs7CmVzYWMKCiMKIyBU
  d2Vha3MgZm9yIHZhcmlvdXMgdmVyc2lvbnMgb2YgT3BlbkJTRAojCmNhc2UgIiRvc3ZlcnMiIGlu
  CjIuNSkKCSMgT3BlbkJTRCAyLjUgaGFzIGJyb2tlbiBvZGJtIHN1cHBvcnQKCWlfZGJtPSR1bmRl
  ZgoJOzsKZXNhYwoKIyBPcGVuQlNEIGRvZXNuJ3QgbmVlZCBsaWJjcnlwdCBidXQgbWFueSBmb2xr
  cyBrZWVwIGEgc3R1YiBsaWIKIyBhcm91bmQgZm9yIG9sZCBOZXRCU0QgYmluYXJpZXMuCmxpYnN3
  YW50ZWQ9YGVjaG8gJGxpYnN3YW50ZWQgfCBzZWQgJ3MvIGNyeXB0IC8gLydgCgojIENvbmZpZ3Vy
  ZSBjYW4ndCBmaWd1cmUgdGhpcyBvdXQgbm9uLWludGVyYWN0aXZlbHkKZF9zdWlkc2FmZT0kZGVm
  aW5lCgojIGNjIGlzIGdjYyBzbyB3ZSBjYW4gZG8gYmV0dGVyIHRoYW4gLU8KIyBBbGxvdyBhIGNv
  bW1hbmQtbGluZSBvdmVycmlkZSwgc3VjaCBhcyAtRG9wdGltaXplPS1nCmNhc2UgIiR7QVJDSH0t
  JHtvc3ZlcnN9IiBpbgpocHBhLTMuM3xtODhrLTIuKnxtODhrLTMuWzAtM10pCiAgIHRlc3QgIiRv
  cHRpbWl6ZSIgfHwgb3B0aW1pemU9Jy1PMCcKICAgOzsKbTg4ay0zLjQpCiAgIHRlc3QgIiRvcHRp
  bWl6ZSIgfHwgb3B0aW1pemU9Jy1PMScKICAgOzsKKikKICAgdGVzdCAiJG9wdGltaXplIiB8fCBv
  cHRpbWl6ZT0nLU8yJwogICA7Owplc2FjCgojIFRoaXMgc2NyaXB0IFVVL3VzZXRocmVhZHMuY2J1
  IHdpbGwgZ2V0ICdjYWxsZWQtYmFjaycgYnkgQ29uZmlndXJlIAojIGFmdGVyIGl0IGhhcyBwcm9t
  cHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgdGhyZWFkcy4KY2F0ID4gVVUvdXNldGhy
  ZWFkcy5jYnUgPDwnRU9DQlUnCmNhc2UgIiR1c2V0aHJlYWRzIiBpbgokZGVmaW5lfHRydWV8W3lZ
  XSopCgkjIGFueSBvcGVuYnNkIHZlcnNpb24gZGVwZW5kZW5jaWVzIHdpdGggcHRocmVhZHM/Cglj
  Y2ZsYWdzPSItcHRocmVhZCAkY2NmbGFncyIKCWxkZmxhZ3M9Ii1wdGhyZWFkICRsZGZsYWdzIgoJ
  Y2FzZSAiJG9zdmVycyIgaW4KCVswLTJdLip8My5bMC0yXSkKCQkjIENoYW5nZSBmcm9tIC1sYyB0
  byAtbGNfcgoJCXNldCBgZWNobyAiWCAkbGlic3dhbnRlZCAiIHwgc2VkICdzLyBjIC8gY19yIC8n
  YAoJCXNoaWZ0CgkJbGlic3dhbnRlZD0iJCoiCgk7OwoJZXNhYwoJY2FzZSAiJG9zdmVycyIgaW4K
  CVswMTJdLip8My5bMC02XSkKICAgICAgICAJIyBCcm9rZW4gdXAgdG8gT3BlbkJTRCAzLjYsIGZp
  eGVkIGluIE9wZW5CU0QgMy43CgkJZF9nZXRzZXJ2YnluYW1lX3I9JHVuZGVmIDs7Cgllc2FjCmVz
  YWMKRU9DQlUKCiMgV2hlbiBidWlsZGluZyBpbiB0aGUgT3BlbkJTRCB0cmVlIHdlIHVzZSBkaWZm
  ZXJlbnQgcGF0aHMKIyBUaGlzIGlzIG9ubHkgcGFydCBvZiB0aGUgc3RvcnksIHRoZSByZXN0IGNv
  bWVzIGZyb20gY29uZmlnLm92ZXIKY2FzZSAiJG9wZW5ic2RfZGlzdHJpYnV0aW9uIiBpbgonJ3wk
  dW5kZWZ8ZmFsc2UpIDs7CiopCgkjIFdlIHB1dCB0aGluZ3MgaW4gL3Vzciwgbm90IC91c3IvbG9j
  YWwKCXByZWZpeD0nL3VzcicKCXByZWZpeGV4cD0nL3VzcicKCXN5c21hbj0nL3Vzci9zaGFyZS9t
  YW4vbWFuMScKCWxpYnB0aD0nL3Vzci9saWInCglnbGlicHRoPScvdXNyL2xpYicKCSMgTG9jYWwg
  dGhpbmdzLCBob3dldmVyLCBkbyBnbyBpbiAvdXNyL2xvY2FsCglzaXRlcHJlZml4PScvdXNyL2xv
  Y2FsJwoJc2l0ZXByZWZpeGV4cD0nL3Vzci9sb2NhbCcKCSMgUG9ydHMgaW5zdGFsbHMgbm9uLXN0
  ZCBsaWJzIGluIC91c3IvbG9jYWwvbGliIHNvIGxvb2sgdGhlcmUgdG9vCglsb2NpbmNwdGg9Jy91
  c3IvbG9jYWwvaW5jbHVkZScKCWxvY2xpYnB0aD0nL3Vzci9sb2NhbC9saWInCgkjIExpbmsgcGVy
  bCB3aXRoIHNoYXJlZCBsaWJwZXJsCglpZiBbICIkdXNlZGwiID0gIiRkZWZpbmUiIC1hIC1yIHNo
  bGliX3ZlcnNpb24gXTsgdGhlbgoJCXVzZXNocnBsaWI9dHJ1ZQoJCWxpYnBlcmw9YC4gLi9zaGxp
  Yl92ZXJzaW9uOyBlY2hvIGxpYnBlcmwuc28uJHttYWpvcn0uJHttaW5vcn1gCglmaQoJOzsKZXNh
  YwoKIyBlbmQK','solaris'=>'IyBoaW50cy9zb2xhcmlzXzIuc2gKIyBDb250cmlidXRpb25zIGJ5IChpbiBhbHBoYWJldGljYWwg
  b3JkZXIpIEFsYW4gQnVybGlzb24sIEFuZHkgRG91Z2hlcnR5LAojIERlYW4gUm9laHJpY2gsIEph
  cmtrbyBIaWV0YW5pZW1pLCBMdXBlIENocmlzdG9waCwgUmljaGFyZCBTb2RlcmJlcmcgYW5kCiMg
  bWFueSBvdGhlcnMuCiMKIyBTZWUgUkVBRE1FLnNvbGFyaXMgZm9yIGFkZGl0aW9uYWwgaW5mb3Jt
  YXRpb24uCiMKIyBGb3IgY29uc2lzdGVuY3kgd2l0aCBnY2MsIHdlIGRvIG5vdCBhZG9wdCBTdW4g
  TWFya2V0aW5nJ3MKIyByZW1vdmFsIG9mIHRoZSAnMi4nIHByZWZpeCBmcm9tIHRoZSBTb2xhcmlz
  IHZlcnNpb24gbnVtYmVyLgojIChDb25maWd1cmUgdHJpZXMgdG8gZGV0ZWN0IGFuIG9sZCBmaXhp
  bmNsdWRlcyBhbmQgbmVlZHMKIyB0aGlzIGluZm9ybWF0aW9uLikKCiMgSWYgcGVybCBmYWlscyB0
  ZXN0cyB0aGF0IGludm9sdmUgZHluYW1pYyBsb2FkaW5nIG9mIGV4dGVuc2lvbnMsIGFuZAojIHlv
  dSBhcmUgdXNpbmcgZ2NjLCBiZSBzdXJlIHRoYXQgeW91IGFyZSBOT1QgdXNpbmcgR05VIGFzIGFu
  ZCBsZC4gIE9uZQojIHdheSB0byBkbyB0aGF0IGlzIHRvIGludm9rZSBDb25maWd1cmUgd2l0aAoj
  CiMgICAgIHNoIENvbmZpZ3VyZSAtRGNjPSdnY2MgLUIvdXNyL2Njcy9iaW4vJwojCiMgIChOb3Rl
  IHRoYXQgdGhlIHRyYWlsaW5nIHNsYXNoIGlzICpyZXF1aXJlZCouKQojICBnY2Mgd2lsbCBvY2Nh
  c2lvbmFsbHkgZW1pdCB3YXJuaW5ncyBhYm91dCAidW51c2VkIHByZWZpeCIsIGJ1dAojICB0aGVz
  ZSBvdWdodCB0byBiZSBoYXJtbGVzcy4gIFNlZSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLgoKIyBT
  b2xhcmlzIGhhcyBzZWN1cmUgU1VJRCBzY3JpcHRzCmRfc3VpZHNhZmU9JHtkX3N1aWRzYWZlOi1k
  ZWZpbmV9CgojIEJlIHBhcmFub2lkIGFib3V0IG5tIGZhaWxpbmcgdG8gZmluZCBzeW1ib2xzCm1p
  c3RydXN0bm09JHttaXN0cnVzdG5tOi1ydW59CgojIFNldmVyYWwgcGVvcGxlIHJlcG9ydGVkIHBy
  b2JsZW1zIHdpdGggcGVybCdzIG1hbGxvYywgZXNwZWNpYWxseQojIHdoZW4gdXNlNjRiaXRhbGwg
  aXMgZGVmaW5lZCBvciB3aGVuIHVzaW5nIGdjYy4KIyAgICAgaHR0cDovL3d3dy54cmF5Lm1wZS5t
  cGcuZGUvbWFpbGluZy1saXN0cy9wZXJsNS1wb3J0ZXJzLzIwMDEtMDEvbXNnMDEzMTguaHRtbAoj
  ICAgICBodHRwOi8vd3d3LnhyYXkubXBlLm1wZy5kZS9tYWlsaW5nLWxpc3RzL3Blcmw1LXBvcnRl
  cnMvMjAwMS0wMS9tc2cwMDQ2NS5odG1sCnVzZW15bWFsbG9jPSR7dXNlbXltYWxsb2M6LWZhbHNl
  fQoKIyBtYWxsb2Mgd3JhcCB3b3JrcwpjYXNlICIkdXNlbWFsbG9jd3JhcCIgaW4KJycpIHVzZW1h
  bGxvY3dyYXA9J2RlZmluZScgOzsKZXNhYwoKIyBBdm9pZCBhbGwgbGlicmFyaWVzIGluIC91c3Iv
  dWNibGliLgojIC9saWIgaXMganVzdCBhIHN5bWxpbmsgdG8gL3Vzci9saWIKc2V0IGBlY2hvICRn
  bGlicHRoIHwgc2VkIC1lICdzQC91c3IvdWNibGliQEAnIC1lICdzQCAvbGliIEAgQCdgCmdsaWJw
  dGg9IiQqIgoKIyBTdGFydGluZyB3aXRoIFNvbGFyaXMgMTAsIHdlIGRvbid0IHdhbnQgdmVyc2lv
  bmVkIHNoYXJlZCBsaWJyYXJpZXMgYmVjYXVzZQojIHRob3NlIG9mdGVuIGluZGljYXRlIGEgcHJp
  dmF0ZSB1c2Ugb25seSBsaWJyYXJ5LiAgRXNwZWNpYWxseSBiYWRseSB0aGF0IHdvdWxkCiMgYnJl
  YWsgdGhpbmdzIHdpdGggU1VOV2JkYiAoQmVya2VsZXkgREIpIGJlaW5nIGluc3RhbGxlZCwgd2hp
  Y2ggYnJpbmdzIGluCiMgL3Vzci9saWIvbGliZGIuc28uMSwgYnV0IHRoYXQgaXMgbm90IHJlYWxs
  eSBtZWFudCBmb3IgcHVibGljIGNvbnN1bXB0aW9uLgojICBYWFggUmV2aXNpdCBhZnRlciBwZXJs
  IDUuMTAgLS0gc2hvdWxkIHdlIGFwcGx5IHRoaXMgdG8gb2xkZXIgU29sYXJpcwojIHZlcnNpb25z
  IHRvbz8gIChBLkQuIDExLzIwMDcpLgpjYXNlICJgJHJ1biB1bmFtZSAtcmAiIGluCjUuWzAtOV0p
  IDs7CiopIGlnbm9yZV92ZXJzaW9uZWRfc29saWJzPXkgOzsKZXNhYwoKIyBSZW1vdmUgdW53YW50
  ZWQgbGlicmFyaWVzLiAgLWx1Y2IgY29udGFpbnMgaW5jb21wYXRpYmxlIHJvdXRpbmVzLgojIC1s
  bGQgYW5kIC1sc2VjIGRvbid0IGRvIGFueXRoaW5nIHVzZWZ1bC4gLWxjcnlwdCBkb2VzIG5vdAoj
  IHJlYWxseSBwcm92aWRlIGFueXRoaW5nIHdlIG5lZWQgb3ZlciAtbGMsIHNvIHdlIGRyb3AgaXQs
  IHRvby4KIyAtbG1hbGxvYyBjYW4gY2F1c2UgYSBwcm9ibGVtIHdpdGggR05VIENDICYgU29sYXJp
  cy4gIFNwZWNpZmljYWxseSwKIyBsaWJtYWxsb2MuYSBtYXkgYWxsb2NhdGUgbWVtb3J5IHRoYXQg
  aXMgb25seSA0IGJ5dGUgYWxpZ25lZCwgYnV0CiMgR05VIENDIG9uIHRoZSBTcGFyYyBhc3N1bWVz
  IHRoYXQgZG91YmxlcyBhcmUgOCBieXRlIGFsaWduZWQuCiMgVGhhbmtzIHRvICBIYWxsdmFyZCBC
  LiBGdXJ1c2V0aCA8aC5iLmZ1cnVzZXRoQHVzaXQudWlvLm5vPgpzZXQgYGVjaG8gIiAkbGlic3dh
  bnRlZCAiIHwgc2VkIC1lICdzQCBsZCBAIEAnIC1lICdzQCBtYWxsb2MgQCBAJyAtZSAnc0AgdWNi
  IEAgQCcgLWUgJ3NAIHNlYyBAIEAnIC1lICdzQCBjcnlwdCBAIEAnYApsaWJzd2FudGVkPSIkKiIK
  CiMgTG9vayBmb3IgYXJjaGl0ZWN0dXJlIG5hbWUuICBXZSB3YW50IHRvIHN1Z2dlc3QgYSB1c2Vm
  dWwgZGVmYXVsdC4KY2FzZSAiJGFyY2huYW1lIiBpbgonJykKICAgIGlmIHRlc3QgLWYgL3Vzci9i
  aW4vYXJjaDsgdGhlbgoJYXJjaG5hbWU9YC91c3IvYmluL2FyY2hgCglhcmNobmFtZT0iJHthcmNo
  bmFtZX0tJHtvc25hbWV9IgogICAgZWxpZiB0ZXN0IC1mIC91c3IvdWNiL2FyY2g7IHRoZW4KCWFy
  Y2huYW1lPWAvdXNyL3VjYi9hcmNoYAoJYXJjaG5hbWU9IiR7YXJjaG5hbWV9LSR7b3NuYW1lfSIK
  ICAgIGZpCiAgICA7Owplc2FjCgojCiMgVGhpcyBleHRyYWN0cyB0aGUgbGlicmFyeSBkaXJlY3Rv
  cmllcyB0aGF0IHdpbGwgYmUgc2VhcmNoZWQgYnkgdGhlIFN1bgojIFdvcmtzaG9wIGNvbXBpbGVy
  LCBnaXZlbiB0aGUgY29tbWFuZC1saW5lIHN1cHBsaWVkIGluICR0cnl3b3Jrc2hvcGNjLgojIFVz
  ZSB0aHVzbHk6IGxvY2xpYnB0aD0iYCRnZXR3b3Jrc2hvcGxpYnNgICRsb2NsaWJwdGgiCiMKCWdl
  dHdvcmtzaG9wbGlicz1gY2F0IDw8J0VORCcKZXZhbCAkdHJ5d29ya3Nob3BjYyAtIyMjIDI+JjEg
  fCBcCnNlZCAtbiAnLyAtWSAvcyEuKiAtWSAiUCxcKFteIl0qXCkiLiohXDEhcCcgfCB0ciAnOicg
  JyAnIHwgXApzZWQgLWUgJ3MhL3Vzci9saWIvc3BhcmN2OSEhJyAtZSAncyEvdXNyL2Njcy9saWIv
  c3BhcmN2OSEhJyBcCiAgICAtZSAncyEvdXNyL2xpYiEhZycgLWUgJ3MhL3Vzci9jY3MvbGliISFn
  JwpFTkQKYAoKY2FzZSAiJGNjIiBpbgonJykgICAgZm9yIGkgaW4gYGxzIC1yIC9vcHQvc29sKnN0
  dWRpbyovYmluL2NjYCAvb3B0L1NVTldzcHJvL2Jpbi9jYwogICAgICAgZG8KCSAgICAgICBpZiB0
  ZXN0IC1mICIkaSI7IHRoZW4KCQkgICAgICAgY2M9JGkKCQkgICAgICAgY2F0IDw8RU9GID4mNAoK
  WW91IHNwZWNpZmllZCBubyBjYyBidXQgeW91IHNlZW0gdG8gaGF2ZSB0aGUgV29ya3Nob3AgY29t
  cGlsZXIKKCRjYykgaW5zdGFsbGVkLCB1c2luZyB0aGF0LgpJZiB5b3Ugd2FudCBzb21ldGhpbmcg
  ZWxzZSwgc3BlY2lmeSB0aGF0IGluIHRoZSBjb21tYW5kIGxpbmUsCmUuZy4gQ29uZmlndXJlIC1E
  Y2M9Z2NjCgpFT0YKCQkJYnJlYWsKCQlmaQoJZG9uZQoJOzsKZXNhYwoKIyMjIyMjIyMjIyMjIyMj
  IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMgR2VuZXJhbCBzYW5pdHkg
  dGVzdGluZy4gIFNlZSBiZWxvdyBmb3IgZXhjZXJwdHMgZnJvbSB0aGUgU29sYXJpcyBGQVEuCiMK
  IyBGcm9tIHJvZWhyaWNoQGlyb253b29kLWZkZGkuY3JheS5jb20gV2VkIFNlcCAyNyAxMjo1MTo0
  NiAxOTk1CiMgRGF0ZTogVGh1LCA3IFNlcCAxOTk1IDE2OjMxOjQwIC0wNTAwCiMgRnJvbTogRGVh
  biBSb2VocmljaCA8cm9laHJpY2hAaXJvbndvb2QtZmRkaS5jcmF5LmNvbT4KIyBUbzogcGVybDUt
  cG9ydGVyc0BhZnJpY2Eubmljb2guY29tCiMgU3ViamVjdDogUmU6IE9uIHBlcmw1L3NvbGFyaXMv
  Z2NjCiMKIyBIZXJlJ3MgYW5vdGhlciBkcmFmdCBvZiB0aGUgcGVybDUvc29sYXJpcy9nY2Mgc2Fu
  aXR5LWNoZWNrZXIuCgpjYXNlIGB0eXBlICR7Y2M6LWNjfWAgaW4KKi91c3IvdWNiL2NjKikgY2F0
  IDw8RU5EID4mNAoKTk9URTogIFNvbWUgcGVvcGxlIGhhdmUgcmVwb3J0ZWQgcHJvYmxlbXMgd2l0
  aCAvdXNyL3VjYi9jYy4KSWYgeW91IGhhdmUgZGlmZmljdWx0aWVzLCBwbGVhc2UgbWFrZSBzdXJl
  IHRoZSBkaXJlY3RvcnkKY29udGFpbmluZyB5b3VyIEMgY29tcGlsZXIgaXMgYmVmb3JlIC91c3Iv
  dWNiIGluIHlvdXIgUEFUSC4KCkVORAo7Owplc2FjCgoKIyBDaGVjayB0aGF0IC9kZXYvZmQgaXMg
  bW91bnRlZC4gIElmIGl0IGlzIG5vdCBtb3VudGVkLCBsZXQgdGhlCiMgdXNlciBrbm93IHRoYXQg
  c3VpZCBzY3JpcHRzIG1heSBub3Qgd29yay4KJHJ1biBtb3VudCB8IGdyZXAgJ14vZGV2L2ZkICcg
  Mj4mMSA+IC9kZXYvbnVsbApjYXNlICQ/IGluCjApIDs7CiopCgljYXQgPDxFTkQgPiY0CgpOT1RF
  OiBZb3VyIHN5c3RlbSBkb2VzIG5vdCBoYXZlIC9kZXYvZmQgbW91bnRlZC4gIElmIHlvdSB3YW50
  IHRvCmJlIGFibGUgdG8gdXNlIHNldC11aWQgc2NyaXB0cyB5b3UgbXVzdCBhc2sgeW91ciBzeXN0
  ZW0gYWRtaW5pc3RyYXRvcgp0byBtb3VudCAvZGV2L2ZkLgoKRU5ECgk7Owplc2FjCgoKIyBTZWUg
  aWYgbGlidWNiIGNhbiBiZSBmb3VuZCBpbiAvdXNyL2xpYi4gIElmIGl0IGlzLCB3YXJuIHRoZSB1
  c2VyCiMgdGhhdCB0aGlzIG1heSBjYXVzZSBwcm9ibGVtcyB3aGlsZSBidWlsZGluZyBQZXJsIGV4
  dGVuc2lvbnMuCmZvdW5kX2xpYnVjYj0nJwpjYXNlICIkcnVuIiBpbgonJykgL3Vzci9iaW4vbHMg
  L3Vzci9saWIvbGlidWNiKiA+L2Rldi9udWxsIDI+JjEKICAgIGZvdW5kX2xpYnVjYj0kPwogICAg
  OzsKKikgICRydW4gL3Vzci9iaW4vbHMgJy91c3IvbGliL2xpYnVjYionID4vZGV2L251bGwgMj4m
  MQogICAgZm91bmRfbGlidWNiPSQ/CiAgICA7Owplc2FjCgpjYXNlICRmb3VuZF9saWJ1Y2IgaW4K
  MCkKCWNhdCA8PEVORCA+JjQKCk5PVEU6IGxpYnVjYiBoYXMgYmVlbiBmb3VuZCBpbiAvdXNyL2xp
  Yi4gIGxpYnVjYiBzaG91bGQgcmVzaWRlIGluCi91c3IvdWNibGliLiAgWW91IG1heSBoYXZlIHRy
  b3VibGUgd2hpbGUgYnVpbGRpbmcgUGVybCBleHRlbnNpb25zLgoKRU5ECjs7CmVzYWMKCiMgVXNl
  IHNoZWxsIGJ1aWx0LWluICd0eXBlJyBjb21tYW5kIGluc3RlYWQgb2YgL3Vzci9iaW4vd2hpY2gg
  dG8KIyBhdm9pZCBwb3NzaWJsZSBjc2ggc3RhcnQtdXAgcHJvYmxlbXMgYW5kIGFsc28gdG8gdXNl
  IHRoZSBzYW1lIHNoZWxsCiMgd2UnbGwgYmUgdXNpbmcgdG8gQ29uZmlndXJlIGFuZCBtYWtlIHBl
  cmwuCiMgVGhlIHBhdGggbmFtZSBpcyB0aGUgbGFzdCBmaWVsZCBpbiB0aGUgb3V0cHV0LCBidXQg
  dGhlIHR5cGUgY29tbWFuZAojIGhhcyBhbiBhbm5veWluZyBhcnJheSBvZiBwb3NzaWJsZSBvdXRw
  dXRzLCBlLmcuOgojCW1ha2UgaXMgaGFzaGVkICgvb3B0L2dudS9iaW4vbWFrZSkKIwljYyBpcyAv
  dXNyL3VjYi9jYwojCWZvbyBub3QgZm91bmQKIyB1c2UgYSBjb21tYW5kIGxpa2UgdHlwZSBtYWtl
  IHwgYXdrICd7cHJpbnQgJE5GfScgfCBzZWQgJ3MvWygpXS8vZycKCiMgU2VlIGlmIG1ha2UoMSkg
  aXMgR05VIG1ha2UoMSkuCiMgSWYgaXQgaXMsIG1ha2Ugc3VyZSB0aGUgc2V0Z2lkIGJpdCBpcyBu
  b3Qgc2V0LgptYWtlIC12ID4gbWFrZS52ZXJzIDI+JjEKaWYgZ3JlcCBHTlUgbWFrZS52ZXJzID4g
  L2Rldi9udWxsIDI+JjE7IHRoZW4KICAgIHRtcD1gdHlwZSBtYWtlIHwgYXdrICd7cHJpbnQgJE5G
  fScgfCBzZWQgJ3MvWygpXS8vZydgCiAgICBjYXNlICJgJHtsczotJy91c3IvYmluL2xzJ30gLWxM
  ICR0bXBgIiBpbgogICAgPz8/Pz8/cyopCgkgICAgY2F0IDw8RU5EID4mMgoKTk9URTogWW91ciBQ
  QVRIIHBvaW50cyB0byBHTlUgbWFrZSwgYW5kIHlvdXIgR05VIG1ha2UgaGFzIHRoZSBzZXQtZ3Jv
  dXAtaWQKYml0IHNldC4gIFlvdSBtdXN0IGVpdGhlciByZWFycmFuZ2UgeW91ciBQQVRIIHRvIHB1
  dCAvdXNyL2Njcy9iaW4gYmVmb3JlIHRoZQpHTlUgdXRpbGl0aWVzIG9yIHlvdSBtdXN0IGFzayB5
  b3VyIHN5c3RlbSBhZG1pbmlzdHJhdG9yIHRvIGRpc2FibGUgdGhlCnNldC1ncm91cC1pZCBiaXQg
  b24gR05VIG1ha2UuCgpFTkQKCSAgICA7OwogICAgZXNhYwpmaQpybSAtZiBtYWtlLnZlcnMKCmNh
  dCA+IFVVL2NjLmNidSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS9jYy5jYnUgd2lsbCBnZXQg
  J2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUgYWZ0ZXIgaXQKIyBoYXMgcHJvbXB0ZWQgdGhlIHVz
  ZXIgZm9yIHRoZSBDIGNvbXBpbGVyIHRvIHVzZS4KCiMgSWYgdGhlIEMgY29tcGlsZXIgaXMgZ2Nj
  OgojICAgLSBjaGVjayB0aGUgZml4ZWQtaW5jbHVkZXMKIyAgIC0gY2hlY2sgYXMoMSkgYW5kIGxk
  KDEpLCB0aGV5IHNob3VsZCBub3QgYmUgR05VCiMJKEdOVSBhcyBhbmQgbGQgMi44LjEgYW5kIGxh
  dGVyIGFyZSByZXBvcnRlZGx5IG9rLCBob3dldmVyLikKIyBJZiB0aGUgQyBjb21waWxlciBpcyBu
  b3QgZ2NjOgojICAgLSBDaGVjayBpZiBpdCBpcyB0aGUgV29ya3Nob3AvRm9ydGUgY29tcGlsZXIu
  CiMgICAgIElmIGl0IGlzLCBwcmVwYXJlIGZvciA2NCBiaXQgYW5kIGxvbmcgZG91Ymxlcy4KIyAg
  IC0gY2hlY2sgYXMoMSkgYW5kIGxkKDEpLCB0aGV5IHNob3VsZCBub3QgYmUgR05VCiMJKEdOVSBh
  cyBhbmQgbGQgMi44LjEgYW5kIGxhdGVyIGFyZSByZXBvcnRlZGx5IG9rLCBob3dldmVyLikKIwoj
  IFdhdGNoIG91dCBpbiBjYXNlIHRoZXkgaGF2ZSBub3Qgc2V0ICRjYy4KCiMgUGVybCBjb21waWxl
  ZCB3aXRoIHNvbWUgY29tYmluYXRpb25zIG9mIEdOVSBhcyBhbmQgbGQgbWF5IG5vdAojIGJlIGFi
  bGUgdG8gcGVyZm9ybSBkeW5hbWljIGxvYWRpbmcgb2YgZXh0ZW5zaW9ucy4gIElmIHlvdSBoYXZl
  IGEKIyBwcm9ibGVtIHdpdGggZHluYW1pYyBsb2FkaW5nLCBiZSBzdXJlIHRoYXQgeW91IGFyZSB1
  c2luZyB0aGUgU29sYXJpcwojIC91c3IvY2NzL2Jpbi9hcyBhbmQgL3Vzci9jY3MvYmluL2xkLiAg
  WW91IGNhbiBkbyB0aGF0IHdpdGgKIwlzaCBDb25maWd1cmUgLURjYz0nZ2NjIC1CL3Vzci9jY3Mv
  YmluLycKIyAobm90ZSB0aGUgdHJhaWxpbmcgc2xhc2ggaXMgcmVxdWlyZWQpLgojIENvbWJpbmF0
  aW9ucyB0aGF0IGFyZSBrbm93biB0byB3b3JrIHdpdGggdGhlIGZvbGxvd2luZyBoaW50czoKIwoj
  ICBnY2MtMi43LjIsIEdOVSBhcyAyLjcsIEdOVSBsZCAyLjcKIyAgZWdjcy0xLjAuMywgR05VIGFz
  IDIuOS4xIGFuZCBHTlUgbGQgMi45LjEKIwktLUFuZHkgRG91Z2hlcnR5ICA8ZG91Z2hlcmFAbGFm
  YXlldHRlLmVkdT4KIwlUdWUgQXByIDEzIDE3OjE5OjQzIEVEVCAxOTk5CgojIEdldCBnY2MgdG8g
  c2hhcmUgaXRzIHNlY3JldHMuCmVjaG8gJ2ludCBtYWluKCkgeyByZXR1cm4gMDsgfScgPiB0cnku
  YwoJIyBJbmRlbnQgdG8gYXZvaWQgcHJvcGFnYXRpb24gdG8gY29uZmlnLnNoCgl2ZXJib3NlPWAk
  e2NjOi1jY30gJGNjZmxhZ3MgLXYgLW8gdHJ5IHRyeS5jIDI+JjFgCgojIFhYWCBUT0RPOiAgJ3Nw
  ZWNzJyBvdXRwdXQgY2hhbmdlZCBmcm9tICdSZWFkaW5nIHNwZWNzIGZyb20nIGluIGdjYy1bMjNd
  IHRvICdVc2luZwojIGJ1aWx0LWluIHNwZWNzJyBpbiBnY2MtNC4gIFBlcmhhcHMgd2Ugc2hvdWxk
  IGp1c3QgdXNlIHRoZSBzYW1lIGdjYyB0ZXN0IGFzCiMgaW4gQ29uZmlndXJlIHRvIHNlZSBpZiB3
  ZSdyZSB1c2luZyBnY2MuCmlmIGVjaG8gIiR2ZXJib3NlIiB8IGVncmVwICcoUmVhZGluZyBzcGVj
  cyBmcm9tKXwoVXNpbmcgYnVpbHQtaW4gc3BlY3MpJyA+L2Rldi9udWxsIDI+JjE7IHRoZW4KCSMK
  CSMgVXNpbmcgZ2NjLgoJIwoJY2NfbmFtZT0nZ2NjJwoKCSMgU2VlIGlmIGFzKDEpIGlzIEdOVSBh
  cygxKS4gIEdOVSBhcygxKSBtaWdodCBub3Qgd29yayBmb3IgdGhpcyBqb2IuCglpZiBlY2hvICIk
  dmVyYm9zZSIgfCBncmVwICcgL3Vzci9jY3MvYmluL2FzICcgPi9kZXYvbnVsbCAyPiYxOyB0aGVu
  CgkgICAgOgoJZWxzZQoJICAgIGNhdCA8PEVORCA+JjIKCk5PVEU6IFlvdSBhcmUgdXNpbmcgR05V
  IGFzKDEpLiAgR05VIGFzKDEpIG1pZ2h0IG5vdCBidWlsZCBQZXJsLiAgSWYgeW91CmhhdmUgdHJv
  dWJsZSwgeW91IGNhbiB1c2UgL3Vzci9jY3MvYmluL2FzIGJ5IGluY2x1ZGluZyAtQi91c3IvY2Nz
  L2Jpbi8KaW4geW91ciAke2NjOi1jY30gY29tbWFuZC4gIChOb3RlIHRoYXQgdGhlIHRyYWlsaW5n
  ICIvIiBpcyByZXF1aXJlZC4pCgpFTkQKCSAgICAjIEFwcGFyZW50bHkgbm90IG5lZWRlZCwgYXQg
  bGVhc3QgZm9yIGFzIDIuNyBhbmQgbGF0ZXIuCgkgICAgIyBjYz0iJHtjYzotY2N9ICRjY2ZsYWdz
  IC1CL3Vzci9jY3MvYmluLyIKCWZpCgoJIyBTZWUgaWYgbGQoMSkgaXMgR05VIGxkKDEpLiAgR05V
  IGxkKDEpIG1pZ2h0IG5vdCB3b3JrIGZvciB0aGlzIGpvYi4KCSMgUmVjb21wdXRlICR2ZXJib3Nl
  IHNpbmNlIHdlIG1heSBoYXZlIGp1c3QgY2hhbmdlZCAkY2MuCgl2ZXJib3NlPWAke2NjOi1jY30g
  JGNjZmxhZ3MgLXYgLW8gdHJ5IHRyeS5jIDI+JjEgfCBncmVwIGxkIDI+JjFgCgoJaWYgZWNobyAi
  JHZlcmJvc2UiIHwgZ3JlcCAnIC91c3IvY2NzL2Jpbi9sZCAnID4vZGV2L251bGwgMj4mMTsgdGhl
  bgoJICAgICMgT2ssIGdjYyBkaXJlY3RseSBjYWxscyB0aGUgU29sYXJpcyAvdXNyL2Njcy9iaW4v
  bGQuCgkgICAgOgoJZWxpZiBlY2hvICIkdmVyYm9zZSIgfCBncmVwICJsZDogU29mdHdhcmUgR2Vu
  ZXJhdGlvbiBVdGlsaXRpZXMiID4vZGV2L251bGwgMj4mMTsgdGhlbgoJICAgICMgSG1tLiAgZ2Nj
  IGRvZXNuJ3QgY2FsbCAvdXNyL2Njcy9iaW4vbGQgZGlyZWN0bHksIGJ1dCBpdAoJICAgICMgZG9l
  cyBhcHBlYXIgdG8gYmUgdXNpbmcgaXQgZXZlbnR1YWxseS4gIGVnY3MtMS4wLjMncyBsZAoJICAg
  ICMgd3JhcHBlciBkb2VzIHRoaXMuCgkgICAgIyBNb3N0IFNvbGFyaXMgdmVyc2lvbnMgb2YgbGQg
  SSd2ZSBzZWVuIGNvbnRhaW4gdGhlIG1hZ2ljCgkgICAgIyBzdHJpbmcgdXNlZCBpbiB0aGUgZ3Jl
  cC4KCSAgICA6CgllbGlmIGVjaG8gIiR2ZXJib3NlIiB8IGdyZXAgIlNvbGFyaXMgTGluayBFZGl0
  b3JzIiA+L2Rldi9udWxsIDI+JjE7IHRoZW4KCSAgICAjIEhvd2V2ZXIgc29tZSBTb2xhcmlzIDgg
  dmVyc2lvbnMgcHJpb3IgdG8gbGQgNS44LTEuMjg2IGNvbnRhaW4KCSAgICAjIHRoaXMgc3RyaW5n
  IGluc3RlYWQuCgkgICAgOgoJZWxzZQoJICAgICMgTm8gZXZpZGVuY2UgeWV0IG9mIC91c3IvY2Nz
  L2Jpbi9sZC4gIFNvbWUgdmVyc2lvbnMKCSAgICAjIG9mIGVnY3MncyBsZCB3cmFwcGVyIGNhbGwg
  L3Vzci9jY3MvYmluL2xkIGluIHR1cm4gYnV0CgkgICAgIyBhcHBhcmVudGx5IGRvbid0IHJldmVh
  bCB0aGF0IHVubGVzcyB5b3UgcGFzcyBpbiAtVi4KCSAgICAjIChUaGlzIG1heSBhbGwgZGVwZW5k
  IG9uIGxvY2FsIGNvbmZpZ3VyYXRpb25zIHRvby4pCgoJICAgICMgUmVjb21wdXRlIHZlcmJvc2Ug
  d2l0aCAtV2wsLXYgdG8gZmluZCBHTlUgbGQgaWYgcHJlc2VudAoJICAgIHZlcmJvc2U9YCR7Y2M6
  LWNjfSAkY2NmbGFncyAtV2wsLXYgLW8gdHJ5IHRyeS5jIDI+JjEgfCBncmVwIC9sZCAyPiYxYAoK
  CSAgICBteWxkPWBlY2hvICR2ZXJib3NlIHwgYXdrICcvXC9sZC8ge3ByaW50ICQxfSdgCgkgICAg
  IyBUaGlzIGFzc3VtZXMgdGhhdCBnY2MncyBvdXRwdXQgd2lsbCBub3QgY2hhbmdlLCBhbmQgdGhh
  dAoJICAgICMgL2Z1bGwvcGF0aC90by9sZCB3aWxsIGJlIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBv
  dXRwdXQuCgkgICAgIyBUaHVzIG15bGQgaXMgc29tZXRoaW5nIGxpa2UgL29wdC9nbnUvc3BhcmMt
  c3VuLXNvbGFyaXMyLjUvYmluL2xkCgoJICAgICMgQWxsb3cgdGhhdCAkbXlsZCBtYXkgYmUgJycs
  IGR1ZSB0byBjaGFuZ2VzIGluIGdjYydzIG91dHB1dAoJICAgIGlmICR7bXlsZDotbGR9IC1WIDI+
  JjEgfAoJCWdyZXAgImxkOiBTb2Z0d2FyZSBHZW5lcmF0aW9uIFV0aWxpdGllcyIgPi9kZXYvbnVs
  bCAyPiYxOyB0aGVuCgkJIyBPaywgL3Vzci9jY3MvYmluL2xkIGV2ZW50dWFsbHkgZG9lcyBnZXQg
  Y2FsbGVkLgoJCToKCSAgICBlbGlmICR7bXlsZDotbGR9IC1WIDI+JjEgfAoJCWdyZXAgIlNvbGFy
  aXMgTGluayBFZGl0b3JzIiA+L2Rldi9udWxsIDI+JjE7IHRoZW4KCQkjIE9rLCAvdXNyL2Njcy9i
  aW4vbGQgZXZlbnR1YWxseSBkb2VzIGdldCBjYWxsZWQuCgkJOgoJICAgIGVsc2UKCQllY2hvICJG
  b3VuZCBHTlUgbGQ9JyRteWxkJyIgPiY0CgkJY2F0IDw8RU5EID4mMgoKTk9URTogWW91IGFyZSB1
  c2luZyBHTlUgbGQoMSkuICBHTlUgbGQoMSkgbWlnaHQgbm90IGJ1aWxkIFBlcmwuICBJZiB5b3UK
  aGF2ZSB0cm91YmxlLCB5b3UgY2FuIHVzZSAvdXNyL2Njcy9iaW4vbGQgYnkgaW5jbHVkaW5nIC1C
  L3Vzci9jY3MvYmluLwppbiB5b3VyICR7Y2M6LWNjfSBjb21tYW5kLiAgKE5vdGUgdGhhdCB0aGUg
  dHJhaWxpbmcgIi8iIGlzIHJlcXVpcmVkLikKCkkgd2lsbCB0cnkgdG8gdXNlIEdOVSBsZCBieSBw
  YXNzaW5nIGluIHRoZSAtV2wsLUUgZmxhZywgYnV0IGlmIHRoYXQKZG9lc24ndCB3b3JrLCB5b3Ug
  c2hvdWxkIHVzZSAtQi91c3IvY2NzL2Jpbi8gaW5zdGVhZC4KCkVORAoJCWNjZGxmbGFncz0iJGNj
  ZGxmbGFncyAtV2wsLUUiCgkJbGRkbGZsYWdzPSIkbGRkbGZsYWdzIC1XbCwtRSAtc2hhcmVkIgoJ
  ICAgIGZpCglmaQoKZWxzZQoJIwoJIyBOb3QgdXNpbmcgZ2NjLgoJIwoJY2F0ID4gdHJ5LmMgPDwg
  J0VPTScKI2luY2x1ZGUgPHN0ZGlvLmg+CmludCBtYWluKCkgewojaWYgZGVmaW5lZChfX1NVTlBS
  T19DKQoJcHJpbnRmKCJ3b3Jrc2hvcFxuIik7CiNlbHNlCiNpZiBkZWZpbmVkKF9fU1VOUFJPX0ND
  KQoJcHJpbnRmKCJ3b3Jrc2hvcCBDQ1xuIik7CiNlbHNlCglwcmludGYoIlxuIik7CiNlbmRpZgoj
  ZW5kaWYKcmV0dXJuKDApOwp9CkVPTQoJdHJ5d29ya3Nob3BjYz0iJHtjYzotY2N9ICRjY2ZsYWdz
  IHRyeS5jIC1vIHRyeSIKCWlmICR0cnl3b3Jrc2hvcGNjID4vZGV2L251bGwgMj4mMTsgdGhlbgoJ
  CWNjX25hbWU9YCRydW4gLi90cnlgCgkJaWYgdGVzdCAiJGNjX25hbWUiID0gIndvcmtzaG9wIjsg
  dGhlbgoJCQljY3ZlcnNpb249ImAke2NjOi1jY30gLVYgMj4mMXxzZWQgLW4gLWUgJzFzL15bQ2Nd
  W0NjOV05KjogLy9wJ2AiCgkJZmkKCQlpZiB0ZXN0ICIkY2NfbmFtZSIgPSAid29ya3Nob3AgQ0Mi
  OyB0aGVuCgkJCWNjdmVyc2lvbj0iYCR7Y2M6LUNDfSAtViAyPiYxfHNlZCAtbiAtZSAnMXMvXltD
  Y11bQ106IC8vcCdgIgoJCWZpCgkJY2FzZSAiJGNjX25hbWUiIGluCgkJd29ya3Nob3AqKQoJCQkj
  IFNldHRpbmdzIGZvciBlaXRoZXIgY2Mgb3IgQ0MKCQkJaWYgdGVzdCAhICIkdXNlNjRiaXRhbGxf
  ZG9uZSI7IHRoZW4KCQkJCWxvY2xpYnB0aD0iL3Vzci9saWIgL3Vzci9jY3MvbGliIGAkZ2V0d29y
  a3Nob3BsaWJzYCAkbG9jbGlicHRoIgoJCQlmaQoJCQkjIFN1biBDQy9jYyBkb24ndCBzdXBwb3J0
  IGdjYyBhdHRyaWJ1dGVzCgkJCWRfYXR0cmlidXRlX2Zvcm1hdD0ndW5kZWYnCgkJCWRfYXR0cmli
  dXRlX21hbGxvYz0ndW5kZWYnCgkJCWRfYXR0cmlidXRlX25vbm51bGw9J3VuZGVmJwoJCQlkX2F0
  dHJpYnV0ZV9ub3JldHVybj0ndW5kZWYnCgkJCWRfYXR0cmlidXRlX3B1cmU9J3VuZGVmJwoJCQlk
  X2F0dHJpYnV0ZV91bnVzZWQ9J3VuZGVmJwoJCQlkX2F0dHJpYnV0ZV93YXJuX3VudXNlZF9yZXN1
  bHQ9J3VuZGVmJwoJCQljYXNlICIkY2MiIGluCgkJCSpjOTkpCSMgYzk5IHJlamVjdHMgYmFyZSAn
  LU8nLgoJCQkJY2FzZSAiJG9wdGltaXplIiBpbgoJCQkJJyd8LU8pIG9wdGltaXplPS1PMyA7OwoJ
  CQkJZXNhYwoJCQkJIyBXaXRob3V0IC1YYSBjOTkgZG9lc24ndCBzZWUKCQkJCSMgbWFueSBPUyBp
  bnRlcmZhY2VzLgoJCQkJY2FzZSAiJGNjZmxhZ3MiIGluCgkJCQkqLVhhKikJOzsKCQkJCSopIGNj
  ZmxhZ3M9IiRjY2ZsYWdzIC1YYSIgOzsKCQkJCWVzYWMKCQkJCTs7CgkJCWVzYWMKCQkJOzsKCQll
  c2FjCglmaQoKCSMgU2VlIGlmIGFzKDEpIGlzIEdOVSBhcygxKS4gIEdOVSBtaWdodCBub3Qgd29y
  ayBmb3IgdGhpcyBqb2IuCgljYXNlIGBhcyAtLXZlcnNpb24gPCAvZGV2L251bGwgMj4mMWAgaW4K
  CSpHTlUqKQoJCWNhdCA8PEVORCA+JjIKCk5PVEU6IFlvdSBhcmUgdXNpbmcgR05VIGFzKDEpLiAg
  R05VIGFzKDEpIG1pZ2h0IG5vdCBidWlsZCBQZXJsLgpZb3UgbXVzdCBhcnJhbmdlIHRvIHVzZSAv
  dXNyL2Njcy9iaW4vYXMsIHBlcmhhcHMgYnkgYWRkaW5nIC91c3IvY2NzL2Jpbgp0byB0aGUgYmVn
  aW5uaW5nIG9mIHlvdXIgUEFUSC4KCkVORAoJCTs7Cgllc2FjCgoJIyBTZWUgaWYgbGQoMSkgaXMg
  R05VIGxkKDEpLiAgR05VIGxkKDEpIG1pZ2h0IG5vdCB3b3JrIGZvciB0aGlzIGpvYi4KCSMgbGQg
  LS12ZXJzaW9uIGRvZXNuJ3QgcHJvcGVybHkgcmVwb3J0IGl0c2VsZiBhcyBhIEdOVSB0b29sLAoJ
  IyBhcyBvZiBsZCB2ZXJzaW9uIDIuNiwgc28gd2UgbmVlZCB0byBiZSBtb3JlIHN0cmljdC4gVFdQ
  IDkvNS85NgoJIyBTdW4ncyBsZCBhbHdheXMgZW1pdHMgdGhlICJTb2Z0d2FyZSBHZW5lcmF0aW9u
  IFV0aWxpdGllcyIgc3RyaW5nLgoJaWYgbGQgLVYgMj4mMSB8IGdyZXAgImxkOiBTb2Z0d2FyZSBH
  ZW5lcmF0aW9uIFV0aWxpdGllcyIgPi9kZXYvbnVsbCAyPiYxOyB0aGVuCgkgICAgIyBPaywgbGQg
  aXMgL3Vzci9jY3MvYmluL2xkLgoJICAgIDoKCWVsc2UKCSAgICBjYXQgPDxFTkQgPiYyCgpOT1RF
  OiBZb3UgYXJlIGFwcGFyZW50bHkgdXNpbmcgR05VIGxkKDEpLiAgR05VIGxkKDEpIG1pZ2h0IG5v
  dCBidWlsZCBQZXJsLgpZb3Ugc2hvdWxkIGFycmFuZ2UgdG8gdXNlIC91c3IvY2NzL2Jpbi9sZCwg
  cGVyaGFwcyBieSBhZGRpbmcgL3Vzci9jY3MvYmluCnRvIHRoZSBiZWdpbm5pbmcgb2YgeW91ciBQ
  QVRILgoKRU5ECglmaQpmaQoKIyBhcyAtLXZlcnNpb24gb3IgbGQgLS12ZXJzaW9uIG1pZ2h0IGR1
  bXAgY29yZS4Kcm0gLWYgdHJ5IHRyeS5jIGNvcmUKRU9DQlUKCmNhdCA+IFVVL3VzZXRocmVhZHMu
  Y2J1IDw8J0VPQ0JVJwojIFRoaXMgc2NyaXB0IFVVL3VzZXRocmVhZHMuY2J1IHdpbGwgZ2V0ICdj
  YWxsZWQtYmFjaycgYnkgQ29uZmlndXJlCiMgYWZ0ZXIgaXQgaGFzIHByb21wdGVkIHRoZSB1c2Vy
  IGZvciB3aGV0aGVyIHRvIHVzZSB0aHJlYWRzLgpjYXNlICIkdXNldGhyZWFkcyIgaW4KJGRlZmlu
  ZXx0cnVlfFt5WV0qKQoJY2NmbGFncz0iLURfUkVFTlRSQU5UICRjY2ZsYWdzIgoKCSMgLWxwdGhy
  ZWFkIG92ZXJyaWRlcyBzb21lIGxpYiBDIGZ1bmN0aW9ucywgc28gcHV0IGl0IGJlZm9yZSBjLgoJ
  c2V0IGBlY2hvIFggIiRsaWJzd2FudGVkICJ8IHNlZCAtZSAicy8gYyAvIHB0aHJlYWQgYyAvImAK
  CXNoaWZ0CglsaWJzd2FudGVkPSIkKiIKCgkjIHNjaGVkX3lpZWxkIGlzIGF2YWlsYWJsZSBpbiB0
  aGUgLWxydCBsaWJyYXJ5LiAgSG93ZXZlciwKCSMgd2UgY2FuIGFsc28gcGljayB1cCB0aGUgZXF1
  aXZhbGVudCB5aWVsZCgpIGZ1bmN0aW9uIGluIHRoZQoJIyBub3JtYWwgQyBsaWJyYXJ5LiAgVG8g
  YXZvaWQgcHVsbGluZyBpbiB1bm5lY2Vzc2FyeQoJIyBsaWJyYXJpZXMsIHdlJ2xsIG5vcm1hbGx5
  IGF2b2lkIHNjaGVkX3lpZWxkKCkvLWxydCBhbmQKCSMganVzdCB1c2UgeWllbGQoKS4gIEhvd2V2
  ZXIsIHdlJ2xsIGhvbm9yIGEgY29tbWFuZC1saW5lCgkjIG92ZXJyaWRlIDogIi1Ec2NoZWRfeWll
  bGQ9c2NoZWRfeWllbGQiLgoJIyBJZiB3ZSBlbmQgdXAgdXNpbmcgc2NoZWRfeWllbGQsIHdlJ3Jl
  IGdvaW5nIHRvIG5lZWQgLWxydC4KCXNjaGVkX3lpZWxkPSR7c2NoZWRfeWllbGQ6LXlpZWxkfQoJ
  aWYgdGVzdCAiJHNjaGVkX3lpZWxkIiA9ICJzY2hlZF95aWVsZCI7IHRoZW4KCSAgICBzZXQgYGVj
  aG8gWCAiJGxpYnN3YW50ZWQgInwgc2VkIC1lICJzLyBwdGhyZWFkIC8gcnQgcHRocmVhZCAvImAK
  CSAgICBzaGlmdAoJICAgIGxpYnN3YW50ZWQ9IiQqIgoJZmkKCgkjIE9uIFNvbGFyaXMgMi42IHg4
  NiB0aGVyZSBpcyBhIGJ1ZyB3aXRoIHNpZ3NldGptcCgpIGFuZCBzaWdsb25nam1wKCkKCSMgd2hl
  biBsaW5rZWQgd2l0aCB0aGUgdGhyZWFkcyBsaWJyYXJ5LCBzdWNoIHRoYXQgd2hhdGV2ZXIgcG9z
  aXRpdmUKCSMgdmFsdWUgeW91IHBhc3MgdG8gc2lnbG9uZ2ptcCgpLCBzaWdzZXRqbXAoKSByZXR1
  cm5zIDEuCgkjIFRoYW5rcyB0byBTaW1vbiBQYXJzb25zIDxTLlBhcnNvbnNAZnRlbC5jby51az4g
  Zm9yIHRoaXMgcmVwb3J0LgoJIyBTdW4gQnVnSUQgaXMgNDExNzk0NiwgInNpZ3NldGptcCBhbHdh
  eXMgcmV0dXJucyAxIHdoZW4gY2FsbGVkIGJ5CgkjIHNpZ2xvbmdqbXAgaW4gYSBNVCBwcm9ncmFt
  Ii4gQXMgb2YgMTk5ODA2MjIsIHRoZXJlIGlzIG5vIHBhdGNoCgkjIGF2YWlsYWJsZS4KCWNhdCA+
  dHJ5LmMgPDwnRU9NJwoJLyogVGVzdCBmb3Igc2lnKHNldHxsb25nKWptcCBidWcuICovCgkjaW5j
  bHVkZSA8c2V0am1wLmg+CgoJaW50IG1haW4oKQoJewoJICAgIHNpZ2ptcF9idWYgZW52OwoJICAg
  IGludCByZXQ7CgoJICAgIHJldCA9IHNpZ3NldGptcChlbnYsIDEpOwoJICAgIGlmIChyZXQpIHsg
  cmV0dXJuIHJldCA9PSAyOyB9CgkgICAgc2lnbG9uZ2ptcChlbnYsIDIpOwoJfQpFT00KCWlmIHRl
  c3QgImBhcmNoYCIgPSBpODZwYyAtYSBgdW5hbWUgLXJgID0gNS42ICYmIFwKCSAgICR7Y2M6LWNj
  fSB0cnkuYyAtbHB0aHJlYWQgPi9kZXYvbnVsbCAyPiYxICYmIC4vYS5vdXQ7IHRoZW4KCSAgICBk
  X3NpZ3NldGptcD0kdW5kZWYKCWZpCgoJIyBUaGVzZSBwcm90b3R5cGVzIHNob3VsZCBiZSB2aXNp
  YmxlIHNpbmNlIHdlIHVzaW5nCgkjIC1EX1JFRU5UUkFOVCwgYnV0IHRoYXQgZG9lcyBub3Qgc2Vl
  bSB0byB3b3JrLgoJIyBJdCBkb2VzIHNlZW0gdG8gd29yayBmb3IgZ2V0bmV0YnlhZGRyX3IsIHdl
  aXJkbHkgZW5vdWdoLAoJIyBhbmQgb3RoZXIgX3IgZnVuY3Rpb25zLiAoU29sYXJpcyA4KQoKCWRf
  Y3Rlcm1pZF9yX3Byb3RvPSIkZGVmaW5lIgoJZF9nZXRob3N0YnlhZGRyX3JfcHJvdG89IiRkZWZp
  bmUiCglkX2dldGhvc3RieW5hbWVfcl9wcm90bz0iJGRlZmluZSIKCWRfZ2V0bmV0YnluYW1lX3Jf
  cHJvdG89IiRkZWZpbmUiCglkX2dldHByb3RvYnluYW1lX3JfcHJvdG89IiRkZWZpbmUiCglkX2dl
  dHByb3RvYnludW1iZXJfcl9wcm90bz0iJGRlZmluZSIKCWRfZ2V0c2VydmJ5bmFtZV9yX3Byb3Rv
  PSIkZGVmaW5lIgoJZF9nZXRzZXJ2Ynlwb3J0X3JfcHJvdG89IiRkZWZpbmUiCgoJIyBEaXR0by4g
  KFNvbGFyaXMgNykKCWRfcmVhZGRpcl9yX3Byb3RvPSIkZGVmaW5lIgoJZF9yZWFkZGlyNjRfcl9w
  cm90bz0iJGRlZmluZSIKCWRfdG1wbmFtX3JfcHJvdG89IiRkZWZpbmUiCglkX3R0eW5hbWVfcl9w
  cm90bz0iJGRlZmluZSIKCgk7Owplc2FjCkVPQ0JVCgpjYXQgPiBVVS91c2VsYXJnZWZpbGVzLmNi
  dSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS91c2VsYXJnZWZpbGVzLmNidSB3aWxsIGdldCAn
  Y2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZQojIGFmdGVyIGl0IGhhcyBwcm9tcHRlZCB0aGUgdXNl
  ciBmb3Igd2hldGhlciB0byB1c2UgbGFyZ2UgZmlsZXMuCmNhc2UgIiR1c2VsYXJnZWZpbGVzIiBp
  bgonJ3wkZGVmaW5lfHRydWV8W3lZXSopCgojIEtlZXAgdGhlc2UgaW4gdGhlIGxlZnQgbWFyZ2lu
  LgpjY2ZsYWdzX3VzZWxhcmdlZmlsZXM9ImAkcnVuIGdldGNvbmYgTEZTX0NGTEFHUyAyPi9kZXYv
  bnVsbGAiCmxkZmxhZ3NfdXNlbGFyZ2VmaWxlcz0iYCRydW4gZ2V0Y29uZiBMRlNfTERGTEFHUyAy
  Pi9kZXYvbnVsbGAiCmxpYnN3YW50ZWRfdXNlbGFyZ2VmaWxlcz0iYCRydW4gZ2V0Y29uZiBMRlNf
  TElCUyAyPi9kZXYvbnVsbHxzZWQgLWUgJ3NAXi1sQEAnIC1lICdzQCAtbEAgQGcnYCIKCiAgICBj
  Y2ZsYWdzPSIkY2NmbGFncyAkY2NmbGFnc191c2VsYXJnZWZpbGVzIgogICAgbGRmbGFncz0iJGxk
  ZmxhZ3MgJGxkZmxhZ3NfdXNlbGFyZ2VmaWxlcyIKICAgIGxpYnN3YW50ZWQ9IiRsaWJzd2FudGVk
  ICRsaWJzd2FudGVkX3VzZWxhcmdlZmlsZXMiCiAgICA7Owplc2FjCkVPQ0JVCgojIFRoaXMgaXMg
  dHJ1bHkgYSBtZXNzLgpjYXNlICIkdXNlbW9yZWJpdHMiIGluCiIkZGVmaW5lInx0cnVlfFt5WV0q
  KQoJdXNlNjRiaXRpbnQ9IiRkZWZpbmUiCgl1c2Vsb25nZG91YmxlPSIkZGVmaW5lIgoJOzsKZXNh
  YwoKaWYgdGVzdCBgJHJ1biB1bmFtZSAtcGAgPSBpMzg2OyB0aGVuCiAgICBjYXNlICIkdXNlNjRi
  aXRpbnQiIGluCiAgICAiJGRlZmluZSJ8dHJ1ZXxbeVldKikKICAgICAgICAgICAgY2NmbGFncz0i
  JGNjZmxhZ3MgLURQVFJfSVNfTE9ORyIKICAgICAgICAgICAgOzsKICAgIGVzYWMKZmkKCmlmIHRl
  c3QgYCRydW4gdW5hbWUgLXBgID0gc3BhcmMgLW8gYCRydW4gdW5hbWUgLXBgID0gaTM4NjsgdGhl
  bgogICAgY2F0ID4gVVUvdXNlNjRiaXRpbnQuY2J1IDw8J0VPQ0JVJwojIFRoaXMgc2NyaXB0IFVV
  L3VzZTY0Yml0aW50LmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZQojIGFm
  dGVyIGl0IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgNjQgYml0IGlu
  dGVnZXJzLgpjYXNlICIkdXNlNjRiaXRpbnQiIGluCiIkZGVmaW5lInx0cnVlfFt5WV0qKQoJICAg
  IGNhc2UgImAkcnVuIHVuYW1lIC1yYCIgaW4KCSAgICA1LlswLTRdKQoJCWNhdCA+JjQgPDxFT00K
  U29sYXJpcyBgdW5hbWUgLXJ8c2VkIC1lICdzL141XC4vMi4vJ2AgZG9lcyBub3Qgc3VwcG9ydCA2
  NC1iaXQgaW50ZWdlcnMuCllvdSBzaG91bGQgdXBncmFkZSB0byBhdCBsZWFzdCBTb2xhcmlzIDIu
  NS4KRU9NCgkJZXhpdCAxCgkJOzsKCSAgICBlc2FjCgojIGdjYy0yLjguMSBvbiBTb2xhcmlzIDgg
  d2l0aCAtRHVzZTY0Yml0aW50IGZhaWxzIG9wL3BhdC50IHRlc3QgODIyCiMgaWYgd2UgY29tcGls
  ZSByZWdleGVjLmMgd2l0aCAtTy4gIFR1cm4gb2ZmIG9wdGltaXphdGlvbiBmb3IgdGhhdCBvbmUK
  IyBmaWxlLiAgU2VlIGhpbnRzL1JFQURNRS5oaW50cyAsIGVzcGVjaWFsbHkKIyA9aGVhZDIgUHJv
  cGFnYXRpbmcgdmFyaWFibGVzIHRvIGNvbmZpZy5zaCwgbWV0aG9kIDMuCiMgIEEuIERvdWdoZXJ0
  eSAgTWF5IDI0LCAyMDAyCiAgICBjYXNlICIke2djY3ZlcnNpb259LSR7b3B0aW1pemV9IiBpbgog
  ICAgMi44Ki1PKikKCSMgSG9ub3IgYSBjb21tYW5kLWxpbmUgb3ZlcnJpZGUgKHJhdGhlciB1bmxp
  a2VseSkKCWNhc2UgIiRyZWdleGVjX2NmbGFncyIgaW4KCScnKSBlY2hvICJEaXNhYmxpbmcgb3B0
  aW1pemF0aW9uIG9uIHJlZ2V4ZWMuYyBmb3IgZ2NjICRnY2N2ZXJzaW9uIiA+JjQKCSAgICByZWdl
  eGVjX2NmbGFncz0nb3B0aW1pemU9JwoJICAgIGVjaG8gInJlZ2V4ZWNfY2ZsYWdzPSdvcHRpbWl6
  ZT1cIlwiJyIgPj4gY29uZmlnLnNoCgkgICAgOzsKCWVzYWMKCTs7CiAgICBlc2FjCiAgICA7Owpl
  c2FjCkVPQ0JVCgogICAgY2F0ID4gVVUvdXNlNjRiaXRhbGwuY2J1IDw8J0VPQ0JVJwojIFRoaXMg
  c2NyaXB0IFVVL3VzZTY0Yml0YWxsLmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZp
  Z3VyZQojIGFmdGVyIGl0IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byBiZSBt
  YXhpbWFsbHkgNjQgYml0dHkuCmNhc2UgIiR1c2U2NGJpdGFsbC0kdXNlNjRiaXRhbGxfZG9uZSIg
  aW4KIiRkZWZpbmUtInx0cnVlLXxbeVldKi0pCgkgICAgY2FzZSAiYCRydW4gdW5hbWUgLXJgIiBp
  bgoJICAgIDUuWzAtNl0pCgkJY2F0ID4mNCA8PEVPTQpTb2xhcmlzIGB1bmFtZSAtcnxzZWQgLWUg
  J3MvXjVcLi8yLi8nYCBkb2VzIG5vdCBzdXBwb3J0IDY0LWJpdCBwb2ludGVycy4KWW91IHNob3Vs
  ZCB1cGdyYWRlIHRvIGF0IGxlYXN0IFNvbGFyaXMgMi43LgpFT00KCQlleGl0IDEKCQk7OwoJICAg
  IGVzYWMKCSAgICBwcm9jZXNzb3I9YCRydW4gdW5hbWUgLXBgOwoJICAgIGlmIHRlc3QgIiRwcm9j
  ZXNzb3IiID0gc3BhcmM7IHRoZW4KCQlsaWJjPScvdXNyL2xpYi9zcGFyY3Y5L2xpYmMuc28nCgkJ
  aWYgdGVzdCAhIC1mICRsaWJjOyB0aGVuCgkJICAgIGNhdCA+JjQgPDxFT00KCkkgZG8gbm90IHNl
  ZSB0aGUgNjQtYml0IGxpYmMsICRsaWJjLgpDYW5ub3QgY29udGludWUsIGFib3J0aW5nLgoKRU9N
  CgkJICAgIGV4aXQgMQoJCWZpCgkgICAgZmkKCSAgICBjYXNlICIke2NjOi1jY30gLXYgMj4vZGV2
  L251bGwiIGluCgkgICAgKmdjYyopCgkJZWNobyAnaW50IG1haW4oKSB7IHJldHVybiAwOyB9JyA+
  IHRyeS5jCgkJY2FzZSAiYCR7Y2M6LWNjfSAkY2NmbGFncyAtbWNwdT12OSAtbTY0IC1TIHRyeS5j
  IDI+JjEgfCBncmVwICdtNjQgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGNvbmZpZ3VyYXRpb24n
  YCIgaW4KCQkqIm02NCBpcyBub3Qgc3VwcG9ydGVkIiopCgkJICAgIGNhdCA+JjQgPDxFT00KCkZ1
  bGwgNjQtYml0IGJ1aWxkIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBnY2MgY29uZmlndXJhdGlv
  bi4KQ2hlY2sgaHR0cDovL2djYy5nbnUub3JnLyBmb3IgdGhlIGxhdGVzdCBuZXdzIG9mIGF2YWls
  YWJpbGl0eQpvZiBnY2MgZm9yIDY0LWJpdCBTcGFyYy4KCkNhbm5vdCBjb250aW51ZSwgYWJvcnRp
  bmcuCgpFT00KCQkgICAgZXhpdCAxCgkJICAgIDs7CgkJZXNhYwoJCWlmIHRlc3QgIiRwcm9jZXNz
  b3IiID0gc3BhcmM7IHRoZW4KCQkgICAgbG9jbGlicHRoPSIvdXNyL2xpYi9zcGFyY3Y5ICRsb2Ns
  aWJwdGgiCgkJICAgIGNjZmxhZ3M9IiRjY2ZsYWdzIC1tY3B1PXY5IgoJCWZpCgkJY2NmbGFncz0i
  JGNjZmxhZ3MgLW02NCIKCgkJIyBUaGlzIGFkZHMgaW4gLVdhLC14YXJjaD12OS4gIEkgc3VzcGVj
  dCB0aGF0J3Mgc3VwZXJmbHVvdXMsCgkJIyBzaW5jZSB0aGUgLW02NCBhYm92ZSBzaG91bGQgZG8g
  dGhhdCBhbHJlYWR5LiAgU29tZW9uZQoJCSMgd2l0aCBnY2MtMy54LngsIHBsZWFzZSB0ZXN0IHdp
  dGggZ2NjIC12LiAgIEEuRC4gMjAtTm92LTIwMDMKIwkJaWYgdGVzdCAkcHJvY2Vzc29yID0gc3Bh
  cmMgLWEgWGAkcnVuIGdldGNvbmYgWEJTNV9MUDY0X09GRjY0X0NGTEFHUyAyPi9kZXYvbnVsbGAg
  IT0gWDsgdGhlbgojCQkgICAgY2NmbGFncz0iJGNjZmxhZ3MgLVdhLGAkcnVuIGdldGNvbmYgWEJT
  NV9MUDY0X09GRjY0X0NGTEFHUyAyPi9kZXYvbnVsbGAiCiMJCWZpCgkJbGRmbGFncz0iJGxkZmxh
  Z3MgLW02NCIKCgkJIyBTZWUgW3BlcmwgIzY2NjA0XTogIE9uIFNvbGFyaXMgMTEsIGdjYyAtbTY0
  IG9uIGFtZDY0CgkJIyBhcHBlYXJzIG5vdCB0byB1bmRlcnN0YW5kIC1HLiAgKGdjYyAtRyBoYXMg
  bm90IGNhdXNlZAoJCSMgcHJvYmxlbXMgb24gb3RoZXIgcGxhdGZvcm1zIGluIHRoZSBwYXN0Likg
  IGdjYyB2ZXJzaW9ucwoJCSMgYXQgbGVhc3QgYXMgb2xkIGFzIDMuNC4zIHN1cHBvcnQgLXNoYXJl
  ZCwgc28ganVzdAoJCSMgdXNlIHRoYXQgd2l0aCBTb2xhcmlzIDExIGFuZCBsYXRlciwgYnV0IGtl
  ZXAKCQkjIHRoZSBvbGQgYmVoYXZpb3IgZm9yIG9sZGVyIFNvbGFyaXMgdmVyc2lvbnMuCgkJY2Fz
  ZSAiJG9zdmVycyIgaW4KCQkJMi4/fDIuMTApIGxkZGxmbGFncz0iJGxkZGxmbGFncyAtRyAtbTY0
  IiA7OwoJCQkqKSBsZGRsZmxhZ3M9IiRsZGRsZmxhZ3MgLXNoYXJlZCAtbTY0IiA7OwoJCWVzYWMK
  CQk7OwoJICAgICopCgkJZ2V0Y29uZmNjZmxhZ3M9ImAkcnVuIGdldGNvbmYgWEJTNV9MUDY0X09G
  RjY0X0NGTEFHUyAyPi9kZXYvbnVsbGAiCgkJZ2V0Y29uZmxkZmxhZ3M9ImAkcnVuIGdldGNvbmYg
  WEJTNV9MUDY0X09GRjY0X0xERkxBR1MgMj4vZGV2L251bGxgIgoJCWdldGNvbmZsZGRsZmxhZ3M9
  ImAkcnVuIGdldGNvbmYgWEJTNV9MUDY0X09GRjY0X0xERkxBR1MgMj4vZGV2L251bGxgIgoJCWVj
  aG8gImludCBtYWluKCkgeyByZXR1cm4oMCk7IH0gIiA+IHRyeS5jCgkJY2FzZSAiYCR7Y2M6LWNj
  fSAkZ2V0Y29uZmNjZmxhZ3MgdHJ5LmMgMj4mMSB8IGdyZXAgJ2RlcHJlY2F0ZWQnYCIgaW4KCQkq
  IiAteGFyY2g9Z2VuZXJpYzY0IGlzIGRlcHJlY2F0ZWQsIHVzZSAtbTY0ICIqKQoJCSAgICBnZXRj
  b25mY2NmbGFncz1gZWNobyAkZ2V0Y29uZmNjZmxhZ3MgfCBzZWQgLWUgJ3MveGFyY2g9Z2VuZXJp
  YzY0L202NC8nYAoJCSAgICBnZXRjb25mbGRmbGFncz1gZWNobyAkZ2V0Y29uZmxkZmxhZ3MgfCBz
  ZWQgLWUgJ3MveGFyY2g9Z2VuZXJpYzY0L202NC8nYAoJCSAgICBnZXRjb25mbGRkbGZsYWdzPWBl
  Y2hvICRnZXRjb25mbGRkbGZsYWdzIHwgc2VkIC1lICdzL3hhcmNoPWdlbmVyaWM2NC9tNjQvJ2AK
  CQkgICAgOzsKCQllc2FjCgkJY2NmbGFncz0iJGNjZmxhZ3MgJGdldGNvbmZjY2ZsYWdzIgoJCWxk
  ZmxhZ3M9IiRsZGZsYWdzICRnZXRjb25mbGRmbGFncyIKCQlsZGRsZmxhZ3M9IiRsZGRsZmxhZ3Mg
  LUcgJGdldGNvbmZsZGRsZmxhZ3MiCgoJCWVjaG8gImludCBtYWluKCkgeyByZXR1cm4oMCk7IH0g
  IiA+IHRyeS5jCgkJdHJ5d29ya3Nob3BjYz0iJHtjYzotY2N9IHRyeS5jIC1vIHRyeSAkY2NmbGFn
  cyIKCQlpZiB0ZXN0ICIkcHJvY2Vzc29yIiA9IHNwYXJjOyB0aGVuCgkJICAgIGxvY2xpYnB0aD0i
  L3Vzci9saWIvc3BhcmN2OSAvdXNyL2Njcy9saWIvc3BhcmN2OSAkbG9jbGlicHRoIgoJCWZpCgkJ
  bG9jbGlicHRoPSJgJGdldHdvcmtzaG9wbGlic2AgJGxvY2xpYnB0aCIKCQk7OwoJICAgIGVzYWMK
  CSAgICB1bnNldCBwcm9jZXNzb3IKCSAgICB1c2U2NGJpdGFsbF9kb25lPXllcwoJICAgIGFyY2hu
  YW1lNjQ9NjQKCSAgICA7Owplc2FjCkVPQ0JVCgogICAgIyBBY3R1YWxseSwgd2Ugd2FudCB0byBy
  dW4gdGhpcyBhbHJlYWR5IG5vdywgaWYgc28gcmVxdWVzdGVkLAogICAgIyBiZWNhdXNlIHdlIG5l
  ZWQgdG8gZml4IHVwIHRoaW5ncyByaWdodCBub3cuCiAgICBjYXNlICIkdXNlNjRiaXRhbGwiIGlu
  CiAgICAiJGRlZmluZSJ8dHJ1ZXxbeVldKikKCSMgQ0JVcyBleHBlY3QgdG8gYmUgcnVuIGluIFVV
  CgljZCBVVTsgLiAuL3VzZTY0Yml0YWxsLmNidTsgY2QgLi4KCTs7CiAgICBlc2FjCmZpCgpjYXQg
  PiBVVS91c2Vsb25nZG91YmxlLmNidSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS91c2Vsb25n
  ZG91YmxlLmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZQojIGFmdGVyIGl0
  IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgbG9uZyBkb3VibGVzLgpj
  YXNlICIkdXNlbG9uZ2RvdWJsZSIgaW4KIiRkZWZpbmUifHRydWV8W3lZXSopCglpZiB0ZXN0ICIk
  Y2NfbmFtZSIgPSAid29ya3Nob3AiOyB0aGVuCgkJY2F0ID4gdHJ5LmMgPDwgJ0VPTScKI2luY2x1
  ZGUgPHN1bm1hdGguaD4KaW50IG1haW4oKSB7ICh2b2lkKSBwb3dsKDIsIDI1Nik7IHJldHVybigw
  KTsgfQpFT00KCQlpZiAke2NjOi1jY30gdHJ5LmMgLWxzdW5tYXRoIC1vIHRyeSA+IC9kZXYvbnVs
  bCAyPiYxICYmIC4vdHJ5OyB0aGVuCgkJCWxpYnN3YW50ZWQ9IiRsaWJzd2FudGVkIHN1bm1hdGgi
  CgkJZmkKCWVsc2UKCQljYXQgPiY0IDw8RU9NCgpUaGUgU3VuIFdvcmtzaG9wIG1hdGggbGlicmFy
  eSBpcyBlaXRoZXIgbm90IGF2YWlsYWJsZSBvciBub3Qgd29ya2luZywKc28gSSBkbyBub3Qga25v
  dyBob3cgdG8gZG8gbG9uZyBkb3VibGVzLCBzb3JyeS4KSSdtIHRoZXJlZm9yZSBkaXNhYmxpbmcg
  dGhlIHVzZSBvZiBsb25nIGRvdWJsZXMuCkVPTQoJCXVzZWxvbmdkb3VibGU9IiR1bmRlZiIKCWZp
  Cgk7Owplc2FjCkVPQ0JVCgojCiMgSWYgdW5zZXRlbnYgaXMgYXZhaWxhYmxlLCB1c2UgaXQgaW4g
  Y29uanVuY3Rpb24gd2l0aCBQRVJMX1VTRV9TQUZFX1BVVEVOViB0bwojIHdvcmsgYXJvdW5kIFN1
  biBidWdpZCA2MzMzODMwLiAgQm90aCB1bnNldGVudiBhbmQgNjMzMzgzMCBvbmx5IGFwcGVhciBp
  bgojIFNvbGFyaXMgMTAsIHNvIHdlIGRvbid0IG5lZWQgdG8gcHJvYmUgZXhwbGljaXRseSBmb3Ig
  YW4gT1MgdmVyc2lvbi4gIFdlIGhhdmUKIyB0byBhcHBlbmQgdGhpcyB0ZXN0IHRvIHRoZSBlbmQg
  b2YgY29uZmlnLm92ZXIgYXMgaXQgbmVlZHMgdG8gcnVuIGFmdGVyCiMgQ29uZmlndXJlIGhhcyBw
  cm9iZWQgZm9yIHVuc2V0ZW52LCBhbmQgdGhpcyBoaW50cyBmaWxlIGlzIHByb2Nlc3NlZCBiZWZv
  cmUKIyB0aGF0IGhhcyBoYXBwZW5lZC4KIwpjYXQgPj4gY29uZmlnLm92ZXIgPDwnRU9PVkVSJwpp
  ZiB0ZXN0ICIkZF91bnNldGVudiIgPSAiJGRlZmluZSIgLWEgXAogICAgYGV4cHIgIiRjY2ZsYWdz
  IiA6ICcuKi1EUEVSTF9VU0VfU0FGRV9QVVRFTlYnYCAtZXEgMDsgdGhlbgogICAgICAgIGNjZmxh
  Z3M9IiRjY2ZsYWdzIC1EUEVSTF9VU0VfU0FGRV9QVVRFTlYiCmZpCkVPT1ZFUgoKcm0gLWYgdHJ5
  LmMgdHJ5Lm8gdHJ5IGEub3V0CgojIElmIHVzaW5nIEMrKywgdGhlIENvbmZpZ3VyZSBzY2FuIGZv
  ciBkbG9wZW4oKSB3aWxsIGZhaWwgaW4gU29sYXJpcwojIGJlY2F1c2Ugb25lIG9mIHRoZSB0d28g
  KDEpIGFuIGV4dGVybiAiQyIgbGlua2FnZSBkZWZpbml0aW9uIGlzIG5lZWRlZAojICgyKSAjaW5j
  bHVkZSA8ZGxmY24uaD4gaXMgbmVlZGVkLCAqYW5kKiBhIGNhc3QgdG8gKHZvaWQqKCopKCkpCiMg
  aXMgbmVlZGVkIGZvciB0aGUgJmRsb3Blbi4gIEFkZGluZyBhbnkgb2YgdGhlc2Ugd291bGQgcmVx
  dWlyZSBjaGFuZ2luZwojIGEgZGVsaWNhdGUgc3BvdCBpbiBDb25maWd1cmUsIHNvIGVhc2llciBq
  dXN0IHRvIGZvcmNlIG91ciBndWVzcyBoZXJlCiMgZm9yIFNvbGFyaXMuICBNdWNoIHRoZSBzYW1l
  IGdvZXMgZm9yIGRsZXJyb3IoKS4KY2FzZSAiJGNjIiBpbgoqZysrKnwqQ0MqKQogIGRfZGxvcGVu
  PSdkZWZpbmUnCiAgZF9kbGVycm9yPSdkZWZpbmUnCiAgOzsKZXNhYwoKIyBPcmFjbGUvU3VuIGJ1
  aWxkcyB0aGVpciBQZXJsIHNoYXJlZCBzaW5jZSA1LjYuMSwgYW5kIHRoZXkgYWxzbwojIHN0cm9u
  Z2x5IHJlY29tbWVuZCB1c2luZyBzaGFyZWQgbGlicmFyaWVzIGluIGdlbmVyYWwuCiMKIyBGdXJ0
  aGVybW9yZSwgT3BlbkluZGlhbmEgc2VlbXMgdG8gZWZmZWN0aXZlbHkgcmVxdWlyZSBidWlsZGlu
  ZyBwZXJsCiMgc2hhcmVkLCBvciBvdGhlcndpc2UgcGVybCBzY3JpcHRzIHdvbid0IGV2ZW4gZmlu
  ZCB0aGUgUGVybCBsaWJyYXJ5Lgp1c2VzaHJwbGliPSd0cnVlJwo=',);my%files=('freebsd'=>'freebsd.sh','netbsd'=>'netbsd.sh','openbsd'=>'openbsd.sh','linux'=>'linux.sh','dragonfly'=>'dragonfly.sh','darwin'=>'darwin.sh','hpux'=>'hpux.sh','cygwin'=>'cygwin.sh','midnightbsd'=>'midnightbsd.sh','gnukfreebsd'=>'gnukfreebsd.sh','solaris'=>'solaris_2.sh','bitrig'=>'bitrig.sh','gnu'=>'gnu.sh',);sub hint_file {my$os=shift;$os=shift if eval {$os->isa(__PACKAGE__)};$os=$^O unless$os;return unless defined$hints{$os };my$content=decode_base64($hints{$os });return$content unless wantarray;return ($files{$os },$content)}sub hints {return sort keys%hints}qq'nudge nudge wink wink';
DEVEL_PATCHPERL_HINTS

$fatpacked{"Devel/PatchPerl/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_PATCHPERL_PLUGIN';
  package Devel::PatchPerl::Plugin;$Devel::PatchPerl::Plugin::VERSION='1.48';use strict;use warnings;qq[Plug it in];
DEVEL_PATCHPERL_PLUGIN

$fatpacked{"ExtUtils/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_COMMAND';
  package ExtUtils::Command;use 5.00503;use strict;use Carp;use File::Copy;use File::Compare;use File::Basename;use File::Path qw(rmtree);require Exporter;use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);@ISA=qw(Exporter);@EXPORT=qw(cp rm_f rm_rf mv cat eqtime mkpath touch test_f test_d chmod dos2unix);$VERSION='1.16';my$Is_VMS=$^O eq 'VMS';my$Is_VMS_mode=$Is_VMS;my$Is_VMS_noefs=$Is_VMS;my$Is_Win32=$^O eq 'MSWin32';if($Is_VMS){my$vms_unix_rpt;my$vms_efs;my$vms_case;if (eval {local$SIG{__DIE__};require VMS::Feature}){$vms_unix_rpt=VMS::Feature::current("filename_unix_report");$vms_efs=VMS::Feature::current("efs_charset");$vms_case=VMS::Feature::current("efs_case_preserve")}else {my$unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';my$efs_charset=$ENV{'DECC$EFS_CHARSET'}|| '';my$efs_case=$ENV{'DECC$EFS_CASE_PRESERVE'}|| '';$vms_unix_rpt=$unix_rpt =~ /^[ET1]/i;$vms_efs=$efs_charset =~ /^[ET1]/i;$vms_case=$efs_case =~ /^[ET1]/i}$Is_VMS_mode=0 if$vms_unix_rpt;$Is_VMS_noefs=0 if ($vms_efs)}my$wild_regex=$Is_VMS ? '*%' : '*?';sub expand_wildcards {@ARGV=map(/[$wild_regex]/o ? glob($_): $_,@ARGV)}sub cat () {expand_wildcards();print while (<>)}sub eqtime {my ($src,$dst)=@ARGV;local@ARGV=($dst);touch();utime((stat($src))[8,9],$dst)}sub rm_rf {expand_wildcards();rmtree([grep -e $_,@ARGV],0,0)}sub rm_f {expand_wildcards();for my$file (@ARGV){next unless -f $file;next if _unlink($file);chmod(0777,$file);next if _unlink($file);carp "Cannot delete $file: $!"}}sub _unlink {my$files_unlinked=0;for my$file (@_){my$delete_count=0;$delete_count++ while unlink$file;$files_unlinked++ if$delete_count}return$files_unlinked}sub touch {my$t=time;expand_wildcards();for my$file (@ARGV){open(FILE,">>$file")|| die "Cannot write $file:$!";close(FILE);utime($t,$t,$file)}}sub mv {expand_wildcards();my@src=@ARGV;my$dst=pop@src;croak("Too many arguments")if (@src > 1 &&!-d $dst);my$nok=0;for my$src (@src){$nok ||=!move($src,$dst)}return!$nok}sub cp {expand_wildcards();my@src=@ARGV;my$dst=pop@src;croak("Too many arguments")if (@src > 1 &&!-d $dst);my$nok=0;for my$src (@src){$nok ||=!copy($src,$dst);utime(time,time,$dst)if$Is_Win32}return$nok}sub chmod {local@ARGV=@ARGV;my$mode=shift(@ARGV);expand_wildcards();if($Is_VMS_mode && $Is_VMS_noefs){for my$idx (0..$#ARGV){my$path=$ARGV[$idx];next unless -d $path;my@dirs=File::Spec->splitdir($path);$dirs[-1].= '.dir';$path=File::Spec->catfile(@dirs);$ARGV[$idx]=$path}}chmod(oct$mode,@ARGV)|| die "Cannot chmod ".join(' ',$mode,@ARGV).":$!"}sub mkpath {expand_wildcards();File::Path::mkpath([@ARGV],0,0777)}sub test_f {exit(-f $ARGV[0]? 0 : 1)}sub test_d {exit(-d $ARGV[0]? 0 : 1)}sub dos2unix {require File::Find;File::Find::find(sub {return if -d;return unless -w _;return unless -r _;return if -B _;local $\;my$orig=$_;my$temp='.dos2unix_tmp';open ORIG,$_ or do {warn "dos2unix can't open $_: $!";return};open TEMP,">$temp" or do {warn "dos2unix can't create .dos2unix_tmp: $!";return};while (my$line=<ORIG>){$line =~ s/\015\012/\012/g;print TEMP$line}close ORIG;close TEMP;rename$temp,$orig},@ARGV)}
EXTUTILS_COMMAND

$fatpacked{"ExtUtils/Command/MM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_COMMAND_MM';
  package ExtUtils::Command::MM;require 5.006;use strict;use warnings;require Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(test_harness pod2man perllocal_install uninstall warn_if_old_packlist);our$VERSION='6.66';my$Is_VMS=$^O eq 'VMS';sub test_harness {require Test::Harness;require File::Spec;$Test::Harness::verbose=shift;require ExtUtils::Command;my@argv=ExtUtils::Command::expand_wildcards(@ARGV);local@INC=@INC;unshift@INC,map {File::Spec->rel2abs($_)}@_;Test::Harness::runtests(sort {lc$a cmp lc$b}@argv)}sub pod2man {local@ARGV=@_ ? @_ : @ARGV;{local $@;if(!eval {require Pod::Man}){warn "Pod::Man is not available: $@"."Man pages will not be generated during this install.\n";return 0}}require Getopt::Long;my%options=();Getopt::Long::config ('bundling_override');Getopt::Long::GetOptions (\%options,'section|s=s','release|r=s','center|c=s','date|d=s','fixed=s','fixedbold=s','fixeditalic=s','fixedbolditalic=s','official|o','quotes|q=s','lax|l','name|n=s','perm_rw=i');return 0 unless@ARGV;if ($options{official}&&!defined$options{center}){$options{center}=q[Perl Programmer's Reference Guide]}delete$options{lax};do {{my ($pod,$man)=splice(@ARGV,0,2);next if ((-e $man)&& (-M $man < -M $pod)&& (-M $man < -M "Makefile"));print "Manifying $man\n";my$parser=Pod::Man->new(%options);$parser->parse_from_file($pod,$man)or do {warn("Could not install $man\n");next};if (exists$options{perm_rw}){chmod(oct($options{perm_rw}),$man)or do {warn("chmod $options{perm_rw} $man: $!\n");next}}}}while@ARGV;return 1}sub warn_if_old_packlist {my$packlist=$ARGV[0];return unless -f $packlist;print <<"PACKLIST_WARNING"}sub perllocal_install {my($type,$name)=splice(@ARGV,0,2);my@mod_info=$Is_VMS ? split /\|/,<STDIN> : @ARGV;my$pod;$pod=sprintf <<POD,scalar localtime;do {my($key,$val)=splice(@mod_info,0,2);$pod .= <<POD}while(@mod_info);$pod .= "=back\n\n";$pod =~ s/^ //mg;print$pod;return 1}sub uninstall {my($packlist)=shift@ARGV;require ExtUtils::Install;print <<'WARNING';ExtUtils::Install::uninstall($packlist,1,1);print <<'WARNING'}1;
  WARNING: I have found an old package in
      $packlist.
  Please make sure the two installations are not conflicting
  PACKLIST_WARNING
   =head2 %s: C<$type> L<$name|$name>
   
   =over 4
   
  POD
   =item *
   
   C<$key: $val>
   
  POD
  
  Uninstall is unsafe and deprecated, the uninstallation was not performed.
  We will show what would have been done.
  
  WARNING
  
  Uninstall is unsafe and deprecated, the uninstallation was not performed.
  Please check the list above carefully, there may be errors.
  Remove the appropriate files manually.
  Sorry for the inconvenience.
  
  WARNING
EXTUTILS_COMMAND_MM

$fatpacked{"ExtUtils/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALL';
  package ExtUtils::Install;use strict;use vars qw(@ISA @EXPORT $VERSION $MUST_REBOOT %Config);use AutoSplit;use Carp ();use Config qw(%Config);use Cwd qw(cwd);use Exporter;use ExtUtils::Packlist;use File::Basename qw(dirname);use File::Compare qw(compare);use File::Copy;use File::Find qw(find);use File::Path;use File::Spec;@ISA=('Exporter');@EXPORT=('install','uninstall','pm_to_blib','install_default');$VERSION='1.54';$VERSION=eval$VERSION;my$Is_VMS=$^O eq 'VMS';my$Is_VMS_noefs=$Is_VMS;my$Is_MacPerl=$^O eq 'MacOS';my$Is_Win32=$^O eq 'MSWin32';my$Is_cygwin=$^O eq 'cygwin';my$CanMoveAtBoot=($Is_Win32 || $Is_cygwin);if($Is_VMS){my$vms_unix_rpt;my$vms_efs;my$vms_case;if (eval {local$SIG{__DIE__};require VMS::Feature}){$vms_unix_rpt=VMS::Feature::current("filename_unix_report");$vms_efs=VMS::Feature::current("efs_charset");$vms_case=VMS::Feature::current("efs_case_preserve")}else {my$unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';my$efs_charset=$ENV{'DECC$EFS_CHARSET'}|| '';my$efs_case=$ENV{'DECC$EFS_CASE_PRESERVE'}|| '';$vms_unix_rpt=$unix_rpt =~ /^[ET1]/i;$vms_efs=$efs_charset =~ /^[ET1]/i;$vms_case=$efs_case =~ /^[ET1]/i}$Is_VMS_noefs=0 if ($vms_efs)}my$Has_Win32API_File=($Is_Win32 || $Is_cygwin)? (eval {require Win32API::File;1}|| 0): 0;my$Inc_uninstall_warn_handler;my$INSTALL_ROOT=$ENV{PERL_INSTALL_ROOT};my$Curdir=File::Spec->curdir;my$Updir=File::Spec->updir;sub _estr(@) {return join "\n",'!' x 72,@_,'!' x 72,''}{my%warned;sub _warnonce(@) {my$first=shift;my$msg=_estr "WARNING: $first",@_;warn$msg unless$warned{$msg}++}}sub _choke(@) {my$first=shift;my$msg=_estr "ERROR: $first",@_;Carp::croak($msg)}sub _chmod($$;$) {my ($mode,$item,$verbose)=@_;$verbose ||= 0;if (chmod$mode,$item){printf "chmod(0%o, %s)\n",$mode,$item if$verbose > 1}else {my$err="$!";_warnonce sprintf "WARNING: Failed chmod(0%o, %s): %s\n",$mode,$item,$err if -e $item}}sub _move_file_at_boot {my ($file,$target,$moan)=@_;Carp::confess("Panic: Can't _move_file_at_boot on this platform!")unless$CanMoveAtBoot;my$descr=ref$target ? "'$file' for deletion" : "'$file' for installation as '$target'";if (!$Has_Win32API_File){my@msg=("Cannot schedule $descr at reboot.","Try installing Win32API::File to allow operations on locked files","to be scheduled during reboot. Or try to perform the operation by","hand yourself. (You may need to close other perl processes first)");if ($moan){_warnonce(@msg)}else {_choke(@msg)}return 0}my$opts=Win32API::File::MOVEFILE_DELAY_UNTIL_REBOOT();$opts=$opts | Win32API::File::MOVEFILE_REPLACE_EXISTING()unless ref$target;_chmod(0666,$file);_chmod(0666,$target)unless ref$target;if (Win32API::File::MoveFileEx($file,$target,$opts)){$MUST_REBOOT ||= ref$target ? 0 : 1;return 1}else {my@msg=("MoveFileEx $descr at reboot failed: $^E","You may try to perform the operation by hand yourself. ","(You may need to close other perl processes first).",);if ($moan){_warnonce(@msg)}else {_choke(@msg)}}return 0}sub _unlink_or_rename {my ($file,$tryhard,$installing)=@_;_chmod(0666,$file);my$unlink_count=0;while (unlink$file){$unlink_count++}return$file if$unlink_count > 0;my$error="$!";_choke("Cannot unlink '$file': $!")unless$CanMoveAtBoot && $tryhard;my$tmp="AAA";++$tmp while -e "$file.$tmp";$tmp="$file.$tmp";warn "WARNING: Unable to unlink '$file': $error\n","Going to try to rename it to '$tmp'.\n";if (rename$file,$tmp){warn "Rename succesful. Scheduling '$tmp'\nfor deletion at reboot.\n";_move_file_at_boot($tmp,[],$installing);return$file}elsif ($installing){_warnonce("Rename failed: $!. Scheduling '$tmp'\nfor"." installation as '$file' at reboot.\n");_move_file_at_boot($tmp,$file);return$tmp}else {_choke("Rename failed:$!","Cannot procede.")}}sub _get_install_skip {my ($skip,$verbose)=@_;if ($ENV{EU_INSTALL_IGNORE_SKIP}){print "EU_INSTALL_IGNORE_SKIP is set, ignore skipfile settings\n" if$verbose>2;return []}if (!defined$skip){print "Looking for install skip list\n" if$verbose>2;for my$file ('INSTALL.SKIP',$ENV{EU_INSTALL_SITE_SKIPFILE}){next unless$file;print "\tChecking for $file\n" if$verbose>2;if (-e $file){$skip=$file;last}}}if ($skip &&!ref$skip){print "Reading skip patterns from '$skip'.\n" if$verbose;if (open my$fh,$skip){my@patterns;while (<$fh>){chomp;next if /^\s*(?:#|$)/;print "\tSkip pattern: $_\n" if$verbose>3;push@patterns,$_}$skip=\@patterns}else {warn "Can't read skip file:'$skip':$!\n";$skip=[]}}elsif (UNIVERSAL::isa($skip,'ARRAY')){print "Using array for skip list\n" if$verbose>2}elsif ($verbose){print "No skip list found.\n" if$verbose>1;$skip=[]}warn "Got @{[0+@$skip]} skip patterns.\n" if$verbose>3;return$skip}{my$has_posix;sub _have_write_access {my$dir=shift;unless (defined$has_posix){$has_posix=(!$Is_cygwin &&!$Is_Win32 && eval 'local $^W; require POSIX; 1')|| 0}if ($has_posix){return POSIX::access($dir,POSIX::W_OK())}else {return -w $dir}}}sub _can_write_dir {my$dir=shift;return unless defined$dir and length$dir;my ($vol,$dirs,$file)=File::Spec->splitpath($dir,1);my@dirs=File::Spec->splitdir($dirs);unshift@dirs,File::Spec->curdir unless File::Spec->file_name_is_absolute($dir);my$path='';my@make;while (@dirs){if ($Is_VMS_noefs){$dir=File::Spec->catdir($vol,@dirs)}else {$dir=File::Spec->catdir(@dirs);$dir=File::Spec->catpath($vol,$dir,'')if defined$vol and length$vol}next if ($dir eq $path);if (!-e $dir){unshift@make,$dir;next}if (_have_write_access($dir)){return 1,$dir,@make}else {return 0,$dir,@make}}continue {pop@dirs}return 0}sub _mkpath {my ($dir,$show,$mode,$verbose,$dry_run)=@_;if ($verbose && $verbose > 1 &&!-d $dir){$show=1;printf "mkpath(%s,%d,%#o)\n",$dir,$show,$mode}if (!$dry_run){if (!eval {File::Path::mkpath($dir,$show,$mode);1}){_choke("Can't create '$dir'","$@")}}my ($can,$root,@make)=_can_write_dir($dir);if (!$can){my@msg=("Can't create '$dir'",$root ? "Do not have write permissions on '$root'" : "Unknown Error");if ($dry_run){_warnonce@msg}else {_choke@msg}}elsif ($show and $dry_run){print "$_\n" for@make}}sub _copy {my ($from,$to,$verbose,$dry_run)=@_;if ($verbose && $verbose>1){printf "copy(%s,%s)\n",$from,$to}if (!$dry_run){File::Copy::copy($from,$to)or Carp::croak(_estr "ERROR: Cannot copy '$from' to '$to': $!")}}sub _chdir {my ($dir)=@_;my$ret;if (defined wantarray){$ret=cwd}chdir$dir or _choke("Couldn't chdir to '$dir': $!");return$ret}sub install {my($from_to,$verbose,$dry_run,$uninstall_shadows,$skip,$always_copy,$result)=@_;if (@_==1 and eval {1+@$from_to}){my%opts=@$from_to;$from_to=$opts{from_to}or Carp::confess("from_to is a mandatory parameter");$verbose=$opts{verbose};$dry_run=$opts{dry_run};$uninstall_shadows=$opts{uninstall_shadows};$skip=$opts{skip};$always_copy=$opts{always_copy};$result=$opts{result}}$result ||= {};$verbose ||= 0;$dry_run ||= 0;$skip=_get_install_skip($skip,$verbose);$always_copy=$ENV{EU_INSTALL_ALWAYS_COPY}|| $ENV{EU_ALWAYS_COPY}|| 0 unless defined$always_copy;my(%from_to)=%$from_to;my(%pack,$dir,%warned);my($packlist)=ExtUtils::Packlist->new();local(*DIR);for (qw/read write/){$pack{$_}=$from_to{$_};delete$from_to{$_}}my$tmpfile=install_rooted_file($pack{"read"});$packlist->read($tmpfile)if (-f $tmpfile);my$cwd=cwd();my@found_files;my%check_dirs;MOD_INSTALL: foreach my$source (sort keys%from_to){my$targetroot=install_rooted_dir($from_to{$source});my$blib_lib=File::Spec->catdir('blib','lib');my$blib_arch=File::Spec->catdir('blib','arch');if ($source eq $blib_lib and exists$from_to{$blib_arch}and directory_not_empty($blib_arch)){$targetroot=install_rooted_dir($from_to{$blib_arch});print "Files found in $blib_arch: installing files in $blib_lib into architecture dependent library tree\n"}next unless -d $source;_chdir($source);my$current_directory=$Is_MacPerl ? $Curdir : '.';find(sub {my ($mode,$size,$atime,$mtime)=(stat)[2,7,8,9];return if!-f _;my$origfile=$_;return if$origfile eq ".exists";my$targetdir=File::Spec->catdir($targetroot,$File::Find::dir);my$targetfile=File::Spec->catfile($targetdir,$origfile);my$sourcedir=File::Spec->catdir($source,$File::Find::dir);my$sourcefile=File::Spec->catfile($sourcedir,$origfile);for my$pat (@$skip){if ($sourcefile=~/$pat/){print "Skipping $targetfile (filtered)\n" if$verbose>1;$result->{install_filtered}{$sourcefile}=$pat;return}}my$save_cwd=_chdir($cwd);my$diff=0;if ($always_copy or!-f $targetfile or -s $targetfile!=$size){$diff++}else {$diff=compare($sourcefile,$targetfile)}$check_dirs{$targetdir}++ unless -w $targetfile;push@found_files,[$diff,$File::Find::dir,$origfile,$mode,$size,$atime,$mtime,$targetdir,$targetfile,$sourcedir,$sourcefile,];_chdir($save_cwd)},$current_directory);_chdir($cwd)}for my$targetdir (sort keys%check_dirs){_mkpath($targetdir,0,0755,$verbose,$dry_run)}for my$found (@found_files){my ($diff,$ffd,$origfile,$mode,$size,$atime,$mtime,$targetdir,$targetfile,$sourcedir,$sourcefile)=@$found;my$realtarget=$targetfile;if ($diff){eval {if (-f $targetfile){print "_unlink_or_rename($targetfile)\n" if$verbose>1;$targetfile=_unlink_or_rename($targetfile,'tryhard','install')unless$dry_run}elsif (!-d $targetdir){_mkpath($targetdir,0,0755,$verbose,$dry_run)}print "Installing $targetfile\n";_copy($sourcefile,$targetfile,$verbose,$dry_run,);print "utime($atime,$mtime,$targetfile)\n" if$verbose>1;utime($atime,$mtime + $Is_VMS,$targetfile)unless$dry_run>1;$mode=0444 | ($mode & 0111 ? 0111 : 0);$mode=$mode | 0222 if$realtarget ne $targetfile;_chmod($mode,$targetfile,$verbose);$result->{install}{$targetfile}=$sourcefile;1}or do {$result->{install_fail}{$targetfile}=$sourcefile;die $@}}else {$result->{install_unchanged}{$targetfile}=$sourcefile;print "Skipping $targetfile (unchanged)\n" if$verbose}if ($uninstall_shadows){inc_uninstall($sourcefile,$ffd,$verbose,$dry_run,$realtarget ne $targetfile ? $realtarget : "",$result)}$packlist->{$targetfile}++}if ($pack{'write'}){$dir=install_rooted_dir(dirname($pack{'write'}));_mkpath($dir,0,0755,$verbose,$dry_run);print "Writing $pack{'write'}\n" if$verbose;$packlist->write(install_rooted_file($pack{'write'}))unless$dry_run}_do_cleanup($verbose);return$result}sub _do_cleanup {my ($verbose)=@_;if ($MUST_REBOOT){die _estr "Operation not completed! ","You must reboot to complete the installation.","Sorry."}elsif (defined$MUST_REBOOT & $verbose){warn _estr "Installation will be completed at the next reboot.\n","However it is not necessary to reboot immediately.\n"}}sub install_rooted_file {if (defined$INSTALL_ROOT){File::Spec->catfile($INSTALL_ROOT,$_[0])}else {$_[0]}}sub install_rooted_dir {if (defined$INSTALL_ROOT){File::Spec->catdir($INSTALL_ROOT,$_[0])}else {$_[0]}}sub forceunlink {my ($file,$tryhard)=@_;_unlink_or_rename($file,$tryhard,not("installing"))}sub directory_not_empty ($) {my($dir)=@_;my$files=0;find(sub {return if $_ eq ".exists";if (-f){$File::Find::prune++;$files=1}},$dir);return$files}sub install_default {@_ < 2 or Carp::croak("install_default should be called with 0 or 1 argument");my$FULLEXT=@_ ? shift : $ARGV[0];defined$FULLEXT or die "Do not know to where to write install log";my$INST_LIB=File::Spec->catdir($Curdir,"blib","lib");my$INST_ARCHLIB=File::Spec->catdir($Curdir,"blib","arch");my$INST_BIN=File::Spec->catdir($Curdir,'blib','bin');my$INST_SCRIPT=File::Spec->catdir($Curdir,'blib','script');my$INST_MAN1DIR=File::Spec->catdir($Curdir,'blib','man1');my$INST_MAN3DIR=File::Spec->catdir($Curdir,'blib','man3');my@INST_HTML;if($Config{installhtmldir}){my$INST_HTMLDIR=File::Spec->catdir($Curdir,'blib','html');@INST_HTML=($INST_HTMLDIR=>$Config{installhtmldir})}install({read=>"$Config{sitearchexp}/auto/$FULLEXT/.packlist",write=>"$Config{installsitearch}/auto/$FULLEXT/.packlist",$INST_LIB=>(directory_not_empty($INST_ARCHLIB))? $Config{installsitearch}: $Config{installsitelib},$INST_ARCHLIB=>$Config{installsitearch},$INST_BIN=>$Config{installbin},$INST_SCRIPT=>$Config{installscript},$INST_MAN1DIR=>$Config{installman1dir},$INST_MAN3DIR=>$Config{installman3dir},@INST_HTML,},1,0,0)}sub uninstall {my($fil,$verbose,$dry_run)=@_;$verbose ||= 0;$dry_run ||= 0;die _estr "ERROR: no packlist file found: '$fil'" unless -f $fil;my ($packlist)=ExtUtils::Packlist->new($fil);for (sort(keys(%$packlist))){chomp;print "unlink $_\n" if$verbose;forceunlink($_,'tryhard')unless$dry_run}print "unlink $fil\n" if$verbose;forceunlink($fil,'tryhard')unless$dry_run;_do_cleanup($verbose)}sub inc_uninstall {my($filepath,$libdir,$verbose,$dry_run,$ignore,$results)=@_;my($dir);$ignore||="";my$file=(File::Spec->splitpath($filepath))[2];my%seen_dir=();my@PERL_ENV_LIB=split$Config{path_sep},defined$ENV{'PERL5LIB'}? $ENV{'PERL5LIB'}: $ENV{'PERLLIB'}|| '';my@dirs=(@PERL_ENV_LIB,@INC,@Config{qw(archlibexp privlibexp sitearchexp sitelibexp)});my$seen_ours;for$dir (@dirs){my$canonpath=$Is_VMS ? $dir : File::Spec->canonpath($dir);next if$canonpath eq $Curdir;next if$seen_dir{$canonpath}++;my$targetfile=File::Spec->catfile($canonpath,$libdir,$file);next unless -f $targetfile;my$diff=0;if (-f $targetfile && -s _==-s $filepath){$diff=compare($filepath,$targetfile)}else {$diff++}print "#$file and $targetfile differ\n" if$diff && $verbose > 1;if (!$diff or $targetfile eq $ignore){$seen_ours=1;next}if ($dry_run){$results->{uninstall}{$targetfile}=$filepath;if ($verbose){$Inc_uninstall_warn_handler ||= ExtUtils::Install::Warn->new();$libdir =~ s|^\./||s ;$Inc_uninstall_warn_handler->add(File::Spec->catfile($libdir,$file),$targetfile)}}else {print "Unlinking $targetfile (shadowing?)\n" if$verbose;eval {die "Fake die for testing" if$ExtUtils::Install::Testing and ucase(File::Spec->canonpath($ExtUtils::Install::Testing))eq ucase($targetfile);forceunlink($targetfile,'tryhard');$results->{uninstall}{$targetfile}=$filepath;1}or do {$results->{fail_uninstall}{$targetfile}=$filepath;if ($seen_ours){warn "Failed to remove probably harmless shadow file '$targetfile'\n"}else {die "$@\n"}}}}}sub run_filter {my ($cmd,$src,$dest)=@_;local(*CMD,*SRC);open(CMD,"|$cmd >$dest")|| die "Cannot fork: $!";open(SRC,$src)|| die "Cannot open $src: $!";my$buf;my$sz=1024;while (my$len=sysread(SRC,$buf,$sz)){syswrite(CMD,$buf,$len)}close SRC;close CMD or die "Filter command '$cmd' failed for $src"}sub pm_to_blib {my($fromto,$autodir,$pm_filter)=@_;_mkpath($autodir,0,0755);while(my($from,$to)=each %$fromto){if(-f $to && -s $from==-s $to && -M $to < -M $from){print "Skip $to (unchanged)\n";next}my$need_filtering=defined$pm_filter && length$pm_filter && $from =~ /\.pm$/;if (!$need_filtering && 0==compare($from,$to)){print "Skip $to (unchanged)\n";next}if (-f $to){forceunlink($to)}else {_mkpath(dirname($to),0,0755)}if ($need_filtering){run_filter($pm_filter,$from,$to);print "$pm_filter <$from >$to\n"}else {_copy($from,$to);print "cp $from $to\n"}my($mode,$atime,$mtime)=(stat$from)[2,8,9];utime($atime,$mtime+$Is_VMS,$to);_chmod(0444 | ($mode & 0111 ? 0111 : 0),$to);next unless$from =~ /\.pm$/;_autosplit($to,$autodir)}}sub _autosplit {my$retval=autosplit(@_);close*AutoSplit::IN if defined*AutoSplit::IN{IO};return$retval}package ExtUtils::Install::Warn;sub new {bless {},shift}sub add {my($self,$file,$targetfile)=@_;push @{$self->{$file}},$targetfile}sub DESTROY {unless(defined$INSTALL_ROOT){my$self=shift;my($file,$i,$plural);for$file (sort keys %$self){$plural=@{$self->{$file}}> 1 ? "s" : "";print "## Differing version$plural of $file found. You might like to\n";for (0..$#{$self->{$file}}){print "rm ",$self->{$file}[$_],"\n";$i++}}$plural=$i>1 ? "all those files" : "this file";my$inst=(_invokant()eq 'ExtUtils::MakeMaker')? ($Config::Config{make}|| 'make').' install' .($Is_VMS ? '/MACRO="UNINST"=1' : ' UNINST=1'): './Build install uninst=1';print "## Running '$inst' will unlink $plural for you.\n"}}sub _invokant {my@stack;my$frame=0;while (my$file=(caller($frame++))[1]){push@stack,(File::Spec->splitpath($file))[2]}my$builder;my$top=pop@stack;if ($top =~ /^Build/i || exists($INC{'Module/Build.pm'})){$builder='Module::Build'}else {$builder='ExtUtils::MakeMaker'}return$builder}1;
EXTUTILS_INSTALL

$fatpacked{"ExtUtils/Installed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLED';
  package ExtUtils::Installed;use 5.00503;use strict;use Carp qw();use ExtUtils::Packlist;use ExtUtils::MakeMaker;use Config;use File::Find;use File::Basename;use File::Spec;my$Is_VMS=$^O eq 'VMS';my$DOSISH=($^O =~ /^(MSWin\d\d|os2|dos|mint)$/);require VMS::Filespec if$Is_VMS;use vars qw($VERSION);$VERSION='1.999_001';$VERSION=eval$VERSION;sub _is_prefix {my ($self,$path,$prefix)=@_;return unless defined$prefix && defined$path;if($Is_VMS){$prefix=VMS::Filespec::unixify($prefix);$path=VMS::Filespec::unixify($path)}$prefix=File::Spec->canonpath($prefix);return 1 if substr($path,0,length($prefix))eq $prefix;if ($DOSISH){$path =~ s|\\|/|g;$prefix =~ s|\\|/|g;return 1 if$path =~ m{^\Q$prefix\E}i}return(0)}sub _is_doc {my ($self,$path)=@_;my$man1dir=$self->{':private:'}{Config}{man1direxp};my$man3dir=$self->{':private:'}{Config}{man3direxp};return(($man1dir && $self->_is_prefix($path,$man1dir))|| ($man3dir && $self->_is_prefix($path,$man3dir))? 1 : 0)}sub _is_type {my ($self,$path,$type)=@_;return 1 if$type eq "all";return($self->_is_doc($path))if$type eq "doc";my$conf=$self->{':private:'}{Config};if ($type eq "prog"){return($self->_is_prefix($path,$conf->{prefix}|| $conf->{prefixexp})&&!($self->_is_doc($path))? 1 : 0)}return(0)}sub _is_under {my ($self,$path,@under)=@_;$under[0]="" if (!@under);for my$dir (@under){return(1)if ($self->_is_prefix($path,$dir))}return(0)}sub _fix_dirs {my ($self,@dirs)=@_;if($Is_VMS){$_=VMS::Filespec::unixify($_)for@dirs}if ($DOSISH){s|\\|/|g for@dirs}return wantarray ? @dirs : $dirs[0]}sub _make_entry {my ($self,$module,$packlist_file,$modfile)=@_;my$data={module=>$module,packlist=>scalar(ExtUtils::Packlist->new($packlist_file)),packlist_file=>$packlist_file,};if (!$modfile){$data->{version}=$self->{':private:'}{Config}{version}}else {$data->{modfile}=$modfile;$data->{version}='';for my$dir (@{$self->{':private:'}{INC}}){my$p=File::Spec->catfile($dir,$modfile);if (-r $p){$module=_module_name($p,$module)if$Is_VMS;$data->{version}=MM->parse_version($p);$data->{version_from}=$p;$data->{packlist_valid}=exists$data->{packlist}{$p};last}}}$self->{$module}=$data}our$INSTALLED;sub new {my ($class)=shift(@_);$class=ref($class)|| $class;my%args=@_;return$INSTALLED if$INSTALLED and ($args{default_get}|| $args{default});my$self=bless {},$class;$INSTALLED=$self if$args{default_set}|| $args{default};if ($args{config_override}){eval {$self->{':private:'}{Config}={%{$args{config_override}}}}or Carp::croak("The 'config_override' parameter must be a hash reference.")}else {$self->{':private:'}{Config}=\%Config}for my$tuple ([inc_override=>INC=>[@INC ]],[extra_libs=>EXTRA=>[]]){my ($arg,$key,$val)=@$tuple;if ($args{$arg}){eval {$self->{':private:'}{$key}=[@{$args{$arg}}]}or Carp::croak("The '$arg' parameter must be an array reference.")}elsif ($val){$self->{':private:'}{$key}=$val}}{my%dupe;@{$self->{':private:'}{LIBDIRS}}=grep {-e $_ &&!$dupe{$_}++}@{$self->{':private:'}{EXTRA}},@{$self->{':private:'}{INC}}}my@dirs=$self->_fix_dirs(@{$self->{':private:'}{LIBDIRS}});my$archlib=$self->_fix_dirs($self->{':private:'}{Config}{archlibexp});$self->_make_entry("Perl",File::Spec->catfile($archlib,'.packlist'));my$root;my$sub=sub {return if $_ ne ".packlist" || $File::Find::dir eq $archlib;my$module=$File::Find::name;my$found=$module =~ s!^.*?/auto/(.*)/.packlist!$1!s or do {return};my$modfile="$module.pm";$module =~ s!/!::!g;return if$self->{$module};$self->_make_entry($module,$File::Find::name,$modfile)};while (@dirs){$root=shift@dirs;next if!-d $root;find($sub,$root)}return$self}sub _module_name {my($file,$orig_module)=@_;my$module='';if (open PACKFH,$file){while (<PACKFH>){if (/package\s+(\S+)\s*;/){my$pack=$1;if (lc($pack)eq lc($orig_module)){$module=$pack;last}}}close PACKFH}print STDERR "Couldn't figure out the package name for $file\n" unless$module;return$module}sub modules {my ($self)=@_;$self=$self->new(default=>1)if!ref$self;return wantarray ? sort grep {not /^:private:$/}keys %$self : grep {not /^:private:$/}keys %$self}sub files {my ($self,$module,$type,@under)=@_;$self=$self->new(default=>1)if!ref$self;Carp::croak("$module is not installed")if (!exists($self->{$module}));$type="all" if (!defined($type));Carp::croak('type must be "all", "prog" or "doc"')if ($type ne "all" && $type ne "prog" && $type ne "doc");my (@files);for my$file (keys(%{$self->{$module}{packlist}})){push(@files,$file)if ($self->_is_type($file,$type)&& $self->_is_under($file,@under))}return(@files)}sub directories {my ($self,$module,$type,@under)=@_;$self=$self->new(default=>1)if!ref$self;my (%dirs);for my$file ($self->files($module,$type,@under)){$dirs{dirname($file)}++}return sort keys%dirs}sub directory_tree {my ($self,$module,$type,@under)=@_;$self=$self->new(default=>1)if!ref$self;my (%dirs);for my$dir ($self->directories($module,$type,@under)){$dirs{$dir}++;my ($last)=("");while ($last ne $dir){$last=$dir;$dir=dirname($dir);last if!$self->_is_under($dir,@under);$dirs{$dir}++}}return(sort(keys(%dirs)))}sub validate {my ($self,$module,$remove)=@_;$self=$self->new(default=>1)if!ref$self;Carp::croak("$module is not installed")if (!exists($self->{$module}));return($self->{$module}{packlist}->validate($remove))}sub packlist {my ($self,$module)=@_;$self=$self->new(default=>1)if!ref$self;Carp::croak("$module is not installed")if (!exists($self->{$module}));return($self->{$module}{packlist})}sub version {my ($self,$module)=@_;$self=$self->new(default=>1)if!ref$self;Carp::croak("$module is not installed")if (!exists($self->{$module}));return($self->{$module}{version})}sub debug_dump {my ($self,$module)=@_;$self=$self->new(default=>1)if!ref$self;local$self->{":private:"}{Config};require Data::Dumper;print Data::Dumper->new([$self])->Sortkeys(1)->Indent(1)->Dump()}1;
EXTUTILS_INSTALLED

$fatpacked{"ExtUtils/Liblist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_LIBLIST';
  package ExtUtils::Liblist;use strict;our$VERSION='6.66';use File::Spec;require ExtUtils::Liblist::Kid;our@ISA=qw(ExtUtils::Liblist::Kid File::Spec);sub ext {goto&ExtUtils::Liblist::Kid::ext}sub lsdir {shift;my$rex=qr/$_[1]/;opendir DIR,$_[0];my@out=grep /$rex/,readdir DIR;closedir DIR;return@out}
EXTUTILS_LIBLIST

$fatpacked{"ExtUtils/Liblist/Kid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_LIBLIST_KID';
  package ExtUtils::Liblist::Kid;use 5.006;use strict;use warnings;our$VERSION='6.66';use ExtUtils::MakeMaker::Config;use Cwd 'cwd';use File::Basename;use File::Spec;sub ext {if ($^O eq 'VMS'){return&_vms_ext}elsif ($^O eq 'MSWin32'){return&_win32_ext}else {return&_unix_os2_ext}}sub _unix_os2_ext {my ($self,$potential_libs,$verbose,$give_libs)=@_;$verbose ||= 0;if ($^O =~ 'os2' and $Config{perllibs}){$potential_libs .= " " if$potential_libs;$potential_libs .= $Config{perllibs}}return ("","","","",($give_libs ? []: ()))unless$potential_libs;warn "Potential libraries are '$potential_libs':\n" if$verbose;my ($so)=$Config{so};my ($libs)=defined$Config{perllibs}? $Config{perllibs}: $Config{libs};my$Config_libext=$Config{lib_ext}|| ".a";my$Config_dlext=$Config{dlext};my (@searchpath);my (@libpath)=split " ",$Config{'libpth'};my (@ldloadlibs,@bsloadlibs,@extralibs,@ld_run_path,%ld_run_path_seen);my (@libs,%libs_seen);my ($fullname,@fullname);my ($pwd)=cwd();my ($found)=0;for my$thislib (split ' ',$potential_libs){if ($thislib =~ s/^(-[LR]|-Wl,-R)//){my ($ptype)=$1;unless (-d $thislib){warn "$ptype$thislib ignored, directory does not exist\n" if$verbose;next}my ($rtype)=$ptype;if (($ptype eq '-R')or ($ptype eq '-Wl,-R')){if ($Config{'lddlflags'}=~ /-Wl,-R/){$rtype='-Wl,-R'}elsif ($Config{'lddlflags'}=~ /-R/){$rtype='-R'}}unless (File::Spec->file_name_is_absolute($thislib)){warn "Warning: $ptype$thislib changed to $ptype$pwd/$thislib\n";$thislib=$self->catdir($pwd,$thislib)}push(@searchpath,$thislib);push(@extralibs,"$ptype$thislib");push(@ldloadlibs,"$rtype$thislib");next}unless ($thislib =~ s/^-l//){warn "Unrecognized argument in LIBS ignored: '$thislib'\n";next}my ($found_lib)=0;for my$thispth (@searchpath,@libpath){if (@fullname=$self->lsdir($thispth,"^\Qlib$thislib.$so.\E[0-9]+")){$fullname="$thispth/" .(sort {my ($ma)=$a;my ($mb)=$b;$ma =~ tr/A-Za-z/0/s;$ma =~ s/\b(\d)\b/0$1/g;$mb =~ tr/A-Za-z/0/s;$mb =~ s/\b(\d)\b/0$1/g;while (length($ma)< length($mb)){$ma .= ".00"}while (length($mb)< length($ma)){$mb .= ".00"}$mb cmp $ma}@fullname)[0]}elsif (-f ($fullname="$thispth/lib$thislib.$so")&& (($Config{'dlsrc'}ne "dl_dld.xs")|| ($thislib eq "m"))){}elsif (-f ($fullname="$thispth/lib${thislib}_s$Config_libext")&& ($Config{'archname'}!~ /RM\d\d\d-svr4/)&& ($thislib .= "_s")){}elsif (-f ($fullname="$thispth/lib$thislib$Config_libext")){}elsif (defined($Config_dlext)&& -f ($fullname="$thispth/lib$thislib.$Config_dlext")){}elsif (-f ($fullname="$thispth/$thislib$Config_libext")){}elsif (-f ($fullname="$thispth/lib$thislib.dll$Config_libext")){}elsif (-f ($fullname="$thispth/Slib$thislib$Config_libext")){}elsif ($^O eq 'dgux' && -l ($fullname="$thispth/lib$thislib$Config_libext")&& readlink($fullname)=~ /^elink:/s){}else {warn "$thislib not found in $thispth\n" if$verbose;next}warn "'-l$thislib' found at $fullname\n" if$verbose;push@libs,$fullname unless$libs_seen{$fullname}++;$found++;$found_lib++;my$is_dyna=($fullname !~ /\Q$Config_libext\E\z/);my$in_perl=($libs =~ /\B-l\Q${thislib}\E\b/s);my ($fullnamedir)=dirname($fullname);push@ld_run_path,$fullnamedir if$is_dyna &&!$in_perl &&!$ld_run_path_seen{$fullnamedir}++;unless ($in_perl || ($Config{'osname'}eq 'next' && ($thislib eq 'm' || $thislib eq 'ndbm'))){push(@extralibs,"-l$thislib")}if (($Config{'dlsrc'}=~ /dl_next/ && $Config{'osvers'}lt '4_0')|| ($Config{'dlsrc'}=~ /dl_dld/)){push(@bsloadlibs,"$fullname")}else {if ($is_dyna){push(@ldloadlibs,"-l$thislib")unless ($in_perl and $^O eq 'sunos')}else {push(@ldloadlibs,"-l$thislib")}}last}warn "Warning (mostly harmless): " ."No library found for -l$thislib\n" unless$found_lib > 0}unless ($found){return ('','','','',($give_libs ? \@libs : ()))}else {return ("@extralibs","@bsloadlibs","@ldloadlibs",join(":",@ld_run_path),($give_libs ? \@libs : ()))}}sub _win32_ext {require Text::ParseWords;my ($self,$potential_libs,$verbose,$give_libs)=@_;$verbose ||= 0;return ("","","","",($give_libs ? []: ()))unless$potential_libs;my%libs_seen;my@extralibs;my$cc=$Config{cc}|| '';my$VC=$cc =~ /\bcl\b/i;my$GC=$cc =~ /\bgcc\b/i;my$libext=_win32_lib_extensions();my@searchpath=('');my@libpath=_win32_default_search_paths($VC,$GC);my$pwd=cwd();my$search=1;my@lib_search_list=_win32_make_lib_search_list($potential_libs,$verbose);for (@lib_search_list){my$thislib=$_;if (/^:\w+$/){$search=0 if lc eq ':nosearch';$search=1 if lc eq ':search';_debug("Ignoring unknown flag '$thislib'\n",$verbose)if!/^:(no)?(search|default)$/i;next}unless ($search){s/^-l(.+)$/$1.lib/ unless$GC;s/^-L/-libpath:/ if$VC;push(@extralibs,$_);next}if (s/^-L// and not -d){_debug("$thislib ignored, directory does not exist\n",$verbose);next}elsif (-d){unless (File::Spec->file_name_is_absolute($_)){warn "Warning: '$thislib' changed to '-L$pwd/$_'\n";$_=$self->catdir($pwd,$_)}push(@searchpath,$_);next}my@paths=(@searchpath,@libpath);my ($fullname,$path)=_win32_search_file($thislib,$libext,\@paths,$verbose,$GC);if (!$fullname){warn "Warning (mostly harmless): No library found for $thislib\n";next}_debug("'$thislib' found as '$fullname'\n",$verbose);push(@extralibs,$fullname);$libs_seen{$fullname}=1 if$path}my@libs=keys%libs_seen;return ('','','','',($give_libs ? \@libs : ()))unless@extralibs;@extralibs=map {/\s/ ? qq["$_"] : $_}@extralibs;@libs=map {/\s/ ? qq["$_"] : $_}@libs;my$lib=join(' ',@extralibs);$lib =~ s,/,\\,g;_debug("Result: $lib\n",$verbose);wantarray ? ($lib,'',$lib,'',($give_libs ? \@libs : ())): $lib}sub _win32_make_lib_search_list {my ($potential_libs,$verbose)=@_;my$libs=$Config{'perllibs'};$potential_libs=join(' ',$potential_libs,$libs)if$libs and $potential_libs !~ /:nodefault/i;_debug("Potential libraries are '$potential_libs':\n",$verbose);$potential_libs =~ s,\\,/,g;my@list=Text::ParseWords::quotewords('\s+',0,$potential_libs);return@list}sub _win32_default_search_paths {my ($VC,$GC)=@_;my$libpth=$Config{'libpth'}|| '';$libpth =~ s,\\,/,g;my@libpath=Text::ParseWords::quotewords('\s+',0,$libpth);push@libpath,"$Config{installarchlib}/CORE";push@libpath,split /;/,$ENV{LIB}if$VC and $ENV{LIB};push@libpath,split /;/,$ENV{LIBRARY_PATH}if$GC and $ENV{LIBRARY_PATH};return@libpath}sub _win32_search_file {my ($thislib,$libext,$paths,$verbose,$GC)=@_;my@file_list=_win32_build_file_list($thislib,$GC,$libext);for my$lib_file (@file_list){for my$path (@{$paths}){my$fullname=$lib_file;$fullname="$path\\$fullname" if$path;return ($fullname,$path)if -f $fullname;_debug("'$thislib' not found as '$fullname'\n",$verbose)}}return}sub _win32_build_file_list {my ($lib,$GC,$extensions)=@_;my@pre_fixed=_win32_build_prefixed_list($lib,$GC);return map _win32_attach_extensions($_,$extensions),@pre_fixed}sub _win32_build_prefixed_list {my ($lib,$GC)=@_;return$lib if$lib !~ s/^-l//;return$lib if$lib =~ /^lib/ and!$GC;(my$no_prefix=$lib)=~ s/^lib//i;$lib="lib$lib" if$no_prefix eq $lib;return ($lib,$no_prefix)if$GC;return ($no_prefix,$lib)}sub _win32_attach_extensions {my ($lib,$extensions)=@_;return map _win32_try_attach_extension($lib,$_),@{$extensions}}sub _win32_try_attach_extension {my ($lib,$extension)=@_;return$lib if$lib =~ /\Q$extension\E$/i;return "$lib$extension"}sub _win32_lib_extensions {my%extensions;$extensions{$Config{'lib_ext'}}=1 if$Config{'lib_ext'};$extensions{".dll.a"}=1 if$extensions{".a"};$extensions{".lib"}=1;return [keys%extensions ]}sub _debug {my ($message,$verbose)=@_;return if!$verbose;warn$message;return}sub _vms_ext {my ($self,$potential_libs,$verbose,$give_libs)=@_;$verbose ||= 0;my (@crtls,$crtlstr);@crtls=(($Config{'ldflags'}=~ m-/Debug-i ? $Config{'dbgprefix'}: '').'PerlShr/Share');push(@crtls,grep {not /\(/}split /\s+/,$Config{'perllibs'});push(@crtls,grep {not /\(/}split /\s+/,$Config{'libc'});if ($self->{PERL_SRC}){my ($locspec,$type);for my$lib (@crtls){if (($locspec,$type)=$lib =~ m{^([\w\$-]+)(/\w+)?} and $locspec =~ /perl/i){if (lc$type eq '/share'){$locspec .= $Config{'exe_ext'}}elsif (lc$type eq '/library'){$locspec .= $Config{'lib_ext'}}else {$locspec .= $Config{'obj_ext'}}$locspec=$self->catfile($self->{PERL_SRC},$locspec);$lib="$locspec$type" if -e $locspec}}}$crtlstr=@crtls ? join(' ',@crtls): '';unless ($potential_libs){warn "Result:\n\tEXTRALIBS: \n\tLDLOADLIBS: $crtlstr\n" if$verbose;return ('','',$crtlstr,'',($give_libs ? []: ()))}my (%found,@fndlibs,$ldlib);my$cwd=cwd();my ($so,$lib_ext,$obj_ext)=@Config{'so','lib_ext','obj_ext' };my (@flibs,%libs_seen);my%libmap=('m'=>'','f77'=>'','F77'=>'','V77'=>'','c'=>'','malloc'=>'','crypt'=>'','resolv'=>'','c_s'=>'','socket'=>'','X11'=>'DECW$XLIBSHR','Xt'=>'DECW$XTSHR','Xm'=>'DECW$XMLIBSHR','Xmu'=>'DECW$XMULIBSHR');if ($Config{'vms_cc_type'}ne 'decc'){$libmap{'curses'}='VAXCCURSE'}warn "Potential libraries are '$potential_libs'\n" if$verbose;my (@dirs,@libs);for my$lib (split ' ',$potential_libs){push(@dirs,$1),next if$lib =~ /^-L(.*)/;push(@dirs,$lib),next if$lib =~ /[:>\]]$/;push(@dirs,$lib),next if -d $lib;push(@libs,$1),next if$lib =~ /^-l(.*)/;push(@libs,$lib)}push(@dirs,split(' ',$Config{'libpth'}));for my$dir (@dirs){unless (-d $dir){warn "Skipping nonexistent Directory $dir\n" if$verbose > 1;$dir='';next}warn "Resolving directory $dir\n" if$verbose;if (File::Spec->file_name_is_absolute($dir)){$dir=$self->fixpath($dir,1)}else {$dir=$self->catdir($cwd,$dir)}}@dirs=grep {length($_)}@dirs;unshift(@dirs,'');LIB: foreach my$lib (@libs){if (exists$libmap{$lib}){next unless length$libmap{$lib};$lib=$libmap{$lib}}my (@variants,$cand);my ($ctype)='';if ($lib !~ /\.[^:>\]]*$/){push(@variants,"${lib}shr","${lib}rtl","${lib}lib");push(@variants,"lib$lib")if$lib !~ /[:>\]]/}push(@variants,$lib);warn "Looking for $lib\n" if$verbose;for my$variant (@variants){my ($fullname,$name);for my$dir (@dirs){my ($type);$name="$dir$variant";warn "\tChecking $name\n" if$verbose > 2;$fullname=VMS::Filespec::rmsexpand($name);if (defined$fullname and -f $fullname){if ($fullname =~ /(?:$so|exe)$/i){$type='SHR'}elsif ($fullname =~ /(?:$lib_ext|olb)$/i){$type='OLB'}elsif ($fullname =~ /(?:$obj_ext|obj)$/i){warn "Warning (mostly harmless): " ."Plain object file $fullname found in library list\n";$type='OBJ'}else {warn "Warning (mostly harmless): " ."Unknown library type for $fullname; assuming shared\n";$type='SHR'}}elsif (-f ($fullname=VMS::Filespec::rmsexpand($name,$so))or -f ($fullname=VMS::Filespec::rmsexpand($name,'.exe'))){$type='SHR';$name=$fullname unless$fullname =~ /exe;?\d*$/i}elsif (not length($ctype)and (-f ($fullname=VMS::Filespec::rmsexpand($name,$lib_ext))or -f ($fullname=VMS::Filespec::rmsexpand($name,'.olb')))){$type='OLB';$name=$fullname unless$fullname =~ /olb;?\d*$/i}elsif (not length($ctype)and (-f ($fullname=VMS::Filespec::rmsexpand($name,$obj_ext))or -f ($fullname=VMS::Filespec::rmsexpand($name,'.obj')))){warn "Warning (mostly harmless): " ."Plain object file $fullname found in library list\n";$type='OBJ';$name=$fullname unless$fullname =~ /obj;?\d*$/i}if (defined$type){$ctype=$type;$cand=$name;last if$ctype eq 'SHR'}}if ($ctype){if ($cand eq 'VAXCCURSE'){unshift @{$found{$ctype}},$cand}else {push @{$found{$ctype}},$cand}warn "\tFound as $cand (really $fullname), type $ctype\n" if$verbose > 1;push@flibs,$name unless$libs_seen{$fullname}++;next LIB}}warn "Warning (mostly harmless): " ."No library found for $lib\n"}push@fndlibs,@{$found{OBJ}}if exists$found{OBJ};push@fndlibs,map {"$_/Library"}@{$found{OLB}}if exists$found{OLB};push@fndlibs,map {"$_/Share"}@{$found{SHR}}if exists$found{SHR};my$lib=join(' ',@fndlibs);$ldlib=$crtlstr ? "$lib $crtlstr" : $lib;warn "Result:\n\tEXTRALIBS: $lib\n\tLDLOADLIBS: $ldlib\n" if$verbose;wantarray ? ($lib,'',$ldlib,'',($give_libs ? \@flibs : ())): $lib}1;
EXTUTILS_LIBLIST_KID

$fatpacked{"ExtUtils/MM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM';
  package ExtUtils::MM;use strict;use ExtUtils::MakeMaker::Config;our$VERSION='6.66';require ExtUtils::Liblist;require ExtUtils::MakeMaker;our@ISA=qw(ExtUtils::Liblist ExtUtils::MakeMaker);{package MM;our@ISA=qw(ExtUtils::MM);sub DESTROY {}}sub _is_win95 {my$have_win32=eval {require Win32};return$have_win32 && defined&Win32::IsWin95 ? Win32::IsWin95():!defined$ENV{SYSTEMROOT}}my%Is=();$Is{VMS}=$^O eq 'VMS';$Is{OS2}=$^O eq 'os2';$Is{MacOS}=$^O eq 'MacOS';if($^O eq 'MSWin32'){_is_win95()? $Is{Win95}=1 : $Is{Win32}=1}$Is{UWIN}=$^O =~ /^uwin(-nt)?$/;$Is{Cygwin}=$^O eq 'cygwin';$Is{NW5}=$Config{osname}eq 'NetWare';$Is{BeOS}=($^O =~ /beos/i or $^O eq 'haiku');$Is{DOS}=$^O eq 'dos';if($Is{NW5}){$^O='NetWare';delete$Is{Win32}}$Is{VOS}=$^O eq 'vos';$Is{QNX}=$^O eq 'qnx';$Is{AIX}=$^O eq 'aix';$Is{Darwin}=$^O eq 'darwin';$Is{Unix}=!grep {$_}values%Is;map {delete$Is{$_}unless$Is{$_}}keys%Is;_assert(keys%Is==1);my($OS)=keys%Is;my$class="ExtUtils::MM_$OS";eval "require $class" unless$INC{"ExtUtils/MM_$OS.pm"};die $@ if $@;unshift@ISA,$class;sub _assert {my$sanity=shift;die sprintf "Assert failed at %s line %d\n",(caller)[1,2]unless$sanity;return}
EXTUTILS_MM

$fatpacked{"ExtUtils/MM_AIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_AIX';
  package ExtUtils::MM_AIX;use strict;our$VERSION='6.66';require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Unix);use ExtUtils::MakeMaker qw(neatvalue);sub dlsyms {my($self,%attribs)=@_;return '' unless$self->needs_linking();my($funcs)=$attribs{DL_FUNCS}|| $self->{DL_FUNCS}|| {};my($vars)=$attribs{DL_VARS}|| $self->{DL_VARS}|| [];my($funclist)=$attribs{FUNCLIST}|| $self->{FUNCLIST}|| [];my(@m);push(@m,"
  dynamic :: $self->{BASEEXT}.exp
  
  ")unless$self->{SKIPHASH}{'dynamic'};push(@m,"
  static :: $self->{BASEEXT}.exp
  
  ")unless$self->{SKIPHASH}{'static'};push(@m,"
  $self->{BASEEXT}.exp: Makefile.PL
  ",'	$(PERLRUN) -e \'use ExtUtils::Mksymlists; \\
  	Mksymlists("NAME" => "',$self->{NAME},'", "DL_FUNCS" => ',neatvalue($funcs),', "FUNCLIST" => ',neatvalue($funclist),', "DL_VARS" => ',neatvalue($vars),');\'
  ');join('',@m)}1;
EXTUTILS_MM_AIX

$fatpacked{"ExtUtils/MM_Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_ANY';
  package ExtUtils::MM_Any;use strict;our$VERSION='6.66';use Carp;use File::Spec;use File::Basename;BEGIN {our@ISA=qw(File::Spec)}use ExtUtils::MakeMaker qw($Verbose);use ExtUtils::MakeMaker::Config;my$Curdir=__PACKAGE__->curdir;my$Rootdir=__PACKAGE__->rootdir;my$Updir=__PACKAGE__->updir;sub os_flavor_is {my$self=shift;my%flavors=map {($_=>1)}$self->os_flavor;return (grep {$flavors{$_}}@_)? 1 : 0}sub can_load_xs {return defined&DynaLoader::boot_DynaLoader ? 1 : 0}sub split_command {my($self,$cmd,@args)=@_;my@cmds=();return(@cmds)unless@args;chomp$cmd;my$len_left=int($self->max_exec_len * 0.70);$len_left -= length$self->_expand_macros($cmd);do {my$arg_str='';my@next_args;while(@next_args=splice(@args,0,2)){my$next_arg_str="\t  ".join ' ',@next_args,"\n";if(!length$arg_str){$arg_str .= $next_arg_str}elsif(length($arg_str)+ length($next_arg_str)> $len_left){unshift@args,@next_args;last}else {$arg_str .= $next_arg_str}}chop$arg_str;push@cmds,$self->escape_newlines("$cmd \n$arg_str")}while@args;return@cmds}sub _expand_macros {my($self,$cmd)=@_;$cmd =~ s{\$\((\w+)\)}{
          defined $self->{$1} ? $self->{$1} : "\$($1)"
      }e;return$cmd}sub echo {my($self,$text,$file,$opts)=@_;if(!ref$opts){my$append=$opts;$opts={append=>$append || 0 }}$opts->{allow_variables}=0 unless defined$opts->{allow_variables};my$ql_opts={allow_variables=>$opts->{allow_variables}};my@cmds=map {'$(NOECHO) $(ECHO) '.$self->quote_literal($_,$ql_opts)}split /\n/,$text;if($file){my$redirect=$opts->{append}? '>>' : '>';$cmds[0].= " $redirect $file";$_ .= " >> $file" foreach@cmds[1..$#cmds]}return@cmds}sub wraplist {my$self=shift;return join " \\\n\t",@_}sub maketext_filter {return $_[1]}sub escape_dollarsigns {my($self,$text)=@_;$text =~ s{\$ (?!\() }{\$\$}gx;return$text}sub escape_all_dollarsigns {my($self,$text)=@_;$text =~ s{\$}{\$\$}gx;return$text}sub make {my$self=shift;my$make=lc$self->{MAKE};$make =~ s/^(\w+make).*/$1/;$make =~ s/^gnu/g/;return$make}sub all_target {my$self=shift;return <<'MAKE_EXT'}sub blibdirs_target {my$self=shift;my@dirs=map {uc "\$(INST_$_)"}qw(libdir archlib autodir archautodir bin script man1dir man3dir);my@exists=map {$_.'$(DFSEP).exists'}@dirs;my$make=sprintf <<'MAKE',join(' ',@exists);$make .= $self->dir_target(@dirs);return$make}sub clean {my($self,%attribs)=@_;my@m;push(@m,'
  all :: pure_all
  	$(NOECHO) $(NOOP)
  MAKE_EXT
  blibdirs : %s
  	$(NOECHO) $(NOOP)
  
  # Backwards compat with 6.18 through 6.25
  blibdirs.ts : blibdirs
  	$(NOECHO) $(NOOP)
  
  MAKE
  # Delete temporary files but do not touch installed files. We don\'t delete
  # the Makefile here so a later make realclean still has a makefile to use.
  
  clean :: clean_subdirs
  ');my@files=values %{$self->{XS}};my@dirs=qw(blib);if($attribs{FILES}){push@dirs,ref$attribs{FILES}? @{$attribs{FILES}}: split /\s+/,$attribs{FILES}}push(@files,qw[$(MAKE_APERL_FILE) MYMETA.json MYMETA.yml perlmain.c tmon.out mon.out so_locations blibdirs.ts pm_to_blib pm_to_blib.ts *$(OBJ_EXT) *$(LIB_EXT) perl.exe perl perl$(EXE_EXT) $(BOOTSTRAP) $(BASEEXT).bso $(BASEEXT).def lib$(BASEEXT).def $(BASEEXT).exp $(BASEEXT).x]);push(@files,$self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'));push(@files,$self->catfile('$(INST_ARCHAUTODIR)','extralibs.ld'));push(@files,qw[core core.*perl.*.? *perl.core]);push(@files,map {"core." ."[0-9]"x$_}(1..5));push@dirs,$self->extra_clean_files;{my(%f)=map {($_=>1)}@files;@files=keys%f}{my(%d)=map {($_=>1)}@dirs;@dirs=keys%d}push@m,map "\t$_\n",$self->split_command('- $(RM_F)',@files);push@m,map "\t$_\n",$self->split_command('- $(RM_RF)',@dirs);push@m,<<'MAKE';push(@m,"\t$attribs{POSTOP}\n")if$attribs{POSTOP};join("",@m)}sub clean_subdirs_target {my($self)=shift;return <<'NOOP_FRAG' unless @{$self->{DIR}};my$clean="clean_subdirs :\n";for my$dir (@{$self->{DIR}}){my$subclean=$self->oneliner(sprintf <<'CODE',$dir);$clean .= "\t$subclean\n"}return$clean}sub dir_target {my($self,@dirs)=@_;my$make='';for my$dir (@dirs){$make .= sprintf <<'MAKE',($dir)x 7}return$make}*dist_dir=*distdir;sub distdir {my($self)=shift;my$meta_target=$self->{NO_META}? '' : 'distmeta';my$sign_target=!$self->{SIGN}? '' : 'distsignature';return sprintf <<'MAKE_FRAG',$meta_target,$sign_target}sub dist_test {my($self)=shift;my$mpl_args=join " ",map qq["$_"],@ARGV;my$test=$self->cd('$(DISTVNAME)','$(ABSPERLRUN) Makefile.PL '.$mpl_args,'$(MAKE) $(PASTHRU)','$(MAKE) test $(PASTHRU)');return sprintf <<'MAKE_FRAG',$test}sub dynamic {my($self)=shift;'
  	- $(MV) $(FIRST_MAKEFILE) $(MAKEFILE_OLD) $(DEV_NULL)
  MAKE
  clean_subdirs :
  	$(NOECHO) $(NOOP)
  NOOP_FRAG
  chdir '%s';  system '$(MAKE) clean' if -f '$(FIRST_MAKEFILE)';
  CODE
  %s$(DFSEP).exists :: Makefile.PL
  	$(NOECHO) $(MKPATH) %s
  	$(NOECHO) $(CHMOD) $(PERM_DIR) %s
  	$(NOECHO) $(TOUCH) %s$(DFSEP).exists
  
  MAKE
  create_distdir :
  	$(RM_RF) $(DISTVNAME)
  	$(PERLRUN) "-MExtUtils::Manifest=manicopy,maniread" \
  		-e "manicopy(maniread(),'$(DISTVNAME)', '$(DIST_CP)');"
  
  distdir : create_distdir %s %s
  	$(NOECHO) $(NOOP)
  
  MAKE_FRAG
  disttest : distdir
  	%s
  
  MAKE_FRAG
  dynamic :: $(FIRST_MAKEFILE) $(INST_DYNAMIC) $(INST_BOOT)
  	$(NOECHO) $(NOOP)
  '}sub makemakerdflt_target {return <<'MAKE_FRAG'}sub manifypods_target {my($self)=shift;my$man1pods='';my$man3pods='';my$dependencies='';for my$name (keys %{$self->{MAN1PODS}},keys %{$self->{MAN3PODS}}){$dependencies .= " \\\n\t$name"}my$manify=<<END;my@man_cmds;for my$section (qw(1 3)){my$pods=$self->{"MAN${section}PODS"};push@man_cmds,$self->split_command(<<CMD,%$pods)}$manify .= "\t\$(NOECHO) \$(NOOP)\n" unless@man_cmds;$manify .= join '',map {"$_\n"}@man_cmds;return$manify}sub _has_cpan_meta {return eval {require CPAN::Meta;CPAN::Meta->VERSION(2.112150);1}}sub metafile_target {my$self=shift;return <<'MAKE_FRAG' if$self->{NO_META}or!_has_cpan_meta();my%metadata=$self->metafile_data($self->{META_ADD}|| {},$self->{META_MERGE}|| {},);_fix_metadata_before_conversion(\%metadata);my$meta=eval {CPAN::Meta->create(\%metadata,{lazy_validation=>1 })};warn $@ if $@ and $@ !~ /encountered CODE.*, but JSON can only represent references to arrays or hashes/;if(!$meta || !eval {$meta->as_string({version=>"1.4" })}|| !eval {$meta->as_string}){$meta=bless \%metadata,'CPAN::Meta'}my@write_metayml=$self->echo($meta->as_string({version=>"1.4"}),'META_new.yml');my@write_metajson=$self->echo($meta->as_string(),'META_new.json');my$metayml=join("\n\t",@write_metayml);my$metajson=join("\n\t",@write_metajson);return sprintf <<'MAKE_FRAG',$metayml,$metajson}sub _fix_metadata_before_conversion {my ($metadata)=@_;return unless _has_cpan_meta;my$bad_version=$metadata->{version}&& !CPAN::Meta::Validator->new->version('version',$metadata->{version});if($bad_version){warn "Can't parse version '$metadata->{version}'\n";$metadata->{version}=''}my$validator=CPAN::Meta::Validator->new($metadata);return if$validator->is_valid;for my$error ($validator->errors){my ($key)=($error =~ /Custom resource '(.*)' must be in CamelCase./);next if!$key;(my$new_key=$key)=~ s/[^_a-zA-Z]//g;$new_key=ucfirst$new_key if!$validator->custom_1($new_key);$metadata->{resources}{$new_key}=$metadata->{resources}{$key}if$validator->custom_1($new_key);delete$metadata->{resources}{$key}}return}sub _sort_pairs {my$sort=shift;my$pairs=shift;return map {$_=>$pairs->{$_}}sort$sort keys %$pairs}sub _hash_merge {my ($self,$h,$k,$v)=@_;if (ref$h->{$k}eq 'ARRAY'){push @{$h->{$k}},ref$v ? @$v : $v}elsif (ref$h->{$k}eq 'HASH'){$self->_hash_merge($h->{$k},$_,$v->{$_})foreach keys %$v}else {$h->{$k}=$v}}sub metafile_data {my$self=shift;my($meta_add,$meta_merge)=@_;my%meta=(name=>$self->{DISTNAME},version=>_normalize_version($self->{VERSION}),abstract=>$self->{ABSTRACT}|| 'unknown',license=>$self->{LICENSE}|| 'unknown',dynamic_config=>1,distribution_type=>$self->{PM}? 'module' : 'script',no_index=>{directory=>[qw(t inc)]},generated_by=>"ExtUtils::MakeMaker version $ExtUtils::MakeMaker::VERSION",'meta-spec'=>{url=>'http://module-build.sourceforge.net/META-spec-v1.4.html',version=>1.4 },);$meta{author}=defined$self->{AUTHOR}? $self->{AUTHOR}: [];if($self->{ARGS}{CONFIGURE_REQUIRES}){$meta{configure_requires}=_normalize_prereqs($self->{CONFIGURE_REQUIRES})}else {$meta{configure_requires}={'ExtUtils::MakeMaker'=>0,}}%meta=$self->_add_requirements_to_meta_v1_4(%meta);while(my($key,$val)=each %$meta_add){$meta{$key}=$val}while(my($key,$val)=each %$meta_merge){$self->_hash_merge(\%meta,$key,$val)}return%meta}sub _add_requirements_to_meta_v1_4 {my ($self,%meta)=@_;if($self->{ARGS}{BUILD_REQUIRES}){$meta{build_requires}=_normalize_prereqs($self->{BUILD_REQUIRES})}else {$meta{build_requires}={'ExtUtils::MakeMaker'=>0,}}if($self->{ARGS}{TEST_REQUIRES}){$meta{build_requires}={%{$meta{build_requires}},%{_normalize_prereqs($self->{TEST_REQUIRES})},}}$meta{requires}=_normalize_prereqs($self->{PREREQ_PM})if defined$self->{PREREQ_PM};$meta{requires}{perl}=_normalize_version($self->{MIN_PERL_VERSION})if$self->{MIN_PERL_VERSION};return%meta}sub _add_requirements_to_meta_v2 {my ($self,%meta)=@_;if($self->{ARGS}{BUILD_REQUIRES}){$meta{prereqs}{build}{requires}=_normalize_prereqs($self->{BUILD_REQUIRES})}else {$meta{prereqs}{build}{requires}={'ExtUtils::MakeMaker'=>0,}}if($self->{ARGS}{TEST_REQUIRES}){$meta{prereqs}{test}{requires}=_normalize_prereqs($self->{TEST_REQUIRES})}$meta{prereqs}{runtime}{requires}=_normalize_prereqs($self->{PREREQ_PM})if defined$self->{PREREQ_PM};$meta{prereqs}{runtime}{requires}{perl}=_normalize_version($self->{MIN_PERL_VERSION})if$self->{MIN_PERL_VERSION};return%meta}sub _normalize_prereqs {my ($hash)=@_;my%prereqs;while (my ($k,$v)=each %$hash){$prereqs{$k}=_normalize_version($v)}return \%prereqs}sub _normalize_version {my ($version)=@_;$version=0 unless defined$version;if (ref$version eq 'version'){$version=$version->is_qv ? $version->normal : $version->stringify}elsif ($version =~ /^[^v][^.]*\.[^.]+\./){$version="v$version"}else {}return$version}sub _dump_hash {croak "first argument should be a hash ref" unless ref $_[0]eq 'HASH';my$options=shift;my%hash=@_;my@pairs;my$k_sort =exists$options->{key_sort}? $options->{key_sort}: sub {lc$a cmp lc$b};if ($k_sort){croak "'key_sort' should be a coderef" unless ref$k_sort eq 'CODE';@pairs=_sort_pairs($k_sort,\%hash)}else {@pairs=@_}my$yaml=$options->{use_header}? "--- #YAML:1.0\n" : '';my$indent=$options->{indent}|| '';my$k_length=min(($options->{max_key_length}|| 20),max(map {length($_)+ 1}grep {!ref$hash{$_}}keys%hash));my$customs=$options->{customs}|| {};my$k_format="%-${k_length}s";while(@pairs){my($key,$val)=splice@pairs,0,2;$val='~' unless defined$val;if(ref$val eq 'HASH'){if (keys %$val){my%k_options=(delta=>$options->{delta},use_header=>0,indent=>$indent .$options->{delta},);if (exists$customs->{$key}){my%k_custom=%{$customs->{$key}};for my$k (qw(key_sort max_key_length customs)){$k_options{$k}=$k_custom{$k}if exists$k_custom{$k}}}$yaml .= $indent ."$key:\n" ._dump_hash(\%k_options,%$val)}else {$yaml .= $indent ."$key:  {}\n"}}elsif (ref$val eq 'ARRAY'){if(@$val){$yaml .= $indent ."$key:\n";for (@$val){croak "only nested arrays of non-refs are supported" if ref $_;$yaml .= $indent .$options->{delta}."- $_\n"}}else {$yaml .= $indent ."$key:  []\n"}}elsif(ref$val and!blessed($val)){croak "only nested hashes, arrays and objects are supported"}else {$yaml .= $indent .sprintf "$k_format  %s\n","$key:",$val}};return$yaml}sub blessed {return eval {$_[0]->isa("UNIVERSAL")}}sub max {return (sort {$b <=> $a}@_)[0]}sub min {return (sort {$a <=> $b}@_)[0]}sub metafile_file {my$self=shift;my%dump_options=(use_header=>1,delta=>' ' x 4,key_sort=>undef,);return _dump_hash(\%dump_options,@_)}sub distmeta_target {my$self=shift;my@add_meta=($self->oneliner(<<'CODE',['-MExtUtils::Manifest=maniadd']),$self->oneliner(<<'CODE',['-MExtUtils::Manifest=maniadd']));my@add_meta_to_distdir=map {$self->cd('$(DISTVNAME)',$_)}@add_meta;return sprintf <<'MAKE',@add_meta_to_distdir}sub mymeta {my$self=shift;my$file=shift || '';my$mymeta=$self->_mymeta_from_meta($file);my$v2=1;unless ($mymeta){my@metadata=$self->metafile_data($self->{META_ADD}|| {},$self->{META_MERGE}|| {},);$mymeta={@metadata};$v2=0}my$method=$v2 ? '_add_requirements_to_meta_v2' : '_add_requirements_to_meta_v1_4';$mymeta={$self->$method(%$mymeta)};$mymeta->{dynamic_config}=0;return$mymeta}sub _mymeta_from_meta {my$self=shift;my$metafile=shift || '';return unless _has_cpan_meta();my$meta;for my$file ($metafile,"META.json","META.yml"){next unless -e $file;eval {$meta=CPAN::Meta->load_file($file)->as_struct({version=>2 })};last if$meta}return unless$meta;if ($meta->{generated_by}&& $meta->{generated_by}=~ /ExtUtils::MakeMaker version ([\d\._]+)/){my$eummv=do {local $^W=0;$1+0};if ($eummv < 6.2501){return}}return$meta}sub write_mymeta {my$self=shift;my$mymeta=shift;return unless _has_cpan_meta();_fix_metadata_before_conversion($mymeta);my$meta_obj=CPAN::Meta->new($mymeta,{lazy_validation=>1 });$meta_obj->save('MYMETA.json');$meta_obj->save('MYMETA.yml',{version=>"1.4" });return 1}sub realclean {my($self,%attribs)=@_;my@dirs=qw($(DISTVNAME));my@files=qw($(FIRST_MAKEFILE) $(MAKEFILE_OLD));if($self->{PERL_CORE}){push@dirs,qw($(INST_AUTODIR) $(INST_ARCHAUTODIR));push@files,values %{$self->{PM}}}if($self->has_link_code){push@files,qw($(OBJECT))}if($attribs{FILES}){if(ref$attribs{FILES}){push@dirs,@{$attribs{FILES}}}else {push@dirs,split /\s+/,$attribs{FILES}}}{my(%f)=map {($_=>1)}@files;@files=keys%f}{my(%d)=map {($_=>1)}@dirs;@dirs=keys%d}my$rm_cmd=join "\n\t",map {"$_"}$self->split_command('- $(RM_F)',@files);my$rmf_cmd=join "\n\t",map {"$_"}$self->split_command('- $(RM_RF)',@dirs);my$m=sprintf <<'MAKE',$rm_cmd,$rmf_cmd;$m .= "\t$attribs{POSTOP}\n" if$attribs{POSTOP};return$m}sub realclean_subdirs_target {my$self=shift;return <<'NOOP_FRAG' unless @{$self->{DIR}};my$rclean="realclean_subdirs :\n";for my$dir (@{$self->{DIR}}){for my$makefile ('$(MAKEFILE_OLD)','$(FIRST_MAKEFILE)'){my$subrclean .= $self->oneliner(sprintf <<'CODE',$dir,($makefile)x 2);$rclean .= sprintf <<'RCLEAN',$subrclean}}return$rclean}sub signature_target {my$self=shift;return <<'MAKE_FRAG'}sub distsignature_target {my$self=shift;my$add_sign=$self->oneliner(<<'CODE',['-MExtUtils::Manifest=maniadd']);my$sign_dist=$self->cd('$(DISTVNAME)'=>'cpansign -s');my$touch_sig=$self->cd('$(DISTVNAME)'=>'$(TOUCH) SIGNATURE');my$add_sign_to_dist=$self->cd('$(DISTVNAME)'=>$add_sign);return sprintf <<'MAKE',$add_sign_to_dist,$touch_sig,$sign_dist}sub special_targets {my$make_frag=<<'MAKE_FRAG';$make_frag .= <<'MAKE_FRAG' if$ENV{CLEARCASE_ROOT};return$make_frag}sub init_ABSTRACT {my$self=shift;if($self->{ABSTRACT_FROM}and $self->{ABSTRACT}){warn "Both ABSTRACT_FROM and ABSTRACT are set.  "."Ignoring ABSTRACT_FROM.\n";return}if ($self->{ABSTRACT_FROM}){$self->{ABSTRACT}=$self->parse_abstract($self->{ABSTRACT_FROM})or carp "WARNING: Setting ABSTRACT via file "."'$self->{ABSTRACT_FROM}' failed\n"}}sub init_INST {my($self)=shift;$self->{INST_ARCHLIB}||= $self->catdir($Curdir,"blib","arch");$self->{INST_BIN}||= $self->catdir($Curdir,'blib','bin');unless ($self->{INST_LIB}){if ($self->{PERL_CORE}){if (defined$Cross::platform){$self->{INST_LIB}=$self->{INST_ARCHLIB}=$self->catdir($self->{PERL_LIB},"..","xlib",$Cross::platform)}else {$self->{INST_LIB}=$self->{INST_ARCHLIB}=$self->{PERL_LIB}}}else {$self->{INST_LIB}=$self->catdir($Curdir,"blib","lib")}}my@parentdir=split(/::/,$self->{PARENT_NAME});$self->{INST_LIBDIR}=$self->catdir('$(INST_LIB)',@parentdir);$self->{INST_ARCHLIBDIR}=$self->catdir('$(INST_ARCHLIB)',@parentdir);$self->{INST_AUTODIR}=$self->catdir('$(INST_LIB)','auto','$(FULLEXT)');$self->{INST_ARCHAUTODIR}=$self->catdir('$(INST_ARCHLIB)','auto','$(FULLEXT)');$self->{INST_SCRIPT}||= $self->catdir($Curdir,'blib','script');$self->{INST_MAN1DIR}||= $self->catdir($Curdir,'blib','man1');$self->{INST_MAN3DIR}||= $self->catdir($Curdir,'blib','man3');return 1}sub init_INSTALL {my($self)=shift;if($self->{ARGS}{INSTALL_BASE}and $self->{ARGS}{PREFIX}){die "Only one of PREFIX or INSTALL_BASE can be given.  Not both.\n"}if($self->{ARGS}{INSTALL_BASE}){$self->init_INSTALL_from_INSTALL_BASE}else {$self->init_INSTALL_from_PREFIX}}sub init_INSTALL_from_PREFIX {my$self=shift;$self->init_lib2arch;for my$num (1,3){my$k='installsiteman'.$num.'dir';$self->{uc$k}||= uc "\$(installman${num}dir)" unless$Config{$k}}for my$num (1,3){my$k='installvendorman'.$num.'dir';unless($Config{$k}){$self->{uc$k}||= $Config{usevendorprefix}? uc "\$(installman${num}dir)" : ''}}$self->{INSTALLSITEBIN}||= '$(INSTALLBIN)' unless$Config{installsitebin};$self->{INSTALLSITESCRIPT}||= '$(INSTALLSCRIPT)' unless$Config{installsitescript};unless($Config{installvendorbin}){$self->{INSTALLVENDORBIN}||= $Config{usevendorprefix}? $Config{installbin}: ''}unless($Config{installvendorscript}){$self->{INSTALLVENDORSCRIPT}||= $Config{usevendorprefix}? $Config{installscript}: ''}my$iprefix=$Config{installprefixexp}|| $Config{installprefix}|| $Config{prefixexp}|| $Config{prefix}|| '';my$vprefix=$Config{usevendorprefix}? $Config{vendorprefixexp}: '';my$sprefix=$Config{siteprefixexp}|| '';$sprefix=$iprefix unless$sprefix;$self->{PREFIX}||= '';if($self->{PREFIX}){@{$self}{qw(PERLPREFIX SITEPREFIX VENDORPREFIX)}=('$(PREFIX)')x 3}else {$self->{PERLPREFIX}||= $iprefix;$self->{SITEPREFIX}||= $sprefix;$self->{VENDORPREFIX}||= $vprefix;$self->{PREFIX}='$('.uc$self->{INSTALLDIRS}.'PREFIX)'}my$arch=$Config{archname};my$version=$Config{version};my$libstyle=$Config{installstyle}|| 'lib/perl5';my$manstyle='';if($self->{LIBSTYLE}){$libstyle=$self->{LIBSTYLE};$manstyle=$self->{LIBSTYLE}eq 'lib/perl5' ? 'lib/perl5' : ''}for my$num (1,3){$self->{'INSTALLMAN'.$num.'DIR'}||= 'none' unless$Config{'installman'.$num.'dir'}}my%bin_layouts=(bin=>{s=>$iprefix,t=>'perl',d=>'bin' },vendorbin=>{s=>$vprefix,t=>'vendor',d=>'bin' },sitebin=>{s=>$sprefix,t=>'site',d=>'bin' },script=>{s=>$iprefix,t=>'perl',d=>'bin' },vendorscript=>{s=>$vprefix,t=>'vendor',d=>'bin' },sitescript=>{s=>$sprefix,t=>'site',d=>'bin' },);my%man_layouts=(man1dir=>{s=>$iprefix,t=>'perl',d=>'man/man1',style=>$manstyle,},siteman1dir=>{s=>$sprefix,t=>'site',d=>'man/man1',style=>$manstyle,},vendorman1dir=>{s=>$vprefix,t=>'vendor',d=>'man/man1',style=>$manstyle,},man3dir=>{s=>$iprefix,t=>'perl',d=>'man/man3',style=>$manstyle,},siteman3dir=>{s=>$sprefix,t=>'site',d=>'man/man3',style=>$manstyle,},vendorman3dir=>{s=>$vprefix,t=>'vendor',d=>'man/man3',style=>$manstyle,},);my%lib_layouts=(privlib=>{s=>$iprefix,t=>'perl',d=>'',style=>$libstyle,},vendorlib=>{s=>$vprefix,t=>'vendor',d=>'',style=>$libstyle,},sitelib=>{s=>$sprefix,t=>'site',d=>'site_perl',style=>$libstyle,},archlib=>{s=>$iprefix,t=>'perl',d=>"$version/$arch",style=>$libstyle },vendorarch=>{s=>$vprefix,t=>'vendor',d=>"$version/$arch",style=>$libstyle },sitearch=>{s=>$sprefix,t=>'site',d=>"site_perl/$version/$arch",style=>$libstyle },);if($self->{LIB}){for my$var (keys%lib_layouts){my$Installvar=uc "install$var";if($var =~ /arch/){$self->{$Installvar}||= $self->catdir($self->{LIB},$Config{archname})}else {$self->{$Installvar}||= $self->{LIB}}}}my%type2prefix=(perl=>'PERLPREFIX',site=>'SITEPREFIX',vendor=>'VENDORPREFIX');my%layouts=(%bin_layouts,%man_layouts,%lib_layouts);while(my($var,$layout)=each(%layouts)){my($s,$t,$d,$style)=@{$layout}{qw(s t d style)};my$r='$('.$type2prefix{$t}.')';warn "Prefixing $var\n" if$Verbose >= 2;my$installvar="install$var";my$Installvar=uc$installvar;next if$self->{$Installvar};$d="$style/$d" if$style;$self->prefixify($installvar,$s,$r,$d);warn "  $Installvar == $self->{$Installvar}\n" if$Verbose >= 2}$self->{VENDORARCHEXP}||= $self->{INSTALLVENDORARCH};$self->{VENDORLIBEXP}||= $self->{INSTALLVENDORLIB};return 1}my%map=(lib=>[qw(lib perl5)],arch=>[('lib','perl5',$Config{archname})],bin=>[qw(bin)],man1dir=>[qw(man man1)],man3dir=>[qw(man man3)]);$map{script}=$map{bin};sub init_INSTALL_from_INSTALL_BASE {my$self=shift;@{$self}{qw(PREFIX VENDORPREFIX SITEPREFIX PERLPREFIX)}='$(INSTALL_BASE)';my%install;for my$thing (keys%map){for my$dir (('','SITE','VENDOR')){my$uc_thing=uc$thing;my$key="INSTALL".$dir.$uc_thing;$install{$key}||= $self->catdir('$(INSTALL_BASE)',@{$map{$thing}})}}$install{INSTALLARCHLIB}||= delete$install{INSTALLARCH};$install{INSTALLPRIVLIB}||= delete$install{INSTALLLIB};for my$key (keys%install){$self->{$key}||= $install{$key}}return 1}sub init_VERSION {my($self)=shift;$self->{MAKEMAKER}=$ExtUtils::MakeMaker::Filename;$self->{MM_VERSION}=$ExtUtils::MakeMaker::VERSION;$self->{MM_REVISION}=$ExtUtils::MakeMaker::Revision;$self->{VERSION_FROM}||= '';if ($self->{VERSION_FROM}){$self->{VERSION}=$self->parse_version($self->{VERSION_FROM});if($self->{VERSION}eq 'undef'){carp("WARNING: Setting VERSION via file "."'$self->{VERSION_FROM}' failed\n")}}if (defined$self->{VERSION}){$self->{VERSION}=~ s/^\s+//;$self->{VERSION}=~ s/\s+$//}else {$self->{VERSION}=''}$self->{VERSION_MACRO}='VERSION';($self->{VERSION_SYM}=$self->{VERSION})=~ s/\W/_/g;$self->{DEFINE_VERSION}='-D$(VERSION_MACRO)=\"$(VERSION)\"';$self->{XS_VERSION}||= $self->{VERSION};$self->{XS_VERSION_MACRO}='XS_VERSION';$self->{XS_DEFINE_VERSION}='-D$(XS_VERSION_MACRO)=\"$(XS_VERSION)\"'}sub init_tools {my$self=shift;$self->{ECHO}||= $self->oneliner('print qq{@ARGV}',['-l']);$self->{ECHO_N}||= $self->oneliner('print qq{@ARGV}');$self->{TOUCH}||= $self->oneliner('touch',["-MExtUtils::Command"]);$self->{CHMOD}||= $self->oneliner('chmod',["-MExtUtils::Command"]);$self->{RM_F}||= $self->oneliner('rm_f',["-MExtUtils::Command"]);$self->{RM_RF}||= $self->oneliner('rm_rf',["-MExtUtils::Command"]);$self->{TEST_F}||= $self->oneliner('test_f',["-MExtUtils::Command"]);$self->{FALSE}||= $self->oneliner('exit 1');$self->{TRUE}||= $self->oneliner('exit 0');$self->{MKPATH}||= $self->oneliner('mkpath',["-MExtUtils::Command"]);$self->{CP}||= $self->oneliner('cp',["-MExtUtils::Command"]);$self->{MV}||= $self->oneliner('mv',["-MExtUtils::Command"]);$self->{MOD_INSTALL}||= $self->oneliner(<<'CODE',['-MExtUtils::Install']);$self->{DOC_INSTALL}||= $self->oneliner('perllocal_install',["-MExtUtils::Command::MM"]);$self->{UNINSTALL}||= $self->oneliner('uninstall',["-MExtUtils::Command::MM"]);$self->{WARN_IF_OLD_PACKLIST}||= $self->oneliner('warn_if_old_packlist',["-MExtUtils::Command::MM"]);$self->{FIXIN}||= $self->oneliner('MY->fixin(shift)',["-MExtUtils::MY"]);$self->{EQUALIZE_TIMESTAMP}||= $self->oneliner('eqtime',["-MExtUtils::Command"]);$self->{UNINST}||= 0;$self->{VERBINST}||= 0;$self->{SHELL}||= $Config{sh};$self->{UMASK_NULL}||= "umask 0";$self->{DEV_NULL}||= "> /dev/null 2>&1";$self->{NOOP}||= '$(TRUE)';$self->{NOECHO}='@' unless defined$self->{NOECHO};$self->{FIRST_MAKEFILE}||= $self->{MAKEFILE}|| 'Makefile';$self->{MAKEFILE}||= $self->{FIRST_MAKEFILE};$self->{MAKEFILE_OLD}||= $self->{MAKEFILE}.'.old';$self->{MAKE_APERL_FILE}||= $self->{MAKEFILE}.'.aperl';$self->{USEMAKEFILE}||= '-f';$self->{MACROSTART}||= '';$self->{MACROEND}||= '';return}sub init_others {my$self=shift;$self->{LD_RUN_PATH}="";$self->{LIBS}=$self->_fix_libs($self->{LIBS});for my$libs (@{$self->{LIBS}}){$libs =~ s/^\s*(.*\S)\s*$/$1/;my(@libs)=$self->extliblist($libs);if ($libs[0]or $libs[1]or $libs[2]){($self->{EXTRALIBS},$self->{BSLOADLIBS},$self->{LDLOADLIBS},$self->{LD_RUN_PATH})=@libs;last}}if ($self->{OBJECT}){$self->{OBJECT}=~ s!\.o(bj)?\b!\$(OBJ_EXT)!g}else {$self->{OBJECT}="";$self->{OBJECT}='$(BASEEXT)$(OBJ_EXT)' if @{$self->{C}||[]}}$self->{OBJECT}=~ s/\n+/ \\\n\t/g;$self->{BOOTDEP}=(-f "$self->{BASEEXT}_BS")? "$self->{BASEEXT}_BS" : "";$self->{PERLMAINCC}||= '$(CC)';$self->{LDFROM}='$(OBJECT)' unless$self->{LDFROM};if (!$self->{LINKTYPE}){$self->{LINKTYPE}=$self->{SKIPHASH}{'dynamic'}? 'static' : ($Config{usedl}? 'dynamic' : 'static')}return}sub _fix_libs {my($self,$libs)=@_;return!defined$libs ? ['']: !ref$libs ? [$libs]: !defined$libs->[0]? ['']: $libs }sub tools_other {my($self)=shift;my@m;for my$tool (qw{SHELL CHMOD CP MV NOOP NOECHO RM_F RM_RF TEST_F TOUCH UMASK_NULL DEV_NULL MKPATH EQUALIZE_TIMESTAMP FALSE TRUE ECHO ECHO_N UNINST VERBINST MOD_INSTALL DOC_INSTALL UNINSTALL WARN_IF_OLD_PACKLIST MACROSTART MACROEND USEMAKEFILE PM_FILTER FIXIN}){next unless defined$self->{$tool};push@m,"$tool = $self->{$tool}\n"}return join "",@m}sub init_platform {return ''}sub init_MAKE {my$self=shift;$self->{MAKE}||= $ENV{MAKE}|| $Config{make}}sub manifypods {my$self=shift;my$POD2MAN_macro=$self->POD2MAN_macro();my$manifypods_target=$self->manifypods_target();return <<END_OF_TARGET}sub POD2MAN_macro {my$self=shift;return <<'END_OF_DEF'}sub test_via_harness {my($self,$perl,$tests)=@_;return qq{\t$perl "-MExtUtils::Command::MM" }.qq{"-e" "test_harness(\$(TEST_VERBOSE), '\$(INST_LIB)', '\$(INST_ARCHLIB)')" $tests\n}}sub test_via_script {my($self,$perl,$script)=@_;return qq{\t$perl "-I\$(INST_LIB)" "-I\$(INST_ARCHLIB)" $script\n}}sub tool_autosplit {my($self,%attribs)=@_;my$maxlen=$attribs{MAXLEN}? '$$AutoSplit::Maxlen=$attribs{MAXLEN};' : '';my$asplit=$self->oneliner(sprintf <<'PERL_CODE',$maxlen);return sprintf <<'MAKE_FRAG',$asplit}sub arch_check {my$self=shift;my($pconfig,$cconfig)=@_;return 1 if$self->{PERL_SRC};my($pvol,$pthinks)=$self->splitpath($pconfig);my($cvol,$cthinks)=$self->splitpath($cconfig);$pthinks=$self->canonpath($pthinks);$cthinks=$self->canonpath($cthinks);my$ret=1;if ($pthinks ne $cthinks){print "Have $pthinks\n";print "Want $cthinks\n";$ret=0;my$arch=(grep length,$self->splitdir($pthinks))[-1];print <<END unless$self->{UNINSTALLED_PERL}}return$ret}sub catfile {my$self=shift;return$self->canonpath($self->SUPER::catfile(@_))}sub find_tests {my($self)=shift;return -d 't' ? 't/*.t' : ''}sub extra_clean_files {return}sub installvars {return qw(PRIVLIB SITELIB VENDORLIB ARCHLIB SITEARCH VENDORARCH BIN SITEBIN VENDORBIN SCRIPT SITESCRIPT VENDORSCRIPT MAN1DIR SITEMAN1DIR VENDORMAN1DIR MAN3DIR SITEMAN3DIR VENDORMAN3DIR)}sub libscan {my($self,$path)=@_;my($dirs,$file)=($self->splitpath($path))[1,2];return '' if grep /^(?:RCS|CVS|SCCS|\.svn|_darcs)$/,$self->splitdir($dirs),$file;return$path}sub platform_constants {return ''}sub _PREREQ_PRINT {my$self=shift;require Data::Dumper;my@what=('PREREQ_PM');push@what,'MIN_PERL_VERSION' if$self->{MIN_PERL_VERSION};push@what,'BUILD_REQUIRES' if$self->{BUILD_REQUIRES};print Data::Dumper->Dump([@{$self}{@what}],\@what);exit 0}sub _PRINT_PREREQ {my$self=shift;my$prereqs=$self->{PREREQ_PM};my@prereq=map {[$_,$prereqs->{$_}]}keys %$prereqs;if ($self->{MIN_PERL_VERSION}){push@prereq,['perl'=>$self->{MIN_PERL_VERSION}]}print join(" ",map {"perl($_->[0])>=$_->[1] "}sort {$a->[0]cmp $b->[0]}@prereq),"\n";exit 0}sub _all_prereqs {my$self=shift;return {%{$self->{PREREQ_PM}},%{$self->{BUILD_REQUIRES}}}}sub _perl_header_files {my$self=shift;my$header_dir=$self->{PERL_SRC}|| $self->catdir($Config{archlibexp},'CORE');opendir my$dh,$header_dir or die "Failed to opendir '$header_dir' to find header files: $!";my@perl_headers=sort grep {/\.h\z/}readdir($dh);closedir$dh;return@perl_headers}sub _perl_header_files_fragment {my ($self,$separator)=@_;$separator ||= "";return join("\\\n","PERL_HDRS = ",map {sprintf("        \$(PERL_INC)%s%s            ",$separator,$_)}$self->_perl_header_files())."\n\n" ."\$(OBJECT) : \$(PERL_HDRS)\n"}1;
  makemakerdflt : all
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  manifypods : pure_all $dependencies
  END
  	\$(NOECHO) \$(POD2MAN) --section=$section --perm_rw=\$(PERM_RW)
  CMD
  metafile :
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  metafile : create_distdir
  	$(NOECHO) $(ECHO) Generating META.yml
  	%s
  	-$(NOECHO) $(MV) META_new.yml $(DISTVNAME)/META.yml
  	$(NOECHO) $(ECHO) Generating META.json
  	%s
  	-$(NOECHO) $(MV) META_new.json $(DISTVNAME)/META.json
  MAKE_FRAG
  exit unless -e q{META.yml};
  eval { maniadd({q{META.yml} => q{Module YAML meta-data (added by MakeMaker)}}) }
      or print "Could not add META.yml to MANIFEST: $${'@'}\n"
  CODE
  exit unless -f q{META.json};
  eval { maniadd({q{META.json} => q{Module JSON meta-data (added by MakeMaker)}}) }
      or print "Could not add META.json to MANIFEST: $${'@'}\n"
  CODE
  distmeta : create_distdir metafile
  	$(NOECHO) %s
  	$(NOECHO) %s
  
  MAKE
  # Delete temporary files (via clean) and also delete dist files
  realclean purge ::  clean realclean_subdirs
  	%s
  	%s
  MAKE
  realclean_subdirs :
  	$(NOECHO) $(NOOP)
  NOOP_FRAG
  chdir '%s';  system '$(MAKE) $(USEMAKEFILE) %s realclean' if -f '%s';
  CODE
  	- %s
  RCLEAN
  signature :
  	cpansign -s
  MAKE_FRAG
  eval { maniadd({q{SIGNATURE} => q{Public-key signature (added by MakeMaker)}}) } 
      or print "Could not add SIGNATURE to MANIFEST: $${'@'}\n"
  CODE
  distsignature : create_distdir
  	$(NOECHO) %s
  	$(NOECHO) %s
  	%s
  
  MAKE
  .SUFFIXES : .xs .c .C .cpp .i .s .cxx .cc $(OBJ_EXT)
  
  .PHONY: all config static dynamic test linkext manifest blibdirs clean realclean disttest distdir
  
  MAKE_FRAG
  .NO_CONFIG_REC: Makefile
  
  MAKE_FRAG
  install([ from_to => {@ARGV}, verbose => '$(VERBINST)', uninstall_shadows => '$(UNINST)', dir_mode => '$(PERM_DIR)' ]);
  CODE
  
  $POD2MAN_macro
  
  $manifypods_target
  
  END_OF_TARGET
  POD2MAN_EXE = $(PERLRUN) "-MExtUtils::Command::MM" -e pod2man "--"
  POD2MAN = $(POD2MAN_EXE)
  END_OF_DEF
  use AutoSplit; %s autosplit($$ARGV[0], $$ARGV[1], 0, 1, 1)
  PERL_CODE
  # Usage: $(AUTOSPLITFILE) FileToSplit AutoDirToSplitInto
  AUTOSPLITFILE = %s
  
  MAKE_FRAG
  Your perl and your Config.pm seem to have different ideas about the 
  architecture they are running on.
  Perl thinks: [$arch]
  Config says: [$Config{archname}]
  This may or may not cause problems. Please check your installation of perl 
  if you have problems building this extension.
  END
EXTUTILS_MM_ANY

$fatpacked{"ExtUtils/MM_BeOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_BEOS';
  package ExtUtils::MM_BeOS;use strict;use ExtUtils::MakeMaker::Config;use File::Spec;require ExtUtils::MM_Any;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Any ExtUtils::MM_Unix);our$VERSION='6.66';sub os_flavor {return('BeOS')}sub init_linker {my($self)=shift;$self->{PERL_ARCHIVE}||= File::Spec->catdir('$(PERL_INC)',$Config{libperl});$self->{PERL_ARCHIVE_AFTER}||= '';$self->{EXPORT_LIST}||= ''}
EXTUTILS_MM_BEOS

$fatpacked{"ExtUtils/MM_Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_CYGWIN';
  package ExtUtils::MM_Cygwin;use strict;use ExtUtils::MakeMaker::Config;use File::Spec;require ExtUtils::MM_Unix;require ExtUtils::MM_Win32;our@ISA=qw(ExtUtils::MM_Unix);our$VERSION='6.66';sub os_flavor {return('Unix','Cygwin')}sub cflags {my($self,$libperl)=@_;return$self->{CFLAGS}if$self->{CFLAGS};return '' unless$self->needs_linking();my$base=$self->SUPER::cflags($libperl);for (split /\n/,$base){/^(\S*)\s*=\s*(\S*)$/ and $self->{$1}=$2};$self->{CCFLAGS}.= " -DUSEIMPORTLIB" if ($Config{useshrplib}eq 'true');return$self->{CFLAGS}=qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  }}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s{/+}{.}g;return$man}sub init_linker {my$self=shift;if ($Config{useshrplib}eq 'true'){my$libperl='$(PERL_INC)' .'/'."$Config{libperl}";if($] >= 5.006002){$libperl =~ s/a$/dll.a/}$self->{PERL_ARCHIVE}=$libperl}else {$self->{PERL_ARCHIVE}='$(PERL_INC)' .'/'.("$Config{libperl}" or "libperl.a")}$self->{PERL_ARCHIVE_AFTER}||= '';$self->{EXPORT_LIST}||= ''}sub maybe_command {my ($self,$file)=@_;if ($file =~ m{^/cygdrive/}i){return ExtUtils::MM_Win32->maybe_command($file)}return$self->SUPER::maybe_command($file)}sub dynamic_lib {my($self,%attribs)=@_;my$s=ExtUtils::MM_Unix::dynamic_lib($self,%attribs);my$ori="$self->{INSTALLARCHLIB}/auto/$self->{FULLEXT}/$self->{BASEEXT}.$self->{DLEXT}";if (-e $ori){my$imagebase=`/bin/objdump -p $ori | /bin/grep ImageBase | /bin/cut -c12-`;chomp$imagebase;if ($imagebase gt "40000000"){my$LDDLFLAGS=$self->{LDDLFLAGS};$LDDLFLAGS =~ s/-Wl,--enable-auto-image-base/-Wl,--image-base=0x$imagebase/;$s =~ s/ \$\(LDDLFLAGS\) / $LDDLFLAGS /m}}$s}sub all_target {ExtUtils::MM_Unix::all_target(shift)}1;
EXTUTILS_MM_CYGWIN

$fatpacked{"ExtUtils/MM_DOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_DOS';
  package ExtUtils::MM_DOS;use strict;our$VERSION='6.66';require ExtUtils::MM_Any;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Any ExtUtils::MM_Unix);sub os_flavor {return('DOS')}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s,/+,__,g;return$man}1;
EXTUTILS_MM_DOS

$fatpacked{"ExtUtils/MM_Darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_DARWIN';
  package ExtUtils::MM_Darwin;use strict;BEGIN {require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Unix)}our$VERSION='6.66';sub init_dist {my$self=shift;$self->{TAR}||= 'COPY_EXTENDED_ATTRIBUTES_DISABLE=1 COPYFILE_DISABLE=1 tar';$self->SUPER::init_dist(@_)}1;
EXTUTILS_MM_DARWIN

$fatpacked{"ExtUtils/MM_MacOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_MACOS';
  package ExtUtils::MM_MacOS;use strict;our$VERSION='6.66';sub new {die <<'UNSUPPORTED'}1;
  MacOS Classic (MacPerl) is no longer supported by MakeMaker.
  Please use Module::Build instead.
  UNSUPPORTED
EXTUTILS_MM_MACOS

$fatpacked{"ExtUtils/MM_NW5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_NW5';
  package ExtUtils::MM_NW5;use strict;use ExtUtils::MakeMaker::Config;use File::Basename;our$VERSION='6.66';require ExtUtils::MM_Win32;our@ISA=qw(ExtUtils::MM_Win32);use ExtUtils::MakeMaker qw(&neatvalue);$ENV{EMXSHELL}='sh';my$BORLAND=$Config{'cc'}=~ /^bcc/i;my$GCC=$Config{'cc'}=~ /^gcc/i;sub os_flavor {my$self=shift;return ($self->SUPER::os_flavor,'Netware')}sub init_platform {my($self)=shift;$self->SUPER::init_platform;my$libpth=$Config{'libpth'};$libpth =~ s( )(;);$self->{'LIBPTH'}=$libpth;$self->{'BASE_IMPORT'}=$Config{'base_import'};if($self->{'base_import'}){$self->{'BASE_IMPORT'}.= ', ' .$self->{'base_import'}}$self->{'NLM_VERSION'}=$Config{'nlm_version'};$self->{'MPKTOOL'}=$Config{'mpktool'};$self->{'TOOLPATH'}=$Config{'toolpath'};(my$boot=$self->{'NAME'})=~ s/:/_/g;$self->{'BOOT_SYMBOL'}=$boot;if(length($self->{'BASEEXT'})> 8){$self->{'NLM_SHORT_NAME'}=substr($self->{'BASEEXT'},0,8)}($self->{INCLUDE}=$Config{'incpath'})=~ s/([ ]*)-I/;/g;$self->{PATH}='$(PATH);$(TOOLPATH)';$self->{MM_NW5_VERSION}=$VERSION}sub platform_constants {my($self)=shift;my$make_frag='';$make_frag .= $self->SUPER::platform_constants;for my$macro (qw(LIBPTH BASE_IMPORT NLM_VERSION MPKTOOL TOOLPATH BOOT_SYMBOL NLM_SHORT_NAME INCLUDE PATH MM_NW5_VERSION)){next unless defined$self->{$macro};$make_frag .= "$macro = $self->{$macro}\n"}return$make_frag}sub const_cccmd {my($self,$libperl)=@_;return$self->{CONST_CCCMD}if$self->{CONST_CCCMD};return '' unless$self->needs_linking();return$self->{CONST_CCCMD}=<<'MAKE_FRAG'}sub static_lib {my($self)=@_;return '' unless$self->has_link_code;my$m=<<'END';$m .= <<'END' if$self->{MYEXTLIB};my$ar_arg;if($BORLAND){$ar_arg='$@ $(OBJECT:^"+")'}elsif($GCC){$ar_arg='-ru $@ $(OBJECT)'}else {$ar_arg='-type library -o $@ $(OBJECT)'}$m .= sprintf <<'END',$ar_arg;$m .= <<'END' if$self->{PERL_SRC};return$m}sub dynamic_lib {my($self,%attribs)=@_;return '' unless$self->needs_linking();return '' unless$self->has_link_code;my($otherldflags)=$attribs{OTHERLDFLAGS}|| ($BORLAND ? 'c0d32.obj': '');my($inst_dynamic_dep)=$attribs{INST_DYNAMIC_DEP}|| "";my($ldfrom)='$(LDFROM)';(my$boot=$self->{NAME})=~ s/:/_/g;my$m=<<'MAKE_FRAG';if ($self->{CCFLAGS}=~ m/ -DMPK_ON /){$m .= <<'MAKE_FRAG'}my$version=join '.',map {sprintf "%d",$_}$] =~ /(\d)\.(\d{3})(\d{2})/;$m .= sprintf '	$(LD) $(LDFLAGS) $(OBJECT:.obj=.obj) -desc "Perl %s Extension ($(BASEEXT))  XS_VERSION: $(XS_VERSION)" -nlmversion $(NLM_VERSION)',$version;if($self->{NLM_SHORT_NAME}){$m .= q{ -o $(NLM_SHORT_NAME).$(DLEXT)}}else {$m .= q{ -o $(INST_AUTODIR)\\$(BASEEXT).$(DLEXT)}}$m .= q{ $(MYEXTLIB) } if$self->{MYEXTLIB};$m .= q{ $(PERL_INC)\Main.lib -commandfile $(BASEEXT).def}."\n";if($self->{NLM_SHORT_NAME}){$m .= <<'MAKE_FRAG'}$m .= <<'MAKE_FRAG';return$m}1;
  CCCMD = $(CC) $(CCFLAGS) $(INC) $(OPTIMIZE) \
  	$(PERLTYPE) $(MPOLLUTE) -o $@ \
  	-DVERSION=\"$(VERSION)\" -DXS_VERSION=\"$(XS_VERSION)\"
  MAKE_FRAG
  $(INST_STATIC): $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DFSEP).exists
  	$(RM_RF) $@
  END
  	$self->{CP} $(MYEXTLIB) $@
  END
  	$(AR) %s
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" > $(INST_ARCHAUTODIR)\extralibs.ld
  	$(CHMOD) 755 $@
  END
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" >> $(PERL_SRC)\ext.libs
  
  
  END
  # This section creates the dynamically loadable $(INST_DYNAMIC)
  # from $(OBJECT) and possibly $(MYEXTLIB).
  OTHERLDFLAGS = '.$otherldflags.'
  INST_DYNAMIC_DEP = '.$inst_dynamic_dep.'
  
  # Create xdc data for an MT safe NLM in case of mpk build
  $(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DFSEP).exists
  	$(NOECHO) $(ECHO) Export boot_$(BOOT_SYMBOL) > $(BASEEXT).def
  	$(NOECHO) $(ECHO) $(BASE_IMPORT) >> $(BASEEXT).def
  	$(NOECHO) $(ECHO) Import @$(PERL_INC)\perl.imp >> $(BASEEXT).def
  MAKE_FRAG
  	$(MPKTOOL) $(XDCFLAGS) $(BASEEXT).xdc
  	$(NOECHO) $(ECHO) xdcdata $(BASEEXT).xdc >> $(BASEEXT).def
  MAKE_FRAG
  	if exist $(INST_AUTODIR)\$(NLM_SHORT_NAME).$(DLEXT) del $(INST_AUTODIR)\$(NLM_SHORT_NAME).$(DLEXT) 
  	move $(NLM_SHORT_NAME).$(DLEXT) $(INST_AUTODIR)
  MAKE_FRAG
  
  	$(CHMOD) 755 $@
  MAKE_FRAG
EXTUTILS_MM_NW5

$fatpacked{"ExtUtils/MM_OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_OS2';
  package ExtUtils::MM_OS2;use strict;use ExtUtils::MakeMaker qw(neatvalue);use File::Spec;our$VERSION='6.66';require ExtUtils::MM_Any;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Any ExtUtils::MM_Unix);sub init_dist {my($self)=@_;$self->{TO_UNIX}||= <<'MAKE_TEXT';$self->SUPER::init_dist}sub dlsyms {my($self,%attribs)=@_;my($funcs)=$attribs{DL_FUNCS}|| $self->{DL_FUNCS}|| {};my($vars)=$attribs{DL_VARS}|| $self->{DL_VARS}|| [];my($funclist)=$attribs{FUNCLIST}|| $self->{FUNCLIST}|| [];my($imports)=$attribs{IMPORTS}|| $self->{IMPORTS}|| {};my(@m);(my$boot=$self->{NAME})=~ s/:/_/g;if (not $self->{SKIPHASH}{'dynamic'}){push(@m,"
  $(NOECHO) $(TEST_F) tmp.zip && $(RM_F) tmp.zip; $(ZIP) -ll -mr tmp.zip $(DISTVNAME) && unzip -o tmp.zip && $(RM_F) tmp.zip
  MAKE_TEXT
  $self->{BASEEXT}.def: Makefile.PL
  ",'	$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -e \'use ExtUtils::Mksymlists; \\
       Mksymlists("NAME" => "$(NAME)", "DLBASE" => "$(DLBASE)", ','"VERSION" => "$(VERSION)", "DISTNAME" => "$(DISTNAME)", ','"INSTALLDIRS" => "$(INSTALLDIRS)", ','"DL_FUNCS" => ',neatvalue($funcs),', "FUNCLIST" => ',neatvalue($funclist),', "IMPORTS" => ',neatvalue($imports),', "DL_VARS" => ',neatvalue($vars),');\'
  ')}if ($self->{IMPORTS}&& %{$self->{IMPORTS}}){-d 'tmp_imp' or mkdir 'tmp_imp',0777 or die "Can't mkdir tmp_imp";open my$imp,'>','tmpimp.imp' or die "Can't open tmpimp.imp";while (my($name,$exp)=each %{$self->{IMPORTS}}){my ($lib,$id)=($exp =~ /(.*)\.(.*)/)or die "Malformed IMPORT `$exp'";print$imp "$name $lib $id ?\n"}close$imp or die "Can't close tmpimp.imp";system "emximp -o tmpimp$Config::Config{lib_ext} tmpimp.imp" and die "Cannot make import library: $!, \$?=$?";eval {unlink <tmp_imp/*>;1}or system "rm tmp_imp/*";system "cd tmp_imp; $Config::Config{ar} x ../tmpimp$Config::Config{lib_ext}" and die "Cannot extract import objects: $!, \$?=$?"}join('',@m)}sub static_lib {my($self)=@_;my$old=$self->ExtUtils::MM_Unix::static_lib();return$old unless$self->{IMPORTS}&& %{$self->{IMPORTS}};my@chunks=split /\n{2,}/,$old;shift@chunks unless length$chunks[0];$chunks[0].= <<'EOC';return join "\n\n".'',@chunks}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s,/+,.,g;$man}sub maybe_command {my($self,$file)=@_;$file =~ s,[/\\]+,/,g;return$file if -x $file &&!-d _;return "$file.exe" if -x "$file.exe" &&!-d _;return "$file.cmd" if -x "$file.cmd" &&!-d _;return}sub init_linker {my$self=shift;$self->{PERL_ARCHIVE}="\$(PERL_INC)/libperl\$(LIB_EXT)";$self->{PERL_ARCHIVE_AFTER}=$OS2::is_aout ? '' : '$(PERL_INC)/libperl_override$(LIB_EXT)';$self->{EXPORT_LIST}='$(BASEEXT).def'}sub os_flavor {return('OS/2')}1;
  
  	$(AR) $(AR_STATIC_ARGS) $@ tmp_imp/* && $(RANLIB) $@
  EOC
EXTUTILS_MM_OS2

$fatpacked{"ExtUtils/MM_QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_QNX';
  package ExtUtils::MM_QNX;use strict;our$VERSION='6.66';require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Unix);sub extra_clean_files {my$self=shift;my@errfiles=@{$self->{C}};for (@errfiles){s/.c$/.err/}return(@errfiles,'perlmain.err')}1;
EXTUTILS_MM_QNX

$fatpacked{"ExtUtils/MM_UWIN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_UWIN';
  package ExtUtils::MM_UWIN;use strict;our$VERSION='6.66';require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Unix);sub os_flavor {return('Unix','U/WIN')}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s,/+,.,g;return$man}1;
EXTUTILS_MM_UWIN

$fatpacked{"ExtUtils/MM_Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_UNIX';
  package ExtUtils::MM_Unix;require 5.006;use strict;use Carp;use ExtUtils::MakeMaker::Config;use File::Basename qw(basename dirname);use DirHandle;our%Config_Override;use ExtUtils::MakeMaker qw($Verbose neatvalue);use vars qw($VERSION);$VERSION='6.66';$VERSION=eval$VERSION;require ExtUtils::MM_Any;our@ISA=qw(ExtUtils::MM_Any);my%Is;BEGIN {$Is{OS2}=$^O eq 'os2';$Is{Win32}=$^O eq 'MSWin32' || $Config{osname}eq 'NetWare';$Is{Dos}=$^O eq 'dos';$Is{VMS}=$^O eq 'VMS';$Is{OSF}=$^O eq 'dec_osf';$Is{IRIX}=$^O eq 'irix';$Is{NetBSD}=$^O eq 'netbsd';$Is{Interix}=$^O eq 'interix';$Is{SunOS4}=$^O eq 'sunos';$Is{Solaris}=$^O eq 'solaris';$Is{SunOS}=$Is{SunOS4}|| $Is{Solaris};$Is{BSD}=($^O =~ /^(?:free|net|open)bsd$/ or grep($^O eq $_,qw(bsdos interix dragonfly)))}BEGIN {if($Is{VMS}){require VMS::Filespec;VMS::Filespec->import}}my$Curdir=__PACKAGE__->curdir;my$Rootdir=__PACKAGE__->rootdir;my$Updir=__PACKAGE__->updir;sub os_flavor {return('Unix')}sub c_o {my($self)=shift;return '' unless$self->needs_linking();my(@m);my$command='$(CCCMD)';my$flags='$(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE)';if (my$cpp=$Config{cpprun}){my$cpp_cmd=$self->const_cccmd;$cpp_cmd =~ s/^CCCMD\s*=\s*\$\(CC\)/$cpp/;push@m,qq{
  .c.i:
  	$cpp_cmd $flags \$*.c > \$*.i
  }}push@m,qq{
  .c.s:
  	$command -S $flags \$*.c
  
  .c\$(OBJ_EXT):
  	$command $flags \$*.c
  
  .cpp\$(OBJ_EXT):
  	$command $flags \$*.cpp
  
  .cxx\$(OBJ_EXT):
  	$command $flags \$*.cxx
  
  .cc\$(OBJ_EXT):
  	$command $flags \$*.cc
  };push@m,qq{
  .C\$(OBJ_EXT):
  	$command $flags \$*.C
  } if!$Is{OS2}and!$Is{Win32}and!$Is{Dos};return join "",@m}sub cflags {my($self,$libperl)=@_;return$self->{CFLAGS}if$self->{CFLAGS};return '' unless$self->needs_linking();my($prog,$uc,$perltype,%cflags);$libperl ||= $self->{LIBPERL_A}|| "libperl$self->{LIB_EXT}" ;$libperl =~ s/\.\$\(A\)$/$self->{LIB_EXT}/;@cflags{qw(cc ccflags optimize shellflags)}=@Config{qw(cc ccflags optimize shellflags)};my($optdebug)="";$cflags{shellflags}||= '';my(%map)=(D=>'-DDEBUGGING',E=>'-DEMBED',DE=>'-DDEBUGGING -DEMBED',M=>'-DEMBED -DMULTIPLICITY',DM=>'-DDEBUGGING -DEMBED -DMULTIPLICITY',);if ($libperl =~ /libperl(\w*)\Q$self->{LIB_EXT}/){$uc=uc($1)}else {$uc=""}$perltype=$map{$uc}? $map{$uc}: "";if ($uc =~ /^D/){$optdebug="-g"}my($name);($name=$self->{NAME}."_cflags")=~ s/:/_/g ;if ($prog=$Config{$name}){print "Processing $name hint:\n" if$Verbose;my(@o)=`cc=\"$cflags{cc}\"
  	  ccflags=\"$cflags{ccflags}\"
  	  optimize=\"$cflags{optimize}\"
  	  perltype=\"$cflags{perltype}\"
  	  optdebug=\"$cflags{optdebug}\"
  	  eval '$prog'
  	  echo cc=\$cc
  	  echo ccflags=\$ccflags
  	  echo optimize=\$optimize
  	  echo perltype=\$perltype
  	  echo optdebug=\$optdebug
  	  `;for my$line (@o){chomp$line;if ($line =~ /(.*?)=\s*(.*)\s*$/){$cflags{$1}=$2;print "	$1 = $2\n" if$Verbose}else {print "Unrecognised result from hint: '$line'\n"}}}if ($optdebug){$cflags{optimize}=$optdebug}for (qw(ccflags optimize perltype)){$cflags{$_}||= '';$cflags{$_}=~ s/^\s+//;$cflags{$_}=~ s/\s+/ /g;$cflags{$_}=~ s/\s+$//;$self->{uc $_}||= $cflags{$_}}if ($self->{POLLUTE}){$self->{CCFLAGS}.= ' -DPERL_POLLUTE '}my$pollute='';if ($Config{usemymalloc}and not $Config{bincompat5005}and not $Config{ccflags}=~ /-DPERL_POLLUTE_MALLOC\b/ and $self->{PERL_MALLOC_OK}){$pollute='$(PERL_MALLOC_DEF)'}$self->{CCFLAGS}=quote_paren($self->{CCFLAGS});$self->{OPTIMIZE}=quote_paren($self->{OPTIMIZE});return$self->{CFLAGS}=qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  MPOLLUTE = $pollute
  }}sub const_cccmd {my($self,$libperl)=@_;return$self->{CONST_CCCMD}if$self->{CONST_CCCMD};return '' unless$self->needs_linking();return$self->{CONST_CCCMD}=q{CCCMD = $(CC) -c $(PASTHRU_INC) $(INC) \\
  	$(CCFLAGS) $(OPTIMIZE) \\
  	$(PERLTYPE) $(MPOLLUTE) $(DEFINE_VERSION) \\
  	$(XS_DEFINE_VERSION)}}sub const_config {my($self)=shift;my@m=<<"END";my(%once_only);for my$key (@{$self->{CONFIG}}){next if$once_only{$key};$self->{uc$key}=quote_paren($self->{uc$key});push@m,uc($key),' = ',$self->{uc$key},"\n";$once_only{$key}=1}join('',@m)}sub const_loadlibs {my($self)=shift;return "" unless$self->needs_linking;my@m;push@m,qq{
  
  # These definitions are from config.sh (via $INC{'Config.pm'}).
  # They may have been overridden via Makefile.PL or on the command line.
  END
  # $self->{NAME} might depend on some other libraries:
  # See ExtUtils::Liblist for details
  #
  };for my$tmp (qw/EXTRALIBS LDLOADLIBS BSLOADLIBS/){next unless defined$self->{$tmp};push@m,"$tmp = $self->{$tmp}\n"}for my$tmp (qw/LD_RUN_PATH/){next unless$self->{$tmp};push@m,"$tmp = $self->{$tmp}\n"}return join "",@m}sub constants {my($self)=@_;my@m=();$self->{DFSEP}='$(DIRFILESEP)';for my$macro (qw(AR_STATIC_ARGS DIRFILESEP DFSEP NAME NAME_SYM VERSION VERSION_MACRO VERSION_SYM DEFINE_VERSION XS_VERSION XS_VERSION_MACRO XS_DEFINE_VERSION INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB INST_MAN1DIR INST_MAN3DIR MAN1EXT MAN3EXT INSTALLDIRS INSTALL_BASE DESTDIR PREFIX PERLPREFIX SITEPREFIX VENDORPREFIX),(map {("INSTALL".$_,"DESTINSTALL".$_)}$self->installvars),qw(PERL_LIB PERL_ARCHLIB LIBPERL_A MYEXTLIB FIRST_MAKEFILE MAKEFILE_OLD MAKE_APERL_FILE PERLMAINCC PERL_SRC PERL_INC PERL FULLPERL ABSPERL PERLRUN FULLPERLRUN ABSPERLRUN PERLRUNINST FULLPERLRUNINST ABSPERLRUNINST PERL_CORE PERM_DIR PERM_RW PERM_RWX)){next unless defined$self->{$macro};$self->{$macro}=~ s/#/\\#/g;push@m,"$macro = $self->{$macro}\n"}push@m,qq{
  MAKEMAKER   = $self->{MAKEMAKER}
  MM_VERSION  = $self->{MM_VERSION}
  MM_REVISION = $self->{MM_REVISION}
  };push@m,q{
  # FULLEXT = Pathname for extension directory (eg Foo/Bar/Oracle).
  # BASEEXT = Basename part of FULLEXT. May be just equal FULLEXT. (eg Oracle)
  # PARENT_NAME = NAME without BASEEXT and no trailing :: (eg Foo::Bar)
  # DLBASE  = Basename part of dynamic library. May be just equal BASEEXT.
  };for my$macro (qw/MAKE FULLEXT BASEEXT PARENT_NAME DLBASE VERSION_FROM INC DEFINE OBJECT LDFROM LINKTYPE BOOTDEP/){next unless defined$self->{$macro};push@m,"$macro = $self->{$macro}\n"}push@m,"
  # Handy lists of source code files:
  XS_FILES = ".$self->wraplist(sort keys %{$self->{XS}})."
  C_FILES  = ".$self->wraplist(@{$self->{C}})."
  O_FILES  = ".$self->wraplist(@{$self->{O_FILES}})."
  H_FILES  = ".$self->wraplist(@{$self->{H}})."
  MAN1PODS = ".$self->wraplist(sort keys %{$self->{MAN1PODS}})."
  MAN3PODS = ".$self->wraplist(sort keys %{$self->{MAN3PODS}})."
  ";push@m,q{
  # Where is the Config information that we are using/depend on
  CONFIGDEP = $(PERL_ARCHLIB)$(DFSEP)Config.pm $(PERL_INC)$(DFSEP)config.h
  };push@m,qq{
  # Where to build things
  INST_LIBDIR      = $self->{INST_LIBDIR}
  INST_ARCHLIBDIR  = $self->{INST_ARCHLIBDIR}
  
  INST_AUTODIR     = $self->{INST_AUTODIR}
  INST_ARCHAUTODIR = $self->{INST_ARCHAUTODIR}
  
  INST_STATIC      = $self->{INST_STATIC}
  INST_DYNAMIC     = $self->{INST_DYNAMIC}
  INST_BOOT        = $self->{INST_BOOT}
  };push@m,qq{
  # Extra linker info
  EXPORT_LIST        = $self->{EXPORT_LIST}
  PERL_ARCHIVE       = $self->{PERL_ARCHIVE}
  PERL_ARCHIVE_AFTER = $self->{PERL_ARCHIVE_AFTER}
  };push@m,"
  
  TO_INST_PM = ".$self->wraplist(sort keys %{$self->{PM}})."
  
  PM_TO_BLIB = ".$self->wraplist(%{$self->{PM}})."
  ";join('',@m)}sub depend {my($self,%attribs)=@_;my(@m,$key,$val);while (($key,$val)=each%attribs){last unless defined$key;push@m,"$key : $val\n"}join "",@m}sub init_DEST {my$self=shift;$self->{DESTDIR}||= '';for my$var ($self->installvars){my$destvar='DESTINSTALL'.$var;$self->{$destvar}||= '$(DESTDIR)$(INSTALL'.$var.')'}}sub init_dist {my$self=shift;$self->{TAR}||= 'tar';$self->{TARFLAGS}||= 'cvf';$self->{ZIP}||= 'zip';$self->{ZIPFLAGS}||= '-r';$self->{COMPRESS}||= 'gzip --best';$self->{SUFFIX}||= '.gz';$self->{SHAR}||= 'shar';$self->{PREOP}||= '$(NOECHO) $(NOOP)';$self->{POSTOP}||= '$(NOECHO) $(NOOP)';$self->{TO_UNIX}||= '$(NOECHO) $(NOOP)';$self->{CI}||= 'ci -u';$self->{RCS_LABEL}||= 'rcs -Nv$(VERSION_SYM): -q';$self->{DIST_CP}||= 'best';$self->{DIST_DEFAULT}||= 'tardist';($self->{DISTNAME}=$self->{NAME})=~ s{::}{-}g unless$self->{DISTNAME};$self->{DISTVNAME}||= $self->{DISTNAME}.'-'.$self->{VERSION}}sub dist {my($self,%attribs)=@_;my$make='';for my$key (qw(TAR TARFLAGS ZIP ZIPFLAGS COMPRESS SUFFIX SHAR PREOP POSTOP TO_UNIX CI RCS_LABEL DIST_CP DIST_DEFAULT DISTNAME DISTVNAME)){my$value=$attribs{$key}|| $self->{$key};$make .= "$key = $value\n"}return$make}sub dist_basics {my($self)=shift;return <<'MAKE_FRAG'}sub dist_ci {my($self)=shift;return q{
  distclean :: realclean distcheck
  	$(NOECHO) $(NOOP)
  
  distcheck :
  	$(PERLRUN) "-MExtUtils::Manifest=fullcheck" -e fullcheck
  
  skipcheck :
  	$(PERLRUN) "-MExtUtils::Manifest=skipcheck" -e skipcheck
  
  manifest :
  	$(PERLRUN) "-MExtUtils::Manifest=mkmanifest" -e mkmanifest
  
  veryclean : realclean
  	$(RM_F) *~ */*~ *.orig */*.orig *.bak */*.bak *.old */*.old 
  
  MAKE_FRAG
  ci :
  	$(PERLRUN) "-MExtUtils::Manifest=maniread" \\
  	  -e "@all = keys %{ maniread() };" \\
  	  -e "print(qq{Executing $(CI) @all\n}); system(qq{$(CI) @all});" \\
  	  -e "print(qq{Executing $(RCS_LABEL) ...\n}); system(qq{$(RCS_LABEL) @all});"
  }}sub dist_core {my($self)=shift;my$make_frag='';for my$target (qw(dist tardist uutardist tarfile zipdist zipfile shdist)){my$method=$target.'_target';$make_frag .= "\n";$make_frag .= $self->$method()}return$make_frag}sub dist_target {my($self)=shift;my$date_check=$self->oneliner(<<'CODE',['-l']);return sprintf <<'MAKE_FRAG',$date_check}sub tardist_target {my($self)=shift;return <<'MAKE_FRAG'}sub zipdist_target {my($self)=shift;return <<'MAKE_FRAG'}sub tarfile_target {my($self)=shift;return <<'MAKE_FRAG'}sub zipfile_target {my($self)=shift;return <<'MAKE_FRAG'}sub uutardist_target {my($self)=shift;return <<'MAKE_FRAG'}sub shdist_target {my($self)=shift;return <<'MAKE_FRAG'}sub dlsyms {return ''}sub dynamic_bs {my($self,%attribs)=@_;return '
  print 'Warning: Makefile possibly out of date with $(VERSION_FROM)'
      if -e '$(VERSION_FROM)' and -M '$(VERSION_FROM)' < -M '$(FIRST_MAKEFILE)';
  CODE
  dist : $(DIST_DEFAULT) $(FIRST_MAKEFILE)
  	$(NOECHO) %s
  MAKE_FRAG
  tardist : $(DISTVNAME).tar$(SUFFIX)
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  zipdist : $(DISTVNAME).zip
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  $(DISTVNAME).tar$(SUFFIX) : distdir
  	$(PREOP)
  	$(TO_UNIX)
  	$(TAR) $(TARFLAGS) $(DISTVNAME).tar $(DISTVNAME)
  	$(RM_RF) $(DISTVNAME)
  	$(COMPRESS) $(DISTVNAME).tar
  	$(POSTOP)
  MAKE_FRAG
  $(DISTVNAME).zip : distdir
  	$(PREOP)
  	$(ZIP) $(ZIPFLAGS) $(DISTVNAME).zip $(DISTVNAME)
  	$(RM_RF) $(DISTVNAME)
  	$(POSTOP)
  MAKE_FRAG
  uutardist : $(DISTVNAME).tar$(SUFFIX)
  	uuencode $(DISTVNAME).tar$(SUFFIX) $(DISTVNAME).tar$(SUFFIX) > $(DISTVNAME).tar$(SUFFIX)_uu
  MAKE_FRAG
  shdist : distdir
  	$(PREOP)
  	$(SHAR) $(DISTVNAME) > $(DISTVNAME).shar
  	$(RM_RF) $(DISTVNAME)
  	$(POSTOP)
  MAKE_FRAG
  BOOTSTRAP =
  ' unless$self->has_link_code();my$target=$Is{VMS}? '$(MMS$TARGET)' : '$@';return sprintf <<'MAKE_FRAG',($target)x 5}sub dynamic_lib {my($self,%attribs)=@_;return '' unless$self->needs_linking();return '' unless$self->has_link_code;my($otherldflags)=$attribs{OTHERLDFLAGS}|| "";my($inst_dynamic_dep)=$attribs{INST_DYNAMIC_DEP}|| "";my($armaybe)=$attribs{ARMAYBE}|| $self->{ARMAYBE}|| ":";my($ldfrom)='$(LDFROM)';$armaybe='ar' if ($Is{OSF}and $armaybe eq ':');my(@m);my$ld_opt=$Is{OS2}? '$(OPTIMIZE) ' : '';my$ld_fix=$Is{OS2}? '|| ( $(RM_F) $@ && sh -c false )' : '';push(@m,'
  BOOTSTRAP = $(BASEEXT).bs
  
  # As Mkbootstrap might not write a file (if none is required)
  # we use touch to prevent make continually trying to remake it.
  # The DynaLoader only reads a non-empty file.
  $(BOOTSTRAP) : $(FIRST_MAKEFILE) $(BOOTDEP) $(INST_ARCHAUTODIR)$(DFSEP).exists
  	$(NOECHO) $(ECHO) "Running Mkbootstrap for $(NAME) ($(BSLOADLIBS))"
  	$(NOECHO) $(PERLRUN) \
  		"-MExtUtils::Mkbootstrap" \
  		-e "Mkbootstrap('$(BASEEXT)','$(BSLOADLIBS)');"
  	$(NOECHO) $(TOUCH) %s
  	$(CHMOD) $(PERM_RW) %s
  
  $(INST_BOOT) : $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DFSEP).exists
  	$(NOECHO) $(RM_RF) %s
  	- $(CP) $(BOOTSTRAP) %s
  	$(CHMOD) $(PERM_RW) %s
  MAKE_FRAG
  # This section creates the dynamically loadable $(INST_DYNAMIC)
  # from $(OBJECT) and possibly $(MYEXTLIB).
  ARMAYBE = '.$armaybe.'
  OTHERLDFLAGS = '.$ld_opt.$otherldflags.'
  INST_DYNAMIC_DEP = '.$inst_dynamic_dep.'
  INST_DYNAMIC_FIX = '.$ld_fix.'
  
  $(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DFSEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(PERL_ARCHIVE_AFTER) $(INST_DYNAMIC_DEP)
  ');if ($armaybe ne ':'){$ldfrom='tmp$(LIB_EXT)';push(@m,'	$(ARMAYBE) cr '.$ldfrom.' $(OBJECT)'."\n");push(@m,'	$(RANLIB) '."$ldfrom\n")}$ldfrom="-all $ldfrom -none" if$Is{OSF};my$ldrun=$Is{IRIX}&& $self->{LD_RUN_PATH}? qq{-rpath "$self->{LD_RUN_PATH}"} : '';push(@m,'	$(RM_F) $@
  ');my$libs='$(LDLOADLIBS)';if (($Is{NetBSD}|| $Is{Interix})&& $Config{'useshrplib'}eq 'true'){if ($Config{'lddlflags'}=~ /-Wl,-R/){$libs .= ' -L$(PERL_INC) -Wl,-R$(INSTALLARCHLIB)/CORE -Wl,-R$(PERL_ARCHLIB)/CORE -lperl'}elsif ($Config{'lddlflags'}=~ /-R/){$libs .= ' -L$(PERL_INC) -R$(INSTALLARCHLIB)/CORE -R$(PERL_ARCHLIB)/CORE -lperl'}}my$ld_run_path_shell="";if ($self->{LD_RUN_PATH}ne ""){$ld_run_path_shell='LD_RUN_PATH="$(LD_RUN_PATH)" '}push@m,sprintf <<'MAKE',$ld_run_path_shell,$ldrun,$ldfrom,$libs;push@m,<<'MAKE';return join('',@m)}sub exescan {my($self,$path)=@_;$path}sub extliblist {my($self,$libs)=@_;require ExtUtils::Liblist;$self->ext($libs,$Verbose)}sub find_perl {my($self,$ver,$names,$dirs,$trace)=@_;if ($trace >= 2){print "Looking for perl $ver by these names:
  	%s$(LD) %s $(LDDLFLAGS) %s $(OTHERLDFLAGS) -o $@ $(MYEXTLIB)	\
  	  $(PERL_ARCHIVE) %s $(PERL_ARCHIVE_AFTER) $(EXPORT_LIST)	\
  	  $(INST_DYNAMIC_FIX)
  MAKE
  	$(CHMOD) $(PERM_RWX) $@
  MAKE
  @$names
  in these dirs:
  @$dirs
  "}my$stderr_duped=0;local*STDERR_COPY;unless ($Is{BSD}){if(open(STDERR_COPY,'>&STDERR')){$stderr_duped=1}else {warn <<WARNING}}for my$name (@$names){for my$dir (@$dirs){next unless defined$dir;my ($abs,$val);if ($self->file_name_is_absolute($name)){$abs=$name}elsif ($self->canonpath($name)eq $self->canonpath(basename($name))){$abs=$self->catfile($dir,$name)}else {$abs=$self->catfile($Curdir,$name)}print "Checking $abs\n" if ($trace >= 2);next unless$self->maybe_command($abs);print "Executing $abs\n" if ($trace >= 2);my$version_check=qq{$abs -le "require $ver; print qq{VER_OK}"};$version_check="$Config{run} $version_check" if defined$Config{run}and length$Config{run};if ($Is{BSD}){$val=`$version_check 2>&1`}else {close STDERR if$stderr_duped;$val=`$version_check`;open STDERR,">&STDERR_COPY" if$stderr_duped}if ($val =~ /^VER_OK/m){print "Using PERL=$abs\n" if$trace;return$abs}elsif ($trace >= 2){print "Result: '$val' ".($? >> 8)."\n"}}}print "Unable to find a perl $ver (by these names: @$names, in these dirs: @$dirs)\n";0}sub fixin {my ($self,@files)=@_;for my$file (@files){my$file_new="$file.new";my$file_bak="$file.bak";open(my$fixin,'<',$file)or croak "Can't process '$file': $!";local $/="\n";chomp(my$line=<$fixin>);next unless$line =~ s/^\s*\#!\s*//;my$shb=$self->_fixin_replace_shebang($file,$line);next unless defined$shb;open(my$fixout,">","$file_new")or do {warn "Can't create new $file: $!\n";next};local $\;local $/;print$fixout $shb,<$fixin>;close$fixin;close$fixout;chmod 0666,$file_bak;unlink$file_bak;unless (_rename($file,$file_bak)){warn "Can't rename $file to $file_bak: $!";next}unless (_rename($file_new,$file)){warn "Can't rename $file_new to $file: $!";unless (_rename($file_bak,$file)){warn "Can't rename $file_bak back to $file either: $!";warn "Leaving $file renamed as $file_bak\n"}next}unlink$file_bak}continue {system("$Config{'eunicefix'} $file")if$Config{'eunicefix'}ne ':'}}sub _rename {my($old,$new)=@_;for my$file ($old,$new){if($Is{VMS}and basename($file)!~ /\./){$file="$file."}}return rename($old,$new)}sub _fixin_replace_shebang {my ($self,$file,$line)=@_;my ($cmd,$arg)=split ' ',$line,2;$cmd =~ s!^.*/!!;my$interpreter;if ($cmd =~ m{^perl(?:\z|[^a-z])}){if ($Config{startperl}=~ m,^\#!.*/perl,){$interpreter=$Config{startperl};$interpreter =~ s,^\#!,,}else {$interpreter=$Config{perlpath}}}else {my (@absdirs)=reverse grep {$self->file_name_is_absolute($_)}$self->path;$interpreter='';for my$dir (@absdirs){if ($self->maybe_command($cmd)){warn "Ignoring $interpreter in $file\n" if$Verbose && $interpreter;$interpreter=$self->catfile($dir,$cmd)}}}my ($does_shbang)=$Config{'sharpbang'}=~ /^\s*\#\!/;my ($shb)="";if ($interpreter){print "Changing sharpbang in $file to $interpreter" if$Verbose;if ($does_shbang){$shb .= "$Config{'sharpbang'}$interpreter";$shb .= ' ' .$arg if defined$arg;$shb .= "\n"}$shb .= qq{
  find_perl() can't dup STDERR: $!
  You might see some garbage while we search for Perl
  WARNING
  eval 'exec $interpreter $arg -S \$0 \${1+"\$\@"}'
      if 0; # not running under some shell
  } unless$Is{Win32}}else {warn "Can't find $cmd in PATH, $file unchanged" if$Verbose;return}return$shb}sub force {my($self)=shift;'# Phony target to force checking subdirectories.
  FORCE :
  	$(NOECHO) $(NOOP)
  '}sub guess_name {my($self)=@_;use Cwd 'cwd';my$name=basename(cwd());$name =~ s|[\-_][\d\.\-]+\z||;print "Warning: Guessing NAME [$name] from current directory name.\n";$name}sub has_link_code {my($self)=shift;return$self->{HAS_LINK_CODE}if defined$self->{HAS_LINK_CODE};if ($self->{OBJECT}or @{$self->{C}|| []}or $self->{MYEXTLIB}){$self->{HAS_LINK_CODE}=1;return 1}return$self->{HAS_LINK_CODE}=0}sub init_dirscan {my($self)=@_;my(%dir,%xs,%c,%h,%pl_files,%pm);my%ignore=map {($_=>1)}qw(Makefile.PL Build.PL test.pl t);$Is{VMS}? $ignore{"$self->{DISTVNAME}.dir"}=1 : $ignore{$self->{DISTVNAME}}=1;@ignore{map lc,keys%ignore}=values%ignore if$Is{VMS};for my$name ($self->lsdir($Curdir)){next if$name =~ /\#/;$name=lc($name)if$Is{VMS};next if$name eq $Curdir or $name eq $Updir or $ignore{$name};next unless$self->libscan($name);if (-d $name){next if -l $name;next if$self->{NORECURS};$dir{$name}=$name if (-f $self->catfile($name,"Makefile.PL"))}elsif ($name =~ /\.xs\z/){my($c);($c=$name)=~ s/\.xs\z/.c/;$xs{$name}=$c;$c{$c}=1}elsif ($name =~ /\.c(pp|xx|c)?\z/i){$c{$name}=1 unless$name =~ m/perlmain\.c/}elsif ($name =~ /\.h\z/i){$h{$name}=1}elsif ($name =~ /\.PL\z/){($pl_files{$name}=$name)=~ s/\.PL\z// }elsif (($Is{VMS}|| $Is{Dos})&& $name =~ /[._]pl$/i){local($/);open(my$pl,'<',$name);my$txt=<$pl>;close$pl;if ($txt =~ /Extracting \S+ \(with variable substitutions/){($pl_files{$name}=$name)=~ s/[._]pl\z//i }else {$pm{$name}=$self->catfile($self->{INST_LIBDIR},$name)}}elsif ($name =~ /\.(p[ml]|pod)\z/){$pm{$name}=$self->catfile($self->{INST_LIBDIR},$name)}}$self->{PL_FILES}||= \%pl_files;$self->{DIR}||= [sort keys%dir];$self->{XS}||= \%xs;$self->{C}||= [sort keys%c];$self->{H}||= [sort keys%h];$self->{PM}||= \%pm;my@o_files=@{$self->{C}};$self->{O_FILES}=[grep s/\.c(pp|xx|c)?\z/$self->{OBJ_EXT}/i,@o_files]}sub init_MANPODS {my$self=shift;for my$man (qw(MAN1 MAN3)){if ($self->{"${man}PODS"}or $self->{"INSTALL${man}DIR"}=~ /^(none|\s*)$/){$self->{"${man}PODS"}||= {}}else {my$init_method="init_${man}PODS";$self->$init_method()}}}sub _has_pod {my($self,$file)=@_;my($ispod)=0;if (open(my$fh,'<',$file)){while (<$fh>){if (/^=(?:head\d+|item|pod)\b/){$ispod=1;last}}close$fh}else {$ispod=1}return$ispod}sub init_MAN1PODS {my($self)=@_;if (exists$self->{EXE_FILES}){for my$name (@{$self->{EXE_FILES}}){next unless$self->_has_pod($name);$self->{MAN1PODS}->{$name}=$self->catfile("\$(INST_MAN1DIR)",basename($name).".\$(MAN1EXT)")}}}sub init_MAN3PODS {my$self=shift;my%manifypods=();for my$name (keys %{$self->{PM}}){if ($name =~ /\.pod\z/){$manifypods{$name}=$self->{PM}{$name}}elsif ($name =~ /\.p[ml]\z/){if($self->_has_pod($name)){$manifypods{$name}=$self->{PM}{$name}}}}my$parentlibs_re=join '|',@{$self->{PMLIBPARENTDIRS}};for my$name (keys%manifypods){if ($self->{PERL_CORE}and $name =~ /(config|setup).*\.pm/is){delete$manifypods{$name};next}my($manpagename)=$name;$manpagename =~ s/\.p(od|m|l)\z//;unless($manpagename =~ s!^\W*($parentlibs_re)\W+!!s){$manpagename=$self->catfile(split(/::/,$self->{PARENT_NAME}),$manpagename)}$manpagename=$self->replace_manpage_separator($manpagename);$self->{MAN3PODS}->{$name}=$self->catfile("\$(INST_MAN3DIR)","$manpagename.\$(MAN3EXT)")}}sub init_PM {my$self=shift;unless($self->{PMLIBDIRS}){if($Is{VMS}){$self->{PMLIBDIRS}=['./lib',"./$self->{BASEEXT}"]}else {$self->{PMLIBDIRS}=['lib',$self->{BASEEXT}]}}my (@pmlibdirs)=@{$self->{PMLIBDIRS}};@{$self->{PMLIBDIRS}}=();my%dir=map {($_=>$_)}@{$self->{DIR}};for my$pmlibdir (@pmlibdirs){-d $pmlibdir &&!$dir{$pmlibdir}&& push @{$self->{PMLIBDIRS}},$pmlibdir}unless($self->{PMLIBPARENTDIRS}){@{$self->{PMLIBPARENTDIRS}}=('lib')}return if$self->{PM}and $self->{ARGS}{PM};if (@{$self->{PMLIBDIRS}}){print "Searching PMLIBDIRS: @{$self->{PMLIBDIRS}}\n" if ($Verbose >= 2);require File::Find;File::Find::find(sub {if (-d $_){unless ($self->libscan($_)){$File::Find::prune=1}return}return if /\#/;return if /~$/;return if /,v$/;return if m{\.swp$};my$path=$File::Find::name;my$prefix=$self->{INST_LIBDIR};my$striplibpath;my$parentlibs_re=join '|',@{$self->{PMLIBPARENTDIRS}};$prefix=$self->{INST_LIB}if ($striplibpath=$path)=~ s{^(\W*)($parentlibs_re)\W}
  	                                       {$1}i;my($inst)=$self->catfile($prefix,$striplibpath);local($_)=$inst;$inst=$self->libscan($inst);print "libscan($path) => '$inst'\n" if ($Verbose >= 2);return unless$inst;$self->{PM}{$path}=$inst},@{$self->{PMLIBDIRS}})}}sub init_DIRFILESEP {my($self)=shift;$self->{DIRFILESEP}='/'}sub init_main {my($self)=@_;$self->{FULLEXT}=$self->catdir(split /::/,$self->{NAME});my(@modparts)=split(/::/,$self->{NAME});my($modfname)=$modparts[-1];if (defined&DynaLoader::mod2fname){$modfname=&DynaLoader::mod2fname(\@modparts)}($self->{PARENT_NAME},$self->{BASEEXT})=$self->{NAME}=~ m!(?:([\w:]+)::)?(\w+)\z! ;$self->{PARENT_NAME}||= '';if (defined&DynaLoader::mod2fname){$self->{DLBASE}=$modfname}else {$self->{DLBASE}='$(BASEEXT)'}my$inc_config_dir=dirname($INC{'Config.pm'});my$inc_carp_dir=dirname($INC{'Carp.pm'});unless ($self->{PERL_SRC}){for my$dir_count (1..8){my$dir=$self->catdir(($Updir)x $dir_count);if (-f $self->catfile($dir,"config_h.SH")&& -f $self->catfile($dir,"perl.h")&& -f $self->catfile($dir,"lib","strict.pm")){$self->{PERL_SRC}=$dir ;last}}}warn "PERL_CORE is set but I can't find your PERL_SRC!\n" if $self->{PERL_CORE}and!$self->{PERL_SRC};if ($self->{PERL_SRC}){$self->{PERL_LIB}||= $self->catdir("$self->{PERL_SRC}","lib");if (defined$Cross::platform){$self->{PERL_ARCHLIB}=$self->catdir("$self->{PERL_SRC}","xlib",$Cross::platform);$self->{PERL_INC}=$self->catdir("$self->{PERL_SRC}","xlib",$Cross::platform,$Is{Win32}?("CORE"):())}else {$self->{PERL_ARCHLIB}=$self->{PERL_LIB};$self->{PERL_INC}=($Is{Win32})? $self->catdir($self->{PERL_LIB},"CORE"): $self->{PERL_SRC}}unless (-s $self->catfile($self->{PERL_SRC},'cflags')or $Is{VMS}&& -s $self->catfile($self->{PERL_SRC},'vmsish.h')or $Is{Win32}){warn qq{
  You cannot build extensions below the perl source tree after executing
  a 'make clean' in the perl source tree.
  
  To rebuild extensions distributed with the perl source you should
  simply Configure (to include those extensions) and then build perl as
  normal. After installing perl the source tree can be deleted. It is
  not needed for building extensions by running 'perl Makefile.PL'
  usually without extra arguments.
  
  It is recommended that you unpack and build additional extensions away
  from the perl source tree.
  }}}else {my$old=$self->{PERL_LIB}|| $self->{PERL_ARCHLIB}|| $self->{PERL_INC};$self->{PERL_LIB}||= $Config{privlibexp};$self->{PERL_ARCHLIB}||= $Config{archlibexp};$self->{PERL_INC}=$self->catdir("$self->{PERL_ARCHLIB}","CORE");my$perl_h;if (not -f ($perl_h=$self->catfile($self->{PERL_INC},"perl.h"))and not $old){my$lib;for my$dir (@INC){$lib=$dir,last if -e $self->catfile($dir,"Config.pm")}if ($lib){my$inc=$Is{Win32}? $self->catdir($lib,"CORE"): dirname$lib;if (-e $self->catfile($inc,"perl.h")){$self->{PERL_LIB}=$lib;$self->{PERL_ARCHLIB}=$lib;$self->{PERL_INC}=$inc;$self->{UNINSTALLED_PERL}=1;print <<EOP}}}}$self->{INSTALLDIRS}||= "site";$self->{MAN1EXT}||= $Config{man1ext};$self->{MAN3EXT}||= $Config{man3ext};print "CONFIG must be an array ref\n" if ($self->{CONFIG}and ref$self->{CONFIG}ne 'ARRAY');$self->{CONFIG}=[]unless (ref$self->{CONFIG});push(@{$self->{CONFIG}},@ExtUtils::MakeMaker::Get_from_Config);push(@{$self->{CONFIG}},'shellflags')if$Config{shellflags};my(%once_only);for my$m (@{$self->{CONFIG}}){next if$once_only{$m};print "CONFIG key '$m' does not exist in Config.pm\n" unless exists$Config{$m};$self->{uc$m}||= $Config{$m};$once_only{$m}=1}$self->{AR_STATIC_ARGS}||= "cr";$self->{OBJ_EXT}||= '.o';$self->{LIB_EXT}||= '.a';$self->{MAP_TARGET}||= "perl";$self->{LIBPERL_A}||= "libperl$self->{LIB_EXT}";warn "Warning: PERL_LIB ($self->{PERL_LIB}) seems not to be a perl library directory
  ... Detected uninstalled Perl.  Trying to continue.
  EOP
          (strict.pm not found)" unless -f $self->catfile("$self->{PERL_LIB}","strict.pm")|| $self->{NAME}eq "ExtUtils::MakeMaker"}sub init_tools {my$self=shift;$self->{ECHO}||= 'echo';$self->{ECHO_N}||= 'echo -n';$self->{RM_F}||= "rm -f";$self->{RM_RF}||= "rm -rf";$self->{TOUCH}||= "touch";$self->{TEST_F}||= "test -f";$self->{CP}||= "cp";$self->{MV}||= "mv";$self->{CHMOD}||= "chmod";$self->{FALSE}||= 'false';$self->{TRUE}||= 'true';$self->{LD}||= 'ld';return$self->SUPER::init_tools(@_);$self->{SHELL}||= '/bin/sh';return}sub init_linker {my($self)=shift;$self->{PERL_ARCHIVE}||= '';$self->{PERL_ARCHIVE_AFTER}||= '';$self->{EXPORT_LIST}||= ''}sub init_lib2arch {my($self)=shift;for my$libpair ({l=>"privlib",a=>"archlib"},{l=>"sitelib",a=>"sitearch"},{l=>"vendorlib",a=>"vendorarch"},){my$lib="install$libpair->{l}";my$Lib=uc$lib;my$Arch=uc "install$libpair->{a}";if($self->{$Lib}&&!$self->{$Arch}){my($ilib)=$Config{$lib};$self->prefixify($Arch,$ilib,$self->{$Lib});unless (-d $self->{$Arch}){print "Directory $self->{$Arch} not found\n" if$Verbose;$self->{$Arch}=$self->{$Lib}}print "Defaulting $Arch to $self->{$Arch}\n" if$Verbose}}}sub init_PERL {my($self)=shift;my@defpath=();for my$component ($self->{PERL_SRC},$self->path(),$Config{binexp}){push@defpath,$component if defined$component}my$thisperl=$self->canonpath($^X);$thisperl .= $Config{exe_ext}unless $Is{VMS}? $thisperl =~ m/$Config{exe_ext}(;\d+)?$/i : $thisperl =~ m/$Config{exe_ext}$/i;$thisperl=$self->abs2rel($thisperl)if$self->{PERL_CORE};my@perls=($thisperl);push@perls,map {"$_$Config{exe_ext}"}('perl','perl5',"perl$Config{version}");my$miniperl="miniperl$Config{exe_ext}";if($self->{PERL_CORE}){splice@perls,1,0,$miniperl}else {push@perls,$miniperl}$self->{PERL}||= $self->find_perl(5.0,\@perls,\@defpath,$Verbose);my$perl_name='perl';$perl_name='ndbgperl' if$Is{VMS}&& defined$Config{usevmsdebug}&& $Config{usevmsdebug}eq 'define';($self->{FULLPERL}=$self->{PERL})=~ s/miniperl/$perl_name/i unless$self->{FULLPERL};$self->{ABSPERL}=$self->{PERL};my$has_mcr=$self->{ABSPERL}=~ s/^MCR\s*//;if($self->file_name_is_absolute($self->{ABSPERL})){$self->{ABSPERL}='$(PERL)'}else {$self->{ABSPERL}=$self->rel2abs($self->{ABSPERL});$self->{ABSPERL}=$self->quote_literal($self->{ABSPERL})if$self->{ABSPERL}=~ /\s/;$self->{ABSPERL}='MCR '.$self->{ABSPERL}if$has_mcr}$self->{PERL_CORE}=$ENV{PERL_CORE}unless exists$self->{PERL_CORE};$self->{PERL_CORE}=0 unless defined$self->{PERL_CORE};for my$perl (qw(PERL FULLPERL ABSPERL)){my$run=$perl.'RUN';$self->{$run}="\$($perl)";$self->{$run}.= q{ "-I$(PERL_LIB)" "-I$(PERL_ARCHLIB)"} if$self->{UNINSTALLED_PERL}|| $self->{PERL_CORE};$self->{$perl.'RUNINST'}=sprintf q{$(%sRUN) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)"},$perl}return 1}sub init_platform {my($self)=shift;$self->{MM_Unix_VERSION}=$VERSION;$self->{PERL_MALLOC_DEF}='-DPERL_EXTMALLOC_DEF -Dmalloc=Perl_malloc '.'-Dfree=Perl_mfree -Drealloc=Perl_realloc '.'-Dcalloc=Perl_calloc'}sub platform_constants {my($self)=shift;my$make_frag='';for my$macro (qw(MM_Unix_VERSION PERL_MALLOC_DEF)){next unless defined$self->{$macro};$make_frag .= "$macro = $self->{$macro}\n"}return$make_frag}sub init_PERM {my($self)=shift;$self->{PERM_DIR}=755 unless defined$self->{PERM_DIR};$self->{PERM_RW}=644 unless defined$self->{PERM_RW};$self->{PERM_RWX}=755 unless defined$self->{PERM_RWX};return 1}sub init_xs {my$self=shift;if ($self->has_link_code()){$self->{INST_STATIC}=$self->catfile('$(INST_ARCHAUTODIR)','$(BASEEXT)$(LIB_EXT)');$self->{INST_DYNAMIC}=$self->catfile('$(INST_ARCHAUTODIR)','$(DLBASE).$(DLEXT)');$self->{INST_BOOT}=$self->catfile('$(INST_ARCHAUTODIR)','$(BASEEXT).bs')}else {$self->{INST_STATIC}='';$self->{INST_DYNAMIC}='';$self->{INST_BOOT}=''}}sub install {my($self,%attribs)=@_;my(@m);push@m,q{
  install :: pure_install doc_install
  	$(NOECHO) $(NOOP)
  
  install_perl :: pure_perl_install doc_perl_install
  	$(NOECHO) $(NOOP)
  
  install_site :: pure_site_install doc_site_install
  	$(NOECHO) $(NOOP)
  
  install_vendor :: pure_vendor_install doc_vendor_install
  	$(NOECHO) $(NOOP)
  
  pure_install :: pure_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  doc_install :: doc_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  pure__install : pure_site_install
  	$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
  
  doc__install : doc_site_install
  	$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
  
  pure_perl_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  		read }.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{ \
  		write }.$self->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').q{ \
  		$(INST_LIB) $(DESTINSTALLPRIVLIB) \
  		$(INST_ARCHLIB) $(DESTINSTALLARCHLIB) \
  		$(INST_BIN) $(DESTINSTALLBIN) \
  		$(INST_SCRIPT) $(DESTINSTALLSCRIPT) \
  		$(INST_MAN1DIR) $(DESTINSTALLMAN1DIR) \
  		$(INST_MAN3DIR) $(DESTINSTALLMAN3DIR)
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) \
  		}.$self->catdir('$(SITEARCHEXP)','auto','$(FULLEXT)').q{
  
  
  pure_site_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  		read }.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{ \
  		write }.$self->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').q{ \
  		$(INST_LIB) $(DESTINSTALLSITELIB) \
  		$(INST_ARCHLIB) $(DESTINSTALLSITEARCH) \
  		$(INST_BIN) $(DESTINSTALLSITEBIN) \
  		$(INST_SCRIPT) $(DESTINSTALLSITESCRIPT) \
  		$(INST_MAN1DIR) $(DESTINSTALLSITEMAN1DIR) \
  		$(INST_MAN3DIR) $(DESTINSTALLSITEMAN3DIR)
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) \
  		}.$self->catdir('$(PERL_ARCHLIB)','auto','$(FULLEXT)').q{
  
  pure_vendor_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  		read }.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{ \
  		write }.$self->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').q{ \
  		$(INST_LIB) $(DESTINSTALLVENDORLIB) \
  		$(INST_ARCHLIB) $(DESTINSTALLVENDORARCH) \
  		$(INST_BIN) $(DESTINSTALLVENDORBIN) \
  		$(INST_SCRIPT) $(DESTINSTALLVENDORSCRIPT) \
  		$(INST_MAN1DIR) $(DESTINSTALLVENDORMAN1DIR) \
  		$(INST_MAN3DIR) $(DESTINSTALLVENDORMAN3DIR)
  
  doc_perl_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to $(DESTINSTALLARCHLIB)/perllocal.pod
  	-$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" "$(INSTALLPRIVLIB)" \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> }.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{
  
  doc_site_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to $(DESTINSTALLARCHLIB)/perllocal.pod
  	-$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" "$(INSTALLSITELIB)" \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> }.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{
  
  doc_vendor_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to $(DESTINSTALLARCHLIB)/perllocal.pod
  	-$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" "$(INSTALLVENDORLIB)" \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> }.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{
  
  };push@m,q{
  uninstall :: uninstall_from_$(INSTALLDIRS)dirs
  	$(NOECHO) $(NOOP)
  
  uninstall_from_perldirs ::
  	$(NOECHO) $(UNINSTALL) }.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{
  
  uninstall_from_sitedirs ::
  	$(NOECHO) $(UNINSTALL) }.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{
  
  uninstall_from_vendordirs ::
  	$(NOECHO) $(UNINSTALL) }.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{
  };join("",@m)}sub installbin {my($self)=shift;return "" unless$self->{EXE_FILES}&& ref$self->{EXE_FILES}eq "ARRAY";my@exefiles=@{$self->{EXE_FILES}};return "" unless@exefiles;@exefiles=map vmsify($_),@exefiles if$Is{VMS};my%fromto;for my$from (@exefiles){my($path)=$self->catfile('$(INST_SCRIPT)',basename($from));local($_)=$path;my$to=$self->libscan($path);print "libscan($from) => '$to'\n" if ($Verbose >=2);$to=vmsify($to)if$Is{VMS};$fromto{$from}=$to}my@to=values%fromto;my@m;push(@m,qq{
  EXE_FILES = @exefiles
  
  pure_all :: @to
  	\$(NOECHO) \$(NOOP)
  
  realclean ::
  });push@m,map "\t$_\n",$self->split_command('$(RM_F)',@to);push@m,"\n";while (my($from,$to)=each%fromto){last unless defined$from;push@m,sprintf <<'MAKE',$to,$from,$to,$from,$to,$to,$to}join "",@m}sub linkext {my($self,%attribs)=@_;my($linktype)=defined$attribs{LINKTYPE}? $attribs{LINKTYPE}: '$(LINKTYPE)';"
  %s : %s $(FIRST_MAKEFILE) $(INST_SCRIPT)$(DFSEP).exists $(INST_BIN)$(DFSEP).exists
  	$(NOECHO) $(RM_F) %s
  	$(CP) %s %s
  	$(FIXIN) %s
  	-$(NOECHO) $(CHMOD) $(PERM_RWX) %s
  
  MAKE
  linkext :: $linktype
  	\$(NOECHO) \$(NOOP)
  "}sub lsdir {my($self)=shift;my($dir,$regex)=@_;my(@ls);my$dh=new DirHandle;$dh->open($dir || ".")or return ();@ls=$dh->read;$dh->close;@ls=grep(/$regex/,@ls)if$regex;@ls}sub macro {my($self,%attribs)=@_;my(@m,$key,$val);while (($key,$val)=each%attribs){last unless defined$key;push@m,"$key = $val\n"}join "",@m}sub makeaperl {my($self,%attribs)=@_;my($makefilename,$searchdirs,$static,$extra,$perlinc,$target,$tmp,$libperl)=@attribs{qw(MAKE DIRS STAT EXTRA INCL TARGET TMP LIBPERL)};my(@m);push@m,"
  # --- MakeMaker makeaperl section ---
  MAP_TARGET    = $target
  FULLPERL      = $self->{FULLPERL}
  ";return join '',@m if$self->{PARENT};my($dir)=join ":",@{$self->{DIR}};unless ($self->{MAKEAPERL}){push@m,q{
  $(MAP_TARGET) :: static $(MAKE_APERL_FILE)
  	$(MAKE) $(USEMAKEFILE) $(MAKE_APERL_FILE) $@
  
  $(MAKE_APERL_FILE) : $(FIRST_MAKEFILE) pm_to_blib
  	$(NOECHO) $(ECHO) Writing \"$(MAKE_APERL_FILE)\" for this $(MAP_TARGET)
  	$(NOECHO) $(PERLRUNINST) \
  		Makefile.PL DIR=},$dir,q{ \
  		MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \
  		MAKEAPERL=1 NORECURS=1 CCCDLFLAGS=};for (@ARGV){if(/\s/){s/=(.*)/='$1'/}push@m," \\\n\t\t$_"}push@m,"\n";return join '',@m}my($cccmd,$linkcmd,$lperl);$cccmd=$self->const_cccmd($libperl);$cccmd =~ s/^CCCMD\s*=\s*//;$cccmd =~ s/\$\(INC\)/ "-I$self->{PERL_INC}" /;$cccmd .= " $Config{cccdlflags}" if ($Config{useshrplib}eq 'true');$cccmd =~ s/\(CC\)/\(PERLMAINCC\)/;$linkcmd=join ' ',"\$(CC)",grep($_,@Config{qw(ldflags ccdlflags)});$linkcmd =~ s/\s+/ /g;$linkcmd =~ s,(perl\.exp),\$(PERL_INC)/$1,;my%static;require File::Find;File::Find::find(sub {return unless m/\Q$self->{LIB_EXT}\E$/;return if m/^libperl/ or m/^perl\Q$self->{LIB_EXT}\E$/;return if m/_pure_\w+_\w+_\w+\.\w+$/ and -f "$File::Find::dir/.pure";if(exists$self->{INCLUDE_EXT}){my$found=0;(my$xx=$File::Find::name)=~ s,.*?/auto/,,s;$xx =~ s,/?$_,,;$xx =~ s,/,::,g;for my$incl ((@{$self->{INCLUDE_EXT}},'DynaLoader')){if($xx eq $incl){$found++;last}}return unless$found}elsif(exists$self->{EXCLUDE_EXT}){(my$xx=$File::Find::name)=~ s,.*?/auto/,,s;$xx =~ s,/?$_,,;$xx =~ s,/,::,g;for my$excl (@{$self->{EXCLUDE_EXT}}){return if($xx eq $excl)}}return if$File::Find::name =~ m:auto/$self->{FULLEXT}/$self->{BASEEXT}$self->{LIB_EXT}\z:;use Cwd 'cwd';$static{cwd()."/" .$_}++},grep(-d $_,@{$searchdirs || []}));$static=[]unless$static;@static{@{$static}}=(1)x @{$static};$extra=[]unless$extra && ref$extra eq 'ARRAY';for (sort keys%static){next unless /\Q$self->{LIB_EXT}\E\z/;$_=dirname($_)."/extralibs.ld";push @$extra,$_}s/^(.*)/"-I$1"/ for @{$perlinc || []};$target ||= "perl";$tmp ||= ".";push@m,"
  MAP_LINKCMD   = $linkcmd
  MAP_PERLINC   = @{$perlinc || []}
  MAP_STATIC    = ",join(" \\\n\t",reverse sort keys%static),"
  
  MAP_PRELIBS   = $Config{perllibs} $Config{cryptlib}
  ";if (defined$libperl){($lperl=$libperl)=~ s/\$\(A\)/$self->{LIB_EXT}/}unless ($libperl && -f $lperl){my$dir=$self->{PERL_SRC}|| "$self->{PERL_ARCHLIB}/CORE";$dir="$self->{PERL_ARCHLIB}/.." if$self->{UNINSTALLED_PERL};$libperl ||= "libperl$self->{LIB_EXT}";$libperl="$dir/$libperl";$lperl ||= "libperl$self->{LIB_EXT}";$lperl="$dir/$lperl";if (!-f $libperl and!-f $lperl){if ($Is{SunOS}){$lperl=$libperl="$dir/$Config{libperl}";$libperl='' if$Is{SunOS4}}}print "Warning: $libperl not found
      If you're going to build a static perl binary, make sure perl is installed
      otherwise ignore this warning\n" unless (-f $lperl || defined($self->{PERL_SRC}))}my$llibperl=$libperl ? '$(MAP_LIBPERL)' : '-lperl';push@m,"
  MAP_LIBPERL = $libperl
  LLIBPERL    = $llibperl
  ";push@m,'
  $(INST_ARCHAUTODIR)/extralibs.all : $(INST_ARCHAUTODIR)$(DFSEP).exists '.join(" \\\n\t",@$extra).'
  	$(NOECHO) $(RM_F)  $@
  	$(NOECHO) $(TOUCH) $@
  ';for my$catfile (@$extra){push@m,"\tcat $catfile >> \$\@\n"}push@m,"
  \$(MAP_TARGET) :: $tmp/perlmain\$(OBJ_EXT) \$(MAP_LIBPERL) \$(MAP_STATIC) \$(INST_ARCHAUTODIR)/extralibs.all
  	\$(MAP_LINKCMD) -o \$\@ \$(OPTIMIZE) $tmp/perlmain\$(OBJ_EXT) \$(LDFROM) \$(MAP_STATIC) \$(LLIBPERL) `cat \$(INST_ARCHAUTODIR)/extralibs.all` \$(MAP_PRELIBS)
  	\$(NOECHO) \$(ECHO) 'To install the new \"\$(MAP_TARGET)\" binary, call'
  	\$(NOECHO) \$(ECHO) '    \$(MAKE) \$(USEMAKEFILE) $makefilename inst_perl MAP_TARGET=\$(MAP_TARGET)'
  	\$(NOECHO) \$(ECHO) 'To remove the intermediate files say'
  	\$(NOECHO) \$(ECHO) '    \$(MAKE) \$(USEMAKEFILE) $makefilename map_clean'
  
  $tmp/perlmain\$(OBJ_EXT): $tmp/perlmain.c
  ";push@m,"\t".$self->cd($tmp,qq[$cccmd "-I\$(PERL_INC)" perlmain.c])."\n";push@m,qq{
  $tmp/perlmain.c: $makefilename},q{
  	$(NOECHO) $(ECHO) Writing $@
  	$(NOECHO) $(PERL) $(MAP_PERLINC) "-MExtUtils::Miniperl" \\
  		-e "writemain(grep s#.*/auto/##s, split(q| |, q|$(MAP_STATIC)|))" > $@t && $(MV) $@t $@
  
  };push@m,"\t",q{$(NOECHO) $(PERL) $(INSTALLSCRIPT)/fixpmain
  } if (defined (&Dos::UseLFN)&& Dos::UseLFN()==0);push@m,q{
  doc_inst_perl :
  	$(NOECHO) $(ECHO) Appending installation info to $(DESTINSTALLARCHLIB)/perllocal.pod
  	-$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Perl binary" "$(MAP_TARGET)" \
  		MAP_STATIC "$(MAP_STATIC)" \
  		MAP_EXTRA "`cat $(INST_ARCHAUTODIR)/extralibs.all`" \
  		MAP_LIBPERL "$(MAP_LIBPERL)" \
  		>> }.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{
  
  };push@m,q{
  inst_perl : pure_inst_perl doc_inst_perl
  
  pure_inst_perl : $(MAP_TARGET)
  	}.$self->{CP}.q{ $(MAP_TARGET) }.$self->catfile('$(DESTINSTALLBIN)','$(MAP_TARGET)').q{
  
  clean :: map_clean
  
  map_clean :
  	}.$self->{RM_F}.qq{ $tmp/perlmain\$(OBJ_EXT) $tmp/perlmain.c \$(MAP_TARGET) $makefilename \$(INST_ARCHAUTODIR)/extralibs.all
  };join '',@m}sub makefile {my($self)=shift;my$m;$m='
  $(OBJECT) : $(FIRST_MAKEFILE)
  
  ' if$self->{OBJECT};my$newer_than_target=$Is{VMS}? '$(MMS$SOURCE_LIST)' : '$?';my$mpl_args=join " ",map qq["$_"],@ARGV;$m .= sprintf <<'MAKE_FRAG',$newer_than_target,$mpl_args;return$m}sub maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d $file;return}sub needs_linking {my($self)=shift;my$caller=(caller(0))[3];confess("needs_linking called too early")if $caller =~ /^ExtUtils::MakeMaker::/;return$self->{NEEDS_LINKING}if defined$self->{NEEDS_LINKING};if ($self->has_link_code or $self->{MAKEAPERL}){$self->{NEEDS_LINKING}=1;return 1}for my$child (keys %{$self->{CHILDREN}}){if ($self->{CHILDREN}->{$child}->needs_linking){$self->{NEEDS_LINKING}=1;return 1}}return$self->{NEEDS_LINKING}=0}sub parse_abstract {my($self,$parsefile)=@_;my$result;local $/="\n";open(my$fh,'<',$parsefile)or die "Could not open '$parsefile': $!";my$inpod=0;my$package=$self->{DISTNAME};$package =~ s/-/::/g;while (<$fh>){$inpod=/^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;next if!$inpod;chop;next unless /^($package(?:\.pm)? \s+ -+ \s+)(.*)/x;$result=$2;last}close$fh;return$result}sub parse_version {my($self,$parsefile)=@_;my$result;local $/="\n";local $_;open(my$fh,'<',$parsefile)or die "Could not open '$parsefile': $!";my$inpod=0;while (<$fh>){$inpod=/^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;next if$inpod || /^\s*#/;chop;next if /^\s*(if|unless|elsif)/;if (m{^ \s* package \s+ \w[\w\:\']* \s+ (v?[0-9._]+) \s* ;  }x){local $^W=0;$result=$1}elsif (m{(?<!\\) ([\$*]) (([\w\:\']*) \bVERSION)\b .* =}x){my$eval=qq{
  # We take a very conservative approach here, but it's worth it.
  # We move Makefile to Makefile.old here to avoid gnu make looping.
  $(FIRST_MAKEFILE) : Makefile.PL $(CONFIGDEP)
  	$(NOECHO) $(ECHO) "Makefile out-of-date with respect to %s"
  	$(NOECHO) $(ECHO) "Cleaning current config before rebuilding Makefile..."
  	-$(NOECHO) $(RM_F) $(MAKEFILE_OLD)
  	-$(NOECHO) $(MV)   $(FIRST_MAKEFILE) $(MAKEFILE_OLD)
  	- $(MAKE) $(USEMAKEFILE) $(MAKEFILE_OLD) clean $(DEV_NULL)
  	$(PERLRUN) Makefile.PL %s
  	$(NOECHO) $(ECHO) "==> Your Makefile has been rebuilt. <=="
  	$(NOECHO) $(ECHO) "==> Please rerun the $(MAKE) command.  <=="
  	$(FALSE)
  
  MAKE_FRAG
                  package ExtUtils::MakeMaker::_version;
                  no strict;
                  BEGIN { eval {
                      # Ensure any version() routine which might have leaked
                      # into this package has been deleted.  Interferes with
                      # version->import()
                      undef *version;
                      require version;
                      "version"->import;
                  } }
  
                  local $1$2;
                  \$$2=undef;
                  do {
                      $_
                  };
                  \$$2;
              };local $^W=0;$result=eval($eval);warn "Could not eval '$eval' in $parsefile: $@" if $@}else {next}last if defined$result}close$fh;$result="undef" unless defined$result;return$result}sub pasthru {my($self)=shift;my(@m);my(@pasthru);my($sep)=$Is{VMS}? ',' : '';$sep .= "\\\n\t";for my$key (qw(LIB LIBPERL_A LINKTYPE OPTIMIZE PREFIX INSTALL_BASE)){next unless defined$self->{$key};push@pasthru,"$key=\"\$($key)\""}for my$key (qw(DEFINE INC)){next unless defined$self->{$key};push@pasthru,"PASTHRU_$key=\"\$(PASTHRU_$key)\""}push@m,"\nPASTHRU = ",join ($sep,@pasthru),"\n";join "",@m}sub perl_script {my($self,$file)=@_;return$file if -r $file && -f _;return}sub perldepend {my($self)=shift;my(@m);my$make_config=$self->cd('$(PERL_SRC)','$(MAKE) lib/Config.pm');push@m,sprintf <<'MAKE_FRAG',$make_config if$self->{PERL_SRC};return join "",@m unless$self->needs_linking;if ($self->{OBJECT}){push@m,$self->_perl_header_files_fragment("/")}push@m,join(" ",values %{$self->{XS}})." : \$(XSUBPPDEPS)\n" if %{$self->{XS}};return join "\n",@m}sub pm_to_blib {my$self=shift;my($autodir)=$self->catdir('$(INST_LIB)','auto');my$r=q{
  # Check for unpropogated config.sh changes. Should never happen.
  # We do NOT just update config.h because that is not sufficient.
  # An out of date config.h is not fatal but complains loudly!
  $(PERL_INC)/config.h: $(PERL_SRC)/config.sh
  	-$(NOECHO) $(ECHO) "Warning: $(PERL_INC)/config.h out of date with $(PERL_SRC)/config.sh"; $(FALSE)
  
  $(PERL_ARCHLIB)/Config.pm: $(PERL_SRC)/config.sh
  	$(NOECHO) $(ECHO) "Warning: $(PERL_ARCHLIB)/Config.pm may be out of date with $(PERL_SRC)/config.sh"
  	%s
  MAKE_FRAG
  pm_to_blib : $(FIRST_MAKEFILE) $(TO_INST_PM)
  };my$pm_to_blib=$self->oneliner(<<CODE,['-MExtUtils::Install']);my@cmds=$self->split_command($pm_to_blib,%{$self->{PM}});$r .= join '',map {"\t\$(NOECHO) $_\n"}@cmds;$r .= qq{\t\$(NOECHO) \$(TOUCH) pm_to_blib\n};return$r}sub post_constants{""}sub post_initialize {""}sub postamble {""}sub _ppd_version {my ($self,$string)=@_;return join ',',((split /\./,$string),(0)x 4)[0..3]}sub ppd {my($self)=@_;my$abstract=$self->{ABSTRACT}|| '';$abstract =~ s/\n/\\n/sg;$abstract =~ s/</&lt;/g;$abstract =~ s/>/&gt;/g;my$author=join(', ',@{$self->{AUTHOR}|| []});$author =~ s/</&lt;/g;$author =~ s/>/&gt;/g;my$ppd_file='$(DISTNAME).ppd';my@ppd_cmds=$self->echo(<<'PPD_HTML',$ppd_file,{append=>0,allow_variables=>1 });my$ppd_xml=sprintf <<'PPD_HTML',$abstract,$author;$ppd_xml .= "    <IMPLEMENTATION>\n";if ($self->{MIN_PERL_VERSION}){my$min_perl_version=$self->_ppd_version($self->{MIN_PERL_VERSION});$ppd_xml .= sprintf <<'PPD_PERLVERS',$min_perl_version}my%prereqs=%{$self->{PREREQ_PM}};delete$prereqs{perl};for my$prereq (sort keys%prereqs){my$name=$prereq;$name .= '::' unless$name =~ /::/;my$version=$prereqs{$prereq}+0;my%attrs=(NAME=>$name);$attrs{VERSION}=$version if$version;my$attrs=join " ",map {qq[$_="$attrs{$_}"]}keys%attrs;$ppd_xml .= qq(        <REQUIRE $attrs />\n)}my$archname=$Config{archname};if ($] >= 5.008){$archname .= "-$Config{PERL_REVISION}.$Config{PERL_VERSION}"}$ppd_xml .= sprintf <<'PPD_OUT',$archname;if ($self->{PPM_INSTALL_SCRIPT}){if ($self->{PPM_INSTALL_EXEC}){$ppd_xml .= sprintf qq{        <INSTALL EXEC="%s">%s</INSTALL>\n},$self->{PPM_INSTALL_EXEC},$self->{PPM_INSTALL_SCRIPT}}else {$ppd_xml .= sprintf qq{        <INSTALL>%s</INSTALL>\n},$self->{PPM_INSTALL_SCRIPT}}}my ($bin_location)=$self->{BINARY_LOCATION}|| '';$bin_location =~ s/\\/\\\\/g;$ppd_xml .= sprintf <<'PPD_XML',$bin_location;push@ppd_cmds,$self->echo($ppd_xml,$ppd_file,{append=>1 });return sprintf <<'PPD_OUT',join "\n\t",@ppd_cmds}sub prefixify {my($self,$var,$sprefix,$rprefix,$default)=@_;my$path=$self->{uc$var}|| $Config_Override{lc$var}|| $Config{lc$var}|| '';$rprefix .= '/' if$sprefix =~ m|/$|;warn "  prefixify $var => $path\n" if$Verbose >= 2;warn "    from $sprefix to $rprefix\n" if$Verbose >= 2;if($self->{ARGS}{PREFIX}&& $path !~ s{^\Q$sprefix\E\b}{$rprefix}s){warn "    cannot prefix, using default.\n" if$Verbose >= 2;warn "    no default!\n" if!$default && $Verbose >= 2;$path=$self->catdir($rprefix,$default)if$default}print "    now $path\n" if$Verbose >= 2;return$self->{uc$var}=$path}sub processPL {my$self=shift;my$pl_files=$self->{PL_FILES};return "" unless$pl_files;my$m='';for my$plfile (sort keys %$pl_files){my$list=ref($pl_files->{$plfile})? $pl_files->{$plfile}: [$pl_files->{$plfile}];for my$target (@$list){if($Is{VMS}){$plfile=vmsify($self->eliminate_macros($plfile));$target=vmsify($self->eliminate_macros($target))}my$pm_dep;my$perlrun;if(defined$self->{PM}{$target}){$pm_dep='';$perlrun='PERLRUN'}else {$pm_dep='pm_to_blib';$perlrun='PERLRUNINST'}$m .= <<MAKE_FRAG}}return$m}sub quote_paren {my$arg=shift;$arg =~ s{\$\((.+?)\)}{\$\\\\($1\\\\)}g;$arg =~ s{(?<!\\)([()])}{\\$1}g;$arg =~ s{\$\\\\\((.+?)\\\\\)}{\$($1)}g;return$arg}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s,/+,::,g;return$man}sub cd {my($self,$dir,@cmds)=@_;my$make_frag=join "\n\t",map {"cd $dir && $_"}@cmds;return$make_frag}sub oneliner {my($self,$cmd,$switches)=@_;$switches=[]unless defined$switches;$cmd =~ s{^\n+}{};$cmd =~ s{\n+$}{};my@cmds=split /\n/,$cmd;$cmd=join " \n\t  -e ",map$self->quote_literal($_),@cmds;$cmd=$self->escape_newlines($cmd);$switches=join ' ',@$switches;return qq{\$(ABSPERLRUN) $switches -e $cmd --}}sub quote_literal {my($self,$text,$opts)=@_;$opts->{allow_variables}=1 unless defined$opts->{allow_variables};$text =~ s{'}{'\\''}g;$text=$opts->{allow_variables}? $self->escape_dollarsigns($text): $self->escape_all_dollarsigns($text);return "'$text'"}sub escape_newlines {my($self,$text)=@_;$text =~ s{\n}{\\\n}g;return$text}sub max_exec_len {my$self=shift;if (!defined$self->{_MAX_EXEC_LEN}){if (my$arg_max=eval {require POSIX;&POSIX::ARG_MAX}){$self->{_MAX_EXEC_LEN}=$arg_max}else {$self->{_MAX_EXEC_LEN}=4096}}return$self->{_MAX_EXEC_LEN}}sub static {my($self)=shift;'
  pm_to_blib({\@ARGV}, '$autodir', q[\$(PM_FILTER)], '\$(PERM_DIR)')
  CODE
  <SOFTPKG NAME="$(DISTNAME)" VERSION="$(VERSION)">
  PPD_HTML
      <ABSTRACT>%s</ABSTRACT>
      <AUTHOR>%s</AUTHOR>
  PPD_HTML
          <PERLCORE VERSION="%s" />
  PPD_PERLVERS
          <ARCHITECTURE NAME="%s" />
  PPD_OUT
          <CODEBASE HREF="%s" />
      </IMPLEMENTATION>
  </SOFTPKG>
  PPD_XML
  # Creates a PPD (Perl Package Description) for a binary distribution.
  ppd :
  	%s
  PPD_OUT
  
  all :: $target
  	\$(NOECHO) \$(NOOP)
  
  $target :: $plfile $pm_dep
  	\$($perlrun) $plfile $target
  MAKE_FRAG
  ## $(INST_PM) has been moved to the all: target.
  ## It remains here for awhile to allow for old usage: "make static"
  static :: $(FIRST_MAKEFILE) $(INST_STATIC)
  	$(NOECHO) $(NOOP)
  '}sub static_lib {my($self)=@_;return '' unless$self->has_link_code;my(@m);push(@m,<<'END');push(@m,<<'MAKE_FRAG')if$self->{MYEXTLIB};my$ar;if (exists$self->{FULL_AR}&& -x $self->{FULL_AR}){$ar='FULL_AR'}else {$ar='AR'}push@m,sprintf <<'MAKE_FRAG',$ar;push@m,<<'MAKE_FRAG' if$self->{PERL_SRC}&& $self->{EXTRALIBS};join('',@m)}sub staticmake {my($self,%attribs)=@_;my(@static);my(@searchdirs)=($self->{PERL_ARCHLIB},$self->{SITEARCHEXP},$self->{INST_ARCHLIB});if (@{$self->{C}}){@static=$self->catfile($self->{INST_ARCHLIB},"auto",$self->{FULLEXT},"$self->{BASEEXT}$self->{LIB_EXT}")}my(@perlinc)=($self->{INST_ARCHLIB},$self->{INST_LIB},$self->{PERL_ARCHLIB},$self->{PERL_LIB});$self->makeaperl(MAKE=>$self->{MAKEFILE},DIRS=>\@searchdirs,STAT=>\@static,INCL=>\@perlinc,TARGET=>$self->{MAP_TARGET},TMP=>"",LIBPERL=>$self->{LIBPERL_A})}sub subdir_x {my($self,$subdir)=@_;my$subdir_cmd=$self->cd($subdir,'$(MAKE) $(USEMAKEFILE) $(FIRST_MAKEFILE) all $(PASTHRU)');return sprintf <<'EOT',$subdir_cmd}sub subdirs {my($self)=shift;my(@m);for my$dir (@{$self->{DIR}}){push(@m,$self->subdir_x($dir))}if (@m){unshift(@m,"
  
  $(INST_STATIC) : $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DFSEP).exists
  	$(RM_RF) $@
  END
  	$(CP) $(MYEXTLIB) $@
  MAKE_FRAG
  	$(%s) $(AR_STATIC_ARGS) $@ $(OBJECT) && $(RANLIB) $@
  	$(CHMOD) $(PERM_RWX) $@
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" > $(INST_ARCHAUTODIR)/extralibs.ld
  MAKE_FRAG
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" >> $(PERL_SRC)/ext.libs
  MAKE_FRAG
  
  subdirs ::
  	$(NOECHO) %s
  EOT
  # The default clean, realclean and test targets in this Makefile
  # have automatically been given entries for each subdir.
  
  ")}else {push(@m,"\n# none")}join('',@m)}sub test {my($self,%attribs)=@_;my$tests=$attribs{TESTS}|| '';if (!$tests && -d 't'){$tests=$self->find_tests}my(@m);push(@m,"
  TEST_VERBOSE=0
  TEST_TYPE=test_\$(LINKTYPE)
  TEST_FILE = test.pl
  TEST_FILES = $tests
  TESTDB_SW = -d
  
  testdb :: testdb_\$(LINKTYPE)
  
  test :: \$(TEST_TYPE) subdirs-test
  
  subdirs-test ::
  	\$(NOECHO) \$(NOOP)
  
  ");for my$dir (@{$self->{DIR}}){my$test=$self->cd($dir,'$(MAKE) test $(PASTHRU)');push@m,<<END}push(@m,"\t\$(NOECHO) \$(ECHO) 'No tests defined for \$(NAME) extension.'\n")unless$tests or -f "test.pl" or @{$self->{DIR}};push(@m,"\n");push(@m,"test_dynamic :: pure_all\n");push(@m,$self->test_via_harness('$(FULLPERLRUN)','$(TEST_FILES)'))if$tests;push(@m,$self->test_via_script('$(FULLPERLRUN)','$(TEST_FILE)'))if -f "test.pl";push(@m,"\n");push(@m,"testdb_dynamic :: pure_all\n");push(@m,$self->test_via_script('$(FULLPERLRUN) $(TESTDB_SW)','$(TEST_FILE)'));push(@m,"\n");push@m,"test_ : test_dynamic\n\n";if ($self->needs_linking()){push(@m,"test_static :: pure_all \$(MAP_TARGET)\n");push(@m,$self->test_via_harness('./$(MAP_TARGET)','$(TEST_FILES)'))if$tests;push(@m,$self->test_via_script('./$(MAP_TARGET)','$(TEST_FILE)'))if -f "test.pl";push(@m,"\n");push(@m,"testdb_static :: pure_all \$(MAP_TARGET)\n");push(@m,$self->test_via_script('./$(MAP_TARGET) $(TESTDB_SW)','$(TEST_FILE)'));push(@m,"\n")}else {push@m,"test_static :: test_dynamic\n";push@m,"testdb_static :: testdb_dynamic\n"}join("",@m)}sub test_via_harness {my($self,$perl,$tests)=@_;return$self->SUPER::test_via_harness("PERL_DL_NONLAZY=1 $perl",$tests)}sub test_via_script {my($self,$perl,$script)=@_;return$self->SUPER::test_via_script("PERL_DL_NONLAZY=1 $perl",$script)}sub tool_xsubpp {my($self)=shift;return "" unless$self->needs_linking;my$xsdir;my@xsubpp_dirs=@INC;unshift@xsubpp_dirs,$self->{PERL_LIB}if$self->{PERL_CORE};for my$dir (@xsubpp_dirs){$xsdir=$self->catdir($dir,'ExtUtils');if(-r $self->catfile($xsdir,"xsubpp")){last}}my$tmdir=File::Spec->catdir($self->{PERL_LIB},"ExtUtils");my(@tmdeps)=$self->catfile($tmdir,'typemap');if($self->{TYPEMAPS}){for my$typemap (@{$self->{TYPEMAPS}}){if(!-f $typemap){warn "Typemap $typemap not found.\n"}else {push(@tmdeps,$typemap)}}}push(@tmdeps,"typemap")if -f "typemap";my(@tmargs)=map("-typemap $_",@tmdeps);if(exists$self->{XSOPT}){unshift(@tmargs,$self->{XSOPT})}if ($Is{VMS}&& $Config{'ldflags'}&& $Config{'ldflags'}=~ m!/Debug!i && (!exists($self->{XSOPT})|| $self->{XSOPT}!~ /linenumbers/)){unshift(@tmargs,'-nolinenumbers')}$self->{XSPROTOARG}="" unless defined$self->{XSPROTOARG};return qq{
  subdirs-test ::
  	\$(NOECHO) $test
  
  END
  XSUBPPDIR = $xsdir
  XSUBPP = \$(XSUBPPDIR)\$(DFSEP)xsubpp
  XSUBPPRUN = \$(PERLRUN) \$(XSUBPP)
  XSPROTOARG = $self->{XSPROTOARG}
  XSUBPPDEPS = @tmdeps \$(XSUBPP)
  XSUBPPARGS = @tmargs
  XSUBPP_EXTRA_ARGS = 
  }};sub all_target {my$self=shift;return <<'MAKE_EXT'}sub top_targets {my($self)=shift;my(@m);push@m,$self->all_target,"\n" unless$self->{SKIPHASH}{'all'};push@m,'
  all :: pure_all manifypods
  	$(NOECHO) $(NOOP)
  MAKE_EXT
  pure_all :: config pm_to_blib subdirs linkext
  	$(NOECHO) $(NOOP)
  
  subdirs :: $(MYEXTLIB)
  	$(NOECHO) $(NOOP)
  
  config :: $(FIRST_MAKEFILE) blibdirs
  	$(NOECHO) $(NOOP)
  ';push@m,'
  $(O_FILES): $(H_FILES)
  ' if @{$self->{O_FILES}|| []}&& @{$self->{H}|| []};push@m,q{
  help :
  	perldoc ExtUtils::MakeMaker
  };join('',@m)}sub writedoc {my($self,$what,$name,@attribs)=@_;my$time=localtime;print "=head2 $time: $what C<$name>\n\n=over 4\n\n=item *\n\n";print join "\n\n=item *\n\n",map("C<$_>",@attribs);print "\n\n=back\n\n"}sub xs_c {my($self)=shift;return '' unless$self->needs_linking();'
  .xs.c:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(XSUBPP_EXTRA_ARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
  '}sub xs_cpp {my($self)=shift;return '' unless$self->needs_linking();'
  .xs.cpp:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.cpp
  '}sub xs_o {my($self)=shift;return '' unless$self->needs_linking();'
  .xs$(OBJ_EXT):
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
  	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.c
  '}1;
EXTUTILS_MM_UNIX

$fatpacked{"ExtUtils/MM_VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_VMS';
  package ExtUtils::MM_VMS;use strict;use ExtUtils::MakeMaker::Config;require Exporter;BEGIN {if($^O eq 'VMS'){require VMS::Filespec;VMS::Filespec->import}}use File::Basename;our$VERSION='6.66';require ExtUtils::MM_Any;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Any ExtUtils::MM_Unix);use ExtUtils::MakeMaker qw($Verbose neatvalue);our$Revision=$ExtUtils::MakeMaker::Revision;sub wraplist {my($self)=shift;my($line,$hlen)=('',0);for my$word (@_){next unless$word =~ /\w/;$line .= ' ' if length($line);if ($hlen > 80){$line .= "\\\n\t";$hlen=0}$line .= $word;$hlen += length($word)+ 2}$line}sub ext {require ExtUtils::Liblist::Kid;goto&ExtUtils::Liblist::Kid::ext}sub guess_name {my($self)=@_;my($defname,$defpm,@pm,%xs);local*PM;$defname=basename(fileify($ENV{'DEFAULT'}));$defname =~ s![\d\-_]*\.dir.*$!!;$defpm=$defname;if (not -e "${defpm}.pm"){@pm=glob('*.pm');s/.pm$// for@pm;if (@pm==1){($defpm=$pm[0])=~ s/.pm$//}elsif (@pm){%xs=map {s/.xs$//;($_,1)}glob('*.xs');if (keys%xs){for my$pm (@pm){$defpm=$pm,last if exists$xs{$pm}}}}}if (open(my$pm,'<',"${defpm}.pm")){while (<$pm>){if (/^\s*package\s+([^;]+)/i){$defname=$1;last}}print "Warning (non-fatal): Couldn't find package name in ${defpm}.pm;\n\t","defaulting package name to $defname\n" if eof($pm);close$pm}else {print "Warning (non-fatal): Couldn't find ${defpm}.pm;\n\t","defaulting package name to $defname\n"}$defname =~ s#[\d.\-_]+$##;$defname}sub find_perl {my($self,$ver,$names,$dirs,$trace)=@_;my($vmsfile,@sdirs,@snames,@cand);my($rslt);my($inabs)=0;local*TCF;if($self->{PERL_CORE}){@sdirs=sort {my($absa)=$self->file_name_is_absolute($a);my($absb)=$self->file_name_is_absolute($b);if ($absa && $absb){return$a cmp $b}else {return$absa ? 1 : ($absb ? -1 : ($a cmp $b))}}@$dirs;@snames=sort {my($ba)=$a =~ m!([^:>\]/]+)$!;my($bb)=$b =~ m!([^:>\]/]+)$!;my($ahasdir)=(length($a)- length($ba)> 0);my($bhasdir)=(length($b)- length($bb)> 0);if ($ahasdir and not $bhasdir){return 1}elsif ($bhasdir and not $ahasdir){return -1}else {$bb =~ /\d/ <=> $ba =~ /\d/ or substr($ba,0,1)cmp substr($bb,0,1)or length($bb)<=> length($ba)}}@$names}else {@sdirs=@$dirs;@snames=@$names}s/\.(\d+)$/_$1/ for@snames;if ($trace >= 2){print "Looking for perl $ver by these names:\n";print "\t@snames,\n";print "in these dirs:\n";print "\t@sdirs\n"}for my$dir (@sdirs){next unless defined$dir;$inabs++ if$self->file_name_is_absolute($dir);if ($inabs==1){for my$name (@snames){push(@cand,$name)if$name =~ /^[\w\-\$]+$/}$inabs++}for my$name (@snames){push@cand,($name !~ m![/:>\]]!)? $self->catfile($dir,$name): $self->fixpath($name,0)}}for my$name (@cand){print "Checking $name\n" if$trace >= 2;if ($name =~ /^[\w\-\$]+$/){open(my$tcf,">","temp_mmvms.com")or die('unable to open temp file');print$tcf "\$ set message/nofacil/nosever/noident/notext\n";print$tcf "\$ $name -e \"require $ver; print \"\"VER_OK\\n\"\"\"\n";close$tcf;$rslt=`\@temp_mmvms.com` ;unlink('temp_mmvms.com');if ($rslt =~ /VER_OK/){print "Using PERL=$name\n" if$trace;return$name}}next unless$vmsfile=$self->maybe_command($name);$vmsfile =~ s/;[\d\-]*$//;print "Executing $vmsfile\n" if ($trace >= 2);open(my$tcf,'>',"temp_mmvms.com")or die('unable to open temp file');print$tcf "\$ set message/nofacil/nosever/noident/notext\n";print$tcf "\$ mcr $vmsfile -e \"require $ver; print \"\"VER_OK\\n\"\"\" \n";close$tcf;$rslt=`\@temp_mmvms.com`;unlink('temp_mmvms.com');if ($rslt =~ /VER_OK/){print "Using PERL=MCR $vmsfile\n" if$trace;return "MCR $vmsfile"}}print "Unable to find a perl $ver (by these names: @$names, in these dirs: @$dirs)\n";0}sub _fixin_replace_shebang {my ($self,$file,$line)=@_;my (undef,$arg)=split ' ',$line,2;return$Config{startperl}."\n" .$Config{sharpbang}."perl $arg\n"}sub maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d _;my(@dirs)=('');my(@exts)=('',$Config{'exe_ext'},'.exe','.com');if ($file !~ m![/:>\]]!){for (my$i=0;defined$ENV{"DCL\$PATH;$i"};$i++){my$dir=$ENV{"DCL\$PATH;$i"};$dir .= ':' unless$dir =~ m%[\]:]$%;push(@dirs,$dir)}push(@dirs,'Sys$System:');for my$dir (@dirs){my$sysfile="$dir$file";for my$ext (@exts){return$file if -x "$sysfile$ext" &&!-d _}}}return 0}sub pasthru {return "PASTHRU=\n"}sub pm_to_blib {my$self=shift;my$make=$self->SUPER::pm_to_blib;$make =~ s{^pm_to_blib :}{pm_to_blib.ts :}m;$make =~ s{\$\(TOUCH\) pm_to_blib}{\$(TOUCH) pm_to_blib.ts};$make=<<'MAKE' .$make;return$make}sub perl_script {my($self,$file)=@_;return$file if -r $file &&!-d _;return "$file.com" if -r "$file.com";return "$file.pl" if -r "$file.pl";return ''}sub replace_manpage_separator {my($self,$man)=@_;$man=unixify($man);$man =~ s#/+#__#g;$man}sub init_DEST {my$self=shift;$self->SUPER::init_DEST;for my$var ($self->installvars){my$destvar='DESTINSTALL'.$var;$self->{$destvar}=$self->eliminate_macros($self->{$destvar})}}sub init_DIRFILESEP {my($self)=shift;$self->{DIRFILESEP}='';return 1}sub init_main {my($self)=shift;$self->SUPER::init_main;$self->{DEFINE}||= '';if ($self->{DEFINE}ne ''){my(@terms)=split(/\s+/,$self->{DEFINE});my(@defs,@udefs);for my$def (@terms){next unless$def;my$targ=\@defs;if ($def =~ s/^-([DU])//){$targ=\@udefs if $1 eq 'U';$def =~ s/='(.*)'$/=$1/;$def =~ s/^'(.*)'$/$1/}if ($def =~ /=/){$def =~ s/"/""/g;$def=qq["$def"]}push @$targ,$def}$self->{DEFINE}='';if (@defs){$self->{DEFINE}='/Define=(' .join(',',@defs).')'}if (@udefs){$self->{DEFINE}.= '/Undef=(' .join(',',@udefs).')'}}}sub init_tools {my($self)=@_;$self->{NOOP}='Continue';$self->{NOECHO}||= '@ ';$self->{MAKEFILE}||= $self->{FIRST_MAKEFILE}|| 'Descrip.MMS';$self->{FIRST_MAKEFILE}||= $self->{MAKEFILE};$self->{MAKE_APERL_FILE}||= 'Makeaperl.MMS';$self->{MAKEFILE_OLD}||= $self->eliminate_macros('$(FIRST_MAKEFILE)_old');$self->{MAKEFILE}.= '.' unless$self->{MAKEFILE}=~ m/\./;$self->{FIRST_MAKEFILE}.= '.' unless$self->{FIRST_MAKEFILE}=~ m/\./;$self->{MAKE_APERL_FILE}.= '.' unless$self->{MAKE_APERL_FILE}=~ m/\./;$self->{MAKEFILE_OLD}.= '.' unless$self->{MAKEFILE_OLD}=~ m/\./;$self->{MACROSTART}||= '/Macro=(';$self->{MACROEND}||= ')';$self->{USEMAKEFILE}||= '/Descrip=';$self->{EQUALIZE_TIMESTAMP}||= '$(ABSPERLRUN) -we "open F,qq{>>$ARGV[1]};close F;utime(0,(stat($ARGV[0]))[9]+1,$ARGV[1])"';$self->{MOD_INSTALL}||= $self->oneliner(<<'CODE',['-MExtUtils::Install']);$self->{UMASK_NULL}='! ';$self->SUPER::init_tools;$self->{SHELL}||= 'Posix';$self->{DEV_NULL}='';return}sub init_platform {my($self)=shift;$self->{MM_VMS_REVISION}=$Revision;$self->{MM_VMS_VERSION}=$VERSION;$self->{PERL_VMS}=$self->catdir($self->{PERL_SRC},'VMS')if$self->{PERL_SRC}}sub platform_constants {my($self)=shift;my$make_frag='';for my$macro (qw(PERL_VMS MM_VMS_REVISION MM_VMS_VERSION)){next unless defined$self->{$macro};$make_frag .= "$macro = $self->{$macro}\n"}return$make_frag}sub init_VERSION {my$self=shift;$self->SUPER::init_VERSION;$self->{DEFINE_VERSION}='"$(VERSION_MACRO)=""$(VERSION)"""';$self->{XS_DEFINE_VERSION}='"$(XS_VERSION_MACRO)=""$(XS_VERSION)"""';$self->{MAKEMAKER}=vmsify($INC{'ExtUtils/MakeMaker.pm'})}sub constants {my($self)=@_;for (@ARGV){$_=uc($_)if /POLLUTE/i}for my$macro (qw [ INST_BIN INST_SCRIPT INST_LIB INST_ARCHLIB PERL_LIB PERL_ARCHLIB PERL_INC PERL_SRC],(map {'INSTALL'.$_}$self->installvars)){next unless defined$self->{$macro};next if$macro =~ /MAN/ && $self->{$macro}eq 'none';$self->{$macro}=$self->fixpath($self->{$macro},1)}for my$macro (qw[LIBPERL_A FIRST_MAKEFILE MAKEFILE_OLD MAKE_APERL_FILE MYEXTLIB]){next unless defined$self->{$macro};$self->{$macro}=$self->fixpath($self->{$macro},0)}for my$macro (qw/FULLEXT VERSION_FROM/){next unless defined$self->{$macro};$self->{$macro}=$self->fixpath($self->{$macro},0)}for my$macro (qw/OBJECT LDFROM/){next unless defined$self->{$macro};$self->{$macro}=$self->eliminate_macros($self->{$macro});if ($self->{$macro}=~ /(?<!\^)\s/){$self->{$macro}=~ s/(\\)?\n+\s+/ /g;$self->{$macro}=$self->wraplist(map$self->fixpath($_,0),split /,?(?<!\^)\s+/,$self->{$macro})}else {$self->{$macro}=$self->fixpath($self->{$macro},0)}}for my$macro (qw/XS MAN1PODS MAN3PODS PM/){next unless$self ne " " && defined$self->{$macro};my%tmp=();for my$key (keys %{$self->{$macro}}){$tmp{$self->fixpath($key,0)}=$self->fixpath($self->{$macro}{$key},0)}$self->{$macro}=\%tmp}for my$macro (qw/C O_FILES H/){next unless defined$self->{$macro};my@tmp=();for my$val (@{$self->{$macro}}){push(@tmp,$self->fixpath($val,0))}$self->{$macro}=\@tmp}$self->{MAKE}='$(MMS)$(MMSQUALIFIERS)';return$self->SUPER::constants}sub special_targets {my$self=shift;my$make_frag .= <<'MAKE_FRAG';return$make_frag}sub cflags {my($self,$libperl)=@_;my($quals)=$self->{CCFLAGS}|| $Config{'ccflags'};my($definestr,$undefstr,$flagoptstr)=('','','');my($incstr)='/Include=($(PERL_INC)';my($name,$sys,@m);($name=$self->{NAME}."_cflags")=~ s/:/_/g ;print "Unix shell script ".$Config{"$self->{'BASEEXT'}_cflags"}." required to modify CC command for $self->{'BASEEXT'}\n" if ($Config{$name});if ($quals =~ / -[DIUOg]/){while ($quals =~ / -([Og])(\d*)\b/){my($type,$lvl)=($1,$2);$quals =~ s/ -$type$lvl\b\s*//;if ($type eq 'g'){$flagoptstr='/NoOptimize'}else {$flagoptstr='/Optimize' .(defined($lvl)? "=$lvl" : '')}}while ($quals =~ / -([DIU])(\S+)/){my($type,$def)=($1,$2);$quals =~ s/ -$type$def\s*//;$def =~ s/"/""/g;if ($type eq 'D'){$definestr .= qq["$def",]}elsif ($type eq 'I'){$incstr .= ',' .$self->fixpath($def,1)}else {$undefstr .= qq["$def",]}}}if (length$quals and $quals !~ m!/!){warn "MM_VMS: Ignoring unrecognized CCFLAGS elements \"$quals\"\n";$quals=''}$definestr .= q["PERL_POLLUTE",] if$self->{POLLUTE};if (length$definestr){chop($definestr);$quals .= "/Define=($definestr)"}if (length$undefstr){chop($undefstr);$quals .= "/Undef=($undefstr)"}if ($self->{DEFINE}){$quals .= $self->{DEFINE}}for my$type (qw(Def Undef)){my(@terms);while ($quals =~ m:/${type}i?n?e?=([^/]+):ig){my$term=$1;$term =~ s:^\((.+)\)$:$1:;push@terms,$term}if ($type eq 'Def'){push@terms,qw[$(DEFINE_VERSION) $(XS_DEFINE_VERSION)]}if (@terms){$quals =~ s:/${type}i?n?e?=[^/]+::ig;$quals .= "/${type}ine=(" .join(',',@terms).')'}}$libperl or $libperl=$self->{LIBPERL_A}|| "libperl.olb";if ($self->{'INC'}){my(@includes)=split(/\s+/,$self->{INC});for (@includes){s/^-I//;$incstr .= ','.$self->fixpath($_,1)}}$quals .= "$incstr)";$self->{CCFLAGS}=$quals;$self->{PERLTYPE}||= '';$self->{OPTIMIZE}||= $flagoptstr || $Config{'optimize'};if ($self->{OPTIMIZE}!~ m!/!){if ($self->{OPTIMIZE}=~ m!-g!){$self->{OPTIMIZE}='/Debug/NoOptimize'}elsif ($self->{OPTIMIZE}=~ /-O(\d*)/){$self->{OPTIMIZE}='/Optimize' .(defined($1)? "=$1" : '')}else {warn "MM_VMS: Can't parse OPTIMIZE \"$self->{OPTIMIZE}\"; using default\n" if length$self->{OPTIMIZE};$self->{OPTIMIZE}='/Optimize'}}return$self->{CFLAGS}=qq{
  # Dummy target to match Unix target name; we use pm_to_blib.ts as
  # timestamp file to avoid repeated invocations under VMS
  pm_to_blib : pm_to_blib.ts
  	$(NOECHO) $(NOOP)
  
  MAKE
  install([ from_to => {split(' ', <STDIN>)}, verbose => '$(VERBINST)', uninstall_shadows => '$(UNINST)', dir_mode => '$(PERM_DIR)' ]);
  CODE
  .SUFFIXES :
  .SUFFIXES : $(OBJ_EXT) .c .cpp .cxx .xs
  
  MAKE_FRAG
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  }}sub const_cccmd {my($self,$libperl)=@_;my(@m);return$self->{CONST_CCCMD}if$self->{CONST_CCCMD};return '' unless$self->needs_linking();if ($Config{'vms_cc_type'}eq 'gcc'){push@m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" Then Define/NoLog SYS GNU_CC_Include:[VMS]'}elsif ($Config{'vms_cc_type'}eq 'vaxc'){push@m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("VAXC$Include").eqs."" Then Define/NoLog SYS Sys$Library
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("VAXC$Include").nes."" Then Define/NoLog SYS VAXC$Include'}else {push@m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("DECC$System_Include").eqs."" Then Define/NoLog SYS ',($Config{'archname'}eq 'VMS_AXP' ? 'Sys$Library' : 'DECC$Library_Include'),'
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("DECC$System_Include").nes."" Then Define/NoLog SYS DECC$System_Include'}push(@m,"\n\nCCCMD = $Config{'cc'} \$(CCFLAGS)\$(OPTIMIZE)\n");$self->{CONST_CCCMD}=join('',@m)}sub tools_other {my($self)=@_;my$extra_tools=<<'EXTRA_TOOLS';return$self->SUPER::tools_other .$extra_tools}sub init_dist {my($self)=@_;$self->{ZIPFLAGS}||= '-Vu';$self->{COMPRESS}||= 'gzip';$self->{SUFFIX}||= '-gz';$self->{SHAR}||= 'vms_share';$self->{DIST_DEFAULT}||= 'zipdist';$self->SUPER::init_dist;$self->{DISTVNAME}="$self->{DISTNAME}-$self->{VERSION_SYM}" unless$self->{ARGS}{DISTVNAME};return}sub c_o {my($self)=@_;return '' unless$self->needs_linking();'
  
  # Just in case anyone is using the old macro.
  USEMACROS = $(MACROSTART)
  SAY = $(ECHO)
  
  EXTRA_TOOLS
  .c$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c
  
  .cpp$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).cpp
  
  .cxx$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).cxx
  
  '}sub xs_c {my($self)=@_;return '' unless$self->needs_linking();'
  .xs.c :
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET)
  '}sub xs_o {my($self)=@_;return '' unless$self->needs_linking();'
  .xs$(OBJ_EXT) :
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET_NAME).c
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c
  '}sub dlsyms {my($self,%attribs)=@_;return '' unless$self->needs_linking();my($funcs)=$attribs{DL_FUNCS}|| $self->{DL_FUNCS}|| {};my($vars)=$attribs{DL_VARS}|| $self->{DL_VARS}|| [];my($funclist)=$attribs{FUNCLIST}|| $self->{FUNCLIST}|| [];my(@m);unless ($self->{SKIPHASH}{'dynamic'}){push(@m,'
  dynamic :: $(INST_ARCHAUTODIR)$(BASEEXT).opt
  	$(NOECHO) $(NOOP)
  ')}push(@m,'
  static :: $(INST_ARCHAUTODIR)$(BASEEXT).opt
  	$(NOECHO) $(NOOP)
  ')unless$self->{SKIPHASH}{'static'};push@m,'
  $(INST_ARCHAUTODIR)$(BASEEXT).opt : $(BASEEXT).opt
  	$(CP) $(MMS$SOURCE) $(MMS$TARGET)
  
  $(BASEEXT).opt : Makefile.PL
  	$(PERLRUN) -e "use ExtUtils::Mksymlists;" -
  	',qq[-e "Mksymlists('NAME' => '$self->{NAME}', 'DL_FUNCS' => ],neatvalue($funcs),q[, 'DL_VARS' => ],neatvalue($vars),q[, 'FUNCLIST' => ],neatvalue($funclist),qq[)"\n];push@m,'	$(PERL) -e "print ""$(INST_STATIC)/Include=';if ($self->{OBJECT}=~ /\bBASEEXT\b/ or $self->{OBJECT}=~ /\b$self->{BASEEXT}\b/i){push@m,($Config{d_vms_case_sensitive_symbols}? uc($self->{BASEEXT}):'$(BASEEXT)')}else {my($upcase)=$Config{d_vms_case_sensitive_symbols};my(@omods)=split ' ',$self->eliminate_macros($self->{OBJECT});for (@omods){s/\.[^.]*$//;s[\$\(\w+_EXT\)][];s/.*[:>\/\]]//;$_=uc if$upcase};my(@lines);my$tmp=shift@omods;for my$elt (@omods){$tmp .= ",$elt";if (length($tmp)> 80){push@lines,$tmp;$tmp=''}}push@lines,$tmp;push@m,'(',join(qq[, -\\n\\t"";" >>\$(MMS\$TARGET)\n\t\$(PERL) -e "print ""],@lines),')'}push@m,'\n$(INST_STATIC)/Library\n"";" >>$(MMS$TARGET)',"\n";if (length$self->{LDLOADLIBS}){my($line)='';for my$lib (split ' ',$self->{LDLOADLIBS}){$lib =~ s%\$%\\\$%g;if (length($line)+ length($lib)> 160){push@m,"\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n";$line=$lib .'\n'}else {$line .= $lib .'\n'}}push@m,"\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n" if$line}join('',@m)}sub dynamic_lib {my($self,%attribs)=@_;return '' unless$self->needs_linking();return '' unless$self->has_link_code();my($otherldflags)=$attribs{OTHERLDFLAGS}|| "";my($inst_dynamic_dep)=$attribs{INST_DYNAMIC_DEP}|| "";my$shr=$Config{'dbgprefix'}.'PerlShr';my(@m);push@m,"
  
  OTHERLDFLAGS = $otherldflags
  INST_DYNAMIC_DEP = $inst_dynamic_dep
  
  ";push@m,'
  $(INST_DYNAMIC) : $(INST_STATIC) $(PERL_INC)perlshr_attr.opt $(INST_ARCHAUTODIR)$(DFSEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
  	If F$TrnLNm("',$shr,'").eqs."" Then Define/NoLog/User ',"$shr Sys\$Share:$shr.$Config{'dlext'}",'
  	Link $(LDFLAGS) /Shareable=$(MMS$TARGET)$(OTHERLDFLAGS) $(BASEEXT).opt/Option,$(PERL_INC)perlshr_attr.opt/Option
  ';join('',@m)}sub static_lib {my($self)=@_;return '' unless$self->needs_linking();return '
  $(INST_STATIC) :
  	$(NOECHO) $(NOOP)
  ' unless ($self->{OBJECT}or @{$self->{C}|| []}or $self->{MYEXTLIB});my(@m);push@m,'
  # Rely on suffix rule for update action
  $(OBJECT) : $(INST_ARCHAUTODIR)$(DFSEP).exists
  
  $(INST_STATIC) : $(OBJECT) $(MYEXTLIB)
  ';push(@m,"\t",'$(CP) $(MYEXTLIB) $(MMS$TARGET)',"\n")if$self->{MYEXTLIB};push(@m,"\t",'If F$Search("$(MMS$TARGET)").eqs."" Then Library/Object/Create $(MMS$TARGET)',"\n");if ($self->{MYEXTLIB}){push(@m,"\t",'Library/Object/Replace $(MMS$TARGET) $(OBJECT)',"\n")}else {push(@m,"\t",'Library/Object/Replace $(MMS$TARGET) $(MMS$SOURCE_LIST)',"\n")}push@m,"\t\$(NOECHO) \$(PERL) -e 1 >\$(INST_ARCHAUTODIR)extralibs.ld\n";for my$lib (split ' ',$self->{EXTRALIBS}){push(@m,"\t",'$(NOECHO) $(PERL) -e "print qq{',$lib,'\n}" >>$(INST_ARCHAUTODIR)extralibs.ld',"\n")}join('',@m)}sub extra_clean_files {return qw(*.Map *.Dmp *.Lis *.cpp *.$(DLEXT) *.Opt $(BASEEXT).bso .MM_Tmp cxx_repository)}sub zipfile_target {my($self)=shift;return <<'MAKE_FRAG'}sub tarfile_target {my($self)=shift;return <<'MAKE_FRAG'}sub shdist_target {my($self)=shift;return <<'MAKE_FRAG'}sub install {my($self,%attribs)=@_;my(@m);push@m,q[
  $(DISTVNAME).zip : distdir
  	$(PREOP)
  	$(ZIP) "$(ZIPFLAGS)" $(MMS$TARGET) [.$(DISTVNAME)...]*.*;
  	$(RM_RF) $(DISTVNAME)
  	$(POSTOP)
  MAKE_FRAG
  $(DISTVNAME).tar$(SUFFIX) : distdir
  	$(PREOP)
  	$(TO_UNIX)
          $(TAR) "$(TARFLAGS)" $(DISTVNAME).tar [.$(DISTVNAME)...]
  	$(RM_RF) $(DISTVNAME)
  	$(COMPRESS) $(DISTVNAME).tar
  	$(POSTOP)
  MAKE_FRAG
  shdist : distdir
  	$(PREOP)
  	$(SHAR) [.$(DISTVNAME)...]*.*; $(DISTVNAME).share
  	$(RM_RF) $(DISTVNAME)
  	$(POSTOP)
  MAKE_FRAG
  install :: all pure_install doc_install
  	$(NOECHO) $(NOOP)
  
  install_perl :: all pure_perl_install doc_perl_install
  	$(NOECHO) $(NOOP)
  
  install_site :: all pure_site_install doc_site_install
  	$(NOECHO) $(NOOP)
  
  pure_install :: pure_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  doc_install :: doc_$(INSTALLDIRS)_install
          $(NOECHO) $(NOOP)
  
  pure__install : pure_site_install
  	$(NOECHO) $(ECHO) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
  
  doc__install : doc_site_install
  	$(NOECHO) $(ECHO) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
  
  # This hack brought to you by DCL's 255-character command line limit
  pure_perl_install ::
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read '.File::Spec->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').' '" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write '.File::Spec->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').' '" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_LIB) $(DESTINSTALLPRIVLIB) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB) $(DESTINSTALLARCHLIB) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN) $(DESTINSTALLBIN) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT) $(DESTINSTALLSCRIPT) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR) $(DESTINSTALLMAN1DIR) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR) $(DESTINSTALLMAN3DIR) " >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) ].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
  
  # Likewise
  pure_site_install ::
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read '.File::Spec->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').' '" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write '.File::Spec->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').' '" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_LIB) $(DESTINSTALLSITELIB) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB) $(DESTINSTALLSITEARCH) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN) $(DESTINSTALLSITEBIN) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT) $(DESTINSTALLSCRIPT) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR) $(DESTINSTALLSITEMAN1DIR) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR) $(DESTINSTALLSITEMAN3DIR) " >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) ].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[
  
  pure_vendor_install ::
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read '.File::Spec->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').' '" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write '.File::Spec->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').' '" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_LIB) $(DESTINSTALLVENDORLIB) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB) $(DESTINSTALLVENDORARCH) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN) $(DESTINSTALLVENDORBIN) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT) $(DESTINSTALLSCRIPT) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR) $(DESTINSTALLVENDORMAN1DIR) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR) $(DESTINSTALLVENDORMAN3DIR) " >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  
  # Ditto
  doc_perl_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLPRIVLIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  # And again
  doc_site_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLSITELIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  doc_vendor_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLVENDORLIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  ];push@m,q[
  uninstall :: uninstall_from_$(INSTALLDIRS)dirs
  	$(NOECHO) $(NOOP)
  
  uninstall_from_perldirs ::
  	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[
  	$(NOECHO) $(ECHO) "Uninstall is now deprecated and makes no actual changes."
  	$(NOECHO) $(ECHO) "Please check the list above carefully for errors, and manually remove"
  	$(NOECHO) $(ECHO) "the appropriate files.  Sorry for the inconvenience."
  
  uninstall_from_sitedirs ::
  	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
  	$(NOECHO) $(ECHO) "Uninstall is now deprecated and makes no actual changes."
  	$(NOECHO) $(ECHO) "Please check the list above carefully for errors, and manually remove"
  	$(NOECHO) $(ECHO) "the appropriate files.  Sorry for the inconvenience."
  ];join('',@m)}sub perldepend {my($self)=@_;my(@m);if ($self->{OBJECT}){push@m,$self->_perl_header_files_fragment("")}if ($self->{PERL_SRC}){my(@macros);my($mmsquals)='$(USEMAKEFILE)[.vms]$(FIRST_MAKEFILE)';push(@macros,'__AXP__=1')if$Config{'archname'}eq 'VMS_AXP';push(@macros,'DECC=1')if$Config{'vms_cc_type'}eq 'decc';push(@macros,'GNUC=1')if$Config{'vms_cc_type'}eq 'gcc';push(@macros,'SOCKET=1')if$Config{'d_has_sockets'};push(@macros,qq["CC=$Config{'cc'}"])if$Config{'cc'}=~ m!/!;$mmsquals .= '$(USEMACROS)' .join(',',@macros).'$(MACROEND)' if@macros;push(@m,q[
  # Check for unpropagated config.sh changes. Should never happen.
  # We do NOT just update config.h because that is not sufficient.
  # An out of date config.h is not fatal but complains loudly!
  $(PERL_INC)config.h : $(PERL_SRC)config.sh
  	$(NOOP)
  
  $(PERL_ARCHLIB)Config.pm : $(PERL_SRC)config.sh
  	$(NOECHO) Write Sys$Error "$(PERL_ARCHLIB)Config.pm may be out of date with config.h or genconfig.pl"
  	olddef = F$Environment("Default")
  	Set Default $(PERL_SRC)
  	$(MMS)],$mmsquals,);if ($self->{PERL_ARCHLIB}=~ m|\[-| && $self->{PERL_SRC}=~ m|(\[-+)|){my($prefix,$target)=($1,$self->fixpath('$(PERL_ARCHLIB)Config.pm',0));$target =~ s/\Q$prefix/[/;push(@m," $target")}else {push(@m,' $(MMS$TARGET)')}push(@m,q[
  	Set Default 'olddef'
  ])}push(@m,join(" ",map($self->fixpath($_,0),values %{$self->{XS}}))." : \$(XSUBPPDEPS)\n")if %{$self->{XS}};join('',@m)}our%olbs;sub makeaperl {my($self,%attribs)=@_;my($makefilename,$searchdirs,$static,$extra,$perlinc,$target,$tmpdir,$libperl)=@attribs{qw(MAKE DIRS STAT EXTRA INCL TARGET TMP LIBPERL)};my(@m);push@m,"
  # --- MakeMaker makeaperl section ---
  MAP_TARGET    = $target
  ";return join '',@m if$self->{PARENT};my($dir)=join ":",@{$self->{DIR}};unless ($self->{MAKEAPERL}){push@m,q{
  $(MAKE_APERL_FILE) : $(FIRST_MAKEFILE)
  	$(NOECHO) $(ECHO) "Writing ""$(MMS$TARGET)"" for this $(MAP_TARGET)"
  	$(NOECHO) $(PERLRUNINST) \
  		Makefile.PL DIR=},$dir,q{ \
  		FIRST_MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \
  		MAKEAPERL=1 NORECURS=1 };push@m,map(q[ \\\n\t\t"$_"],@ARGV),q{
  
  $(MAP_TARGET) :: $(MAKE_APERL_FILE)
  	$(MAKE)$(USEMAKEFILE)$(MAKE_APERL_FILE) static $(MMS$TARGET)
  };push@m,"\n";return join '',@m}my($linkcmd,@optlibs,@staticpkgs,$extralist,$targdir,$libperldir,%libseen);local($_);$linkcmd=join ' ',$Config{'ld'},grep($_,@Config{qw(large split ldflags ccdlflags)});$linkcmd =~ s/\s+/ /g;local(%olbs);$olbs{$self->{INST_ARCHAUTODIR}}="$self->{BASEEXT}\$(LIB_EXT)";require File::Find;File::Find::find(sub {return unless m/\Q$self->{LIB_EXT}\E$/;return if m/^libperl/;if(exists$self->{INCLUDE_EXT}){my$found=0;(my$xx=$File::Find::name)=~ s,.*?/auto/,,;$xx =~ s,/?$_,,;$xx =~ s,/,::,g;for my$incl ((@{$self->{INCLUDE_EXT}},'DynaLoader')){if($xx eq $incl){$found++;last}}return unless$found}elsif(exists$self->{EXCLUDE_EXT}){(my$xx=$File::Find::name)=~ s,.*?/auto/,,;$xx =~ s,/?$_,,;$xx =~ s,/,::,g;for my$excl (@{$self->{EXCLUDE_EXT}}){return if($xx eq $excl)}}$olbs{$ENV{DEFAULT}}=$_},grep(-d $_,@{$searchdirs || []}));$static=[]unless$static;@olbs{@{$static}}=(1)x @{$static};$extra=[]unless$extra && ref$extra eq 'ARRAY';for (sort {length($a)<=> length($b)}keys%olbs){next unless$olbs{$_}=~ /\Q$self->{LIB_EXT}\E$/;my($dir)=$self->fixpath($_,1);my($extralibs)=$dir ."extralibs.ld";my($extopt)=$dir .$olbs{$_};$extopt =~ s/$self->{LIB_EXT}$/.opt/;push@optlibs,"$dir$olbs{$_}";if (-f $extralibs){my%seenthis;open my$list,"<",$extralibs or warn $!,next;while (<$list>){chomp;my$skip=exists($libseen{$_})&&!exists($seenthis{$_});$libseen{$_}++;$seenthis{$_}++;next if$skip;push @$extra,$_}}if (-f $extopt){open my$opt,'<',$extopt or die $!;while (<$opt>){next unless /(?:UNIVERSAL|VECTOR)=boot_([\w_]+)/;my$pkg=$1;$pkg =~ s#__*#::#g;push@staticpkgs,$pkg}}}push@optlibs,@$extra;$target="Perl$Config{'exe_ext'}" unless$target;my$shrtarget;($shrtarget,$targdir)=fileparse($target);$shrtarget =~ s/^([^.]*)/$1Shr/;$shrtarget=$targdir .$shrtarget;$target="Perlshr.$Config{'dlext'}" unless$target;$tmpdir="[]" unless$tmpdir;$tmpdir=$self->fixpath($tmpdir,1);if (@optlibs){$extralist=join(' ',@optlibs)}else {$extralist=''}push@optlibs,grep {!/PerlShr/i}split ' ',+($self->ext())[2];if ($libperl){unless (-f $libperl || -f ($libperl=$self->catfile($Config{'installarchlib'},'CORE',$libperl))){print "Warning: $libperl not found\n";undef$libperl}}unless ($libperl){if (defined$self->{PERL_SRC}){$libperl=$self->catfile($self->{PERL_SRC},"libperl$self->{LIB_EXT}")}elsif (-f ($libperl=$self->catfile($Config{'installarchlib'},'CORE',"libperl$self->{LIB_EXT}"))){}else {print "Warning: $libperl not found
      If you're going to build a static perl binary, make sure perl is installed
      otherwise ignore this warning\n"}}$libperldir=$self->fixpath((fileparse($libperl))[1],1);push@m,'
  # Fill in the target you want to produce if it\'s not perl
  MAP_TARGET    = ',$self->fixpath($target,0),'
  MAP_SHRTARGET = ',$self->fixpath($shrtarget,0),"
  MAP_LINKCMD   = $linkcmd
  MAP_PERLINC   = ",$perlinc ? map('"$_" ',@{$perlinc}): '',"
  MAP_EXTRA     = $extralist
  MAP_LIBPERL = ",$self->fixpath($libperl,0),'
  ';push@m,"\n${tmpdir}Makeaperl.Opt : \$(MAP_EXTRA)\n";for (@optlibs){push@m,'	$(NOECHO) $(PERL) -e "print q{',$_,'}" >>$(MMS$TARGET)',"\n"}push@m,"\n${tmpdir}PerlShr.Opt :\n\t";push@m,'$(NOECHO) $(PERL) -e "print q{$(MAP_SHRTARGET)}" >$(MMS$TARGET)',"\n";push@m,'
  $(MAP_SHRTARGET) : $(MAP_LIBPERL) Makeaperl.Opt ',"${libperldir}Perlshr_Attr.Opt",'
  	$(MAP_LINKCMD)/Shareable=$(MMS$TARGET) $(MAP_LIBPERL), Makeaperl.Opt/Option ',"${libperldir}Perlshr_Attr.Opt/Option",'
  $(MAP_TARGET) : $(MAP_SHRTARGET) ',"${tmpdir}perlmain\$(OBJ_EXT) ${tmpdir}PerlShr.Opt",'
  	$(MAP_LINKCMD) ',"${tmpdir}perlmain\$(OBJ_EXT)",', PerlShr.Opt/Option
  	$(NOECHO) $(ECHO) "To install the new ""$(MAP_TARGET)"" binary, say"
  	$(NOECHO) $(ECHO) "    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) inst_perl $(USEMACROS)MAP_TARGET=$(MAP_TARGET)$(ENDMACRO)"
  	$(NOECHO) $(ECHO) "To remove the intermediate files, say
  	$(NOECHO) $(ECHO) "    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) map_clean"
  ';push@m,"\n${tmpdir}perlmain.c : \$(FIRST_MAKEFILE)\n\t\$(NOECHO) \$(PERL) -e 1 >${tmpdir}Writemain.tmp\n";push@m,"# More from the 255-char line length limit\n";for (@staticpkgs){push@m,'	$(NOECHO) $(PERL) -e "print q{',$_,qq[}" >>${tmpdir}Writemain.tmp\n]}push@m,sprintf <<'MAKE_FRAG',$tmpdir,$tmpdir;push@m,q[
  	$(NOECHO) $(PERL) $(MAP_PERLINC) -ane "use ExtUtils::Miniperl; writemain(@F)" %sWritemain.tmp >$(MMS$TARGET)
  	$(NOECHO) $(RM_F) %sWritemain.tmp
  MAKE_FRAG
  # Still more from the 255-char line length limit
  doc_inst_perl :
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO) "Perl binary $(MAP_TARGET)|" >.MM_tmp
  	$(NOECHO) $(ECHO) "MAP_STATIC|$(MAP_STATIC)|" >>.MM_tmp
  	$(NOECHO) $(PERL) -pl040 -e " " ].$self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'),q[ >>.MM_tmp
  	$(NOECHO) $(ECHO) -e "MAP_LIBPERL|$(MAP_LIBPERL)|" >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) <.MM_tmp >>].$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  ];push@m,"
  inst_perl : pure_inst_perl doc_inst_perl
  	\$(NOECHO) \$(NOOP)
  
  pure_inst_perl : \$(MAP_TARGET)
  	$self->{CP} \$(MAP_SHRTARGET) ",$self->fixpath($Config{'installbin'},1),"
  	$self->{CP} \$(MAP_TARGET) ",$self->fixpath($Config{'installbin'},1),"
  
  clean :: map_clean
  	\$(NOECHO) \$(NOOP)
  
  map_clean :
  	\$(RM_F) ${tmpdir}perlmain\$(OBJ_EXT) ${tmpdir}perlmain.c \$(FIRST_MAKEFILE)
  	\$(RM_F) ${tmpdir}Makeaperl.Opt ${tmpdir}PerlShr.Opt \$(MAP_TARGET)
  ";join '',@m}sub maketext_filter {my($self,$text)=@_;$text =~ s/^([^\s:=]+)(:+\s)/$1 $2/mg;return$text}sub prefixify {my($self,$var,$sprefix,$rprefix,$default)=@_;$rprefix=$self->eliminate_macros($rprefix);$rprefix=vmspath($rprefix)if$rprefix;$sprefix=vmspath($sprefix)if$sprefix;$default=vmsify($default)unless$default =~ /\[.*\]/;(my$var_no_install=$var)=~ s/^install//;my$path=$self->{uc$var}|| $ExtUtils::MM_Unix::Config_Override{lc$var}|| $Config{lc$var}|| $Config{lc$var_no_install};if(!$path){warn "  no Config found for $var.\n" if$Verbose >= 2;$path=$self->_prefixify_default($rprefix,$default)}elsif(!$self->{ARGS}{PREFIX}||!$self->file_name_is_absolute($path)){}elsif($sprefix eq $rprefix){warn "  no new prefix.\n" if$Verbose >= 2}else {warn "  prefixify $var => $path\n" if$Verbose >= 2;warn "    from $sprefix to $rprefix\n" if$Verbose >= 2;my($path_vol,$path_dirs)=$self->splitpath($path);if($path_vol eq $Config{vms_prefix}.':'){warn "  $Config{vms_prefix}: seen\n" if$Verbose >= 2;$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix($rprefix,$path_dirs)}else {$path=$self->_prefixify_default($rprefix,$default)}}print "    now $path\n" if$Verbose >= 2;return$self->{uc$var}=$path}sub _prefixify_default {my($self,$rprefix,$default)=@_;warn "  cannot prefix, using default.\n" if$Verbose >= 2;if(!$default){warn "No default!\n" if$Verbose >= 1;return}if(!$rprefix){warn "No replacement prefix!\n" if$Verbose >= 1;return ''}return$self->_catprefix($rprefix,$default)}sub _catprefix {my($self,$rprefix,$default)=@_;my($rvol,$rdirs)=$self->splitpath($rprefix);if($rvol){return$self->catpath($rvol,$self->catdir($rdirs,$default),'')}else {return$self->catdir($rdirs,$default)}}sub cd {my($self,$dir,@cmds)=@_;$dir=vmspath($dir);my$cmd=join "\n\t",map "$_",@cmds;my$make_frag=sprintf <<'MAKE_FRAG',$dir,$cmd;chomp$make_frag;return$make_frag}sub oneliner {my($self,$cmd,$switches)=@_;$switches=[]unless defined$switches;$cmd =~ s{^\n+}{};$cmd =~ s{\n+$}{};$cmd=$self->quote_literal($cmd);$cmd=$self->escape_newlines($cmd);$switches=join ' ',map {qq{"$_"}}@$switches;return qq{\$(ABSPERLRUN) $switches -e $cmd "--"}}sub echo {my($self,$text,$file,$opts)=@_;if(!ref$opts){my$append=$opts;$opts={append=>$append || 0 }}my$opencmd=$opts->{append}? 'Open/Append' : 'Open/Write';$opts->{allow_variables}=0 unless defined$opts->{allow_variables};my$ql_opts={allow_variables=>$opts->{allow_variables}};my@cmds=("\$(NOECHO) $opencmd MMECHOFILE $file ");push@cmds,map {'$(NOECHO) Write MMECHOFILE '.$self->quote_literal($_,$ql_opts)}split /\n/,$text;push@cmds,'$(NOECHO) Close MMECHOFILE';return@cmds}sub quote_literal {my($self,$text,$opts)=@_;$opts->{allow_variables}=1 unless defined$opts->{allow_variables};$text =~ s{"}{""}g;$text=$opts->{allow_variables}? $self->escape_dollarsigns($text): $self->escape_all_dollarsigns($text);return qq{"$text"}}sub escape_dollarsigns {my($self,$text)=@_;$text =~ s{\$ (?!\() }{"\$"}gx;return$text}sub escape_all_dollarsigns {my($self,$text)=@_;$text =~ s{\$}{"\$\"}gx;return$text}sub escape_newlines {my($self,$text)=@_;$text =~ s{\n}{-\n}g;return$text}sub max_exec_len {my$self=shift;return$self->{_MAX_EXEC_LEN}||= 256}sub init_linker {my$self=shift;$self->{EXPORT_LIST}||= '$(BASEEXT).opt';my$shr=$Config{dbgprefix}.'PERLSHR';if ($self->{PERL_SRC}){$self->{PERL_ARCHIVE}||= $self->catfile($self->{PERL_SRC},"$shr.$Config{'dlext'}")}else {$self->{PERL_ARCHIVE}||= $ENV{$shr}? $ENV{$shr}: "Sys\$Share:$shr.$Config{'dlext'}"}$self->{PERL_ARCHIVE_AFTER}||= ''}sub catdir {my$self=shift;my@args=map {m{\$\(} ? $self->eliminate_macros($_): $_}@_;my$dir=$self->SUPER::catdir(@args);$dir=$self->fixpath($dir,1);return$dir}sub catfile {my$self=shift;my@args=map {m{\$\(} ? $self->eliminate_macros($_): $_}@_;my$file=$self->SUPER::catfile(@args);$file=vmsify($file);return$file}sub eliminate_macros {my($self,$path)=@_;return '' unless$path;$self={}unless ref$self;if ($path =~ /\s/){return join ' ',map {$self->eliminate_macros($_)}split /\s+/,$path}my($npath)=unixify($path);$npath =~ s{\0$}{};my($complex)=0;my($head,$macro,$tail);while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs){if (defined$self->{$2}){($head,$macro,$tail)=($1,$2,$3);if (ref$self->{$macro}){if (ref$self->{$macro}eq 'ARRAY'){$macro=join ' ',@{$self->{$macro}}}else {print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),"\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";$macro="\cB$macro\cB";$complex=1}}else {($macro=unixify($self->{$macro}))=~ s#/\Z(?!\n)##}$npath="$head$macro$tail"}}if ($complex){$npath =~ s#\cB(.*?)\cB#\${$1}#gs}$npath}sub fixpath {my($self,$path,$force_path)=@_;return '' unless$path;$self=bless {},$self unless ref$self;my($fixedpath,$prefix,$name);if ($path =~ /[ \t]/){return join ' ',map {$self->fixpath($_,$force_path)}split /[ \t]+/,$path}if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#){if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/){$fixedpath=vmspath($self->eliminate_macros($path))}else {$fixedpath=vmsify($self->eliminate_macros($path))}}elsif ((($prefix,$name)=($path =~ m#^\$\(([^\)]+)\)(.+)#s))&& $self->{$prefix}){my($vmspre)=$self->eliminate_macros("\$($prefix)");$vmspre=($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/)? vmspath($vmspre): '';$fixedpath=($vmspre ? $vmspre : $self->{$prefix}).$name;$fixedpath=vmspath($fixedpath)if$force_path}else {$fixedpath=$path;$fixedpath=vmspath($fixedpath)if$force_path}if (!defined($force_path)and $fixedpath !~ /[:>(.\]]/){$fixedpath=vmspath($fixedpath)if -d $fixedpath}$fixedpath =~ s/\.000000([\]>])/$1/;if ($path =~ /^[\[>][^.\-]/){$fixedpath =~ s/^[^\[<]+//}return$fixedpath}sub os_flavor {return('VMS')}1;
  startdir = F$Environment("Default")
  	Set Default %s
  	%s
  	Set Default 'startdir'
  MAKE_FRAG
EXTUTILS_MM_VMS

$fatpacked{"ExtUtils/MM_VOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_VOS';
  package ExtUtils::MM_VOS;use strict;our$VERSION='6.66';require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Unix);sub extra_clean_files {return qw(*.kp)}1;
EXTUTILS_MM_VOS

$fatpacked{"ExtUtils/MM_Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_WIN32';
  package ExtUtils::MM_Win32;use strict;use ExtUtils::MakeMaker::Config;use File::Basename;use File::Spec;use ExtUtils::MakeMaker qw(neatvalue);require ExtUtils::MM_Any;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Any ExtUtils::MM_Unix);our$VERSION='6.66';$ENV{EMXSHELL}='sh';my ($BORLAND,$GCC,$DLLTOOL)=_identify_compiler_environment(\%Config);sub _identify_compiler_environment {my ($config)=@_;my$BORLAND=$config->{cc}=~ /^bcc/i ? 1 : 0;my$GCC=$config->{cc}=~ /\bgcc\b/i ? 1 : 0;my$DLLTOOL=$config->{dlltool}|| 'dlltool';return ($BORLAND,$GCC,$DLLTOOL)}sub dlsyms {my($self,%attribs)=@_;my($funcs)=$attribs{DL_FUNCS}|| $self->{DL_FUNCS}|| {};my($vars)=$attribs{DL_VARS}|| $self->{DL_VARS}|| [];my($funclist)=$attribs{FUNCLIST}|| $self->{FUNCLIST}|| [];my($imports)=$attribs{IMPORTS}|| $self->{IMPORTS}|| {};my(@m);if (not $self->{SKIPHASH}{'dynamic'}){push(@m,"
  $self->{BASEEXT}.def: Makefile.PL
  ",q!	$(PERLRUN) -MExtUtils::Mksymlists \\
       -e "Mksymlists('NAME'=>\"!,$self->{NAME},q!\", 'DLBASE' => '!,$self->{DLBASE},q!', 'DL_FUNCS' => !,neatvalue($funcs),q!, 'FUNCLIST' => !,neatvalue($funclist),q!, 'IMPORTS' => !,neatvalue($imports),q!, 'DL_VARS' => !,neatvalue($vars),q!);"
  !)}join('',@m)}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s,/+,.,g;$man}sub maybe_command {my($self,$file)=@_;my@e=exists($ENV{'PATHEXT'})? split(/;/,$ENV{PATHEXT}): qw(.com .exe .bat .cmd);my$e='';for (@e){$e .= "\Q$_\E|"}chop$e;if ($file =~ /($e)$/i){return$file if -e $file}else {for (@e){return "$file$_" if -e "$file$_"}}return}sub init_DIRFILESEP {my($self)=shift;$self->{DIRFILESEP}=$self->is_make_type('nmake')? '^\\' : $self->is_make_type('dmake')? '\\\\' : '\\'}sub init_tools {my ($self)=@_;$self->{NOOP}||= 'rem';$self->{DEV_NULL}||= '> NUL';$self->{FIXIN}||= $self->{PERL_CORE}? "\$(PERLRUN) $self->{PERL_SRC}/win32/bin/pl2bat.pl" : 'pl2bat.bat';$self->SUPER::init_tools;delete$self->{SHELL};return}sub init_others {my$self=shift;$self->{LD}||= 'link';$self->{AR}||= 'lib';$self->SUPER::init_others;$self->{LDLOADLIBS}||= $Config{libs};if ($BORLAND){my$libs=$self->{LDLOADLIBS};my$libpath='';while ($libs =~ s/(?:^|\s)(("?)-L.+?\2)(?:\s|$)/ /){$libpath .= ' ' if length$libpath;$libpath .= $1}$self->{LDLOADLIBS}=$libs;$self->{LDDLFLAGS}||= $Config{lddlflags};$self->{LDDLFLAGS}.= " $libpath"}return}sub init_platform {my($self)=shift;$self->{MM_Win32_VERSION}=$VERSION;return}sub platform_constants {my($self)=shift;my$make_frag='';for my$macro (qw(MM_Win32_VERSION)){next unless defined$self->{$macro};$make_frag .= "$macro = $self->{$macro}\n"}return$make_frag}sub constants {my$self=shift;my$make_text=$self->SUPER::constants;return$make_text unless$self->is_make_type('dmake');my$size=$self->{MAXLINELENGTH}|| 64 * 1024;my$prefix=qq{
  # Get dmake to read long commands like PM_TO_BLIB
  MAXLINELENGTH = $size
  
  };return$prefix .$make_text}sub special_targets {my($self)=@_;my$make_frag=$self->SUPER::special_targets;$make_frag .= <<'MAKE_FRAG' if$self->is_make_type('dmake');return$make_frag}sub static_lib {my($self)=@_;return '' unless$self->has_link_code;my(@m);push(@m,<<'END');push@m,<<'MAKE_FRAG' if$self->{MYEXTLIB};push@m,q{	$(AR) }.($BORLAND ? '$@ $(OBJECT:^"+")' : ($GCC ? '-ru $@ $(OBJECT)' : '-out:$@ $(OBJECT)')).q{
  .USESHELL :
  MAKE_FRAG
  $(INST_STATIC): $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DFSEP).exists
  	$(RM_RF) $@
  END
  	$(CP) $(MYEXTLIB) $@
  MAKE_FRAG
  	$(CHMOD) $(PERM_RWX) $@
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" > $(INST_ARCHAUTODIR)\extralibs.ld
  };push@m,<<'MAKE_FRAG' if$self->{PERL_SRC}&& $self->{EXTRALIBS};join('',@m)}sub dynamic_lib {my($self,%attribs)=@_;return '' unless$self->needs_linking();return '' unless$self->has_link_code;my($otherldflags)=$attribs{OTHERLDFLAGS}|| ($BORLAND ? 'c0d32.obj': '');my($inst_dynamic_dep)=$attribs{INST_DYNAMIC_DEP}|| "";my($ldfrom)='$(LDFROM)';my(@m);push(@m,'
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" >> $(PERL_SRC)\ext.libs
  MAKE_FRAG
  # This section creates the dynamically loadable $(INST_DYNAMIC)
  # from $(OBJECT) and possibly $(MYEXTLIB).
  OTHERLDFLAGS = '.$otherldflags.'
  INST_DYNAMIC_DEP = '.$inst_dynamic_dep.'
  
  $(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DFSEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
  ');if ($GCC){push(@m,q{	}.$DLLTOOL.q{ --def $(EXPORT_LIST) --output-exp dll.exp
  	$(LD) -o $@ -Wl,--base-file -Wl,dll.base $(LDDLFLAGS) }.$ldfrom.q{ $(OTHERLDFLAGS) $(MYEXTLIB) $(PERL_ARCHIVE) $(LDLOADLIBS) dll.exp
  	}.$DLLTOOL.q{ --def $(EXPORT_LIST) --base-file dll.base --output-exp dll.exp
  	$(LD) -o $@ $(LDDLFLAGS) }.$ldfrom.q{ $(OTHERLDFLAGS) $(MYEXTLIB) $(PERL_ARCHIVE) $(LDLOADLIBS) dll.exp })}elsif ($BORLAND){push(@m,q{	$(LD) $(LDDLFLAGS) $(OTHERLDFLAGS) }.$ldfrom.q{,$@,,} .($self->is_make_type('dmake')? q{$(PERL_ARCHIVE:s,/,\,) $(LDLOADLIBS:s,/,\,) } .q{$(MYEXTLIB:s,/,\,),$(EXPORT_LIST:s,/,\,)} : q{$(subst /,\,$(PERL_ARCHIVE)) $(subst /,\,$(LDLOADLIBS)) } .q{$(subst /,\,$(MYEXTLIB)),$(subst /,\,$(EXPORT_LIST))}).q{,$(RESFILES)})}else {push(@m,q{	$(LD) -out:$@ $(LDDLFLAGS) }.$ldfrom.q{ $(OTHERLDFLAGS) } .q{$(MYEXTLIB) $(PERL_ARCHIVE) $(LDLOADLIBS) -def:$(EXPORT_LIST)});push(@m,q{
  	if exist $@.manifest mt -nologo -manifest $@.manifest -outputresource:$@;2
  	if exist $@.manifest del $@.manifest})}push@m,'
  	$(CHMOD) $(PERM_RWX) $@
  ';join('',@m)}sub extra_clean_files {my$self=shift;return$GCC ? (qw(dll.base dll.exp)): ('*.pdb')}sub init_linker {my$self=shift;$self->{PERL_ARCHIVE}="\$(PERL_INC)\\$Config{libperl}";$self->{PERL_ARCHIVE_AFTER}='';$self->{EXPORT_LIST}='$(BASEEXT).def'}sub perl_script {my($self,$file)=@_;return$file if -r $file && -f _;return "$file.pl" if -r "$file.pl" && -f _;return "$file.plx" if -r "$file.plx" && -f _;return "$file.bat" if -r "$file.bat" && -f _;return}sub xs_o {return ''}sub pasthru {my($self)=shift;return "PASTHRU = " .($self->is_make_type('nmake')? "-nologo" : "")}sub arch_check {my$self=shift;return 1 unless$self->can_load_xs;return$self->SUPER::arch_check(map {$self->_normalize_path_name($_)}@_)}sub _normalize_path_name {my$self=shift;my$file=shift;require Win32;my$short=Win32::GetShortPathName($file);return defined$short ? lc$short : lc$file}sub oneliner {my($self,$cmd,$switches)=@_;$switches=[]unless defined$switches;$cmd =~ s{^\n+}{};$cmd =~ s{\n+$}{};$cmd=$self->quote_literal($cmd);$cmd=$self->escape_newlines($cmd);$switches=join ' ',@$switches;return qq{\$(ABSPERLRUN) $switches -e $cmd --}}sub quote_literal {my($self,$text,$opts)=@_;$opts->{allow_variables}=1 unless defined$opts->{allow_variables};$text =~ s{\\\\"}{\\\\\\\\\\"}g;$text =~ s{(?<!\\)\\"}{\\\\\\"}g;$text =~ s{(?<!\\)"}{\\"}g;$text=qq{"$text"} if$text =~ /[ \t]/;my@text=split /("[^"]*")/,$text;s{([<>|&^@!])}{^$1}g foreach grep {!/^"[^"]*"$/}@text;$text=join('',@text);if($self->is_make_type('dmake')){$text =~ s/{/{{/g;$text =~ s/}/}}/g}$text=$opts->{allow_variables}? $self->escape_dollarsigns($text): $self->escape_all_dollarsigns($text);return$text}sub escape_newlines {my($self,$text)=@_;$text =~ s{\n}{\\\n}g;return$text}sub cd {my($self,$dir,@cmds)=@_;return$self->SUPER::cd($dir,@cmds)unless$self->is_make_type('nmake');my$cmd=join "\n\t",map "$_",@cmds;my$updirs=$self->catdir(map {$self->updir}$self->splitdir($dir));my$make_frag=sprintf <<'MAKE_FRAG',$dir,$cmd,$updirs;chomp$make_frag;return$make_frag}sub max_exec_len {my$self=shift;return$self->{_MAX_EXEC_LEN}||= 2 * 1024}sub os_flavor {return('Win32')}sub cflags {my($self,$libperl)=@_;return$self->{CFLAGS}if$self->{CFLAGS};return '' unless$self->needs_linking();my$base=$self->SUPER::cflags($libperl);for (split /\n/,$base){/^(\S*)\s*=\s*(\S*)$/ and $self->{$1}=$2};$self->{CCFLAGS}.= " -DPERLDLL" if ($self->{LINKTYPE}eq 'static');return$self->{CFLAGS}=qq{
  cd %s
  	%s
  	cd %s
  MAKE_FRAG
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  }}sub is_make_type {my($self,$type)=@_;return!!($self->make =~ /\b$type(?:\.exe)?$/)}1;
EXTUTILS_MM_WIN32

$fatpacked{"ExtUtils/MM_Win95.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_WIN95';
  package ExtUtils::MM_Win95;use strict;our$VERSION='6.66';require ExtUtils::MM_Win32;our@ISA=qw(ExtUtils::MM_Win32);use ExtUtils::MakeMaker::Config;sub xs_c {my($self)=shift;return '' unless$self->needs_linking();'
  .xs.c:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.c
  	'}sub xs_cpp {my($self)=shift;return '' unless$self->needs_linking();'
  .xs.cpp:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.cpp
  	'}sub xs_o {my($self)=shift;return '' unless$self->needs_linking();'
  .xs$(OBJ_EXT):
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.c
  	$(CCCMD) $(CCCDLFLAGS) -I$(PERL_INC) $(DEFINE) $*.c
  	'}sub max_exec_len {my$self=shift;return$self->{_MAX_EXEC_LEN}||= 1024}sub os_flavor {my$self=shift;return ($self->SUPER::os_flavor,'Win9x')}1;
EXTUTILS_MM_WIN95

$fatpacked{"ExtUtils/MY.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MY';
  package ExtUtils::MY;use strict;require ExtUtils::MM;our$VERSION='6.66';our@ISA=qw(ExtUtils::MM);{package MY;our@ISA=qw(ExtUtils::MY)}sub DESTROY {}
EXTUTILS_MY

$fatpacked{"ExtUtils/MakeMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER';
  package ExtUtils::MakeMaker;use strict;BEGIN {require 5.006}require Exporter;use ExtUtils::MakeMaker::Config;use Carp;use File::Path;our$Verbose=0;our@Parent;our@Get_from_Config;our@MM_Sections;our@Overridable;my@Prepend_parent;my%Recognized_Att_Keys;our$VERSION='6.66';$VERSION=eval$VERSION;(our$Revision=$VERSION)=~ s{_}{};$Revision=int$Revision * 10000;our$Filename=__FILE__;our@ISA=qw(Exporter);our@EXPORT=qw(&WriteMakefile &writeMakefile $Verbose &prompt);our@EXPORT_OK=qw($VERSION &neatvalue &mkbootstrap &mksymlists &WriteEmptyMakefile);my$Is_VMS=$^O eq 'VMS';my$Is_Win32=$^O eq 'MSWin32';full_setup();require ExtUtils::MM;require ExtUtils::MY;sub WriteMakefile {croak "WriteMakefile: Need even number of args" if @_ % 2;require ExtUtils::MY;my%att=@_;_convert_compat_attrs(\%att);_verify_att(\%att);my$mm=MM->new(\%att);$mm->flush;return$mm}my%Att_Sigs;my%Special_Sigs=(AUTHOR=>'ARRAY',C=>'ARRAY',CONFIG=>'ARRAY',CONFIGURE=>'CODE',DIR=>'ARRAY',DL_FUNCS=>'HASH',DL_VARS=>'ARRAY',EXCLUDE_EXT=>'ARRAY',EXE_FILES=>'ARRAY',FUNCLIST=>'ARRAY',H=>'ARRAY',IMPORTS=>'HASH',INCLUDE_EXT=>'ARRAY',LIBS=>['ARRAY',''],MAN1PODS=>'HASH',MAN3PODS=>'HASH',META_ADD=>'HASH',META_MERGE=>'HASH',PL_FILES=>'HASH',PM=>'HASH',PMLIBDIRS=>'ARRAY',PMLIBPARENTDIRS=>'ARRAY',PREREQ_PM=>'HASH',BUILD_REQUIRES=>'HASH',CONFIGURE_REQUIRES=>'HASH',TEST_REQUIRES=>'HASH',SKIP=>'ARRAY',TYPEMAPS=>'ARRAY',XS=>'HASH',VERSION=>['version',''],_KEEP_AFTER_FLUSH=>'',clean=>'HASH',depend=>'HASH',dist=>'HASH',dynamic_lib=>'HASH',linkext=>'HASH',macro=>'HASH',postamble=>'HASH',realclean=>'HASH',test=>'HASH',tool_autosplit=>'HASH',);@Att_Sigs{keys%Recognized_Att_Keys}=('')x keys%Recognized_Att_Keys;@Att_Sigs{keys%Special_Sigs}=values%Special_Sigs;sub _convert_compat_attrs {my($att)=@_;if (exists$att->{AUTHOR}){if ($att->{AUTHOR}){if (!ref($att->{AUTHOR})){my$t=$att->{AUTHOR};$att->{AUTHOR}=[$t]}}else {$att->{AUTHOR}=[]}}}sub _verify_att {my($att)=@_;while(my($key,$val)=each %$att){my$sig=$Att_Sigs{$key};unless(defined$sig){warn "WARNING: $key is not a known parameter.\n";next}my@sigs=ref$sig ? @$sig : $sig;my$given=ref$val;unless(grep {_is_of_type($val,$_)}@sigs){my$takes=join " or ",map {_format_att($_)}@sigs;my$has=_format_att($given);warn "WARNING: $key takes a $takes not a $has.\n"."         Please inform the author.\n"}}}sub _is_of_type {my($thing,$type)=@_;return 1 if ref$thing eq $type;local$SIG{__DIE__};return 1 if eval{$thing->isa($type)};return 0}sub _format_att {my$given=shift;return$given eq '' ? "string/number" : uc$given eq $given ? "$given reference" : "$given object" }sub prompt ($;$) {my($mess,$def)=@_;confess("prompt function called without an argument")unless defined$mess;my$isa_tty=-t STDIN && (-t STDOUT ||!(-f STDOUT || -c STDOUT));my$dispdef=defined$def ? "[$def] " : " ";$def=defined$def ? $def : "";local $|=1;local $\;print "$mess $dispdef";my$ans;if ($ENV{PERL_MM_USE_DEFAULT}|| (!$isa_tty && eof STDIN)){print "$def\n"}else {$ans=<STDIN>;if(defined$ans){chomp$ans}else {print "\n"}}return (!defined$ans || $ans eq '')? $def : $ans}sub eval_in_subdirs {my($self)=@_;use Cwd qw(cwd abs_path);my$pwd=cwd()|| die "Can't figure out your cwd!";local@INC=map eval {abs_path($_)if -e}|| $_,@INC;push@INC,'.';for my$dir (@{$self->{DIR}}){my($abs)=$self->catdir($pwd,$dir);eval {$self->eval_in_x($abs)};last if $@}chdir$pwd;die $@ if $@}sub eval_in_x {my($self,$dir)=@_;chdir$dir or carp("Couldn't change to directory $dir: $!");{package main;do './Makefile.PL'};if ($@){die "ERROR from evaluation of $dir/Makefile.PL: $@"}}my$PACKNAME='PACK000';sub full_setup {$Verbose ||= 0;my@attrib_help=qw/AUTHOR ABSTRACT ABSTRACT_FROM BINARY_LOCATION C CAPI CCFLAGS CONFIG CONFIGURE DEFINE DIR DISTNAME DISTVNAME DL_FUNCS DL_VARS EXCLUDE_EXT EXE_FILES FIRST_MAKEFILE FULLPERL FULLPERLRUN FULLPERLRUNINST FUNCLIST H IMPORTS INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB INST_MAN1DIR INST_MAN3DIR INSTALLDIRS DESTDIR PREFIX INSTALL_BASE PERLPREFIX SITEPREFIX VENDORPREFIX INSTALLPRIVLIB INSTALLSITELIB INSTALLVENDORLIB INSTALLARCHLIB INSTALLSITEARCH INSTALLVENDORARCH INSTALLBIN INSTALLSITEBIN INSTALLVENDORBIN INSTALLMAN1DIR INSTALLMAN3DIR INSTALLSITEMAN1DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN1DIR INSTALLVENDORMAN3DIR INSTALLSCRIPT INSTALLSITESCRIPT INSTALLVENDORSCRIPT PERL_LIB PERL_ARCHLIB SITELIBEXP SITEARCHEXP INC INCLUDE_EXT LDFROM LIB LIBPERL_A LIBS LICENSE LINKTYPE MAKE MAKEAPERL MAKEFILE MAKEFILE_OLD MAN1PODS MAN3PODS MAP_TARGET META_ADD META_MERGE MIN_PERL_VERSION BUILD_REQUIRES CONFIGURE_REQUIRES MYEXTLIB NAME NEEDS_LINKING NOECHO NO_META NO_MYMETA NORECURS NO_VC OBJECT OPTIMIZE PERL_MALLOC_OK PERL PERLMAINCC PERLRUN PERLRUNINST PERL_CORE PERL_SRC PERM_DIR PERM_RW PERM_RWX PL_FILES PM PM_FILTER PMLIBDIRS PMLIBPARENTDIRS POLLUTE PPM_INSTALL_EXEC PPM_INSTALL_SCRIPT PREREQ_FATAL PREREQ_PM PREREQ_PRINT PRINT_PREREQ SIGN SKIP TEST_REQUIRES TYPEMAPS VERSION VERSION_FROM XS XSOPT XSPROTOARG XS_VERSION clean depend dist dynamic_lib linkext macro realclean tool_autosplit MACPERL_SRC MACPERL_LIB MACLIBS_68K MACLIBS_PPC MACLIBS_SC MACLIBS_MRC MACLIBS_ALL_68K MACLIBS_ALL_PPC MACLIBS_SHARED/;@MM_Sections=qw(post_initialize const_config constants platform_constants tool_autosplit tool_xsubpp tools_other makemakerdflt dist macro depend cflags const_loadlibs const_cccmd post_constants pasthru special_targets c_o xs_c xs_o top_targets blibdirs linkext dlsyms dynamic dynamic_bs dynamic_lib static static_lib manifypods processPL installbin subdirs clean_subdirs clean realclean_subdirs realclean metafile signature dist_basics dist_core distdir dist_test dist_ci distmeta distsignature install force perldepend makefile staticmake test ppd);@Overridable=@MM_Sections;push@Overridable,qw[libscan makeaperl needs_linking subdir_x test_via_harness test_via_script init_VERSION init_dist init_INST init_INSTALL init_DEST init_dirscan init_PM init_MANPODS init_xs init_PERL init_DIRFILESEP init_linker];push@MM_Sections,qw[pm_to_blib selfdocument];push@MM_Sections,"postamble";push@Overridable,"postamble";@Recognized_Att_Keys{@MM_Sections}=(1)x @MM_Sections;@Get_from_Config=qw(ar cc cccdlflags ccdlflags dlext dlsrc exe_ext full_ar ld lddlflags ldflags libc lib_ext obj_ext osname osvers ranlib sitelibexp sitearchexp so);push@Get_from_Config,qw(vendorarchexp vendorlibexp) if $] >= 5.006;for my$item (@attrib_help){$Recognized_Att_Keys{$item}=1}for my$item (@Get_from_Config){$Recognized_Att_Keys{uc$item}=$Config{$item};print "Attribute '\U$item\E' => '$Config{$item}'\n" if ($Verbose >= 2)}@Prepend_parent=qw(INST_BIN INST_LIB INST_ARCHLIB INST_SCRIPT MAP_TARGET INST_MAN1DIR INST_MAN3DIR PERL_SRC PERL FULLPERL)}sub writeMakefile {die <<END}sub new {my($class,$self)=@_;my($key);_convert_compat_attrs($self)if defined$self && $self;for my$k (keys %$self){$self->{ARGS}{$k}=$self->{$k}}$self={}unless defined$self;bless$self,"MM";for my$key (qw(PREREQ_PM BUILD_REQUIRES CONFIGURE_REQUIRES TEST_REQUIRES)){$self->{$key}||= {};$self->clean_versions($key)}if ("@ARGV" =~ /\bPREREQ_PRINT\b/){$self->_PREREQ_PRINT}if ("@ARGV" =~ /\bPRINT_PREREQ\b/){$self->_PRINT_PREREQ}print "MakeMaker (v$VERSION)\n" if$Verbose;if (-f "MANIFEST" &&!-f "Makefile" &&!$ENV{PERL_CORE}){check_manifest()}check_hints($self);if(defined$self->{MIN_PERL_VERSION}){$self->{MIN_PERL_VERSION}=~ s{ ^ (\d+) \. (\d+) \. (\d+) $ }
  
  The extension you are trying to build apparently is rather old and
  most probably outdated. We detect that from the fact, that a
  subroutine "writeMakefile" is called, and this subroutine is not
  supported anymore since about October 1994.
  
  Please contact the author or look into CPAN (details about CPAN can be
  found in the FAQ and at http:/www.perl.com) for a more recent version
  of the extension. If you're really desperate, you can try to change
  the subroutine name from writeMakefile to WriteMakefile and rerun
  'perl Makefile.PL', but you're most probably left alone, when you do
  so.
  
  The MakeMaker team
  
  END
                                        {sprintf "%d.%03d%03d", $1, $2, $3}ex}my$perl_version_ok=eval {local$SIG{__WARN__}=sub {die @_};!$self->{MIN_PERL_VERSION}or $self->{MIN_PERL_VERSION}<= $]};if (!$perl_version_ok){if (!defined$perl_version_ok){die <<'END'}elsif ($self->{PREREQ_FATAL}){die sprintf <<"END",$self->{MIN_PERL_VERSION},$]}else {warn sprintf "Warning: Perl version %s or higher required. We run %s.\n",$self->{MIN_PERL_VERSION},$]}}my%configure_att;my(%initial_att)=%$self;my(%unsatisfied)=();my$prereqs=$self->_all_prereqs;for my$prereq (sort keys %$prereqs){my$required_version=$prereqs->{$prereq};my$installed_file=MM->_installed_file_for_module($prereq);my$pr_version=0;$pr_version=MM->parse_version($installed_file)if$installed_file;$pr_version=0 if$pr_version eq 'undef';$pr_version =~ s/(\d+)\.(\d+)_(\d+)/$1.$2$3/;if (!$installed_file){warn sprintf "Warning: prerequisite %s %s not found.\n",$prereq,$required_version unless$self->{PREREQ_FATAL}or $ENV{PERL_CORE};$unsatisfied{$prereq}='not installed'}elsif ($pr_version < $required_version){warn sprintf "Warning: prerequisite %s %s not found. We have %s.\n",$prereq,$required_version,($pr_version || 'unknown version')unless$self->{PREREQ_FATAL}or $ENV{PERL_CORE};$unsatisfied{$prereq}=$required_version ? $required_version : 'unknown version' }}if (%unsatisfied && $self->{PREREQ_FATAL}){my$failedprereqs=join "\n",map {"    $_ $unsatisfied{$_}"}sort {$a cmp $b}keys%unsatisfied;die <<"END"}if (defined$self->{CONFIGURE}){if (ref$self->{CONFIGURE}eq 'CODE'){%configure_att=%{&{$self->{CONFIGURE}}};_convert_compat_attrs(\%configure_att);$self={%$self,%configure_att }}else {croak "Attribute 'CONFIGURE' to WriteMakefile() not a code reference\n"}}if (Carp::longmess("")=~ /runsubdirpl/s){carp("WARNING: Please rerun 'perl Makefile.PL' to regenerate your Makefiles\n")}my$newclass=++$PACKNAME;local@Parent=@Parent;{print "Blessing Object into class [$newclass]\n" if$Verbose>=2;mv_all_methods("MY",$newclass);bless$self,$newclass;push@Parent,$self;require ExtUtils::MY;no strict 'refs';@{"$newclass\:\:ISA"}='MM'}if (defined$Parent[-2]){$self->{PARENT}=$Parent[-2];for my$key (@Prepend_parent){next unless defined$self->{PARENT}{$key};next if defined$self->{ARGS}{$key}and $self->{ARGS}{$key}eq $self->{$key};$self->{$key}=$self->{PARENT}{$key};unless ($Is_VMS && $key =~ /PERL$/){$self->{$key}=$self->catdir("..",$self->{$key})unless$self->file_name_is_absolute($self->{$key})}else {my@cmd=split /\s+/,$self->{$key};$cmd[1]=$self->catfile('[-]',$cmd[1])unless (@cmd < 2)|| $self->file_name_is_absolute($cmd[1]);$self->{$key}=join(' ',@cmd)}}if ($self->{PARENT}){$self->{PARENT}->{CHILDREN}->{$newclass}=$self;for my$opt (qw(POLLUTE PERL_CORE LINKTYPE)){if (exists$self->{PARENT}->{$opt}and not exists$self->{$opt}){$self->{$opt}=$self->{PARENT}->{$opt}}}}my@fm=grep /^FIRST_MAKEFILE=/,@ARGV;parse_args($self,@fm)if@fm}else {parse_args($self,split(' ',$ENV{PERL_MM_OPT}|| ''),@ARGV)}$self->{NAME}||= $self->guess_name;($self->{NAME_SYM}=$self->{NAME})=~ s/\W+/_/g;$self->init_MAKE;$self->init_main;$self->init_VERSION;$self->init_dist;$self->init_INST;$self->init_INSTALL;$self->init_DEST;$self->init_dirscan;$self->init_PM;$self->init_MANPODS;$self->init_xs;$self->init_PERL;$self->init_DIRFILESEP;$self->init_linker;$self->init_ABSTRACT;$self->arch_check($INC{'Config.pm'},$self->catfile($Config{'archlibexp'},"Config.pm"));$self->init_tools();$self->init_others();$self->init_platform();$self->init_PERM();my($argv)=neatvalue(\@ARGV);$argv =~ s/^\[/(/;$argv =~ s/\]$/)/;push @{$self->{RESULT}},<<END;push @{$self->{RESULT}},$self->_MakeMaker_Parameters_section(\%initial_att);if (defined$self->{CONFIGURE}){push @{$self->{RESULT}},<<END;if (scalar(keys%configure_att)> 0){for my$key (sort keys%configure_att){next if$key eq 'ARGS';my($v)=neatvalue($configure_att{$key});$v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;$v =~ tr/\n/ /s;push @{$self->{RESULT}},"#     $key => $v"}}else {push @{$self->{RESULT}},"# no values returned"}undef%configure_att}for my$skip (@{$self->{SKIP}|| []}){$self->{SKIPHASH}{$skip}=1}delete$self->{SKIP};if ($self->{PARENT}){for (qw/install dist dist_basics dist_core distdir dist_test dist_ci/){$self->{SKIPHASH}{$_}=1}}unless ($self->{NORECURS}){$self->eval_in_subdirs if @{$self->{DIR}}}for my$section (@MM_Sections){my$method=$section;$method .= '_target' unless$self->can($method);print "Processing Makefile '$section' section\n" if ($Verbose >= 2);my($skipit)=$self->skipcheck($section);if ($skipit){push @{$self->{RESULT}},"\n# --- MakeMaker $section section $skipit."}else {my(%a)=%{$self->{$section}|| {}};push @{$self->{RESULT}},"\n# --- MakeMaker $section section:";push @{$self->{RESULT}},"# " .join ", ",%a if$Verbose && %a;push @{$self->{RESULT}},$self->maketext_filter($self->$method(%a))}}push @{$self->{RESULT}},"\n# End.";$self}sub WriteEmptyMakefile {croak "WriteEmptyMakefile: Need an even number of args" if @_ % 2;my%att=@_;my$self=MM->new(\%att);my$new=$self->{MAKEFILE};my$old=$self->{MAKEFILE_OLD};if (-f $old){_unlink($old)or warn "unlink $old: $!"}if (-f $new){_rename($new,$old)or warn "rename $new => $old: $!"}open my$mfh,'>',$new or die "open $new for write: $!";print$mfh <<'EOP';close$mfh or die "close $new for write: $!"}sub _installed_file_for_module {my$class=shift;my$prereq=shift;my$file="$prereq.pm";$file =~ s{::}{/}g;my$path;for my$dir (@INC){my$tmp=File::Spec->catfile($dir,$file);if (-r $tmp){$path=$tmp;last}}return$path}sub _MakeMaker_Parameters_section {my$self=shift;my$att=shift;my@result=<<'END';for my$key (sort keys %$att){next if$key eq 'ARGS';my ($v)=neatvalue($att->{$key});if ($key eq 'PREREQ_PM'){$v=neatvalue({%{$att->{PREREQ_PM}|| {}},%{$att->{BUILD_REQUIRES}|| {}},%{$att->{TEST_REQUIRES}|| {}},})}else {$v=neatvalue($att->{$key})}$v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;$v =~ tr/\n/ /s;push@result,"#     $key => $v"}return@result}sub check_manifest {print "Checking if your kit is complete...\n";require ExtUtils::Manifest;$ExtUtils::Manifest::Quiet=$ExtUtils::Manifest::Quiet=1;my(@missed)=ExtUtils::Manifest::manicheck();if (@missed){print "Warning: the following files are missing in your kit:\n";print "\t",join "\n\t",@missed;print "\n";print "Please inform the author.\n"}else {print "Looks good\n"}}sub parse_args{my($self,@args)=@_;for (@args){unless (m/(.*?)=(.*)/){++$Verbose if m/^verb/;next}my($name,$value)=($1,$2);if ($value =~ m/^~(\w+)?/){$value =~ s [^~(\w*)]
  Warning: MIN_PERL_VERSION is not in a recognized format.
  Recommended is a quoted numerical value like '5.005' or '5.008001'.
  END
  MakeMaker FATAL: perl version too low for this distribution.
  Required is %s. We run %s.
  END
  MakeMaker FATAL: prerequisites not found.
  $failedprereqs
  
  Please install these modules first and rerun 'perl Makefile.PL'.
  END
  # This Makefile is for the $self->{NAME} extension to perl.
  #
  # It was generated automatically by MakeMaker version
  # $VERSION (Revision: $Revision) from the contents of
  # Makefile.PL. Don't edit this file, edit Makefile.PL instead.
  #
  #       ANY CHANGES MADE HERE WILL BE LOST!
  #
  #   MakeMaker ARGV: $argv
  #
  END
  
  #   MakeMaker 'CONFIGURE' Parameters:
  END
  all :
  
  clean :
  
  install :
  
  makemakerdflt :
  
  test :
  
  EOP
  #   MakeMaker Parameters:
  END
                  [$1 ?
                   ((getpwnam($1))[7] || "~$1") :
                   (getpwuid($>))[7]
                   ]ex}$self->{ARGS}{uc$name}=$self->{uc$name}=$value}if (defined$self->{potential_libs}){my($msg)="'potential_libs' => '$self->{potential_libs}' should be";if ($self->{potential_libs}){print "$msg changed to:\n\t'LIBS' => ['$self->{potential_libs}']\n"}else {print "$msg deleted.\n"}$self->{LIBS}=[$self->{potential_libs}];delete$self->{potential_libs}}if (defined$self->{ARMAYBE}){my($armaybe)=$self->{ARMAYBE};print "ARMAYBE => '$armaybe' should be changed to:\n","\t'dynamic_lib' => {ARMAYBE => '$armaybe'}\n";my(%dl)=%{$self->{dynamic_lib}|| {}};$self->{dynamic_lib}={%dl,ARMAYBE=>$armaybe};delete$self->{ARMAYBE}}if (defined$self->{LDTARGET}){print "LDTARGET should be changed to LDFROM\n";$self->{LDFROM}=$self->{LDTARGET};delete$self->{LDTARGET}}if (defined$self->{DIR}&& ref \$self->{DIR}eq 'SCALAR'){$self->{DIR}=[grep $_,split ":",$self->{DIR}]}if (defined$self->{INCLUDE_EXT}&& ref \$self->{INCLUDE_EXT}eq 'SCALAR'){$self->{INCLUDE_EXT}=[grep $_,split '\s+',$self->{INCLUDE_EXT}]}if (defined$self->{EXCLUDE_EXT}&& ref \$self->{EXCLUDE_EXT}eq 'SCALAR'){$self->{EXCLUDE_EXT}=[grep $_,split '\s+',$self->{EXCLUDE_EXT}]}for my$mmkey (sort keys %$self){next if$mmkey eq 'ARGS';print "  $mmkey => ",neatvalue($self->{$mmkey}),"\n" if$Verbose;print "'$mmkey' is not a known MakeMaker parameter name.\n" unless exists$Recognized_Att_Keys{$mmkey}}$|=1 if$Verbose}sub check_hints {my($self)=@_;require File::Spec;my$curdir=File::Spec->curdir;my$hint_dir=File::Spec->catdir($curdir,"hints");return unless -d $hint_dir;my($hint)="${^O}_$Config{osvers}";$hint =~ s/\./_/g;$hint =~ s/_$//;return unless$hint;while (1){last if -f File::Spec->catfile($hint_dir,"$hint.pl")}continue {last unless$hint =~ s/_[^_]*$//}my$hint_file=File::Spec->catfile($hint_dir,"$hint.pl");return unless -f $hint_file;_run_hintfile($self,$hint_file)}sub _run_hintfile {our$self;local($self)=shift;my($hint_file)=shift;local($@,$!);warn "Processing hints file $hint_file\n";local@INC=(File::Spec->curdir,@INC);my$ret=do$hint_file;if(!defined$ret){my$error=$@ || $!;warn$error}}sub mv_all_methods {my($from,$to)=@_;local$SIG{__WARN__}=sub {warn @_ unless $_[0]=~ /^Subroutine .* redefined/};for my$method (@Overridable){next unless defined &{"${from}::$method"};{no strict 'refs';*{"${to}::$method"}=\&{"${from}::$method"};{package MY;my$super="SUPER::".$method;*{$method}=sub {shift->$super(@_)}}}}}sub skipcheck {my($self)=shift;my($section)=@_;if ($section eq 'dynamic'){print "Warning (non-fatal): Target 'dynamic' depends on targets ","in skipped section 'dynamic_bs'\n" if$self->{SKIPHASH}{dynamic_bs}&& $Verbose;print "Warning (non-fatal): Target 'dynamic' depends on targets ","in skipped section 'dynamic_lib'\n" if$self->{SKIPHASH}{dynamic_lib}&& $Verbose}if ($section eq 'dynamic_lib'){print "Warning (non-fatal): Target '\$(INST_DYNAMIC)' depends on ","targets in skipped section 'dynamic_bs'\n" if$self->{SKIPHASH}{dynamic_bs}&& $Verbose}if ($section eq 'static'){print "Warning (non-fatal): Target 'static' depends on targets ","in skipped section 'static_lib'\n" if$self->{SKIPHASH}{static_lib}&& $Verbose}return 'skipped' if$self->{SKIPHASH}{$section};return ''}sub flush {my$self=shift;my$finalname=$self->{MAKEFILE};print "Writing $finalname for $self->{NAME}\n";unlink($finalname,"MakeMaker.tmp",$Is_VMS ? 'Descrip.MMS' : ());open(my$fh,">","MakeMaker.tmp")or die "Unable to open MakeMaker.tmp: $!";for my$chunk (@{$self->{RESULT}}){print$fh "$chunk\n" or die "Can't write to MakeMaker.tmp: $!"}close$fh or die "Can't write to MakeMaker.tmp: $!";_rename("MakeMaker.tmp",$finalname)or warn "rename MakeMaker.tmp => $finalname: $!";chmod 0644,$finalname unless$Is_VMS;unless ($self->{NO_MYMETA}){if ($self->write_mymeta($self->mymeta)){print "Writing MYMETA.yml and MYMETA.json\n"}}my%keep=map {($_=>1)}qw(NEEDS_LINKING HAS_LINK_CODE);if ($self->{PARENT}&&!$self->{_KEEP_AFTER_FLUSH}){for (keys %$self){delete$self->{$_}unless$keep{$_}}}system("$Config::Config{eunicefix} $finalname")unless$Config::Config{eunicefix}eq ":"}sub _rename {my($src,$dest)=@_;chmod 0666,$dest;unlink$dest;return rename$src,$dest}sub _unlink {my@files=@_;chmod 0666,@files;return unlink@files}sub mkbootstrap {die <<END}sub mksymlists {die <<END}sub neatvalue {my($v)=@_;return "undef" unless defined$v;my($t)=ref$v;return "q[$v]" unless$t;if ($t eq 'ARRAY'){my(@m,@neat);push@m,"[";for my$elem (@$v){push@neat,"q[$elem]"}push@m,join ", ",@neat;push@m,"]";return join "",@m}return "$v" unless$t eq 'HASH';my(@m,$key,$val);while (($key,$val)=each %$v){last unless defined$key;push(@m,"$key=>".neatvalue($val))}return "{ ".join(', ',@m)." }"}sub clean_versions {my($self,$key)=@_;my$reqs=$self->{$key};for my$module (keys %$reqs){my$version=$reqs->{$module};if(!defined$version or $version !~ /^[\d_\.]+$/){carp "Unparsable version '$version' for prerequisite $module";$reqs->{$module}=0}}}sub selfdocument {my($self)=@_;my(@m);if ($Verbose){push@m,"\n# Full list of MakeMaker attribute values:";for my$key (sort keys %$self){next if$key eq 'RESULT' || $key =~ /^[A-Z][a-z]/;my($v)=neatvalue($self->{$key});$v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;$v =~ tr/\n/ /s;push@m,"# $key => $v"}}join "\n",@m}1;
  !!! Your Makefile has been built such a long time ago, !!!
  !!! that is unlikely to work with current MakeMaker.   !!!
  !!! Please rebuild your Makefile                       !!!
  END
  !!! Your Makefile has been built such a long time ago, !!!
  !!! that is unlikely to work with current MakeMaker.   !!!
  !!! Please rebuild your Makefile                       !!!
  END
EXTUTILS_MAKEMAKER

$fatpacked{"ExtUtils/MakeMaker/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_CONFIG';
  package ExtUtils::MakeMaker::Config;use strict;our$VERSION='6.66';use Config ();our%Config=%Config::Config;sub import {my$caller=caller;no strict 'refs';*{$caller.'::Config'}=\%Config}1;
EXTUTILS_MAKEMAKER_CONFIG

$fatpacked{"ExtUtils/Manifest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MANIFEST';
  package ExtUtils::Manifest;require Exporter;use Config;use File::Basename;use File::Copy 'copy';use File::Find;use File::Spec;use Carp;use strict;use vars qw($VERSION @ISA @EXPORT_OK $Is_MacOS $Is_VMS $Is_VMS_mode $Is_VMS_lc $Is_VMS_nodot $Debug $Verbose $Quiet $MANIFEST $DEFAULT_MSKIP);$VERSION='1.60';@ISA=('Exporter');@EXPORT_OK=qw(mkmanifest manicheck filecheck fullcheck skipcheck manifind maniread manicopy maniadd maniskip);$Is_MacOS=$^O eq 'MacOS';$Is_VMS=$^O eq 'VMS';$Is_VMS_mode=0;$Is_VMS_lc=0;$Is_VMS_nodot=0;if ($Is_VMS){require VMS::Filespec if$Is_VMS;my$vms_unix_rpt;my$vms_efs;my$vms_case;$Is_VMS_mode=1;$Is_VMS_lc=1;$Is_VMS_nodot=1;if (eval {local$SIG{__DIE__};require VMS::Feature}){$vms_unix_rpt=VMS::Feature::current("filename_unix_report");$vms_efs=VMS::Feature::current("efs_charset");$vms_case=VMS::Feature::current("efs_case_preserve")}else {my$unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';my$efs_charset=$ENV{'DECC$EFS_CHARSET'}|| '';my$efs_case=$ENV{'DECC$EFS_CASE_PRESERVE'}|| '';$vms_unix_rpt=$unix_rpt =~ /^[ET1]/i;$vms_efs=$efs_charset =~ /^[ET1]/i;$vms_case=$efs_case =~ /^[ET1]/i}$Is_VMS_lc=0 if ($vms_case);$Is_VMS_mode=0 if ($vms_unix_rpt);$Is_VMS_nodot=0 if ($vms_efs)}$Debug=$ENV{PERL_MM_MANIFEST_DEBUG}|| 0;$Verbose=defined$ENV{PERL_MM_MANIFEST_VERBOSE}? $ENV{PERL_MM_MANIFEST_VERBOSE}: 1;$Quiet=0;$MANIFEST='MANIFEST';$DEFAULT_MSKIP=File::Spec->catfile(dirname(__FILE__),"$MANIFEST.SKIP");sub _sort {return sort {lc$a cmp lc$b}@_}sub mkmanifest {my$manimiss=0;my$read=(-r 'MANIFEST' && maniread())or $manimiss++;$read={}if$manimiss;local*M;my$bakbase=$MANIFEST;$bakbase =~ s/\./_/g if$Is_VMS_nodot;rename$MANIFEST,"$bakbase.bak" unless$manimiss;open M,"> $MANIFEST" or die "Could not open $MANIFEST: $!";my$skip=maniskip();my$found=manifind();my($key,$val,$file,%all);%all=(%$found,%$read);$all{$MANIFEST}=($Is_VMS_mode ? "$MANIFEST\t\t" : '').'This list of files' if$manimiss;for$file (_sort keys%all){if ($skip->($file)){warn "Removed from $MANIFEST: $file\n" if$Verbose and exists$read->{$file};next}if ($Verbose){warn "Added to $MANIFEST: $file\n" unless exists$read->{$file}}my$text=$all{$file};$file=_unmacify($file);my$tabs=(5 - (length($file)+1)/8);$tabs=1 if$tabs < 1;$tabs=0 unless$text;if ($file =~ /\s/){$file =~ s/([\\'])/\\$1/g;$file="'$file'"}print M$file,"\t" x $tabs,$text,"\n"}close M}sub clean_up_filename {my$filename=shift;$filename =~ s|^\./||;$filename =~ s/^:([^:]+)$/$1/ if$Is_MacOS;return$filename}sub manifind {my$p=shift || {};my$found={};my$wanted=sub {my$name=clean_up_filename($File::Find::name);warn "Debug: diskfile $name\n" if$Debug;return if -d $_;if($Is_VMS_lc){$name =~ s#(.*)\.$#\L$1#;$name=uc($name)if$name =~ /^MANIFEST(\.SKIP)?$/i}$found->{$name}=""};find({wanted=>$wanted},$Is_MacOS ? ":" : ".");return$found}sub manicheck {return _check_files()}sub filecheck {return _check_manifest()}sub fullcheck {return [_check_files()],[_check_manifest()]}sub skipcheck {my($p)=@_;my$found=manifind();my$matches=maniskip();my@skipped=();for my$file (_sort keys %$found){if (&$matches($file)){warn "Skipping $file\n" unless$Quiet;push@skipped,$file;next}}return@skipped}sub _check_files {my$p=shift;my$dosnames=(defined(&Dos::UseLFN)&& Dos::UseLFN()==0);my$read=maniread()|| {};my$found=manifind($p);my(@missfile)=();for my$file (_sort keys %$read){warn "Debug: manicheck checking from $MANIFEST $file\n" if$Debug;if ($dosnames){$file=lc$file;$file =~ s=(\.(\w|-)+)=substr ($1,0,4)=ge;$file =~ s=((\w|-)+)=substr ($1,0,8)=ge}unless (exists$found->{$file}){warn "No such file: $file\n" unless$Quiet;push@missfile,$file}}return@missfile}sub _check_manifest {my($p)=@_;my$read=maniread()|| {};my$found=manifind($p);my$skip=maniskip();my@missentry=();for my$file (_sort keys %$found){next if$skip->($file);warn "Debug: manicheck checking from disk $file\n" if$Debug;unless (exists$read->{$file}){my$canon=$Is_MacOS ? "\t" ._unmacify($file): '';warn "Not in $MANIFEST: $file$canon\n" unless$Quiet;push@missentry,$file}}return@missentry}sub maniread {my ($mfile)=@_;$mfile ||= $MANIFEST;my$read={};local*M;unless (open M,"< $mfile"){warn "Problem opening $mfile: $!";return$read}local $_;while (<M>){chomp;next if /^\s*#/;my($file,$comment);if (($file,$comment)=/^'(\\[\\']|.+)+'\s*(.*)/){$file =~ s/\\([\\'])/$1/g}else {($file,$comment)=/^(\S+)\s*(.*)/}next unless$file;if ($Is_MacOS){$file=_macify($file);$file =~ s/\\([0-3][0-7][0-7])/sprintf("%c", oct($1))/ge}elsif ($Is_VMS_mode){require File::Basename;my($base,$dir)=File::Basename::fileparse($file);if ($Is_VMS_nodot){$dir =~ tr/./_/;my(@pieces)=split(/\./,$base);if (@pieces > 2){$base=shift(@pieces).'.' .join('_',@pieces)}my$okfile="$dir$base";warn "Debug: Illegal name $file changed to $okfile\n" if$Debug;$file=$okfile}$file=lc($file)unless$Is_VMS_lc &&($file =~ /^MANIFEST(\.SKIP)?$/)}$read->{$file}=$comment}close M;$read}sub maniskip {my@skip ;my$mfile=shift || "$MANIFEST.SKIP";_check_mskip_directives($mfile)if -f $mfile;local(*M,$_);open M,"< $mfile" or open M,"< $DEFAULT_MSKIP" or return sub {0};while (<M>){chomp;s/\r//;$_ =~ qr{^\s*(?:(?:'([^\\']*(?:\\.[^\\']*)*)')|([^#\s]\S*))?(?:(?:\s*)|(?:\s+(.*?)\s*))$};my$filename=$2;if (defined($1)){$filename=$1;$filename =~ s/\\(['\\])/$1/g}next if (not defined($filename)or not $filename);push@skip,_macify($filename)}close M;return sub {0}unless (scalar@skip > 0);my$opts=$Is_VMS_mode ? '(?i)' : '';my$regex=join '|',map "(?:$_)",@skip;return sub {$_[0]=~ qr{$opts$regex}}}sub _check_mskip_directives {my$mfile=shift;local (*M,$_);my@lines=();my$flag=0;unless (open M,"< $mfile"){warn "Problem opening $mfile: $!";return}while (<M>){if (/^#!include_default\s*$/){if (my@default=_include_mskip_file()){push@lines,@default;warn "Debug: Including default MANIFEST.SKIP\n" if$Debug;$flag++}next}if (/^#!include\s+(.*)\s*$/){my$external_file=$1;if (my@external=_include_mskip_file($external_file)){push@lines,@external;warn "Debug: Including external $external_file\n" if$Debug;$flag++}next}push@lines,$_}close M;return unless$flag;my$bakbase=$mfile;$bakbase =~ s/\./_/g if$Is_VMS_nodot;rename$mfile,"$bakbase.bak";warn "Debug: Saving original $mfile as $bakbase.bak\n" if$Debug;unless (open M,"> $mfile"){warn "Problem opening $mfile: $!";return}print M $_ for (@lines);close M;return}sub _include_mskip_file {my$mskip=shift || $DEFAULT_MSKIP;unless (-f $mskip){warn qq{Included file "$mskip" not found - skipping};return}local (*M,$_);unless (open M,"< $mskip"){warn "Problem opening $mskip: $!";return}my@lines=();push@lines,"\n#!start included $mskip\n";push@lines,$_ while <M>;close M;push@lines,"#!end included $mskip\n\n";return@lines}sub manicopy {my($read,$target,$how)=@_;croak "manicopy() called without target argument" unless defined$target;$how ||= 'cp';require File::Path;require File::Basename;$target=VMS::Filespec::unixify($target)if$Is_VMS_mode;File::Path::mkpath([$target ],!$Quiet,$Is_VMS ? undef : 0755);for my$file (keys %$read){if ($Is_MacOS){if ($file =~ m!:!){my$dir=_maccat($target,$file);$dir =~ s/[^:]+$//;File::Path::mkpath($dir,1,0755)}cp_if_diff($file,_maccat($target,$file),$how)}else {$file=VMS::Filespec::unixify($file)if$Is_VMS_mode;if ($file =~ m!/!){my$dir=File::Basename::dirname($file);$dir=VMS::Filespec::unixify($dir)if$Is_VMS_mode;File::Path::mkpath(["$target/$dir"],!$Quiet,$Is_VMS ? undef : 0755)}cp_if_diff($file,"$target/$file",$how)}}}sub cp_if_diff {my($from,$to,$how)=@_;if (!-f $from){carp "$from not found";return}my($diff)=0;local(*F,*T);open(F,"< $from\0")or die "Can't read $from: $!\n";if (open(T,"< $to\0")){local $_;while (<F>){$diff++,last if $_ ne <T>}$diff++ unless eof(T);close T}else {$diff++}close F;if ($diff){if (-e $to){unlink($to)or confess "unlink $to: $!"}STRICT_SWITCH: {best($from,$to),last STRICT_SWITCH if$how eq 'best';cp($from,$to),last STRICT_SWITCH if$how eq 'cp';ln($from,$to),last STRICT_SWITCH if$how eq 'ln';croak("ExtUtils::Manifest::cp_if_diff " ."called with illegal how argument [$how]. " ."Legal values are 'best', 'cp', and 'ln'.")}}}sub cp {my ($srcFile,$dstFile)=@_;my ($access,$mod)=(stat$srcFile)[8,9];copy($srcFile,$dstFile);utime$access,$mod + ($Is_VMS ? 1 : 0),$dstFile;_manicopy_chmod($srcFile,$dstFile)}sub ln {my ($srcFile,$dstFile)=@_;return&cp if$Is_VMS or ($^O eq 'MSWin32' and Win32::IsWin95());link($srcFile,$dstFile);unless(_manicopy_chmod($srcFile,$dstFile)){unlink$dstFile;return}1}sub _manicopy_chmod {my($srcFile,$dstFile)=@_;my$perm=0444 | (stat$srcFile)[2]& 0700;chmod($perm | ($perm & 0100 ? 0111 : 0),$dstFile)}my@Exceptions=qw(MANIFEST META.yml SIGNATURE);sub best {my ($srcFile,$dstFile)=@_;my$is_exception=grep$srcFile =~ /$_/,@Exceptions;if ($is_exception or!$Config{d_link}or -l $srcFile){cp($srcFile,$dstFile)}else {ln($srcFile,$dstFile)or cp($srcFile,$dstFile)}}sub _macify {my($file)=@_;return$file unless$Is_MacOS;$file =~ s|^\./||;if ($file =~ m|/|){$file =~ s|/+|:|g;$file=":$file"}$file}sub _maccat {my($f1,$f2)=@_;return "$f1/$f2" unless$Is_MacOS;$f1 .= ":$f2";$f1 =~ s/([^:]:):/$1/g;return$f1}sub _unmacify {my($file)=@_;return$file unless$Is_MacOS;$file =~ s|^:||;$file =~ s|([/ \n])|sprintf("\\%03o", unpack("c", $1))|ge;$file =~ y|:|/|;$file}sub maniadd {my($additions)=shift;_normalize($additions);_fix_manifest($MANIFEST);my$manifest=maniread();my@needed=grep {!exists$manifest->{$_}}keys %$additions;return 1 unless@needed;open(MANIFEST,">>$MANIFEST")or die "maniadd() could not open $MANIFEST: $!";for my$file (_sort@needed){my$comment=$additions->{$file}|| '';if ($file =~ /\s/){$file =~ s/([\\'])/\\$1/g;$file="'$file'"}printf MANIFEST "%-40s %s\n",$file,$comment}close MANIFEST or die "Error closing $MANIFEST: $!";return 1}sub _fix_manifest {my$manifest_file=shift;open MANIFEST,$MANIFEST or die "Could not open $MANIFEST: $!";local $/;my@manifest=split /(\015\012|\012|\015)/,<MANIFEST>,-1;close MANIFEST;my$must_rewrite="";if ($manifest[-1]eq ""){pop@manifest;for (my$i=1;$i<=$#manifest;$i+=2){unless ($manifest[$i]eq "\n"){$must_rewrite="not a newline at pos $i";last}}}else {$must_rewrite="last line without newline"}if ($must_rewrite){1 while unlink$MANIFEST;open MANIFEST,">",$MANIFEST or die "(must_rewrite=$must_rewrite) Could not open >$MANIFEST: $!";for (my$i=0;$i<=$#manifest;$i+=2){print MANIFEST "$manifest[$i]\n"}close MANIFEST or die "could not write $MANIFEST: $!"}}sub _normalize {return}1;
EXTUTILS_MANIFEST

$fatpacked{"ExtUtils/Mkbootstrap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MKBOOTSTRAP';
  package ExtUtils::Mkbootstrap;use strict 'refs';our$VERSION='6.66';require Exporter;our@ISA=('Exporter');our@EXPORT=('&Mkbootstrap');use Config;our$Verbose=0;sub Mkbootstrap {my($baseext,@bsloadlibs)=@_;@bsloadlibs=grep($_,@bsloadlibs);print "	bsloadlibs=@bsloadlibs\n" if$Verbose;require DynaLoader;rename "$baseext.bs","$baseext.bso" if -s "$baseext.bs";if (-f "${baseext}_BS"){$_="${baseext}_BS";package DynaLoader;local($osname,$dlsrc)=();($osname,$dlsrc)=@Config::Config{qw(osname dlsrc)};$bscode="";unshift@INC,".";require $_;shift@INC}if ($Config{'dlsrc'}=~ /^dl_dld/){package DynaLoader;push(@dl_resolve_using,dl_findfile('-lc'))}my(@all)=(@bsloadlibs,@DynaLoader::dl_resolve_using);my($method)='';if (@all){open my$bs,">","$baseext.bs" or die "Unable to open $baseext.bs: $!";print "Writing $baseext.bs\n";print "	containing: @all" if$Verbose;print$bs "# $baseext DynaLoader bootstrap file for $^O architecture.\n";print$bs "# Do not edit this file, changes will be lost.\n";print$bs "# This file was automatically generated by the\n";print$bs "# Mkbootstrap routine in ExtUtils::Mkbootstrap (v$VERSION).\n";print$bs "\@DynaLoader::dl_resolve_using = ";if (" @all" =~ m/ -[lLR]/){print$bs "  dl_findfile(qw(\n  @all\n  ));\n"}else{print$bs "  qw(@all);\n"}print$bs $DynaLoader::bscode if$DynaLoader::bscode;print$bs "\n1;\n";close$bs}}1;
EXTUTILS_MKBOOTSTRAP

$fatpacked{"ExtUtils/Mksymlists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MKSYMLISTS';
  package ExtUtils::Mksymlists;use 5.006;use strict qw[subs refs];use Carp;use Exporter;use Config;our@ISA=qw(Exporter);our@EXPORT=qw(&Mksymlists);our$VERSION='6.66';sub Mksymlists {my(%spec)=@_;my($osname)=$^O;croak("Insufficient information specified to Mksymlists")unless ($spec{NAME}or ($spec{FILE}and ($spec{DL_FUNCS}or $spec{FUNCLIST})));$spec{DL_VARS}=[]unless$spec{DL_VARS};($spec{FILE}=$spec{NAME})=~ s/.*::// unless$spec{FILE};$spec{FUNCLIST}=[]unless$spec{FUNCLIST};$spec{DL_FUNCS}={$spec{NAME}=>[]}unless (($spec{DL_FUNCS}and keys %{$spec{DL_FUNCS}})or @{$spec{FUNCLIST}});if (defined$spec{DL_FUNCS}){for my$package (sort keys %{$spec{DL_FUNCS}}){my($packprefix,$bootseen);($packprefix=$package)=~ s/\W/_/g;for my$sym (@{$spec{DL_FUNCS}->{$package}}){if ($sym =~ /^boot_/){push(@{$spec{FUNCLIST}},$sym);$bootseen++}else {push(@{$spec{FUNCLIST}},"XS_${packprefix}_$sym")}}push(@{$spec{FUNCLIST}},"boot_$packprefix")unless$bootseen}}if (defined&DynaLoader::mod2fname and not $spec{DLBASE}){$spec{DLBASE}=DynaLoader::mod2fname([split(/::/,$spec{NAME})])}if ($osname eq 'aix'){_write_aix(\%spec)}elsif ($osname eq 'MacOS'){_write_aix(\%spec)}elsif ($osname eq 'VMS'){_write_vms(\%spec)}elsif ($osname eq 'os2'){_write_os2(\%spec)}elsif ($osname eq 'MSWin32'){_write_win32(\%spec)}else {croak("Don't know how to create linker option file for $osname\n")}}sub _write_aix {my($data)=@_;rename "$data->{FILE}.exp","$data->{FILE}.exp_old";open(my$exp,">","$data->{FILE}.exp")or croak("Can't create $data->{FILE}.exp: $!\n");print$exp join("\n",@{$data->{DL_VARS}},"\n")if @{$data->{DL_VARS}};print$exp join("\n",@{$data->{FUNCLIST}},"\n")if @{$data->{FUNCLIST}};close$exp}sub _write_os2 {my($data)=@_;require Config;my$threaded=($Config::Config{archname}=~ /-thread/ ? " threaded" : "");if (not $data->{DLBASE}){($data->{DLBASE}=$data->{NAME})=~ s/.*:://;$data->{DLBASE}=substr($data->{DLBASE},0,7).'_'}my$distname=$data->{DISTNAME}|| $data->{NAME};$distname="Distribution $distname";my$patchlevel=" pl$Config{perl_patchlevel}" || '';my$comment=sprintf "Perl (v%s%s%s) module %s",$Config::Config{version},$threaded,$patchlevel,$data->{NAME};chomp$comment;if ($data->{INSTALLDIRS}and $data->{INSTALLDIRS}eq 'perl'){$distname='perl5-porters@perl.org';$comment="Core $comment"}$comment="$comment (Perl-config: $Config{config_args})";$comment=substr($comment,0,200)."...)" if length$comment > 203;rename "$data->{FILE}.def","$data->{FILE}_def.old";open(my$def,">","$data->{FILE}.def")or croak("Can't create $data->{FILE}.def: $!\n");print$def "LIBRARY '$data->{DLBASE}' INITINSTANCE TERMINSTANCE\n";print$def "DESCRIPTION '\@#$distname:$data->{VERSION}#\@ $comment'\n";print$def "CODE LOADONCALL\n";print$def "DATA LOADONCALL NONSHARED MULTIPLE\n";print$def "EXPORTS\n  ";print$def join("\n  ",@{$data->{DL_VARS}},"\n")if @{$data->{DL_VARS}};print$def join("\n  ",@{$data->{FUNCLIST}},"\n")if @{$data->{FUNCLIST}};_print_imports($def,$data);close$def}sub _print_imports {my ($def,$data)=@_;my$imports=$data->{IMPORTS}or return;if (keys %$imports){print$def "IMPORTS\n";for my$name (sort keys %$imports){print$def "  $name=$imports->{$name}\n"}}}sub _write_win32 {my($data)=@_;require Config;if (not $data->{DLBASE}){($data->{DLBASE}=$data->{NAME})=~ s/.*:://;$data->{DLBASE}=substr($data->{DLBASE},0,7).'_'}rename "$data->{FILE}.def","$data->{FILE}_def.old";open(my$def,">","$data->{FILE}.def")or croak("Can't create $data->{FILE}.def: $!\n");if ($Config::Config{'cc'}!~ /^gcc/i){print$def "LIBRARY \"$data->{DLBASE}\"\n"}print$def "EXPORTS\n  ";my@syms;if ($Config::Config{'cc'}=~ /^bcc/i){for (@{$data->{DL_VARS}},@{$data->{FUNCLIST}}){push@syms,"_$_","$_ = _$_"}}else {for (@{$data->{DL_VARS}},@{$data->{FUNCLIST}}){push@syms,"$_","_$_ = $_"}}print$def join("\n  ",@syms,"\n")if@syms;_print_imports($def,$data);close$def}sub _write_vms {my($data)=@_;require Config;require ExtUtils::XSSymSet;my($isvax)=$Config::Config{'archname'}=~ /VAX/i;my($set)=new ExtUtils::XSSymSet;rename "$data->{FILE}.opt","$data->{FILE}.opt_old";open(my$opt,">","$data->{FILE}.opt")or croak("Can't create $data->{FILE}.opt: $!\n");print$opt "case_sensitive=yes\n" if$Config::Config{d_vms_case_sensitive_symbols};for my$sym (@{$data->{FUNCLIST}}){my$safe=$set->addsym($sym);if ($isvax){print$opt "UNIVERSAL=$safe\n"}else {print$opt "SYMBOL_VECTOR=($safe=PROCEDURE)\n"}}for my$sym (@{$data->{DL_VARS}}){my$safe=$set->addsym($sym);print$opt "PSECT_ATTR=${sym},PIC,OVR,RD,NOEXE,WRT,NOSHR\n";if ($isvax){print$opt "UNIVERSAL=$safe\n"}else {print$opt "SYMBOL_VECTOR=($safe=DATA)\n"}}close$opt}1;
EXTUTILS_MKSYMLISTS

$fatpacked{"ExtUtils/Packlist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_PACKLIST';
  package ExtUtils::Packlist;use 5.00503;use strict;use Carp qw();use Config;use vars qw($VERSION $Relocations);$VERSION='1.43';$VERSION=eval$VERSION;my$fhname="FH1";sub mkfh() {no strict;my$fh=\*{$fhname++};use strict;return($fh)}sub __find_relocations {my%paths;while (my ($raw_key,$raw_val)=each%Config){my$exp_key=$raw_key ."exp";next unless exists$Config{$exp_key};next unless$raw_val =~ m!\.\.\./!;$paths{$Config{$exp_key}}++}my$alternations=join "|",map {quotemeta $_}sort {length$b <=> length$a}keys%paths;qr/^($alternations)/o}sub new($$) {my ($class,$packfile)=@_;$class=ref($class)|| $class;my%self;tie(%self,$class,$packfile);return(bless(\%self,$class))}sub TIEHASH {my ($class,$packfile)=@_;my$self={packfile=>$packfile };bless($self,$class);$self->read($packfile)if (defined($packfile)&& -f $packfile);return($self)}sub STORE {$_[0]->{data}->{$_[1]}=$_[2]}sub FETCH {return($_[0]->{data}->{$_[1]})}sub FIRSTKEY {my$reset=scalar(keys(%{$_[0]->{data}}));return(each(%{$_[0]->{data}}))}sub NEXTKEY {return(each(%{$_[0]->{data}}))}sub EXISTS {return(exists($_[0]->{data}->{$_[1]}))}sub DELETE {return(delete($_[0]->{data}->{$_[1]}))}sub CLEAR {%{$_[0]->{data}}=()}sub DESTROY {}sub read($;$) {my ($self,$packfile)=@_;$self=tied(%$self)|| $self;if (defined($packfile)){$self->{packfile}=$packfile}else {$packfile=$self->{packfile}}Carp::croak("No packlist filename specified")if (!defined($packfile));my$fh=mkfh();open($fh,"<$packfile")|| Carp::croak("Can't open file $packfile: $!");$self->{data}={};my ($line);while (defined($line=<$fh>)){chomp$line;my ($key,$data)=$line;if ($key =~ /^(.*?)( \w+=.*)$/){$key=$1;$data={map {split('=',$_)}split(' ',$2)};if ($Config{userelocatableinc}&& $data->{relocate_as}){require File::Spec;require Cwd;my ($vol,$dir)=File::Spec->splitpath($packfile);my$newpath=File::Spec->catpath($vol,$dir,$data->{relocate_as});$key=Cwd::realpath($newpath)}}$key =~ s!/\./!/!g;$self->{data}->{$key}=$data}close($fh)}sub write($;$) {my ($self,$packfile)=@_;$self=tied(%$self)|| $self;if (defined($packfile)){$self->{packfile}=$packfile}else {$packfile=$self->{packfile}}Carp::croak("No packlist filename specified")if (!defined($packfile));my$fh=mkfh();open($fh,">$packfile")|| Carp::croak("Can't open file $packfile: $!");for my$key (sort(keys(%{$self->{data}}))){my$data=$self->{data}->{$key};if ($Config{userelocatableinc}){$Relocations ||= __find_relocations();if ($packfile =~ $Relocations){my$prefix=$1;if (File::Spec->no_upwards(File::Spec->abs2rel($key,$prefix))){my$packfile_prefix;(undef,$packfile_prefix)=File::Spec->splitpath($packfile);my$relocate_as =File::Spec->abs2rel($key,$packfile_prefix);if (!ref$data){$data={}}$data->{relocate_as}=$relocate_as}}}print$fh ("$key");if (ref($data)){for my$k (sort(keys(%$data))){print$fh (" $k=$data->{$k}")}}print$fh ("\n")}close($fh)}sub validate($;$) {my ($self,$remove)=@_;$self=tied(%$self)|| $self;my@missing;for my$key (sort(keys(%{$self->{data}}))){if (!-e $key){push(@missing,$key);delete($self->{data}{$key})if ($remove)}}return(@missing)}sub packlist_file($) {my ($self)=@_;$self=tied(%$self)|| $self;return($self->{packfile})}1;
EXTUTILS_PACKLIST

$fatpacked{"ExtUtils/testlib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_TESTLIB';
  package ExtUtils::testlib;use strict;use warnings;our$VERSION='6.66';use Cwd;use File::Spec;my$cwd;BEGIN {($cwd)=getcwd()=~ /(.*)/}use lib map {File::Spec->rel2abs($_,$cwd)}qw(blib/arch blib/lib);1;
EXTUTILS_TESTLIB

$fatpacked{"File/Copy/Recursive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_COPY_RECURSIVE';
  package File::Copy::Recursive;use strict;BEGIN {$INC{'warnings.pm'}="fake warnings entry for < 5.6 perl ($])" if $] < 5.006}use warnings;use Carp;use File::Copy;use File::Spec;use vars qw(@ISA @EXPORT_OK $VERSION $MaxDepth $KeepMode $CPRFComp $CopyLink $PFSCheck $RemvBase $NoFtlPth $ForcePth $CopyLoop $RMTrgFil $RMTrgDir $CondCopy $BdTrgWrn $SkipFlop $DirPerms);require Exporter;@ISA=qw(Exporter);@EXPORT_OK=qw(fcopy rcopy dircopy fmove rmove dirmove pathmk pathrm pathempty pathrmdir);$VERSION='0.38';$MaxDepth=0;$KeepMode=1;$CPRFComp=0;$CopyLink=eval {local$SIG{'__DIE__'};symlink '','';1}|| 0;$PFSCheck=1;$RemvBase=0;$NoFtlPth=0;$ForcePth=0;$CopyLoop=0;$RMTrgFil=0;$RMTrgDir=0;$CondCopy={};$BdTrgWrn=0;$SkipFlop=0;$DirPerms=0777;my$samecheck=sub {return 1 if $^O eq 'MSWin32';return if @_!=2 ||!defined $_[0]||!defined $_[1];return if $_[0]eq $_[1];my$one='';if($PFSCheck){$one=join('-',(stat $_[0])[0,1])|| '';my$two=join('-',(stat $_[1])[0,1])|| '';if ($one eq $two && $one){carp "$_[0] and $_[1] are identical";return}}if(-d $_[0]&&!$CopyLoop){$one=join('-',(stat $_[0])[0,1])if!$one;my$abs=File::Spec->rel2abs($_[1]);my@pth=File::Spec->splitdir($abs);while(@pth){my$cur=File::Spec->catdir(@pth);last if!$cur;my$two=join('-',(stat$cur)[0,1])|| '';if ($one eq $two && $one){carp "Caught Deep Recursion Condition: $_[0] contains $_[1]";return}pop@pth}}return 1};my$glob=sub {my ($do,$src_glob,@args)=@_;local$CPRFComp=1;my@rt;for my$path (glob($src_glob)){my@call=[$do->($path,@args)]or return;push@rt,\@call}return@rt};my$move=sub {my$fl=shift;my@x;if($fl){@x=fcopy(@_)or return}else {@x=dircopy(@_)or return}if(@x){if($fl){unlink $_[0]or return}else {pathrmdir($_[0])or return}if($RemvBase){my ($volm,$path)=File::Spec->splitpath($_[0]);pathrm(File::Spec->catpath($volm,$path,''),$ForcePth,$NoFtlPth)or return}}return wantarray ? @x : $x[0]};my$ok_todo_asper_condcopy=sub {my$org=shift;my$copy=1;if(exists$CondCopy->{$org}){if($CondCopy->{$org}{'md5'}){}if($copy){}}return$copy};sub fcopy {$samecheck->(@_)or return;if($RMTrgFil && (-d $_[1]|| -e $_[1])){my$trg=$_[1];if(-d $trg){my@trgx=File::Spec->splitpath($_[0]);$trg=File::Spec->catfile($_[1],$trgx[$#trgx ])}$samecheck->($_[0],$trg)or return;if(-e $trg){if($RMTrgFil==1){unlink$trg or carp "\$RMTrgFil failed: $!"}else {unlink$trg or return}}}my ($volm,$path)=File::Spec->splitpath($_[1]);if($path &&!-d $path){pathmk(File::Spec->catpath($volm,$path,''),$NoFtlPth)}if(-l $_[0]&& $CopyLink){carp "Copying a symlink ($_[0]) whose target does not exist" if!-e readlink($_[0])&& $BdTrgWrn;symlink readlink(shift()),shift()or return}else {copy(@_)or return;my@base_file=File::Spec->splitpath($_[0]);my$mode_trg=-d $_[1]? File::Spec->catfile($_[1],$base_file[$#base_file ]): $_[1];chmod scalar((stat($_[0]))[2]),$mode_trg if$KeepMode}return wantarray ? (1,0,0): 1}sub rcopy {if (-l $_[0]&& $CopyLink){goto&fcopy}goto&dircopy if -d $_[0]|| substr($_[0],(1 * -1),1)eq '*';goto&fcopy}sub rcopy_glob {$glob->(\&rcopy,@_)}sub dircopy {if($RMTrgDir && -d $_[1]){if($RMTrgDir==1){pathrmdir($_[1])or carp "\$RMTrgDir failed: $!"}else {pathrmdir($_[1])or return}}my$globstar=0;my$_zero=$_[0];my$_one=$_[1];if (substr($_zero,(1 * -1),1)eq '*'){$globstar=1;$_zero=substr($_zero,0,(length($_zero)- 1))}$samecheck->($_zero,$_[1])or return;if (!-d $_zero || (-e $_[1]&&!-d $_[1])){$!=20;return}if(!-d $_[1]){pathmk($_[1],$NoFtlPth)or return}else {if($CPRFComp &&!$globstar){my@parts=File::Spec->splitdir($_zero);while($parts[$#parts ]eq ''){pop@parts}$_one=File::Spec->catdir($_[1],$parts[$#parts])}}my$baseend=$_one;my$level=0;my$filen=0;my$dirn=0;my$recurs;$recurs=sub {my ($str,$end,$buf)=@_;$filen++ if$end eq $baseend;$dirn++ if$end eq $baseend;$DirPerms=oct($DirPerms)if substr($DirPerms,0,1)eq '0';mkdir($end,$DirPerms)or return if!-d $end;chmod scalar((stat($str))[2]),$end if$KeepMode;if($MaxDepth && $MaxDepth =~ m/^\d+$/ && $level >= $MaxDepth){return ($filen,$dirn,$level)if wantarray;return$filen}$level++;my@files;if ($] < 5.006){opendir(STR_DH,$str)or return;@files=grep($_ ne '.' && $_ ne '..',readdir(STR_DH));closedir STR_DH}else {opendir(my$str_dh,$str)or return;@files=grep($_ ne '.' && $_ ne '..',readdir($str_dh));closedir$str_dh}for my$file (@files){my ($file_ut)=$file =~ m{ (.*) }xms;my$org=File::Spec->catfile($str,$file_ut);my$new=File::Spec->catfile($end,$file_ut);if(-l $org && $CopyLink){carp "Copying a symlink ($org) whose target does not exist" if!-e readlink($org)&& $BdTrgWrn;symlink readlink($org),$new or return}elsif(-d $org){$recurs->($org,$new,$buf)if defined$buf;$recurs->($org,$new)if!defined$buf;$filen++;$dirn++}else {if($ok_todo_asper_condcopy->($org)){if($SkipFlop){fcopy($org,$new,$buf)or next if defined$buf;fcopy($org,$new)or next if!defined$buf}else {fcopy($org,$new,$buf)or return if defined$buf;fcopy($org,$new)or return if!defined$buf}chmod scalar((stat($org))[2]),$new if$KeepMode;$filen++}}}1};$recurs->($_zero,$_one,$_[2])or return;return wantarray ? ($filen,$dirn,$level): $filen}sub fmove {$move->(1,@_)}sub rmove {if (-l $_[0]&& $CopyLink){goto&fmove}goto&dirmove if -d $_[0]|| substr($_[0],(1 * -1),1)eq '*';goto&fmove}sub rmove_glob {$glob->(\&rmove,@_)}sub dirmove {$move->(0,@_)}sub pathmk {my@parts=File::Spec->splitdir(shift());my$nofatal=shift;my$pth=$parts[0];my$zer=0;if(!$pth){$pth=File::Spec->catdir($parts[0],$parts[1]);$zer=1}for($zer..$#parts){$DirPerms=oct($DirPerms)if substr($DirPerms,0,1)eq '0';mkdir($pth,$DirPerms)or return if!-d $pth &&!$nofatal;mkdir($pth,$DirPerms)if!-d $pth && $nofatal;$pth=File::Spec->catdir($pth,$parts[$_ + 1])unless $_==$#parts}1}sub pathempty {my$pth=shift;return 2 if!-d $pth;my@names;my$pth_dh;if ($] < 5.006){opendir(PTH_DH,$pth)or return;@names=grep!/^\.+$/,readdir(PTH_DH)}else {opendir($pth_dh,$pth)or return;@names=grep!/^\.+$/,readdir($pth_dh)}for my$name (@names){my ($name_ut)=$name =~ m{ (.*) }xms;my$flpth=File::Spec->catdir($pth,$name_ut);if(-l $flpth){unlink$flpth or return}elsif(-d $flpth){pathrmdir($flpth)or return}else {unlink$flpth or return}}if ($] < 5.006){closedir PTH_DH}else {closedir$pth_dh}1}sub pathrm {my$path=shift;return 2 if!-d $path;my@pth=File::Spec->splitdir($path);my$force=shift;while(@pth){my$cur=File::Spec->catdir(@pth);last if!$cur;if(!shift()){pathempty($cur)or return if$force;rmdir$cur or return}else {pathempty($cur)if$force;rmdir$cur}pop@pth}1}sub pathrmdir {my$dir=shift;if(-e $dir){return if!-d $dir}else {return 2}pathempty($dir)or return;rmdir$dir or return}1;
FILE_COPY_RECURSIVE

$fatpacked{"File/Path.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PATH';
  package File::Path;use 5.005_04;use strict;use Cwd 'getcwd';use File::Basename ();use File::Spec ();BEGIN {if ($] < 5.006){eval 'use Symbol'}}use Exporter ();use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);$VERSION='2.12';$VERSION=eval$VERSION;@ISA=qw(Exporter);@EXPORT=qw(mkpath rmtree);@EXPORT_OK=qw(make_path remove_tree);BEGIN {for (qw(VMS MacOS MSWin32 os2)){no strict 'refs';*{"_IS_\U$_"}=$^O eq $_ ? sub () {1}: sub () {0}}*_FORCE_WRITABLE=(grep {$^O eq $_}qw(amigaos dos epoc MSWin32 MacOS os2))? sub () {1}: sub () {0};*_NEED_STAT_CHECK=!(_IS_MSWIN32())? sub () {1}: sub () {0}}sub _carp {require Carp;goto&Carp::carp}sub _croak {require Carp;goto&Carp::croak}sub _error {my$arg=shift;my$message=shift;my$object=shift;if ($arg->{error}){$object='' unless defined$object;$message .= ": $!" if $!;push @{${$arg->{error}}},{$object=>$message }}else {_carp(defined($object)? "$message for $object: $!" : "$message: $!")}}sub __is_arg {my ($arg)=@_;return (ref$arg eq 'HASH')}sub make_path {push @_,{}unless @_ and __is_arg($_[-1]);goto&mkpath}sub mkpath {my$old_style=!(@_ and __is_arg($_[-1]));my$arg;my$paths;if ($old_style){my ($verbose,$mode);($paths,$verbose,$mode)=@_;$paths=[$paths]unless UNIVERSAL::isa($paths,'ARRAY');$arg->{verbose}=$verbose;$arg->{mode}=defined$mode ? $mode : oct '777'}else {my%args_permitted=map {$_=>1}(qw|chmod error group mask mode owner uid user verbose|);my@bad_args=();$arg=pop @_;for my$k (sort keys %{$arg}){push@bad_args,$k unless$args_permitted{$k}}_carp("Unrecognized option(s) passed to make_path(): @bad_args")if@bad_args;$arg->{mode}=delete$arg->{mask}if exists$arg->{mask};$arg->{mode}=oct '777' unless exists$arg->{mode};${$arg->{error}}=[]if exists$arg->{error};$arg->{owner}=delete$arg->{user}if exists$arg->{user};$arg->{owner}=delete$arg->{uid}if exists$arg->{uid};if (exists$arg->{owner}and $arg->{owner}=~ /\D/){my$uid=(getpwnam$arg->{owner})[2];if (defined$uid){$arg->{owner}=$uid}else {_error($arg,"unable to map $arg->{owner} to a uid, ownership not changed");delete$arg->{owner}}}if (exists$arg->{group}and $arg->{group}=~ /\D/){my$gid=(getgrnam$arg->{group})[2];if (defined$gid){$arg->{group}=$gid}else {_error($arg,"unable to map $arg->{group} to a gid, group ownership not changed");delete$arg->{group}}}if (exists$arg->{owner}and not exists$arg->{group}){$arg->{group}=-1}if (exists$arg->{group}and not exists$arg->{owner}){$arg->{owner}=-1}$paths=[@_]}return _mkpath($arg,$paths)}sub _mkpath {my$arg=shift;my$paths=shift;my (@created);for my$path (@{$paths}){next unless defined($path)and length($path);$path .= '/' if _IS_OS2 and $path =~ /^\w:\z/s;if (_IS_VMS){next if$path eq '/';$path=VMS::Filespec::unixify($path)}next if -d $path;my$parent=File::Basename::dirname($path);unless (-d $parent or $path eq $parent){push(@created,_mkpath($arg,[$parent]))}print "mkdir $path\n" if$arg->{verbose};if (mkdir($path,$arg->{mode})){push(@created,$path);if (exists$arg->{owner}){if (!chown$arg->{owner},$arg->{group},$path){_error($arg,"Cannot change ownership of $path to $arg->{owner}:$arg->{group}")}}if (exists$arg->{chmod}){if (!chmod$arg->{chmod},$path){_error($arg,"Cannot change permissions of $path to $arg->{chmod}")}}}else {my$save_bang=$!;my ($e,$e1)=($save_bang,$^E);$e .= "; $e1" if$e ne $e1;if (!-d $path){$!=$save_bang;if ($arg->{error}){push @{${$arg->{error}}},{$path=>$e }}else {_croak("mkdir $path: $e")}}}}return@created}sub remove_tree {push @_,{}unless @_ and __is_arg($_[-1]);goto&rmtree}sub _is_subdir {my ($dir,$test)=@_;my ($dv,$dd)=File::Spec->splitpath($dir,1);my ($tv,$td)=File::Spec->splitpath($test,1);return 0 if$dv ne $tv;my@d=File::Spec->splitdir($dd);my@t=File::Spec->splitdir($td);return 0 if@t < @d;return join('/',@d)eq join('/',splice@t,0,+@d)}sub rmtree {my$old_style=!(@_ and __is_arg($_[-1]));my$arg;my$paths;if ($old_style){my ($verbose,$safe);($paths,$verbose,$safe)=@_;$arg->{verbose}=$verbose;$arg->{safe}=defined$safe ? $safe : 0;if (defined($paths)and length($paths)){$paths=[$paths]unless UNIVERSAL::isa($paths,'ARRAY')}else {_carp("No root path(s) specified\n");return 0}}else {my%args_permitted=map {$_=>1}(qw|error keep_root result safe verbose|);my@bad_args=();$arg=pop @_;for my$k (sort keys %{$arg}){push@bad_args,$k unless$args_permitted{$k}}_carp("Unrecognized option(s) passed to remove_tree(): @bad_args")if@bad_args;${$arg->{error}}=[]if exists$arg->{error};${$arg->{result}}=[]if exists$arg->{result};$paths=[@_]}$arg->{prefix}='';$arg->{depth}=0;my@clean_path;$arg->{cwd}=getcwd()or do {_error($arg,"cannot fetch initial working directory");return 0};for ($arg->{cwd}){/\A(.*)\Z/s;$_=$1}for my$p (@$paths){my$ortho_root=_IS_MSWIN32 ? _slash_lc($p): $p;my$ortho_cwd=_IS_MSWIN32 ? _slash_lc($arg->{cwd}): $arg->{cwd};my$ortho_root_length=length($ortho_root);$ortho_root_length-- if _IS_VMS;if ($ortho_root_length && _is_subdir($ortho_root,$ortho_cwd)){local $!=0;_error($arg,"cannot remove path when cwd is $arg->{cwd}",$p);next}if (_IS_MACOS){$p=":$p" unless$p =~ /:/;$p .= ":" unless$p =~ /:\z/}elsif (_IS_MSWIN32){$p =~ s{[/\\]\z}{}}else {$p =~ s{/\z}{}}push@clean_path,$p}@{$arg}{qw(device inode perm)}=(lstat$arg->{cwd})[0,1 ]or do {_error($arg,"cannot stat initial working directory",$arg->{cwd});return 0};return _rmtree($arg,\@clean_path)}sub _rmtree {my$arg=shift;my$paths=shift;my$count=0;my$curdir=File::Spec->curdir();my$updir=File::Spec->updir();my (@files,$root);ROOT_DIR: foreach my$root (@$paths){my$canon=$arg->{prefix}? File::Spec->catfile($arg->{prefix},$root): $root;my ($ldev,$lino,$perm)=(lstat$root)[0,1,2 ]or next ROOT_DIR;if (-d _){$root=VMS::Filespec::vmspath(VMS::Filespec::pathify($root))if _IS_VMS;if (!chdir($root)){$perm &= oct '7777';my$nperm=$perm | oct '700';if (!($arg->{safe}or $nperm==$perm or chmod($nperm,$root))){_error($arg,"cannot make child directory read-write-exec",$canon);next ROOT_DIR}elsif (!chdir($root)){_error($arg,"cannot chdir to child",$canon);next ROOT_DIR}}my ($cur_dev,$cur_inode,$perm)=(stat$curdir)[0,1,2 ]or do {_error($arg,"cannot stat current working directory",$canon);next ROOT_DIR};if (_NEED_STAT_CHECK){($ldev eq $cur_dev and $lino eq $cur_inode)or _croak("directory $canon changed before chdir, expected dev=$ldev ino=$lino, actual dev=$cur_dev ino=$cur_inode, aborting.")}$perm &= oct '7777';my$nperm=$perm | oct '700';if (!($arg->{safe}or $nperm==$perm or chmod($nperm,$curdir))){_error($arg,"cannot make directory read+writeable",$canon);$nperm=$perm}my$d;$d=gensym()if $] < 5.006;if (!opendir$d,$curdir){_error($arg,"cannot opendir",$canon);@files=()}else {if (!defined ${^TAINT} or ${^TAINT}){@files=map {/\A(.*)\z/s;$1}readdir$d}else {@files=readdir$d}closedir$d}if (_IS_VMS){@files=map {$_ eq '.' ? '.;' : $_}reverse@files}@files=grep {$_ ne $updir and $_ ne $curdir}@files;if (@files){my$narg={%$arg};@{$narg}{qw(device inode cwd prefix depth)}=($cur_dev,$cur_inode,$updir,$canon,$arg->{depth}+ 1);$count += _rmtree($narg,\@files)}if ($nperm!=$perm and not chmod($perm,$curdir)){_error($arg,"cannot reset chmod",$canon)}chdir($arg->{cwd})or _croak("cannot chdir to $arg->{cwd} from $canon: $!, aborting.");($cur_dev,$cur_inode)=(stat$curdir)[0,1 ]or _croak("cannot stat prior working directory $arg->{cwd}: $!, aborting.");if (_NEED_STAT_CHECK){($arg->{device}eq $cur_dev and $arg->{inode}eq $cur_inode)or _croak("previous directory $arg->{cwd} " ."changed before entering $canon, " ."expected dev=$ldev ino=$lino, " ."actual dev=$cur_dev ino=$cur_inode, aborting.")}if ($arg->{depth}or!$arg->{keep_root}){if ($arg->{safe}&& (_IS_VMS ?!&VMS::Filespec::candelete($root):!-w $root)){print "skipped $root\n" if$arg->{verbose};next ROOT_DIR}if (_FORCE_WRITABLE and!chmod$perm | oct '700',$root){_error($arg,"cannot make directory writeable",$canon)}print "rmdir $root\n" if$arg->{verbose};if (rmdir$root){push @{${$arg->{result}}},$root if$arg->{result};++$count}else {_error($arg,"cannot remove directory",$canon);if (_FORCE_WRITABLE &&!chmod($perm,(_IS_VMS ? VMS::Filespec::fileify($root): $root))){_error($arg,sprintf("cannot restore permissions to 0%o",$perm),$canon)}}}}else {$root=VMS::Filespec::vmsify("./$root")if _IS_VMS &&!File::Spec->file_name_is_absolute($root)&& ($root !~ m/(?<!\^)[\]>]+/);if ($arg->{safe}&& (_IS_VMS ?!&VMS::Filespec::candelete($root):!(-l $root || -w $root))){print "skipped $root\n" if$arg->{verbose};next ROOT_DIR}my$nperm=$perm & oct '7777' | oct '600';if (_FORCE_WRITABLE and $nperm!=$perm and not chmod$nperm,$root){_error($arg,"cannot make file writeable",$canon)}print "unlink $canon\n" if$arg->{verbose};for (;;){if (unlink$root){push @{${$arg->{result}}},$root if$arg->{result}}else {_error($arg,"cannot unlink file",$canon);_FORCE_WRITABLE and chmod($perm,$root)or _error($arg,sprintf("cannot restore permissions to 0%o",$perm),$canon);last}++$count;last unless _IS_VMS && lstat$root}}}return$count}sub _slash_lc {my$path=shift;$path =~ tr{\\}{/};return lc($path)}1;
FILE_PATH

$fatpacked{"File/Temp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_TEMP';
  package File::Temp;our$VERSION='0.2304';use 5.006;use strict;use Carp;use File::Spec 0.8;use Cwd ();use File::Path 2.06 qw/rmtree/;use Fcntl 1.03;use IO::Seekable;use Errno;use Scalar::Util 'refaddr';require VMS::Stdio if $^O eq 'VMS';eval {require Carp::Heavy};require Symbol if $] < 5.006;use parent 0.221 qw/IO::Handle IO::Seekable/;use overload '""'=>"STRINGIFY",'0+'=>"NUMIFY",fallback=>1;use vars qw(@EXPORT_OK %EXPORT_TAGS $DEBUG $KEEP_ALL);$DEBUG=0;$KEEP_ALL=0;use Exporter 5.57 'import';@EXPORT_OK=qw{tempfile tempdir tmpnam tmpfile mktemp mkstemp mkstemps mkdtemp unlink0 cleanup SEEK_SET SEEK_CUR SEEK_END};%EXPORT_TAGS=('POSIX'=>[qw/tmpnam tmpfile/],'mktemp'=>[qw/mktemp mkstemp mkstemps mkdtemp/],'seekable'=>[qw/SEEK_SET SEEK_CUR SEEK_END/],);Exporter::export_tags('POSIX','mktemp','seekable');my@CHARS=(qw/A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 _/);use constant MAX_TRIES=>1000;use constant MINX=>4;use constant TEMPXXX=>'X' x 10;use constant STANDARD=>0;use constant MEDIUM=>1;use constant HIGH=>2;my$OPENFLAGS=O_CREAT | O_EXCL | O_RDWR;my$LOCKFLAG;unless ($^O eq 'MacOS'){for my$oflag (qw/NOFOLLOW BINARY LARGEFILE NOINHERIT/){my ($bit,$func)=(0,"Fcntl::O_" .$oflag);no strict 'refs';$OPENFLAGS |= $bit if eval {local$SIG{__DIE__}=sub {};local$SIG{__WARN__}=sub {};$bit=&$func();1}}$LOCKFLAG=eval {local$SIG{__DIE__}=sub {};local$SIG{__WARN__}=sub {};&Fcntl::O_EXLOCK()}}my$OPENTEMPFLAGS=$OPENFLAGS;unless ($^O eq 'MacOS'){for my$oflag (qw/TEMPORARY/){my ($bit,$func)=(0,"Fcntl::O_" .$oflag);local($@);no strict 'refs';$OPENTEMPFLAGS |= $bit if eval {local$SIG{__DIE__}=sub {};local$SIG{__WARN__}=sub {};$bit=&$func();1}}}my%FILES_CREATED_BY_OBJECT;sub _gettemp {croak 'Usage: ($fh, $name) = _gettemp($template, OPTIONS);' unless scalar(@_)>= 1;my$tempErrStr;my%options=("open"=>0,"mkdir"=>0,"suffixlen"=>0,"unlink_on_close"=>0,"use_exlock"=>1,"ErrStr"=>\$tempErrStr,);my$template=shift;if (ref($template)){carp "File::Temp::_gettemp: template must not be a reference";return ()}if (scalar(@_)% 2!=0){carp "File::Temp::_gettemp: Must have even number of options";return ()}%options=(%options,@_)if @_;${$options{ErrStr}}=undef;if ($options{"open"}&& $options{"mkdir"}){${$options{ErrStr}}="doopen and domkdir can not both be true\n";return ()}my$start=length($template)- 1 - $options{"suffixlen"};if (substr($template,$start - MINX + 1,MINX)ne 'X' x MINX){${$options{ErrStr}}="The template must end with at least ".MINX ." 'X' characters\n";return ()}my$path=_replace_XX($template,$options{"suffixlen"});my ($volume,$directories,$file);my$parent;if ($options{"mkdir"}){($volume,$directories,$file)=File::Spec->splitpath($path,1);my@dirs=File::Spec->splitdir($directories);if ($#dirs==0){$parent=File::Spec->curdir}else {if ($^O eq 'VMS'){$parent=File::Spec->catdir($volume,@dirs[0..$#dirs-1]);$parent='sys$disk:[]' if$parent eq ''}else {$parent=File::Spec->catdir(@dirs[0..$#dirs-1]);$parent=File::Spec->catpath($volume,$parent,'')}}}else {($volume,$directories,$file)=File::Spec->splitpath($path);$parent=File::Spec->catpath($volume,$directories,'');$parent=File::Spec->curdir unless$directories ne ''}unless (-e $parent){${$options{ErrStr}}="Parent directory ($parent) does not exist";return ()}unless (-d $parent){${$options{ErrStr}}="Parent directory ($parent) is not a directory";return ()}if (File::Temp->safe_level==MEDIUM){my$safeerr;unless (_is_safe($parent,\$safeerr)){${$options{ErrStr}}="Parent directory ($parent) is not safe ($safeerr)";return ()}}elsif (File::Temp->safe_level==HIGH){my$safeerr;unless (_is_verysafe($parent,\$safeerr)){${$options{ErrStr}}="Parent directory ($parent) is not safe ($safeerr)";return ()}}for (my$i=0;$i < MAX_TRIES;$i++){if ($options{"open"}){my$fh;if ($] < 5.006){$fh=&Symbol::gensym}local $^F=2;my$open_success=undef;if ($^O eq 'VMS' and $options{"unlink_on_close"}&&!$KEEP_ALL){$fh=VMS::Stdio::vmssysopen($path,$OPENFLAGS,0600,'fop=dlt');$open_success=$fh}else {my$flags=(($options{"unlink_on_close"}&&!$KEEP_ALL)? $OPENTEMPFLAGS : $OPENFLAGS);$flags |= $LOCKFLAG if (defined$LOCKFLAG && $options{use_exlock});$open_success=sysopen($fh,$path,$flags,0600)}if ($open_success){chmod(0600,$path);return ($fh,$path)}else {unless ($!{EEXIST}){${$options{ErrStr}}="Could not create temp file $path: $!";return ()}}}elsif ($options{"mkdir"}){if (mkdir($path,0700)){chmod(0700,$path);return undef,$path}else {unless ($!{EEXIST}){${$options{ErrStr}}="Could not create directory $path: $!";return ()}}}else {return (undef,$path)unless -e $path}my$original=$path;my$counter=0;my$MAX_GUESS=50;do {$path=_replace_XX($template,$options{"suffixlen"});$counter++}until ($path ne $original || $counter > $MAX_GUESS);if ($counter > $MAX_GUESS){${$options{ErrStr}}="Tried to get a new temp name different to the previous value $MAX_GUESS times.\nSomething wrong with template?? ($template)";return ()}}${$options{ErrStr}}="Have exceeded the maximum number of attempts (" .MAX_TRIES .") to open temp file/dir";return ()}sub _replace_XX {croak 'Usage: _replace_XX($template, $ignore)' unless scalar(@_)==2;my ($path,$ignore)=@_;my$end=($] >= 5.006 ? "\\z" : "\\Z");if ($ignore){substr($path,0,- $ignore)=~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge}else {$path =~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge}return$path}sub _force_writable {my$file=shift;chmod 0600,$file}sub _is_safe {my$path=shift;my$err_ref=shift;my@info=stat($path);unless (scalar(@info)){$$err_ref="stat(path) returned no values";return 0};return 1 if $^O eq 'VMS';if ($info[4]> File::Temp->top_system_uid()&& $info[4]!=$>){Carp::cluck(sprintf "uid=$info[4] topuid=%s euid=$> path='$path'",File::Temp->top_system_uid());$$err_ref="Directory owned neither by root nor the current user" if ref($err_ref);return 0}if (($info[2]& &Fcntl::S_IWGRP)|| ($info[2]& &Fcntl::S_IWOTH)){unless (-d $path){$$err_ref="Path ($path) is not a directory" if ref($err_ref);return 0}unless (-k $path){$$err_ref="Sticky bit not set on $path when dir is group|world writable" if ref($err_ref);return 0}}return 1}sub _is_verysafe {require POSIX;my$path=shift;print "_is_verysafe testing $path\n" if$DEBUG;return 1 if $^O eq 'VMS';my$err_ref=shift;local($@);my$chown_restricted;$chown_restricted=&POSIX::_PC_CHOWN_RESTRICTED()if eval {&POSIX::_PC_CHOWN_RESTRICTED();1};if (defined$chown_restricted){return _is_safe($path,$err_ref)if POSIX::sysconf($chown_restricted)}unless (File::Spec->file_name_is_absolute($path)){$path=File::Spec->rel2abs($path)}my ($volume,$directories,undef)=File::Spec->splitpath($path,1);my@dirs=File::Spec->splitdir($directories);for my$pos (0.. $#dirs){my$dir=File::Spec->catpath($volume,File::Spec->catdir(@dirs[0.. $#dirs - $pos]),'');print "TESTING DIR $dir\n" if$DEBUG;return 0 unless _is_safe($dir,$err_ref)}return 1}sub _can_unlink_opened_file {if (grep {$^O eq $_}qw/MSWin32 os2 VMS dos MacOS haiku/){return 0}else {return 1}}sub _can_do_level {my$level=shift;return 1 if$level==STANDARD;if ($^O eq 'MSWin32' || $^O eq 'os2' || $^O eq 'cygwin' || $^O eq 'dos' || $^O eq 'MacOS' || $^O eq 'mpeix'){return 0}else {return 1}}{my (%files_to_unlink,%dirs_to_unlink);END {local($.,$@,$!,$^E,$?);cleanup(at_exit=>1)}sub cleanup {my%h=@_;my$at_exit=delete$h{at_exit};$at_exit=0 if not defined$at_exit;{my@k=sort keys%h;die "unrecognized parameters: @k" if@k}if (!$KEEP_ALL){my@files=(exists$files_to_unlink{$$}? @{$files_to_unlink{$$}}: ());for my$file (@files){close($file->[0]);if (-f $file->[1]){_force_writable($file->[1]);unlink$file->[1]or warn "Error removing ".$file->[1]}}my@dirs=(exists$dirs_to_unlink{$$}? @{$dirs_to_unlink{$$}}: ());my ($cwd,$cwd_to_remove);for my$dir (@dirs){if (-d $dir){if ($at_exit){$cwd=Cwd::abs_path(File::Spec->curdir)if not defined$cwd;my$abs=Cwd::abs_path($dir);if ($abs eq $cwd){$cwd_to_remove=$dir;next}}eval {rmtree($dir,$DEBUG,0)};warn $@ if ($@ && $^W)}}if (defined$cwd_to_remove){chdir$cwd_to_remove or die "cannot chdir to $cwd_to_remove: $!";my$updir=File::Spec->updir;chdir$updir or die "cannot chdir to $updir: $!";eval {rmtree($cwd_to_remove,$DEBUG,0)};warn $@ if ($@ && $^W)}@{$files_to_unlink{$$}}=()if exists$files_to_unlink{$$};@{$dirs_to_unlink{$$}}=()if exists$dirs_to_unlink{$$}}}sub _deferred_unlink {croak 'Usage:  _deferred_unlink($fh, $fname, $isdir)' unless scalar(@_)==3;my ($fh,$fname,$isdir)=@_;warn "Setting up deferred removal of $fname\n" if$DEBUG;$fname=Cwd::abs_path($fname);($fname)=$fname =~ /^(.*)$/;if ($isdir){if (-d $fname){$fname=VMS::Filespec::vmspath($fname)if $^O eq 'VMS';$dirs_to_unlink{$$}=[]unless exists$dirs_to_unlink{$$};push (@{$dirs_to_unlink{$$}},$fname)}else {carp "Request to remove directory $fname could not be completed since it does not exist!\n" if $^W}}else {if (-f $fname){$files_to_unlink{$$}=[]unless exists$files_to_unlink{$$};push(@{$files_to_unlink{$$}},[$fh,$fname])}else {carp "Request to remove file $fname could not be completed since it is not there!\n" if $^W}}}}sub _parse_args {my$leading_template=(scalar(@_)% 2==1 ? shift(@_): '');my%args=@_;%args=map {uc($_),$args{$_}}keys%args;my@template=(exists$args{TEMPLATE}? $args{TEMPLATE}: $leading_template ? $leading_template : ());delete$args{TEMPLATE};return(\@template,\%args)}sub new {my$proto=shift;my$class=ref($proto)|| $proto;my ($maybe_template,$args)=_parse_args(@_);my$unlink=(exists$args->{UNLINK}? $args->{UNLINK}: 1);delete$args->{UNLINK};delete$args->{OPEN};my ($fh,$path)=tempfile(@$maybe_template,%$args);print "Tmp: $fh - $path\n" if$DEBUG;${*$fh}=$path;$FILES_CREATED_BY_OBJECT{$$}{$path}=1;%{*$fh}=%$args;bless$fh,$class;$fh->unlink_on_destroy($unlink);return$fh}sub newdir {my$self=shift;my ($maybe_template,$args)=_parse_args(@_);my$cleanup=(exists$args->{CLEANUP}? $args->{CLEANUP}: 1);delete$args->{CLEANUP};my$tempdir=tempdir(@$maybe_template,%$args);my$real_dir=Cwd::abs_path($tempdir);($real_dir)=$real_dir =~ /^(.*)$/;return bless {DIRNAME=>$tempdir,REALNAME=>$real_dir,CLEANUP=>$cleanup,LAUNCHPID=>$$,},"File::Temp::Dir"}sub filename {my$self=shift;return ${*$self}}sub STRINGIFY {my$self=shift;return$self->filename}sub NUMIFY {return refaddr($_[0])}sub unlink_on_destroy {my$self=shift;if (@_){${*$self}{UNLINK}=shift}return ${*$self}{UNLINK}}sub DESTROY {local($.,$@,$!,$^E,$?);my$self=shift;my$file=$self->filename;my$was_created_by_proc;if (exists$FILES_CREATED_BY_OBJECT{$$}{$file}){$was_created_by_proc=1;delete$FILES_CREATED_BY_OBJECT{$$}{$file}}if (${*$self}{UNLINK}&&!$KEEP_ALL){print "# --------->   Unlinking $self\n" if$DEBUG;return unless$was_created_by_proc;_force_writable($file);unlink1($self,$file)or unlink($file)}}sub tempfile {if (@_ && $_[0]eq 'File::Temp'){croak "'tempfile' can't be called as a method"}my%options=("DIR"=>undef,"SUFFIX"=>'',"UNLINK"=>0,"OPEN"=>1,"TMPDIR"=>0,"EXLOCK"=>1,);my ($maybe_template,$args)=_parse_args(@_);my$template=@$maybe_template ? $maybe_template->[0]: undef;%options=(%options,%$args);if (!$options{"OPEN"}){warn "tempfile(): temporary filename requested but not opened.\nPossibly unsafe, consider using tempfile() with OPEN set to true\n" if $^W}if ($options{"DIR"}and $^O eq 'VMS'){$options{"DIR"}=VMS::Filespec::vmspath($options{"DIR"})}if (defined$template){if ($options{"DIR"}){$template=File::Spec->catfile($options{"DIR"},$template)}elsif ($options{TMPDIR}){$template=File::Spec->catfile(File::Spec->tmpdir,$template)}}else {if ($options{"DIR"}){$template=File::Spec->catfile($options{"DIR"},TEMPXXX)}else {$template=File::Spec->catfile(File::Spec->tmpdir,TEMPXXX)}}$template .= $options{"SUFFIX"};my$unlink_on_close=(wantarray ? 0 : 1);my ($fh,$path,$errstr);croak "Error in tempfile() using template $template: $errstr" unless (($fh,$path)=_gettemp($template,"open"=>$options{'OPEN'},"mkdir"=>0,"unlink_on_close"=>$unlink_on_close,"suffixlen"=>length($options{'SUFFIX'}),"ErrStr"=>\$errstr,"use_exlock"=>$options{EXLOCK},));_deferred_unlink($fh,$path,0)if$options{"UNLINK"};if (wantarray()){if ($options{'OPEN'}){return ($fh,$path)}else {return (undef,$path)}}else {unlink0($fh,$path)or croak "Error unlinking file $path using unlink0";return$fh}}sub tempdir {if (@_ && $_[0]eq 'File::Temp'){croak "'tempdir' can't be called as a method"}my%options=("CLEANUP"=>0,"DIR"=>'',"TMPDIR"=>0,);my ($maybe_template,$args)=_parse_args(@_);my$template=@$maybe_template ? $maybe_template->[0]: undef;%options=(%options,%$args);if (defined$template){if ($options{'TMPDIR'}|| $options{'DIR'}){$template=VMS::Filespec::vmspath($template)if $^O eq 'VMS';my ($volume,$directories,undef)=File::Spec->splitpath($template,1);$template=(File::Spec->splitdir($directories))[-1];if ($options{"DIR"}){$template=File::Spec->catdir($options{"DIR"},$template)}elsif ($options{TMPDIR}){$template=File::Spec->catdir(File::Spec->tmpdir,$template)}}}else {if ($options{"DIR"}){$template=File::Spec->catdir($options{"DIR"},TEMPXXX)}else {$template=File::Spec->catdir(File::Spec->tmpdir,TEMPXXX)}}my$tempdir;my$suffixlen=0;if ($^O eq 'VMS'){$template =~ m/([\.\]:>]+)$/;$suffixlen=length($1)}if (($^O eq 'MacOS')&& (substr($template,-1)eq ':')){++$suffixlen}my$errstr;croak "Error in tempdir() using $template: $errstr" unless ((undef,$tempdir)=_gettemp($template,"open"=>0,"mkdir"=>1,"suffixlen"=>$suffixlen,"ErrStr"=>\$errstr,));if ($options{'CLEANUP'}&& -d $tempdir){_deferred_unlink(undef,$tempdir,1)}return$tempdir}sub mkstemp {croak "Usage: mkstemp(template)" if scalar(@_)!=1;my$template=shift;my ($fh,$path,$errstr);croak "Error in mkstemp using $template: $errstr" unless (($fh,$path)=_gettemp($template,"open"=>1,"mkdir"=>0,"suffixlen"=>0,"ErrStr"=>\$errstr,));if (wantarray()){return ($fh,$path)}else {return$fh}}sub mkstemps {croak "Usage: mkstemps(template, suffix)" if scalar(@_)!=2;my$template=shift;my$suffix=shift;$template .= $suffix;my ($fh,$path,$errstr);croak "Error in mkstemps using $template: $errstr" unless (($fh,$path)=_gettemp($template,"open"=>1,"mkdir"=>0,"suffixlen"=>length($suffix),"ErrStr"=>\$errstr,));if (wantarray()){return ($fh,$path)}else {return$fh}}sub mkdtemp {croak "Usage: mkdtemp(template)" if scalar(@_)!=1;my$template=shift;my$suffixlen=0;if ($^O eq 'VMS'){$template =~ m/([\.\]:>]+)$/;$suffixlen=length($1)}if (($^O eq 'MacOS')&& (substr($template,-1)eq ':')){++$suffixlen}my ($junk,$tmpdir,$errstr);croak "Error creating temp directory from template $template\: $errstr" unless (($junk,$tmpdir)=_gettemp($template,"open"=>0,"mkdir"=>1,"suffixlen"=>$suffixlen,"ErrStr"=>\$errstr,));return$tmpdir}sub mktemp {croak "Usage: mktemp(template)" if scalar(@_)!=1;my$template=shift;my ($tmpname,$junk,$errstr);croak "Error getting name to temp file from template $template: $errstr" unless (($junk,$tmpname)=_gettemp($template,"open"=>0,"mkdir"=>0,"suffixlen"=>0,"ErrStr"=>\$errstr,));return$tmpname}sub tmpnam {my$tmpdir=File::Spec->tmpdir;croak "Error temporary directory is not writable" if$tmpdir eq '';my$template=File::Spec->catfile($tmpdir,TEMPXXX);if (wantarray()){return mkstemp($template)}else {return mktemp($template)}}sub tmpfile {my ($fh,$file)=tmpnam();unlink0($fh,$file)or return undef;return$fh}sub tempnam {croak 'Usage tempnam($dir, $prefix)' unless scalar(@_)==2;my ($dir,$prefix)=@_;$prefix .= 'XXXXXXXX';my$template=File::Spec->catfile($dir,$prefix);return mktemp($template)}sub unlink0 {croak 'Usage: unlink0(filehandle, filename)' unless scalar(@_)==2;my ($fh,$path)=@_;cmpstat($fh,$path)or return 0;if (_can_unlink_opened_file()){return 1 if$KEEP_ALL;croak "unlink0: $path has become a directory!" if -d $path;unlink($path)or return 0;my@fh=stat$fh;print "Link count = $fh[3] \n" if$DEBUG;return 1 if$fh[3]==0 || $^O eq 'cygwin'}_deferred_unlink($fh,$path,0);return 1}sub cmpstat {croak 'Usage: cmpstat(filehandle, filename)' unless scalar(@_)==2;my ($fh,$path)=@_;warn "Comparing stat\n" if$DEBUG;my@fh;{local ($^W)=0;@fh=stat$fh}return unless@fh;if ($fh[3]> 1 && $^W){carp "unlink0: fstat found too many links; SB=@fh" if $^W}my@path=stat$path;unless (@path){carp "unlink0: $path is gone already" if $^W;return}unless (-f $path){confess "panic: $path is no longer a file: SB=@fh"}my@okstat=(0..$#fh);if ($^O eq 'MSWin32'){@okstat=(1,2,3,4,5,7,8,9,10)}elsif ($^O eq 'os2'){@okstat=(0,2..$#fh)}elsif ($^O eq 'VMS'){@okstat=(0,1)}elsif ($^O eq 'dos'){@okstat=(0,2..7,11..$#fh)}elsif ($^O eq 'mpeix'){@okstat=(0..4,8..10)}for (@okstat){print "Comparing: $_ : $fh[$_] and $path[$_]\n" if$DEBUG;unless ($fh[$_]eq $path[$_]){warn "Did not match $_ element of stat\n" if$DEBUG;return 0}}return 1}sub unlink1 {croak 'Usage: unlink1(filehandle, filename)' unless scalar(@_)==2;my ($fh,$path)=@_;cmpstat($fh,$path)or return 0;close($fh)or return 0;_force_writable($path);return 1 if$KEEP_ALL;return unlink($path)}{my$LEVEL=STANDARD;sub safe_level {my$self=shift;if (@_){my$level=shift;if (($level!=STANDARD)&& ($level!=MEDIUM)&& ($level!=HIGH)){carp "safe_level: Specified level ($level) not STANDARD, MEDIUM or HIGH - ignoring\n" if $^W}else {if ($] < 5.006 && $level!=STANDARD){croak "Currently requires perl 5.006 or newer to do the safe checks"}$LEVEL=$level if _can_do_level($level)}}return$LEVEL}}{my$TopSystemUID=10;$TopSystemUID=197108 if $^O eq 'interix';sub top_system_uid {my$self=shift;if (@_){my$newuid=shift;croak "top_system_uid: UIDs should be numeric" unless$newuid =~ /^\d+$/s;$TopSystemUID=$newuid}return$TopSystemUID}}package File::Temp::Dir;use File::Path qw/rmtree/;use strict;use overload '""'=>"STRINGIFY",'0+'=>\&File::Temp::NUMIFY,fallback=>1;sub dirname {my$self=shift;return$self->{DIRNAME}}sub STRINGIFY {my$self=shift;return$self->dirname}sub unlink_on_destroy {my$self=shift;if (@_){$self->{CLEANUP}=shift}return$self->{CLEANUP}}sub DESTROY {my$self=shift;local($.,$@,$!,$^E,$?);if ($self->unlink_on_destroy && $$==$self->{LAUNCHPID}&&!$File::Temp::KEEP_ALL){if (-d $self->{REALNAME}){eval {rmtree($self->{REALNAME},$File::Temp::DEBUG,0)};warn $@ if ($@ && $^W)}}}1;
FILE_TEMP

$fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
  use strict;use warnings;package File::pushd;our$VERSION='1.014';our@EXPORT=qw(pushd tempd);our@ISA=qw(Exporter);use Exporter;use Carp;use Cwd qw(getcwd abs_path);use File::Path qw(rmtree);use File::Temp qw();use File::Spec;use overload q{""}=>sub {File::Spec->canonpath($_[0]->{_pushd})},fallback=>1;sub pushd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::pushd in void context');return}my ($target_dir,$options)=@_;$options->{untaint_pattern}||= qr{^([-+@\w./]+)$};$target_dir="." unless defined$target_dir;croak "Can't locate directory $target_dir" unless -d $target_dir;my$tainted_orig=getcwd;my$orig;if ($tainted_orig =~ $options->{untaint_pattern}){$orig=$1}else {$orig=$tainted_orig}my$tainted_dest;eval {$tainted_dest=$target_dir ? abs_path($target_dir): $orig};croak "Can't locate absolute path for $target_dir: $@" if $@;my$dest;if ($tainted_dest =~ $options->{untaint_pattern}){$dest=$1}else {$dest=$tainted_dest}if ($dest ne $orig){chdir$dest or croak "Can't chdir to $dest\: $!"}my$self=bless {_pushd=>$dest,_original=>$orig },__PACKAGE__;return$self}sub tempd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::tempd in void context');return}my ($options)=@_;my$dir;eval {$dir=pushd(File::Temp::tempdir(CLEANUP=>0),$options)};croak $@ if $@;$dir->{_tempd}=1;return$dir}sub preserve {my$self=shift;return 1 if!$self->{"_tempd"};if (@_==0){return$self->{_preserve}=1}else {return$self->{_preserve}=$_[0]? 1 : 0}}sub DESTROY {my ($self)=@_;my$orig=$self->{_original};chdir$orig if$orig;if ($self->{_tempd}&&!$self->{_preserve}){my$err=do {local $@;eval {rmtree($self->{_pushd})};$@};carp$err if$err}}1;
FILE_PUSHD

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  package Getopt::Long;use 5.004;use strict;use vars qw($VERSION);$VERSION=2.49;use vars qw($VERSION_STRING);$VERSION_STRING="2.49";use Exporter;use vars qw(@ISA @EXPORT @EXPORT_OK);@ISA=qw(Exporter);sub GetOptions(@);sub GetOptionsFromArray(@);sub GetOptionsFromString(@);sub Configure(@);sub HelpMessage(@);sub VersionMessage(@);BEGIN {@EXPORT=qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);@EXPORT_OK=qw(&HelpMessage &VersionMessage &Configure &GetOptionsFromArray &GetOptionsFromString)}use vars@EXPORT,@EXPORT_OK;use vars qw($error $debug $major_version $minor_version);use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order $passthrough);use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);my$bundling_values;sub config(@);sub ConfigDefaults();sub ParseOptionSpec($$);sub OptCtl($);sub FindOption($$$$$);sub ValidValue ($$$$$);my$requested_version=0;sub ConfigDefaults() {if (defined$ENV{"POSIXLY_CORRECT"}){$genprefix="(--|-)";$autoabbrev=0;$bundling=0;$getopt_compat=0;$order=$REQUIRE_ORDER}else {$genprefix="(--|-|\\+)";$autoabbrev=1;$bundling=0;$getopt_compat=1;$order=$PERMUTE}$debug=0;$error=0;$ignorecase=1;$passthrough=0;$gnu_compat=0;$longprefix="(--)";$bundling_values=0}sub import {my$pkg=shift;my@syms=();my@config=();my$dest=\@syms;for (@_){if ($_ eq ':config'){$dest=\@config;next}push(@$dest,$_)}local$Exporter::ExportLevel=1;push(@syms,qw(&GetOptions))if@syms;$requested_version=0;$pkg->SUPER::import(@syms);Configure(@config)if@config}($REQUIRE_ORDER,$PERMUTE,$RETURN_IN_ORDER)=(0..2);($major_version,$minor_version)=$VERSION =~ /^(\d+)\.(\d+)/;ConfigDefaults();package Getopt::Long::Parser;my$default_config=do {Getopt::Long::Configure ()};sub new {my$that=shift;my$class=ref($that)|| $that;my%atts=@_;my$self={caller_pkg=>(caller)[0]};bless ($self,$class);if (defined$atts{config}){my$save=Getopt::Long::Configure ($default_config,@{$atts{config}});$self->{settings}=Getopt::Long::Configure ($save);delete ($atts{config})}else {$self->{settings}=$default_config}if (%atts){die(__PACKAGE__.": unhandled attributes: ".join(" ",sort(keys(%atts)))."\n")}$self}sub configure {my ($self)=shift;my$save=Getopt::Long::Configure ($self->{settings},@_);$self->{settings}=Getopt::Long::Configure ($save)}sub getoptions {my ($self)=shift;return$self->getoptionsfromarray(\@ARGV,@_)}sub getoptionsfromarray {my ($self)=shift;my$save=Getopt::Long::Configure ($self->{settings});my$ret=0;$Getopt::Long::caller=$self->{caller_pkg};eval {local ($SIG{__DIE__})='DEFAULT';$ret=Getopt::Long::GetOptionsFromArray (@_)};Getopt::Long::Configure ($save);die ($@)if $@;return$ret}package Getopt::Long;use constant CTL_TYPE=>0;use constant CTL_CNAME=>1;use constant CTL_DEFAULT=>2;use constant CTL_DEST=>3;use constant CTL_DEST_SCALAR=>0;use constant CTL_DEST_ARRAY=>1;use constant CTL_DEST_HASH=>2;use constant CTL_DEST_CODE=>3;use constant CTL_AMIN=>4;use constant CTL_AMAX=>5;use constant PAT_INT=>"[-+]?_*[0-9][0-9_]*";use constant PAT_XINT=>"(?:"."[-+]?_*[1-9][0-9_]*"."|"."0x_*[0-9a-f][0-9a-f_]*"."|"."0b_*[01][01_]*"."|"."0[0-7_]*".")";use constant PAT_FLOAT=>"[-+]?"."(?=[0-9.])"."[0-9_]*"."(\.[0-9_]+)?"."([eE][-+]?[0-9_]+)?";sub GetOptions(@) {unshift(@_,\@ARGV);goto&GetOptionsFromArray}sub GetOptionsFromString(@) {my ($string)=shift;require Text::ParseWords;my$args=[Text::ParseWords::shellwords($string)];$caller ||= (caller)[0];my$ret=GetOptionsFromArray($args,@_);return ($ret,$args)if wantarray;if (@$args){$ret=0;warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n")}$ret}sub GetOptionsFromArray(@) {my ($argv,@optionlist)=@_;my$argend='--';my%opctl=();my$pkg=$caller || (caller)[0];my@ret=();my%linkage;my$userlinkage;my$opt;my$prefix=$genprefix;$error='';if ($debug){local ($^W)=0;print STDERR ("Getopt::Long $Getopt::Long::VERSION ","called from package \"$pkg\".","\n  ","argv: ",defined($argv)? UNIVERSAL::isa($argv,'ARRAY')? "(@$argv)" : $argv : "<undef>","\n  ","autoabbrev=$autoabbrev,"."bundling=$bundling,","bundling_values=$bundling_values,","getopt_compat=$getopt_compat,","gnu_compat=$gnu_compat,","order=$order,","\n  ","ignorecase=$ignorecase,","requested_version=$requested_version,","passthrough=$passthrough,","genprefix=\"$genprefix\",","longprefix=\"$longprefix\".","\n")}$userlinkage=undef;if (@optionlist && ref($optionlist[0])and UNIVERSAL::isa($optionlist[0],'HASH')){$userlinkage=shift (@optionlist);print STDERR ("=> user linkage: $userlinkage\n")if$debug}if (@optionlist && $optionlist[0]=~ /^\W+$/ &&!($optionlist[0]eq '<>' && @optionlist > 0 && ref($optionlist[1]))){$prefix=shift (@optionlist);$prefix =~ s/(\W)/\\$1/g;$prefix="([" .$prefix ."])";print STDERR ("=> prefix=\"$prefix\"\n")if$debug}%opctl=();while (@optionlist){my$opt=shift (@optionlist);unless (defined($opt)){$error .= "Undefined argument in option spec\n";next}$opt=$+ if$opt =~ /^$prefix+(.*)$/s;if ($opt eq '<>'){if ((defined$userlinkage)&&!(@optionlist > 0 && ref($optionlist[0]))&& (exists$userlinkage->{$opt})&& ref($userlinkage->{$opt})){unshift (@optionlist,$userlinkage->{$opt})}unless (@optionlist > 0 && ref($optionlist[0])&& ref($optionlist[0])eq 'CODE'){$error .= "Option spec <> requires a reference to a subroutine\n";shift (@optionlist)if@optionlist && ref($optionlist[0]);next}$linkage{'<>'}=shift (@optionlist);next}my ($name,$orig)=ParseOptionSpec ($opt,\%opctl);unless (defined$name){$error .= $orig;shift (@optionlist)if@optionlist && ref($optionlist[0]);next}if (defined$userlinkage){unless (@optionlist > 0 && ref($optionlist[0])){if (exists$userlinkage->{$orig}&& ref($userlinkage->{$orig})){print STDERR ("=> found userlinkage for \"$orig\": ","$userlinkage->{$orig}\n")if$debug;unshift (@optionlist,$userlinkage->{$orig})}else {next}}}if (@optionlist > 0 && ref($optionlist[0])){print STDERR ("=> link \"$orig\" to $optionlist[0]\n")if$debug;my$rl=ref($linkage{$orig}=shift (@optionlist));if ($rl eq "ARRAY"){$opctl{$name}[CTL_DEST]=CTL_DEST_ARRAY}elsif ($rl eq "HASH"){$opctl{$name}[CTL_DEST]=CTL_DEST_HASH}elsif ($rl eq "SCALAR" || $rl eq "REF"){}elsif ($rl eq "CODE"){}else {$error .= "Invalid option linkage for \"$opt\"\n"}}else {my$ov=$orig;$ov =~ s/\W/_/g;if ($opctl{$name}[CTL_DEST]==CTL_DEST_ARRAY){print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;")}elsif ($opctl{$name}[CTL_DEST]==CTL_DEST_HASH){print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;")}else {print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;")}}if ($opctl{$name}[CTL_TYPE]eq 'I' && ($opctl{$name}[CTL_DEST]==CTL_DEST_ARRAY || $opctl{$name}[CTL_DEST]==CTL_DEST_HASH)){$error .= "Invalid option linkage for \"$opt\"\n"}}$error .= "GetOptionsFromArray: 1st parameter is not an array reference\n" unless$argv && UNIVERSAL::isa($argv,'ARRAY');die ($error)if$error;$error=0;if (defined($auto_version)? $auto_version : ($requested_version >= 2.3203)){if (!defined($opctl{version})){$opctl{version}=['','version',0,CTL_DEST_CODE,undef];$linkage{version}=\&VersionMessage}$auto_version=1}if (defined($auto_help)? $auto_help : ($requested_version >= 2.3203)){if (!defined($opctl{help})&&!defined($opctl{'?'})){$opctl{help}=$opctl{'?'}=['','help',0,CTL_DEST_CODE,undef];$linkage{help}=\&HelpMessage}$auto_help=1}if ($debug){my ($arrow,$k,$v);$arrow="=> ";while (($k,$v)=each(%opctl)){print STDERR ($arrow,"\$opctl{$k} = $v ",OptCtl($v),"\n");$arrow="   "}}my$goon=1;while ($goon && @$argv > 0){$opt=shift (@$argv);print STDERR ("=> arg \"",$opt,"\"\n")if$debug;if (defined($opt)&& $opt eq $argend){push (@ret,$argend)if$passthrough;last}my$tryopt=$opt;my$found;my$key;my$arg;my$ctl;($found,$opt,$ctl,$arg,$key)=FindOption ($argv,$prefix,$argend,$opt,\%opctl);if ($found){next unless defined$opt;my$argcnt=0;while (defined$arg){print STDERR ("=> cname for \"$opt\" is ")if$debug;$opt=$ctl->[CTL_CNAME];print STDERR ("\"$ctl->[CTL_CNAME]\"\n")if$debug;if (defined$linkage{$opt}){print STDERR ("=> ref(\$L{$opt}) -> ",ref($linkage{$opt}),"\n")if$debug;if (ref($linkage{$opt})eq 'SCALAR' || ref($linkage{$opt})eq 'REF'){if ($ctl->[CTL_TYPE]eq '+'){print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")if$debug;if (defined ${$linkage{$opt}}){${$linkage{$opt}}+= $arg}else {${$linkage{$opt}}=$arg}}elsif ($ctl->[CTL_DEST]==CTL_DEST_ARRAY){print STDERR ("=> ref(\$L{$opt}) auto-vivified"," to ARRAY\n")if$debug;my$t=$linkage{$opt};$$t=$linkage{$opt}=[];print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")if$debug;push (@{$linkage{$opt}},$arg)}elsif ($ctl->[CTL_DEST]==CTL_DEST_HASH){print STDERR ("=> ref(\$L{$opt}) auto-vivified"," to HASH\n")if$debug;my$t=$linkage{$opt};$$t=$linkage{$opt}={};print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")if$debug;$linkage{$opt}->{$key}=$arg}else {print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")if$debug;${$linkage{$opt}}=$arg}}elsif (ref($linkage{$opt})eq 'ARRAY'){print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")if$debug;push (@{$linkage{$opt}},$arg)}elsif (ref($linkage{$opt})eq 'HASH'){print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")if$debug;$linkage{$opt}->{$key}=$arg}elsif (ref($linkage{$opt})eq 'CODE'){print STDERR ("=> &L{$opt}(\"$opt\"",$ctl->[CTL_DEST]==CTL_DEST_HASH ? ", \"$key\"" : "",", \"$arg\")\n")if$debug;my$eval_error=do {local $@;local$SIG{__DIE__}='DEFAULT';eval {&{$linkage{$opt}}(Getopt::Long::CallBack->new (name=>$opt,ctl=>$ctl,opctl=>\%opctl,linkage=>\%linkage,prefix=>$prefix,),$ctl->[CTL_DEST]==CTL_DEST_HASH ? ($key): (),$arg)};$@};print STDERR ("=> die($eval_error)\n")if$debug && $eval_error ne '';if ($eval_error =~ /^!/){if ($eval_error =~ /^!FINISH\b/){$goon=0}}elsif ($eval_error ne ''){warn ($eval_error);$error++}}else {print STDERR ("Invalid REF type \"",ref($linkage{$opt}),"\" in linkage\n");die("Getopt::Long -- internal error!\n")}}elsif ($ctl->[CTL_DEST]==CTL_DEST_ARRAY){if (defined$userlinkage->{$opt}){print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")if$debug;push (@{$userlinkage->{$opt}},$arg)}else {print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")if$debug;$userlinkage->{$opt}=[$arg]}}elsif ($ctl->[CTL_DEST]==CTL_DEST_HASH){if (defined$userlinkage->{$opt}){print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")if$debug;$userlinkage->{$opt}->{$key}=$arg}else {print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")if$debug;$userlinkage->{$opt}={$key=>$arg}}}else {if ($ctl->[CTL_TYPE]eq '+'){print STDERR ("=> \$L{$opt} += \"$arg\"\n")if$debug;if (defined$userlinkage->{$opt}){$userlinkage->{$opt}+= $arg}else {$userlinkage->{$opt}=$arg}}else {print STDERR ("=>\$L{$opt} = \"$arg\"\n")if$debug;$userlinkage->{$opt}=$arg}}$argcnt++;last if$argcnt >= $ctl->[CTL_AMAX]&& $ctl->[CTL_AMAX]!=-1;undef($arg);if ($argcnt < $ctl->[CTL_AMIN]){if (@$argv){if (ValidValue($ctl,$argv->[0],1,$argend,$prefix)){$arg=shift(@$argv);if ($ctl->[CTL_TYPE]=~ /^[iIo]$/){$arg =~ tr/_//d;$arg=$ctl->[CTL_TYPE]eq 'o' && $arg =~ /^0/ ? oct($arg): 0+$arg}($key,$arg)=$arg =~ /^([^=]+)=(.*)/ if$ctl->[CTL_DEST]==CTL_DEST_HASH;next}warn("Value \"$$argv[0]\" invalid for option $opt\n");$error++}else {warn("Insufficient arguments for option $opt\n");$error++}}if (@$argv && ValidValue($ctl,$argv->[0],0,$argend,$prefix)){$arg=shift(@$argv);if ($ctl->[CTL_TYPE]=~ /^[iIo]$/){$arg =~ tr/_//d;$arg=$ctl->[CTL_TYPE]eq 'o' && $arg =~ /^0/ ? oct($arg): 0+$arg}($key,$arg)=$arg =~ /^([^=]+)=(.*)/ if$ctl->[CTL_DEST]==CTL_DEST_HASH;next}}}elsif ($order==$PERMUTE){my$cb;if (defined ($cb=$linkage{'<>'})){print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")if$debug;my$eval_error=do {local $@;local$SIG{__DIE__}='DEFAULT';eval {&$cb($tryopt)};$@};print STDERR ("=> die($eval_error)\n")if$debug && $eval_error ne '';if ($eval_error =~ /^!/){if ($eval_error =~ /^!FINISH\b/){$goon=0}}elsif ($eval_error ne ''){warn ($eval_error);$error++}}else {print STDERR ("=> saving \"$tryopt\" ","(not an option, may permute)\n")if$debug;push (@ret,$tryopt)}next}else {unshift (@$argv,$tryopt);return ($error==0)}}if (@ret && $order==$PERMUTE){print STDERR ("=> restoring \"",join('" "',@ret),"\"\n")if$debug;unshift (@$argv,@ret)}return ($error==0)}sub OptCtl ($) {my ($v)=@_;my@v=map {defined($_)? ($_): ("<undef>")}@$v;"[".join(",","\"$v[CTL_TYPE]\"","\"$v[CTL_CNAME]\"","\"$v[CTL_DEFAULT]\"",("\$","\@","\%","\&")[$v[CTL_DEST]|| 0],$v[CTL_AMIN]|| '',$v[CTL_AMAX]|| '',)."]"}sub ParseOptionSpec ($$) {my ($opt,$opctl)=@_;if ($opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x){return (undef,"Error in option spec: \"$opt\"\n")}my ($names,$spec)=($1,$2);$spec='' unless defined$spec;my$orig;my@names;if (defined$names){@names=split (/\|/,$names);$orig=$names[0]}else {@names=('');$orig=''}my$entry;if ($spec eq '' || $spec eq '+' || $spec eq '!'){$entry=[$spec,$orig,undef,CTL_DEST_SCALAR,0,0]}elsif ($spec =~ /^:(-?\d+|\+)([@%])?$/){my$def=$1;my$dest=$2;my$type=$def eq '+' ? 'I' : 'i';$dest ||= '$';$dest=$dest eq '@' ? CTL_DEST_ARRAY : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;$entry=[$type,$orig,$def eq '+' ? undef : $def,$dest,0,1]}else {my ($mand,$type,$dest)=$spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;return (undef,"Cannot repeat while bundling: \"$opt\"\n")if$bundling && defined($4);my ($mi,$cm,$ma)=($5,$6,$7);return (undef,"{0} is useless in option spec: \"$opt\"\n")if defined($mi)&&!$mi &&!defined($ma)&&!defined($cm);$type='i' if$type eq 'n';$dest ||= '$';$dest=$dest eq '@' ? CTL_DEST_ARRAY : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;$mi=$mand eq '=' ? 1 : 0 unless defined$mi;$mand=$mi ? '=' : ':';$ma=$mi ? $mi : 1 unless defined$ma || defined$cm;return (undef,"Max must be greater than zero in option spec: \"$opt\"\n")if defined($ma)&&!$ma;return (undef,"Max less than min in option spec: \"$opt\"\n")if defined($ma)&& $ma < $mi;$entry=[$type,$orig,undef,$dest,$mi,$ma||-1]}my$dups='';for (@names){$_=lc ($_)if$ignorecase > (($bundling && length($_)==1)? 1 : 0);if (exists$opctl->{$_}){$dups .= "Duplicate specification \"$opt\" for option \"$_\"\n"}if ($spec eq '!'){$opctl->{"no$_"}=$entry;$opctl->{"no-$_"}=$entry;$opctl->{$_}=[@$entry];$opctl->{$_}->[CTL_TYPE]=''}else {$opctl->{$_}=$entry}}if ($dups && $^W){for (split(/\n+/,$dups)){warn($_."\n")}}($names[0],$orig)}sub FindOption ($$$$$) {my ($argv,$prefix,$argend,$opt,$opctl)=@_;print STDERR ("=> find \"$opt\"\n")if$debug;return (0)unless defined($opt);return (0)unless$opt =~ /^($prefix)(.*)$/s;return (0)if$opt eq "-" &&!defined$opctl->{''};$opt=substr($opt,length($1));my$starter=$1;print STDERR ("=> split \"$starter\"+\"$opt\"\n")if$debug;my$optarg;my$rest;if (($starter=~/^$longprefix$/ || ($getopt_compat && ($bundling==0 || $bundling==2)))&& (my$oppos=index($opt,'=',1))> 0){my$optorg=$opt;$opt=substr($optorg,0,$oppos);$optarg=substr($optorg,$oppos + 1);print STDERR ("=> option \"",$opt,"\", optarg = \"$optarg\"\n")if$debug}my$tryopt=$opt;if (($bundling || $bundling_values)&& $starter eq '-'){$tryopt=$ignorecase ? lc($opt): $opt;if ($bundling==2 && length($tryopt)> 1 && defined ($opctl->{$tryopt})){print STDERR ("=> $starter$tryopt overrides unbundling\n")if$debug}elsif ($bundling_values){$tryopt=$opt;$rest=length ($tryopt)> 0 ? substr ($tryopt,1): '';$tryopt=substr ($tryopt,0,1);$tryopt=lc ($tryopt)if$ignorecase > 1;print STDERR ("=> $starter$tryopt unbundled from ","$starter$tryopt$rest\n")if$debug;$optarg=$rest eq '' ? undef : $rest;$rest=undef}else {$tryopt=$opt;$rest=length ($tryopt)> 0 ? substr ($tryopt,1): '';$tryopt=substr ($tryopt,0,1);$tryopt=lc ($tryopt)if$ignorecase > 1;print STDERR ("=> $starter$tryopt unbundled from ","$starter$tryopt$rest\n")if$debug;$rest=undef unless$rest ne ''}}elsif ($autoabbrev && $opt ne ""){my@names=sort(keys (%$opctl));$opt=lc ($opt)if$ignorecase;$tryopt=$opt;my$pat=quotemeta ($opt);my@hits=grep (/^$pat/,@names);print STDERR ("=> ",scalar(@hits)," hits (@hits) with \"$pat\" ","out of ",scalar(@names),"\n")if$debug;unless ((@hits <= 1)|| (grep ($_ eq $opt,@hits)==1)){my%hit;for (@hits){my$hit=$opctl->{$_}->[CTL_CNAME]if defined$opctl->{$_}->[CTL_CNAME];$hit="no" .$hit if$opctl->{$_}->[CTL_TYPE]eq '!';$hit{$hit}=1}if (keys(%hit)==2){if ($auto_version && exists($hit{version})){delete$hit{version}}elsif ($auto_help && exists($hit{help})){delete$hit{help}}}unless (keys(%hit)==1){return (0)if$passthrough;warn ("Option ",$opt," is ambiguous (",join(", ",@hits),")\n");$error++;return (1,undef)}@hits=keys(%hit)}if (@hits==1 && $hits[0]ne $opt){$tryopt=$hits[0];$tryopt=lc ($tryopt)if$ignorecase;print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")if$debug}}elsif ($ignorecase){$tryopt=lc ($opt)}my$ctl=$opctl->{$tryopt};unless (defined$ctl){return (0)if$passthrough;if ($bundling==1 && length($starter)==1){$opt=substr($opt,0,1);unshift (@$argv,$starter.$rest)if defined$rest}if ($opt eq ""){warn ("Missing option after ",$starter,"\n")}else {warn ("Unknown option: ",$opt,"\n")}$error++;return (1,undef)}$opt=$tryopt;print STDERR ("=> found ",OptCtl($ctl)," for \"",$opt,"\"\n")if$debug;my$type=$ctl->[CTL_TYPE];my$arg;if ($type eq '' || $type eq '!' || $type eq '+'){if (defined$optarg){return (0)if$passthrough;warn ("Option ",$opt," does not take an argument\n");$error++;undef$opt;undef$optarg if$bundling_values}elsif ($type eq '' || $type eq '+'){$arg=1}else {$opt =~ s/^no-?//i;$arg=0}unshift (@$argv,$starter.$rest)if defined$rest;return (1,$opt,$ctl,$arg)}my$mand=$ctl->[CTL_AMIN];if ($gnu_compat){my$optargtype=0;$optargtype=(!defined($optarg)? 0 : ((length($optarg)==0)? 1 : 2));return (1,$opt,$ctl,defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: undef)if (($optargtype==0)&&!$mand);return (1,$opt,$ctl,$type eq 's' ? '' : 0)if$optargtype==1}if (defined$optarg ? ($optarg eq ''):!(defined$rest || @$argv > 0)){if ($mand){return (0)if$passthrough;warn ("Option ",$opt," requires an argument\n");$error++;return (1,undef)}if ($type eq 'I'){my@c=@$ctl;$c[CTL_TYPE]='+';return (1,$opt,\@c,1)}return (1,$opt,$ctl,defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: $type eq 's' ? '' : 0)}$arg=(defined$rest ? $rest : (defined$optarg ? $optarg : shift (@$argv)));my$key;if ($ctl->[CTL_DEST]==CTL_DEST_HASH && defined$arg){($key,$arg)=($arg =~ /^([^=]*)=(.*)$/s)? ($1,$2): ($arg,defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: ($mand ? undef : ($type eq 's' ? "" : 1)));if (!defined$arg){warn ("Option $opt, key \"$key\", requires a value\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}}my$key_valid=$ctl->[CTL_DEST]==CTL_DEST_HASH ? "[^=]+=" : "";if ($type eq 's'){return (1,$opt,$ctl,$arg,$key)if$mand;return (1,$opt,$ctl,$arg,$key)if$ctl->[CTL_DEST]==CTL_DEST_HASH;return (1,$opt,$ctl,$arg,$key)if defined$optarg || defined$rest;return (1,$opt,$ctl,$arg,$key)if$arg eq "-";if ($arg eq $argend || $arg =~ /^$prefix.+/){unshift (@$argv,$arg);$arg=''}}elsif ($type eq 'i' || $type eq 'I' || $type eq 'o'){my$o_valid=$type eq 'o' ? PAT_XINT : PAT_INT;if ($bundling && defined$rest && $rest =~ /^($key_valid)($o_valid)(.*)$/si){($key,$arg,$rest)=($1,$2,$+);chop($key)if$key;$arg=($type eq 'o' && $arg =~ /^0/)? oct($arg): 0+$arg;unshift (@$argv,$starter.$rest)if defined$rest && $rest ne ''}elsif ($arg =~ /^$o_valid$/si){$arg =~ tr/_//d;$arg=($type eq 'o' && $arg =~ /^0/)? oct($arg): 0+$arg}else {if (defined$optarg || $mand){if ($passthrough){unshift (@$argv,defined$rest ? $starter.$rest : $arg)unless defined$optarg;return (0)}warn ("Value \"",$arg,"\" invalid for option ",$opt," (",$type eq 'o' ? "extended " : '',"number expected)\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}else {unshift (@$argv,defined$rest ? $starter.$rest : $arg);if ($type eq 'I'){my@c=@$ctl;$c[CTL_TYPE]='+';return (1,$opt,\@c,1)}$arg=defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: 0}}}elsif ($type eq 'f'){my$o_valid=PAT_FLOAT;if ($bundling && defined$rest && $rest =~ /^($key_valid)($o_valid)(.*)$/s){$arg =~ tr/_//d;($key,$arg,$rest)=($1,$2,$+);chop($key)if$key;unshift (@$argv,$starter.$rest)if defined$rest && $rest ne ''}elsif ($arg =~ /^$o_valid$/){$arg =~ tr/_//d}else {if (defined$optarg || $mand){if ($passthrough){unshift (@$argv,defined$rest ? $starter.$rest : $arg)unless defined$optarg;return (0)}warn ("Value \"",$arg,"\" invalid for option ",$opt," (real number expected)\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}else {unshift (@$argv,defined$rest ? $starter.$rest : $arg);$arg=0.0}}}else {die("Getopt::Long internal error (Can't happen)\n")}return (1,$opt,$ctl,$arg,$key)}sub ValidValue ($$$$$) {my ($ctl,$arg,$mand,$argend,$prefix)=@_;if ($ctl->[CTL_DEST]==CTL_DEST_HASH){return 0 unless$arg =~ /[^=]+=(.*)/;$arg=$1}my$type=$ctl->[CTL_TYPE];if ($type eq 's'){return (1)if$mand;return (1)if$arg eq "-";return 0 if$arg eq $argend || $arg =~ /^$prefix.+/;return 1}elsif ($type eq 'i' || $type eq 'I' || $type eq 'o'){my$o_valid=$type eq 'o' ? PAT_XINT : PAT_INT;return$arg =~ /^$o_valid$/si}elsif ($type eq 'f'){my$o_valid=PAT_FLOAT;return$arg =~ /^$o_valid$/}die("ValidValue: Cannot happen\n")}sub Configure (@) {my (@options)=@_;my$prevconfig=[$error,$debug,$major_version,$minor_version,$caller,$autoabbrev,$getopt_compat,$ignorecase,$bundling,$order,$gnu_compat,$passthrough,$genprefix,$auto_version,$auto_help,$longprefix,$bundling_values ];if (ref($options[0])eq 'ARRAY'){($error,$debug,$major_version,$minor_version,$caller,$autoabbrev,$getopt_compat,$ignorecase,$bundling,$order,$gnu_compat,$passthrough,$genprefix,$auto_version,$auto_help,$longprefix,$bundling_values)=@{shift(@options)}}my$opt;for$opt (@options){my$try=lc ($opt);my$action=1;if ($try =~ /^no_?(.*)$/s){$action=0;$try=$+}if (($try eq 'default' or $try eq 'defaults')&& $action){ConfigDefaults ()}elsif (($try eq 'posix_default' or $try eq 'posix_defaults')){local$ENV{POSIXLY_CORRECT};$ENV{POSIXLY_CORRECT}=1 if$action;ConfigDefaults ()}elsif ($try eq 'auto_abbrev' or $try eq 'autoabbrev'){$autoabbrev=$action}elsif ($try eq 'getopt_compat'){$getopt_compat=$action;$genprefix=$action ? "(--|-|\\+)" : "(--|-)"}elsif ($try eq 'gnu_getopt'){if ($action){$gnu_compat=1;$bundling=1;$getopt_compat=0;$genprefix="(--|-)";$order=$PERMUTE;$bundling_values=0}}elsif ($try eq 'gnu_compat'){$gnu_compat=$action;$bundling=0;$bundling_values=1}elsif ($try =~ /^(auto_?)?version$/){$auto_version=$action}elsif ($try =~ /^(auto_?)?help$/){$auto_help=$action}elsif ($try eq 'ignorecase' or $try eq 'ignore_case'){$ignorecase=$action}elsif ($try eq 'ignorecase_always' or $try eq 'ignore_case_always'){$ignorecase=$action ? 2 : 0}elsif ($try eq 'bundling'){$bundling=$action;$bundling_values=0 if$action}elsif ($try eq 'bundling_override'){$bundling=$action ? 2 : 0;$bundling_values=0 if$action}elsif ($try eq 'bundling_values'){$bundling_values=$action;$bundling=0 if$action}elsif ($try eq 'require_order'){$order=$action ? $REQUIRE_ORDER : $PERMUTE}elsif ($try eq 'permute'){$order=$action ? $PERMUTE : $REQUIRE_ORDER}elsif ($try eq 'pass_through' or $try eq 'passthrough'){$passthrough=$action}elsif ($try =~ /^prefix=(.+)$/ && $action){$genprefix=$1;$genprefix="(" .quotemeta($genprefix).")";eval {'' =~ /$genprefix/};die("Getopt::Long: invalid pattern \"$genprefix\"\n")if $@}elsif ($try =~ /^prefix_pattern=(.+)$/ && $action){$genprefix=$1;$genprefix="(" .$genprefix .")" unless$genprefix =~ /^\(.*\)$/;eval {'' =~ m"$genprefix"};die("Getopt::Long: invalid pattern \"$genprefix\"\n")if $@}elsif ($try =~ /^long_prefix_pattern=(.+)$/ && $action){$longprefix=$1;$longprefix="(" .$longprefix .")" unless$longprefix =~ /^\(.*\)$/;eval {'' =~ m"$longprefix"};die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n")if $@}elsif ($try eq 'debug'){$debug=$action}else {die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")}}$prevconfig}sub config (@) {Configure (@_)}sub VersionMessage(@) {my$pa=setup_pa_args("version",@_);my$v=$main::VERSION;my$fh=$pa->{-output}|| (($pa->{-exitval}eq "NOEXIT" || $pa->{-exitval}< 2)? \*STDOUT : \*STDERR);print$fh (defined($pa->{-message})? $pa->{-message}: (),$0,defined$v ? " version $v" : (),"\n","(",__PACKAGE__,"::","GetOptions"," version ",defined($Getopt::Long::VERSION_STRING)? $Getopt::Long::VERSION_STRING : $VERSION,";"," Perl version ",$] >= 5.006 ? sprintf("%vd",$^V): $],")\n");exit($pa->{-exitval})unless$pa->{-exitval}eq "NOEXIT"}sub HelpMessage(@) {eval {require Pod::Usage;import Pod::Usage;1}|| die("Cannot provide help: cannot load Pod::Usage\n");pod2usage(setup_pa_args("help",@_))}sub setup_pa_args($@) {my$tag=shift;@_=()if @_==2 && $_[0]eq $tag;my$pa;if (@_ > 1){$pa={@_ }}else {$pa=shift || {}}if (UNIVERSAL::isa($pa,'HASH')){$pa->{-message}=$pa->{-msg};delete($pa->{-msg})}elsif ($pa =~ /^-?\d+$/){$pa={-exitval=>$pa }}else {$pa={-message=>$pa }}$pa->{-verbose}=0 unless exists($pa->{-verbose});$pa->{-exitval}=0 unless exists($pa->{-exitval});$pa}sub VERSION {$requested_version=$_[1];shift->SUPER::VERSION(@_)}package Getopt::Long::CallBack;sub new {my ($pkg,%atts)=@_;bless {%atts },$pkg}sub name {my$self=shift;''.$self->{name}}use overload '""'=>\&name,fallback=>1;1;
GETOPT_LONG

$fatpacked{"HTTP/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINY';
  package HTTP::Tiny;use strict;use warnings;our$VERSION='0.070';sub _croak {require Carp;Carp::croak(@_)}my@attributes;BEGIN {@attributes=qw(cookie_jar default_headers http_proxy https_proxy keep_alive local_address max_redirect max_size proxy no_proxy SSL_options verify_SSL);my%persist_ok=map {;$_=>1}qw(cookie_jar default_headers max_redirect max_size);no strict 'refs';no warnings 'uninitialized';for my$accessor (@attributes){*{$accessor}=sub {@_ > 1 ? do {delete $_[0]->{handle}if!$persist_ok{$accessor}&& $_[1]ne $_[0]->{$accessor};$_[0]->{$accessor}=$_[1]}: $_[0]->{$accessor}}}}sub agent {my($self,$agent)=@_;if(@_ > 1){$self->{agent}=(defined$agent && $agent =~ / $/)? $agent .$self->_agent : $agent}return$self->{agent}}sub timeout {my ($self,$timeout)=@_;if (@_ > 1){$self->{timeout}=$timeout;if ($self->{handle}){$self->{handle}->timeout($timeout)}}return$self->{timeout}}sub new {my($class,%args)=@_;my$self={max_redirect=>5,timeout=>defined$args{timeout}? $args{timeout}: 60,keep_alive=>1,verify_SSL=>$args{verify_SSL}|| $args{verify_ssl}|| 0,no_proxy=>$ENV{no_proxy},};bless$self,$class;$class->_validate_cookie_jar($args{cookie_jar})if$args{cookie_jar};for my$key (@attributes){$self->{$key}=$args{$key}if exists$args{$key}}$self->agent(exists$args{agent}? $args{agent}: $class->_agent);$self->_set_proxies;return$self}sub _set_proxies {my ($self)=@_;if (!exists$self->{proxy}){$self->{proxy}=$ENV{all_proxy}|| $ENV{ALL_PROXY}}if (defined$self->{proxy}){$self->_split_proxy('generic proxy'=>$self->{proxy})}else {delete$self->{proxy}}if (!exists$self->{http_proxy}){local$ENV{HTTP_PROXY}if$ENV{REQUEST_METHOD};$self->{http_proxy}=$ENV{http_proxy}|| $ENV{HTTP_PROXY}|| $self->{proxy}}if (defined$self->{http_proxy}){$self->_split_proxy(http_proxy=>$self->{http_proxy});$self->{_has_proxy}{http}=1}else {delete$self->{http_proxy}}if (!exists$self->{https_proxy}){$self->{https_proxy}=$ENV{https_proxy}|| $ENV{HTTPS_PROXY}|| $self->{proxy}}if ($self->{https_proxy}){$self->_split_proxy(https_proxy=>$self->{https_proxy});$self->{_has_proxy}{https}=1}else {delete$self->{https_proxy}}unless (ref$self->{no_proxy}eq 'ARRAY'){$self->{no_proxy}=(defined$self->{no_proxy})? [split /\s*,\s*/,$self->{no_proxy}]: []}return}for my$sub_name (qw/get head put post delete/){my$req_method=uc$sub_name;no strict 'refs';eval <<"HERE"}sub post_form {my ($self,$url,$data,$args)=@_;(@_==3 || @_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ ."\n");my$headers={};while (my ($key,$value)=each %{$args->{headers}|| {}}){$headers->{lc$key}=$value}delete$args->{headers};return$self->request('POST',$url,{%$args,content=>$self->www_form_urlencode($data),headers=>{%$headers,'content-type'=>'application/x-www-form-urlencoded' },})}sub mirror {my ($self,$url,$file,$args)=@_;@_==3 || (@_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ ."\n");if (exists$args->{headers}){my$headers={};while (my ($key,$value)=each %{$args->{headers}|| {}}){$headers->{lc$key}=$value}$args->{headers}=$headers}if (-e $file and my$mtime=(stat($file))[9]){$args->{headers}{'if-modified-since'}||= $self->_http_date($mtime)}my$tempfile=$file .int(rand(2**31));require Fcntl;sysopen my$fh,$tempfile,Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()or _croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);binmode$fh;$args->{data_callback}=sub {print {$fh}$_[0]};my$response=$self->request('GET',$url,$args);close$fh or _croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);if ($response->{success}){rename$tempfile,$file or _croak(qq/Error replacing $file with $tempfile: $!\n/);my$lm=$response->{headers}{'last-modified'};if ($lm and my$mtime=$self->_parse_http_date($lm)){utime$mtime,$mtime,$file}}$response->{success}||= $response->{status}eq '304';unlink$tempfile;return$response}my%idempotent=map {$_=>1}qw/GET HEAD PUT DELETE OPTIONS TRACE/;sub request {my ($self,$method,$url,$args)=@_;@_==3 || (@_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ ."\n");$args ||= {};my$response;for (0 .. 1){$response=eval {$self->_request($method,$url,$args)};last unless $@ && $idempotent{$method}&& $@ =~ m{^(?:Socket closed|Unexpected end)}}if (my$e=$@){if (ref$e eq 'HASH' && exists$e->{status}){$e->{redirects}=delete$args->{_redirects}if @{$args->{_redirects}|| []};return$e}$e="$e";$response={url=>$url,success=>q{},status=>599,reason=>'Internal Exception',content=>$e,headers=>{'content-type'=>'text/plain','content-length'=>length$e,},(@{$args->{_redirects}|| []}? (redirects=>delete$args->{_redirects}): ()),}}return$response}sub www_form_urlencode {my ($self,$data)=@_;(@_==2 && ref$data)or _croak(q/Usage: $http->www_form_urlencode(DATAREF)/ ."\n");(ref$data eq 'HASH' || ref$data eq 'ARRAY')or _croak("form data must be a hash or array reference\n");my@params=ref$data eq 'HASH' ? %$data : @$data;@params % 2==0 or _croak("form data reference must have an even number of terms\n");my@terms;while(@params){my ($key,$value)=splice(@params,0,2);if (ref$value eq 'ARRAY'){unshift@params,map {$key=>$_}@$value}else {push@terms,join("=",map {$self->_uri_escape($_)}$key,$value)}}return join("&",(ref$data eq 'ARRAY')? (@terms): (sort@terms))}sub can_ssl {my ($self)=@_;my($ok,$reason)=(1,'');local@INC=@INC;pop@INC if$INC[-1]eq '.';unless (eval {require IO::Socket::SSL;IO::Socket::SSL->VERSION(1.42)}){$ok=0;$reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/}unless (eval {require Net::SSLeay;Net::SSLeay->VERSION(1.49)}){$ok=0;$reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/}if (ref($self)&& ($self->{verify_SSL}|| $self->{SSL_options}{SSL_verify_mode})){my$handle=HTTP::Tiny::Handle->new(SSL_options=>$self->{SSL_options},verify_SSL=>$self->{verify_SSL},);unless (eval {$handle->_find_CA_file;1}){$ok=0;$reason .= "$@"}}wantarray ? ($ok,$reason): $ok}sub connected {my ($self)=@_;if ($self->{handle}&& $self->{handle}{fh}){my$socket=$self->{handle}{fh};if ($socket->connected){return wantarray ? ($socket->peerhost,$socket->peerport): join(':',$socket->peerhost,$socket->peerport)}}return}my%DefaultPort=(http=>80,https=>443,);sub _agent {my$class=ref($_[0])|| $_[0];(my$default_agent=$class)=~ s{::}{-}g;return$default_agent ."/" .$class->VERSION}sub _request {my ($self,$method,$url,$args)=@_;my ($scheme,$host,$port,$path_query,$auth)=$self->_split_url($url);my$request={method=>$method,scheme=>$scheme,host=>$host,port=>$port,host_port=>($port==$DefaultPort{$scheme}? $host : "$host:$port"),uri=>$path_query,headers=>{},};my$peer=$args->{peer}|| $host;my$handle=delete$self->{handle};if ($handle){unless ($handle->can_reuse($scheme,$host,$port,$peer)){$handle->close;undef$handle}}$handle ||= $self->_open_handle($request,$scheme,$host,$port,$peer);$self->_prepare_headers_and_cb($request,$args,$url,$auth);$handle->write_request($request);my$response;do {$response=$handle->read_response_header}until (substr($response->{status},0,1)ne '1');$self->_update_cookie_jar($url,$response)if$self->{cookie_jar};my@redir_args=$self->_maybe_redirect($request,$response,$args);my$known_message_length;if ($method eq 'HEAD' || $response->{status}=~ /^[23]04/){$known_message_length=1}else {my$cb_args=@redir_args ? +{}: $args;my$data_cb=$self->_prepare_data_cb($response,$cb_args);$known_message_length=$handle->read_body($data_cb,$response)}if ($self->{keep_alive}&& $known_message_length && $response->{protocol}eq 'HTTP/1.1' && ($response->{headers}{connection}|| '')ne 'close'){$self->{handle}=$handle}else {$handle->close}$response->{success}=substr($response->{status},0,1)eq '2';$response->{url}=$url;if (@redir_args){push @{$args->{_redirects}},$response;return$self->_request(@redir_args,$args)}$response->{redirects}=delete$args->{_redirects}if @{$args->{_redirects}};return$response}sub _open_handle {my ($self,$request,$scheme,$host,$port,$peer)=@_;my$handle=HTTP::Tiny::Handle->new(timeout=>$self->{timeout},SSL_options=>$self->{SSL_options},verify_SSL=>$self->{verify_SSL},local_address=>$self->{local_address},keep_alive=>$self->{keep_alive});if ($self->{_has_proxy}{$scheme}&&!grep {$host =~ /\Q$_\E$/}@{$self->{no_proxy}}){return$self->_proxy_connect($request,$handle)}else {return$handle->connect($scheme,$host,$port,$peer)}}sub _proxy_connect {my ($self,$request,$handle)=@_;my@proxy_vars;if ($request->{scheme}eq 'https'){_croak(qq{No https_proxy defined})unless$self->{https_proxy};@proxy_vars=$self->_split_proxy(https_proxy=>$self->{https_proxy});if ($proxy_vars[0]eq 'https'){_croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}})}}else {_croak(qq{No http_proxy defined})unless$self->{http_proxy};@proxy_vars=$self->_split_proxy(http_proxy=>$self->{http_proxy})}my ($p_scheme,$p_host,$p_port,$p_auth)=@proxy_vars;if (length$p_auth &&!defined$request->{headers}{'proxy-authorization'}){$self->_add_basic_auth_header($request,'proxy-authorization'=>$p_auth)}$handle->connect($p_scheme,$p_host,$p_port,$p_host);if ($request->{scheme}eq 'https'){$self->_create_proxy_tunnel($request,$handle)}else {$request->{uri}="$request->{scheme}://$request->{host_port}$request->{uri}"}return$handle}sub _split_proxy {my ($self,$type,$proxy)=@_;my ($scheme,$host,$port,$path_query,$auth)=eval {$self->_split_url($proxy)};unless(defined($scheme)&& length($scheme)&& length($host)&& length($port)&& $path_query eq '/'){_croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n})}return ($scheme,$host,$port,$auth)}sub _create_proxy_tunnel {my ($self,$request,$handle)=@_;$handle->_assert_ssl;my$agent=exists($request->{headers}{'user-agent'})? $request->{headers}{'user-agent'}: $self->{agent};my$connect_request={method=>'CONNECT',uri=>"$request->{host}:$request->{port}",headers=>{host=>"$request->{host}:$request->{port}",'user-agent'=>$agent,}};if ($request->{headers}{'proxy-authorization'}){$connect_request->{headers}{'proxy-authorization'}=delete$request->{headers}{'proxy-authorization'}}$handle->write_request($connect_request);my$response;do {$response=$handle->read_response_header}until (substr($response->{status},0,1)ne '1');unless (substr($response->{status},0,1)eq '2'){die$response}$handle->start_ssl($request->{host});return}sub _prepare_headers_and_cb {my ($self,$request,$args,$url,$auth)=@_;for ($self->{default_headers},$args->{headers}){next unless defined;while (my ($k,$v)=each %$_){$request->{headers}{lc$k}=$v;$request->{header_case}{lc$k}=$k}}if (exists$request->{headers}{'host'}){die(qq/The 'Host' header must not be provided as header option\n/)}$request->{headers}{'host'}=$request->{host_port};$request->{headers}{'user-agent'}||= $self->{agent};$request->{headers}{'connection'}="close" unless$self->{keep_alive};if (defined$args->{content}){if (ref$args->{content}eq 'CODE'){$request->{headers}{'content-type'}||= "application/octet-stream";$request->{headers}{'transfer-encoding'}='chunked' unless$request->{headers}{'content-length'}|| $request->{headers}{'transfer-encoding'};$request->{cb}=$args->{content}}elsif (length$args->{content}){my$content=$args->{content};if ($] ge '5.008'){utf8::downgrade($content,1)or die(qq/Wide character in request message body\n/)}$request->{headers}{'content-type'}||= "application/octet-stream";$request->{headers}{'content-length'}=length$content unless$request->{headers}{'content-length'}|| $request->{headers}{'transfer-encoding'};$request->{cb}=sub {substr$content,0,length$content,''}}$request->{trailer_cb}=$args->{trailer_callback}if ref$args->{trailer_callback}eq 'CODE'}if ($self->{cookie_jar}){my$cookies=$self->cookie_jar->cookie_header($url);$request->{headers}{cookie}=$cookies if length$cookies}if (length$auth &&!defined$request->{headers}{authorization}){$self->_add_basic_auth_header($request,'authorization'=>$auth)}return}sub _add_basic_auth_header {my ($self,$request,$header,$auth)=@_;require MIME::Base64;$request->{headers}{$header}="Basic " .MIME::Base64::encode_base64($auth,"");return}sub _prepare_data_cb {my ($self,$response,$args)=@_;my$data_cb=$args->{data_callback};$response->{content}='';if (!$data_cb || $response->{status}!~ /^2/){if (defined$self->{max_size}){$data_cb=sub {$_[1]->{content}.= $_[0];die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)if length $_[1]->{content}> $self->{max_size}}}else {$data_cb=sub {$_[1]->{content}.= $_[0]}}}return$data_cb}sub _update_cookie_jar {my ($self,$url,$response)=@_;my$cookies=$response->{headers}->{'set-cookie'};return unless defined$cookies;my@cookies=ref$cookies ? @$cookies : $cookies;$self->cookie_jar->add($url,$_)for@cookies;return}sub _validate_cookie_jar {my ($class,$jar)=@_;for my$method (qw/add cookie_header/){_croak(qq/Cookie jar must provide the '$method' method\n/)unless ref($jar)&& ref($jar)->can($method)}return}sub _maybe_redirect {my ($self,$request,$response,$args)=@_;my$headers=$response->{headers};my ($status,$method)=($response->{status},$request->{method});$args->{_redirects}||= [];if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))and $headers->{location}and @{$args->{_redirects}}< $self->{max_redirect}){my$location=($headers->{location}=~ /^\//)? "$request->{scheme}://$request->{host_port}$headers->{location}" : $headers->{location};return (($status eq '303' ? 'GET' : $method),$location)}return}sub _split_url {my$url=pop;my ($scheme,$host,$path_query)=$url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)> or die(qq/Cannot parse URL: '$url'\n/);$scheme=lc$scheme;$path_query="/$path_query" unless$path_query =~ m<\A/>;my$auth='';if ((my$i=index$host,'@')!=-1){$auth=substr$host,0,$i,'';substr$host,0,1,'';$auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg}my$port=$host =~ s/:(\d*)\z// && length $1 ? $1 : $scheme eq 'http' ? 80 : $scheme eq 'https' ? 443 : undef;return ($scheme,(length$host ? lc$host : "localhost"),$port,$path_query,$auth)}my$DoW="Sun|Mon|Tue|Wed|Thu|Fri|Sat";my$MoY="Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";sub _http_date {my ($sec,$min,$hour,$mday,$mon,$year,$wday)=gmtime($_[1]);return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",substr($DoW,$wday*4,3),$mday,substr($MoY,$mon*4,3),$year+1900,$hour,$min,$sec)}sub _parse_http_date {my ($self,$str)=@_;require Time::Local;my@tl_parts;if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/){@tl_parts=($6,$5,$4,$1,(index($MoY,$2)/4),$3)}elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/){@tl_parts=($6,$5,$4,$1,(index($MoY,$2)/4),$3)}elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/){@tl_parts=($5,$4,$3,$2,(index($MoY,$1)/4),$6)}return eval {my$t=@tl_parts ? Time::Local::timegm(@tl_parts): -1;$t < 0 ? undef : $t}}my%escapes=map {chr($_)=>sprintf("%%%02X",$_)}0..255;$escapes{' '}="+";my$unsafe_char=qr/[^A-Za-z0-9\-\._~]/;sub _uri_escape {my ($self,$str)=@_;if ($] ge '5.008'){utf8::encode($str)}else {$str=pack("U*",unpack("C*",$str))if (length$str==do {use bytes;length$str});$str=pack("C*",unpack("C*",$str))}$str =~ s/($unsafe_char)/$escapes{$1}/ge;return$str}package HTTP::Tiny::Handle;use strict;use warnings;use Errno qw[EINTR EPIPE];use IO::Socket qw[SOCK_STREAM];use Socket qw[SOL_SOCKET SO_KEEPALIVE];my$SOCKET_CLASS=$ENV{PERL_HTTP_TINY_IPV4_ONLY}? 'IO::Socket::INET' : eval {require IO::Socket::IP;IO::Socket::IP->VERSION(0.25)}? 'IO::Socket::IP' : 'IO::Socket::INET';sub BUFSIZE () {32768}my$Printable=sub {local $_=shift;s/\r/\\r/g;s/\n/\\n/g;s/\t/\\t/g;s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;$_};my$Token=qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;my$Field_Content=qr/[[:print:]]+ (?: [\x20\x09]+ [[:print:]]+ )*/x;sub new {my ($class,%args)=@_;return bless {rbuf=>'',timeout=>60,max_line_size=>16384,max_header_lines=>64,verify_SSL=>0,SSL_options=>{},%args },$class}sub timeout {my ($self,$timeout)=@_;if (@_ > 1){$self->{timeout}=$timeout;if ($self->{fh}&& $self->{fh}->can('timeout')){$self->{fh}->timeout($timeout)}}return$self->{timeout}}sub connect {@_==5 || die(q/Usage: $handle->connect(scheme, host, port, peer)/ ."\n");my ($self,$scheme,$host,$port,$peer)=@_;if ($scheme eq 'https'){$self->_assert_ssl}elsif ($scheme ne 'http'){die(qq/Unsupported URL scheme '$scheme'\n/)}$self->{fh}=$SOCKET_CLASS->new(PeerHost=>$peer,PeerPort=>$port,$self->{local_address}? (LocalAddr=>$self->{local_address}): (),Proto=>'tcp',Type=>SOCK_STREAM,Timeout=>$self->{timeout},)or die(qq/Could not connect to '$host:$port': $@\n/);binmode($self->{fh})or die(qq/Could not binmode() socket: '$!'\n/);if ($self->{keep_alive}){unless (defined($self->{fh}->setsockopt(SOL_SOCKET,SO_KEEPALIVE,1))){CORE::close($self->{fh});die(qq/Could not set SO_KEEPALIVE on socket: '$!'\n/)}}$self->start_ssl($host)if$scheme eq 'https';$self->{scheme}=$scheme;$self->{host}=$host;$self->{peer}=$peer;$self->{port}=$port;$self->{pid}=$$;$self->{tid}=_get_tid();return$self}sub start_ssl {my ($self,$host)=@_;if (ref($self->{fh})eq 'IO::Socket::SSL'){unless ($self->{fh}->stop_SSL){my$ssl_err=IO::Socket::SSL->errstr;die(qq/Error halting prior SSL connection: $ssl_err/)}}my$ssl_args=$self->_ssl_args($host);IO::Socket::SSL->start_SSL($self->{fh},%$ssl_args,SSL_create_ctx_callback=>sub {my$ctx=shift;Net::SSLeay::CTX_set_mode($ctx,Net::SSLeay::MODE_AUTO_RETRY())},);unless (ref($self->{fh})eq 'IO::Socket::SSL'){my$ssl_err=IO::Socket::SSL->errstr;die(qq/SSL connection failed for $host: $ssl_err\n/)}}sub close {@_==1 || die(q/Usage: $handle->close()/ ."\n");my ($self)=@_;CORE::close($self->{fh})or die(qq/Could not close socket: '$!'\n/)}sub write {@_==2 || die(q/Usage: $handle->write(buf)/ ."\n");my ($self,$buf)=@_;if ($] ge '5.008'){utf8::downgrade($buf,1)or die(qq/Wide character in write()\n/)}my$len=length$buf;my$off=0;local$SIG{PIPE}='IGNORE';while (){$self->can_write or die(qq/Timed out while waiting for socket to become ready for writing\n/);my$r=syswrite($self->{fh},$buf,$len,$off);if (defined$r){$len -= $r;$off += $r;last unless$len > 0}elsif ($!==EPIPE){die(qq/Socket closed by remote server: $!\n/)}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not write to SSL socket: '$err'\n /)}else {die(qq/Could not write to socket: '$!'\n/)}}}return$off}sub read {@_==2 || @_==3 || die(q/Usage: $handle->read(len [, allow_partial])/ ."\n");my ($self,$len,$allow_partial)=@_;my$buf='';my$got=length$self->{rbuf};if ($got){my$take=($got < $len)? $got : $len;$buf=substr($self->{rbuf},0,$take,'');$len -= $take}while ($len > 0){$self->can_read or die(q/Timed out while waiting for socket to become ready for reading/ ."\n");my$r=sysread($self->{fh},$buf,$len,length$buf);if (defined$r){last unless$r;$len -= $r}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not read from SSL socket: '$err'\n /)}else {die(qq/Could not read from socket: '$!'\n/)}}}if ($len &&!$allow_partial){die(qq/Unexpected end of stream\n/)}return$buf}sub readline {@_==1 || die(q/Usage: $handle->readline()/ ."\n");my ($self)=@_;while (){if ($self->{rbuf}=~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x){return $1}if (length$self->{rbuf}>= $self->{max_line_size}){die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/)}$self->can_read or die(qq/Timed out while waiting for socket to become ready for reading\n/);my$r=sysread($self->{fh},$self->{rbuf},BUFSIZE,length$self->{rbuf});if (defined$r){last unless$r}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not read from SSL socket: '$err'\n /)}else {die(qq/Could not read from socket: '$!'\n/)}}}die(qq/Unexpected end of stream while looking for line\n/)}sub read_header_lines {@_==1 || @_==2 || die(q/Usage: $handle->read_header_lines([headers])/ ."\n");my ($self,$headers)=@_;$headers ||= {};my$lines=0;my$val;while (){my$line=$self->readline;if (++$lines >= $self->{max_header_lines}){die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/)}elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x){my ($field_name)=lc $1;if (exists$headers->{$field_name}){for ($headers->{$field_name}){$_=[$_]unless ref $_ eq "ARRAY";push @$_,$2;$val=\$_->[-1]}}else {$val=\($headers->{$field_name}=$2)}}elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x){$val or die(qq/Unexpected header continuation line\n/);next unless length $1;$$val .= ' ' if length $$val;$$val .= $1}elsif ($line =~ /\A \x0D?\x0A \z/x){last}else {die(q/Malformed header line: / .$Printable->($line)."\n")}}return$headers}sub write_request {@_==2 || die(q/Usage: $handle->write_request(request)/ ."\n");my($self,$request)=@_;$self->write_request_header(@{$request}{qw/method uri headers header_case/});$self->write_body($request)if$request->{cb};return}my@rfc_request_headers=qw(Accept Accept-Charset Accept-Encoding Accept-Language Authorization Cache-Control Connection Content-Length Expect From Host If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since Max-Forwards Pragma Proxy-Authorization Range Referer TE Trailer Transfer-Encoding Upgrade User-Agent Via);my@other_request_headers=qw(Content-Encoding Content-MD5 Content-Type Cookie DNT Date Origin X-XSS-Protection);my%HeaderCase=map {lc($_)=>$_}@rfc_request_headers,@other_request_headers;sub write_header_lines {(@_ >= 2 && @_ <= 4 && ref $_[1]eq 'HASH')|| die(q/Usage: $handle->write_header_lines(headers, [header_case, prefix])/ ."\n");my($self,$headers,$header_case,$prefix_data)=@_;$header_case ||= {};my$buf=(defined$prefix_data ? $prefix_data : '');my%seen;for my$k (qw/host cache-control expect max-forwards pragma range te/){next unless exists$headers->{$k};$seen{$k}++;my$field_name=$HeaderCase{$k};my$v=$headers->{$k};for (ref$v eq 'ARRAY' ? @$v : $v){$_='' unless defined $_;$buf .= "$field_name: $_\x0D\x0A"}}while (my ($k,$v)=each %$headers){my$field_name=lc$k;next if$seen{$field_name};if (exists$HeaderCase{$field_name}){$field_name=$HeaderCase{$field_name}}else {if (exists$header_case->{$field_name}){$field_name=$header_case->{$field_name}}else {$field_name =~ s/\b(\w)/\u$1/g}$field_name =~ /\A $Token+ \z/xo or die(q/Invalid HTTP header field name: / .$Printable->($field_name)."\n");$HeaderCase{lc$field_name}=$field_name}for (ref$v eq 'ARRAY' ? @$v : $v){s/\x0D?\x0A\s+/ /g;die(qq/Invalid HTTP header field value ($field_name): / .$Printable->($_)."\n")unless $_ eq '' || /\A $Field_Content \z/xo;$_='' unless defined $_;$buf .= "$field_name: $_\x0D\x0A"}}$buf .= "\x0D\x0A";return$self->write($buf)}sub read_body {@_==3 || die(q/Usage: $handle->read_body(callback, response)/ ."\n");my ($self,$cb,$response)=@_;my$te=$response->{headers}{'transfer-encoding'}|| '';my$chunked=grep {/chunked/i}(ref$te eq 'ARRAY' ? @$te : $te);return$chunked ? $self->read_chunked_body($cb,$response): $self->read_content_body($cb,$response)}sub write_body {@_==2 || die(q/Usage: $handle->write_body(request)/ ."\n");my ($self,$request)=@_;if ($request->{headers}{'content-length'}){return$self->write_content_body($request)}else {return$self->write_chunked_body($request)}}sub read_content_body {@_==3 || @_==4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ ."\n");my ($self,$cb,$response,$content_length)=@_;$content_length ||= $response->{headers}{'content-length'};if (defined$content_length){my$len=$content_length;while ($len > 0){my$read=($len > BUFSIZE)? BUFSIZE : $len;$cb->($self->read($read,0),$response);$len -= $read}return length($self->{rbuf})==0}my$chunk;$cb->($chunk,$response)while length($chunk=$self->read(BUFSIZE,1));return}sub write_content_body {@_==2 || die(q/Usage: $handle->write_content_body(request)/ ."\n");my ($self,$request)=@_;my ($len,$content_length)=(0,$request->{headers}{'content-length'});while (){my$data=$request->{cb}->();defined$data && length$data or last;if ($] ge '5.008'){utf8::downgrade($data,1)or die(qq/Wide character in write_content()\n/)}$len += $self->write($data)}$len==$content_length or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);return$len}sub read_chunked_body {@_==3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ ."\n");my ($self,$cb,$response)=@_;while (){my$head=$self->readline;$head =~ /\A ([A-Fa-f0-9]+)/x or die(q/Malformed chunk head: / .$Printable->($head)."\n");my$len=hex($1)or last;$self->read_content_body($cb,$response,$len);$self->read(2)eq "\x0D\x0A" or die(qq/Malformed chunk: missing CRLF after chunk data\n/)}$self->read_header_lines($response->{headers});return 1}sub write_chunked_body {@_==2 || die(q/Usage: $handle->write_chunked_body(request)/ ."\n");my ($self,$request)=@_;my$len=0;while (){my$data=$request->{cb}->();defined$data && length$data or last;if ($] ge '5.008'){utf8::downgrade($data,1)or die(qq/Wide character in write_chunked_body()\n/)}$len += length$data;my$chunk=sprintf '%X',length$data;$chunk .= "\x0D\x0A";$chunk .= $data;$chunk .= "\x0D\x0A";$self->write($chunk)}$self->write("0\x0D\x0A");if (ref$request->{trailer_cb}eq 'CODE'){$self->write_header_lines($request->{trailer_cb}->())}else {$self->write("\x0D\x0A")}return$len}sub read_response_header {@_==1 || die(q/Usage: $handle->read_response_header()/ ."\n");my ($self)=@_;my$line=$self->readline;$line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) [\x09\x20]+ ([^\x0D\x0A]*) \x0D?\x0A/x or die(q/Malformed Status-Line: / .$Printable->($line)."\n");my ($protocol,$version,$status,$reason)=($1,$2,$3,$4);die (qq/Unsupported HTTP protocol: $protocol\n/)unless$version =~ /0*1\.0*[01]/;return {status=>$status,reason=>$reason,headers=>$self->read_header_lines,protocol=>$protocol,}}sub write_request_header {@_==5 || die(q/Usage: $handle->write_request_header(method, request_uri, headers, header_case)/ ."\n");my ($self,$method,$request_uri,$headers,$header_case)=@_;return$self->write_header_lines($headers,$header_case,"$method $request_uri HTTP/1.1\x0D\x0A")}sub _do_timeout {my ($self,$type,$timeout)=@_;$timeout=$self->{timeout}unless defined$timeout && $timeout >= 0;my$fd=fileno$self->{fh};defined$fd && $fd >= 0 or die(qq/select(2): 'Bad file descriptor'\n/);my$initial=time;my$pending=$timeout;my$nfound;vec(my$fdset='',$fd,1)=1;while (){$nfound=($type eq 'read')? select($fdset,undef,undef,$pending): select(undef,$fdset,undef,$pending);if ($nfound==-1){$!==EINTR or die(qq/select(2): '$!'\n/);redo if!$timeout || ($pending=$timeout - (time - $initial))> 0;$nfound=0}last}$!=0;return$nfound}sub can_read {@_==1 || @_==2 || die(q/Usage: $handle->can_read([timeout])/ ."\n");my$self=shift;if (ref($self->{fh})eq 'IO::Socket::SSL'){return 1 if$self->{fh}->pending}return$self->_do_timeout('read',@_)}sub can_write {@_==1 || @_==2 || die(q/Usage: $handle->can_write([timeout])/ ."\n");my$self=shift;return$self->_do_timeout('write',@_)}sub _assert_ssl {my($ok,$reason)=HTTP::Tiny->can_ssl();die$reason unless$ok}sub can_reuse {my ($self,$scheme,$host,$port,$peer)=@_;return 0 if $self->{pid}!=$$ || $self->{tid}!=_get_tid()|| length($self->{rbuf})|| $scheme ne $self->{scheme}|| $host ne $self->{host}|| $port ne $self->{port}|| $peer ne $self->{peer}|| eval {$self->can_read(0)}|| $@ ;return 1}sub _find_CA_file {my$self=shift();my$ca_file=defined($self->{SSL_options}->{SSL_ca_file})? $self->{SSL_options}->{SSL_ca_file}: $ENV{SSL_CERT_FILE};if (defined$ca_file){unless (-r $ca_file){die qq/SSL_ca_file '$ca_file' not found or not readable\n/}return$ca_file}local@INC=@INC;pop@INC if$INC[-1]eq '.';return Mozilla::CA::SSL_ca_file()if eval {require Mozilla::CA;1};for my$ca_bundle ("/etc/ssl/certs/ca-certificates.crt","/etc/pki/tls/certs/ca-bundle.crt","/etc/ssl/ca-bundle.pem","/etc/openssl/certs/ca-certificates.crt","/etc/ssl/cert.pem","/usr/local/share/certs/ca-root-nss.crt","/etc/pki/tls/cacert.pem","/etc/certs/ca-certificates.crt",){return$ca_bundle if -e $ca_bundle}die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/ .qq/Try installing Mozilla::CA from CPAN\n/}sub _get_tid {no warnings 'reserved';return threads->can("tid")? threads->tid : 0}sub _ssl_args {my ($self,$host)=@_;my%ssl_args;if (Net::SSLeay::OPENSSL_VERSION_NUMBER()>= 0x01000000){$ssl_args{SSL_hostname}=$host,}if ($self->{verify_SSL}){$ssl_args{SSL_verifycn_scheme}='http';$ssl_args{SSL_verifycn_name}=$host;$ssl_args{SSL_verify_mode}=0x01;$ssl_args{SSL_ca_file}=$self->_find_CA_file}else {$ssl_args{SSL_verifycn_scheme}='none';$ssl_args{SSL_verify_mode}=0x00}for my$k (keys %{$self->{SSL_options}}){$ssl_args{$k}=$self->{SSL_options}{$k}if$k =~ m/^SSL_/}return \%ssl_args}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or _croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  HERE
HTTP_TINY

$fatpacked{"JSON/PP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP_BOOLEAN';
  use JSON::PP ();use strict;1;
JSON_PP_BOOLEAN

$fatpacked{"JSON/PP/Compat5006.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP_COMPAT5006';
  package JSON::PP::Compat5006;use 5.006;use strict;BEGIN {if ($] >= 5.008){require Carp;die("JSON::PP::Compat5006 is for Perl 5.6")}}my@properties;$JSON::PP::Compat5006::VERSION='1.09';BEGIN {sub utf8::is_utf8 {my$len=length $_[0];{use bytes;return$len!=length $_[0]}}sub utf8::upgrade {}sub utf8::downgrade ($;$) {return 1 unless (utf8::is_utf8($_[0]));if (_is_valid_utf8($_[0])){my$downgrade;for my$c (unpack("U*",$_[0])){if ($c < 256){$downgrade .= pack("C",$c)}else {$downgrade .= pack("U",$c)}}$_[0]=$downgrade;return 1}else {Carp::croak("Wide character in subroutine entry")unless ($_[1]);0}}sub utf8::encode ($) {if (utf8::is_utf8($_[0])){$_[0]=pack("C*",unpack("C*",$_[0]))}else {$_[0]=pack("U*",unpack("C*",$_[0]));$_[0]=pack("C*",unpack("C*",$_[0]))}}sub utf8::decode ($) {if (_is_valid_utf8($_[0])){utf8::downgrade($_[0]);$_[0]=pack("U*",unpack("U*",$_[0]))}}*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&JSON::PP::_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&JSON::PP::_decode_unicode;unless (defined&B::SVp_NOK){eval q{ sub B::SVp_NOK () { 0x02000000; } }}}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',JSON::PP::_encode_surrogates($_))}_unpack_emu($_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',JSON::PP::_encode_surrogates($_))}_unpack_emu($_[0]))}sub _unpack_emu {return!utf8::is_utf8($_[0])? unpack('C*',$_[0]): _is_valid_utf8($_[0])? unpack('U*',$_[0]): unpack('C*',$_[0])}sub _is_valid_utf8 {my$str=$_[0];my$is_utf8;while ($str =~ /(?:
            (
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
            )
          | (.)
      )/xg){if (defined $1){$is_utf8=1 if (!defined$is_utf8)}else {$is_utf8=0 if (!defined$is_utf8);if ($is_utf8){return}}}return$is_utf8}1;
JSON_PP_COMPAT5006

$fatpacked{"Module/Pluggable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE';
  package Module::Pluggable;use strict;use vars qw($VERSION $FORCE_SEARCH_ALL_PATHS);use Module::Pluggable::Object;use if $] > 5.017,'deprecate';$VERSION='5.2';$FORCE_SEARCH_ALL_PATHS=0;sub import {my$class=shift;my%opts=@_;my ($pkg,$file)=caller;my$sub=$opts{'sub_name'}|| 'plugins';my ($package)=$opts{'package'}|| $pkg;$opts{filename}=$file;$opts{package}=$package;$opts{force_search_all_paths}=$FORCE_SEARCH_ALL_PATHS unless exists$opts{force_search_all_paths};my$finder=Module::Pluggable::Object->new(%opts);my$subroutine=sub {my$self=shift;return$finder->plugins(@_)};my$searchsub=sub {my$self=shift;my ($action,@paths)=@_;$finder->{'search_path'}=["${package}::Plugin"]if ($action eq 'add' and not $finder->{'search_path'});push @{$finder->{'search_path'}},@paths if ($action eq 'add');$finder->{'search_path'}=\@paths if ($action eq 'new');return$finder->{'search_path'}};my$onlysub=sub {my ($self,$only)=@_;if (defined$only){$finder->{'only'}=$only};return$finder->{'only'}};my$exceptsub=sub {my ($self,$except)=@_;if (defined$except){$finder->{'except'}=$except};return$finder->{'except'}};no strict 'refs';no warnings qw(redefine prototype);*{"$package\::$sub"}=$subroutine;*{"$package\::search_path"}=$searchsub;*{"$package\::only"}=$onlysub;*{"$package\::except"}=$exceptsub}1;
MODULE_PLUGGABLE

$fatpacked{"Module/Pluggable/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE_OBJECT';
  package Module::Pluggable::Object;use strict;use File::Find ();use File::Basename;use File::Spec::Functions qw(splitdir catdir curdir catfile abs2rel);use Carp qw(croak carp confess);use Devel::InnerPackage;use vars qw($VERSION $MR);use if $] > 5.017,'deprecate';$VERSION='5.2';BEGIN {eval {require Module::Runtime};unless ($@){Module::Runtime->import('require_module')}else {*require_module=sub {my$module=shift;my$path=$module .".pm";$path =~ s{::}{/}g;require$path}}}sub new {my$class=shift;my%opts=@_;return bless \%opts,$class}sub plugins {my$self=shift;my@args=@_;$self->{'require'}=1 if$self->{'inner'};my$filename=$self->{'filename'};my$pkg=$self->{'package'};$self->_setup_exceptions;for (qw(search_path search_dirs)){$self->{$_}=[$self->{$_}]if exists$self->{$_}&&!ref($self->{$_})}$self->{'search_path'}||= ["${pkg}::Plugin"];$self->{'on_require_error'}||= sub {my ($plugin,$err)=@_;carp "Couldn't require $plugin : $err";return 0};$self->{'on_instantiate_error'}||= sub {my ($plugin,$err)=@_;carp "Couldn't instantiate $plugin: $err";return 0};$self->{'follow_symlinks'}=1 unless exists$self->{'follow_symlinks'};my@SEARCHDIR=exists$INC{"blib.pm"}&& defined$filename && $filename =~ m!(^|/)blib/! &&!$self->{'force_search_all_paths'}? grep {/blib/}@INC : @INC;unshift@SEARCHDIR,@{$self->{'search_dirs'}}if defined$self->{'search_dirs'};my@tmp=@INC;unshift@tmp,@{$self->{'search_dirs'}|| []};local@INC=@tmp if defined$self->{'search_dirs'};my@plugins=$self->search_directories(@SEARCHDIR);push(@plugins,$self->handle_inc_hooks($_,@SEARCHDIR))for @{$self->{'search_path'}};push(@plugins,$self->handle_innerpackages($_))for @{$self->{'search_path'}};return ()unless@plugins;my%plugins;for(@plugins){next unless$self->_is_legit($_);$plugins{$_}=1}if (defined$self->{'instantiate'}){my$method=$self->{'instantiate'};my@objs=();for my$package (sort keys%plugins){next unless$package->can($method);my$obj=eval {$package->$method(@_)};$self->{'on_instantiate_error'}->($package,$@)if $@;push@objs,$obj if$obj}return@objs}else {my@objs=sort keys%plugins;return@objs}}sub _setup_exceptions {my$self=shift;my%only;my%except;my$only;my$except;if (defined$self->{'only'}){if (ref($self->{'only'})eq 'ARRAY'){%only=map {$_=>1}@{$self->{'only'}}}elsif (ref($self->{'only'})eq 'Regexp'){$only=$self->{'only'}}elsif (ref($self->{'only'})eq ''){$only{$self->{'only'}}=1}}if (defined$self->{'except'}){if (ref($self->{'except'})eq 'ARRAY'){%except=map {$_=>1}@{$self->{'except'}}}elsif (ref($self->{'except'})eq 'Regexp'){$except=$self->{'except'}}elsif (ref($self->{'except'})eq ''){$except{$self->{'except'}}=1}}$self->{_exceptions}->{only_hash}=\%only;$self->{_exceptions}->{only}=$only;$self->{_exceptions}->{except_hash}=\%except;$self->{_exceptions}->{except}=$except}sub _is_legit {my$self=shift;my$plugin=shift;my%only=%{$self->{_exceptions}->{only_hash}||{}};my%except=%{$self->{_exceptions}->{except_hash}||{}};my$only=$self->{_exceptions}->{only};my$except=$self->{_exceptions}->{except};my$depth=()=split '::',$plugin,-1;return 0 if (keys%only &&!$only{$plugin});return 0 unless (!defined$only || $plugin =~ m!$only!);return 0 if (keys%except && $except{$plugin});return 0 if (defined$except && $plugin =~ m!$except!);return 0 if defined$self->{max_depth}&& $depth>$self->{max_depth};return 0 if defined$self->{min_depth}&& $depth<$self->{min_depth};return 1}sub search_directories {my$self=shift;my@SEARCHDIR=@_;my@plugins;for my$dir (@SEARCHDIR){push@plugins,$self->search_paths($dir)}return@plugins}sub search_paths {my$self=shift;my$dir=shift;my@plugins;my$file_regex=$self->{'file_regex'}|| qr/\.pm$/;for my$searchpath (@{$self->{'search_path'}}){my$sp=catdir($dir,(split /::/,$searchpath));next unless (-e $sp && -d _);my@files=$self->find_files($sp);for my$file (@files){next unless ($file)=($file =~ /(.*$file_regex)$/);my ($name,$directory,$suffix)=fileparse($file,$file_regex);next if (!$self->{include_editor_junk}&& $self->_is_editor_junk($name));$directory=abs2rel($directory,$sp);my@pkg_dirs=();if ($name eq lc($name)|| $name eq uc($name)){my$pkg_file=catfile($sp,$directory,"$name$suffix");open PKGFILE,"<$pkg_file" or die "search_paths: Can't open $pkg_file: $!";my$in_pod=0;while (my$line=<PKGFILE>){$in_pod=1 if$line =~ m/^=\w/;$in_pod=0 if$line =~ /^=cut/;next if ($in_pod || $line =~ /^=cut/);next if$line =~ /^\s*#/;if ($line =~ m/^\s*package\s+(.*::)?($name)\s*;/i){@pkg_dirs=split /::/,$1 if defined $1;;$name=$2;last}}close PKGFILE}$directory =~ s/^[a-z]://i if($^O =~ /MSWin32|dos/);my@dirs=();if ($directory){($directory)=($directory =~ /(.*)/);@dirs=grep(length($_),splitdir($directory))unless$directory eq curdir();for my$d (reverse@dirs){my$pkg_dir=pop@pkg_dirs;last unless defined$pkg_dir;$d =~ s/\Q$pkg_dir\E/$pkg_dir/i}}else {$directory=""}my$plugin=join '::',$searchpath,@dirs,$name;next unless$plugin =~ m!(?:[a-z\d]+)[a-z\d]*!i;$self->handle_finding_plugin($plugin,\@plugins)}push@plugins,$self->handle_innerpackages($searchpath)}return@plugins}sub _is_editor_junk {my$self=shift;my$name=shift;return 1 if$name =~ /~$/;return 1 if$name =~ /^\.#/;return 1 if$name =~ /\.sw[po]$/;return 0}sub handle_finding_plugin {my$self=shift;my$plugin=shift;my$plugins=shift;my$no_req=shift || 0;return unless$self->_is_legit($plugin);unless (defined$self->{'instantiate'}|| $self->{'require'}){push @$plugins,$plugin;return}$self->{before_require}->($plugin)|| return if defined$self->{before_require};unless ($no_req){my$tmp=$@;my$res=eval {require_module($plugin)};my$err=$@;$@=$tmp;if ($err){if (defined$self->{on_require_error}){$self->{on_require_error}->($plugin,$err)|| return}else {return}}}$self->{after_require}->($plugin)|| return if defined$self->{after_require};push @$plugins,$plugin}sub find_files {my$self=shift;my$search_path=shift;my$file_regex=$self->{'file_regex'}|| qr/\.pm$/;my@files=();{local $_;File::Find::find({no_chdir=>1,follow=>$self->{'follow_symlinks'},wanted=>sub {return unless$File::Find::name =~ /$file_regex/;(my$path=$File::Find::name)=~ s#^\\./##;push@files,$path}},$search_path)}return@files}sub handle_inc_hooks {my$self=shift;my$path=shift;my@SEARCHDIR=@_;my@plugins;for my$dir (@SEARCHDIR){next unless ref$dir && eval {$dir->can('files')};for my$plugin ($dir->files){$plugin =~ s/\.pm$//;$plugin =~ s{/}{::}g;next unless$plugin =~ m!^${path}::!;$self->handle_finding_plugin($plugin,\@plugins)}}return@plugins}sub handle_innerpackages {my$self=shift;return ()if (exists$self->{inner}&&!$self->{inner});my$path=shift;my@plugins;for my$plugin (Devel::InnerPackage::list_packages($path)){$self->handle_finding_plugin($plugin,\@plugins,1)}return@plugins}1;
MODULE_PLUGGABLE_OBJECT

$fatpacked{"Perl/Build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_BUILD';
  package Perl::Build;
  use strict;
  use warnings;
  use utf8;
  
  use 5.008002;
  our $VERSION = '1.13';
  
  use Carp ();
  use File::Basename;
  use File::Spec::Functions qw(catfile catdir rel2abs);
  use CPAN::Perl::Releases;
  use File::pushd qw(pushd);
  use File::Temp;
  use HTTP::Tiny;
  use Devel::PatchPerl 0.88;
  use Perl::Build::Built;
  use Time::Local;
  
  our $CPAN_MIRROR = $ENV{PERL_BUILD_CPAN_MIRROR} || 'http://www.cpan.org';
  
  sub available_perls {
      my ( $class, $dist ) = @_;
  
      my $url = "http://www.cpan.org/src/5.0/";
      my $html = http_get( $url );
  
      unless($html) {
          die "\nERROR: Unable to retrieve the list of perls.\n\n";
      }
  
      my @available_versions;
  
      my %uniq;
      while ($html =~ m|<a href="perl-([^"]+)\.tar\.gz">(.+?)</a>|g) {
          my $version = $1;
          next if $uniq{$version}++;
          push @available_versions, $version;
      }
  
      return @available_versions;
  }
  
  # @return extracted source directory
  sub extract_tarball {
      my ($class, $dist_tarball, $destdir) = @_;
  
      # Was broken on Solaris, where GNU tar is probably
      # installed as 'gtar' - RT #61042
      my $tarx =
          ($^O eq 'solaris' ? 'gtar ' : 'tar ') .
          ( $dist_tarball =~ m/bz2$/ ? 'xjf' : 'xzf' );
      my $extract_command = "cd @{[ $destdir ]}; $tarx @{[ File::Spec->rel2abs($dist_tarball) ]}";
      system($extract_command) == 0
          or die "Failed to extract $dist_tarball";
      $dist_tarball =~ s{(?:.*/)?([^/]+)\.tar\.(?:gz|bz2)$}{$1};
      if ($dist_tarball eq 'blead') {
          opendir my $dh, $destdir or die "Can't open $destdir: $!";
          my $latest = [];
          while(my $dir = readdir $dh) {
              next unless -d catfile($destdir, $dir) && $dir =~ /perl-[0-9a-f]{7,8}$/;
              my $mtime = (stat(_))[9];
              $latest = [$dir, $mtime] if !$latest->[1] or $latest->[1] < $mtime;
          }
          closedir $dh;
          return catfile($destdir, $latest->[0]);
      } elsif ($dist_tarball =~ /^cperl-/) {
          opendir my $dh, $destdir or die "Can't open $destdir: $!";
          my $latest = [];
          while(my $dir = readdir $dh) {
              next unless $dir =~ /^cperl-/;
              my $mtime = (stat(_))[9];
              $latest = [$dir, $mtime] if !$latest->[1] or $latest->[1] < $mtime;
          }
          closedir $dh;
          return catfile($destdir, $latest->[0]);
      } else {
          return "$destdir/$dist_tarball"; # Note that this is incorrect for blead
      }
  }
  
  sub perl_release {
      my ($class, $version) = @_;
  
      my ($dist_tarball, $dist_tarball_url);
      for my $func (qw/cpan_perl_releases perl_releases_page search_cpan_org/) {
          eval {
              ($dist_tarball, $dist_tarball_url) = $class->can("perl_release_by_$func")->($class,$version);
          };
          warn "WARN: [$func] $@" if $@;
          last if $dist_tarball && $dist_tarball_url;
      }
      die "ERROR: Cannot find the tarball for perl-$version\n"
          if !$dist_tarball and !$dist_tarball_url;
             
      return ($dist_tarball, $dist_tarball_url);
  }
  
  sub perl_release_by_cpan_perl_releases {
      my ($class, $version) = @_;
      my $tarballs = CPAN::Perl::Releases::perl_tarballs($version);
  
      my $x = $tarballs->{'tar.gz'};
      die "not found the tarball for perl-$version\n" unless $x;
      my $dist_tarball = (split("/", $x))[-1];
      my $dist_tarball_url = $CPAN_MIRROR . "/authors/id/$x";
      return ($dist_tarball, $dist_tarball_url);
  }
  
  sub perl_release_by_perl_releases_page {
      my ($class, $version) = @_;
  
      my $url = "http://perl-releases.s3-website-us-east-1.amazonaws.com/";
      my $http = HTTP::Tiny->new();
      my $response = $http->get($url);
      if (!$response->{success}) {
          die "Cannot get content from $url: $response->{status} $response->{reason}\n";
      }
  
      if ( ! exists $response->{headers}{'last-modified'} ) {
          die "There is not Last-Modified header. ignore this response\n";
      }
  
      my $last_modified;
      # Copy from HTTP::Tiny::_parse_date_time
      my $MoY = "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";
      if ( $response->{headers}{'last-modified'} =~ 
               /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/) {
          my @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
          $last_modified = eval {
              my $t = @tl_parts ? Time::Local::timegm(@tl_parts) : -1;
              $t < 0 ? undef : $t;
          };
      }
      if ( ! defined $last_modified || time - $last_modified > 3*86400 ) { #parse error or 3days old
          die "This page is 3 or more days old. ignore\n";
      }
  
      my ($dist_path, $dist_tarball) =
          $response->{content} =~ m[^\Q${version}\E\t(.+?/(perl-${version}.tar.(gz|bz2)))]m;
      die "not found the tarball for perl-$version\n"
          if !$dist_path and !$dist_tarball;
      my $dist_tarball_url = "$CPAN_MIRROR/authors/id/${dist_path}";
      return ($dist_tarball, $dist_tarball_url);
  
  }
  
  sub perl_release_by_search_cpan_org {
      my ($class, $version) = @_;
  
      my $html = http_get("http://search.cpan.org/dist/perl-${version}");
  
      unless ($html) {
          die "Failed to download perl-${version} tarball\n";
      }
  
      my ($dist_path, $dist_tarball) =
          $html =~ m[<a href="/CPAN/(authors/id/.+/(perl-${version}.tar.(gz|bz2)))">Download</a>];
      die "not found the tarball for perl-$version\n"
          if !$dist_path and !$dist_tarball;
      my $dist_tarball_url = "$CPAN_MIRROR/${dist_path}";
      return ($dist_tarball, $dist_tarball_url);
  
  }
  
  
  sub http_get {
      my ($url) = @_;
  
      my $http = HTTP::Tiny->new();
      my $response = $http->get($url);
      if ($response->{success}) {
          return $response->{content};
      } else {
          die "Cannot get content from $url: $response->{status} $response->{reason}\n";
      }
  }
  
  sub http_mirror {
      my ($url, $path) = @_;
  
      my $http = HTTP::Tiny->new();
      my $response = $http->mirror($url, $path);
      if ($response->{success}) {
          print "Downloaded $url to $path.\n";
      } else {
          die "Cannot get file from $url: $response->{status} $response->{reason}";
      }
  }
  
  sub install_from_cpan {
      my ($class, $version, %args) = @_;
  
      $args{patchperl} && Carp::croak "The patchperl argument was deprected.";
  
      my $tarball_dir = $args{tarball_dir}
          || File::Temp::tempdir( CLEANUP => 1 );
      my $build_dir = $args{build_dir}
          || File::Temp::tempdir( CLEANUP => 1 );
      my $dst_path = $args{dst_path}
          or die "Missing mandatory parameter: dst_path";
      my $configure_options = $args{configure_options}
          || ['-de'];
  
      # download tar ball
      my ($dist_tarball, $dist_tarball_url) = Perl::Build->perl_release($version);
      my $dist_tarball_path = catfile($tarball_dir, $dist_tarball);
      if (-f $dist_tarball_path) {
          print "Use the previously fetched ${dist_tarball}\n";
      }
      else {
          print "Fetching $version as $dist_tarball_path ($dist_tarball_url)\n";
          http_mirror( $dist_tarball_url, $dist_tarball_path );
      }
  
      # and extract tar ball.
      my $dist_extracted_path = Perl::Build->extract_tarball($dist_tarball_path, $build_dir);
      Perl::Build->install(
          src_path          => $dist_extracted_path,
          dst_path          => $dst_path,
          configure_options => $configure_options,
          test              => $args{test},
          jobs              => $args{jobs},
      );
  }
  
  sub install_from_url {
      my ($class, $dist_tarball_url, %args) = @_;
      $args{patchperl} && Carp::croak "The patchperl argument was deprected.";
  
      my $build_dir = $args{build_dir}
          || File::Temp::tempdir( CLEANUP => 1 );
      my $tarball_dir = $args{tarball_dir}
          || File::Temp::tempdir( CLEANUP => 1 );
      my $dst_path = $args{dst_path}
          or die "Missing mandatory parameter: dst_path";
      my $configure_options = $args{configure_options}
          || ['-de'];
  
      my $dist_tarball = basename($dist_tarball_url);
      my $dist_tarball_path = catfile($tarball_dir, $dist_tarball);
      if (-f $dist_tarball_path) {
          print "Use the previously fetched ${dist_tarball}\n";
      }
      else {
          print "Fetching $dist_tarball_path ($dist_tarball_url)\n";
          http_mirror( $dist_tarball_url, $dist_tarball_path );
      }
  
      my $dist_extracted_path = Perl::Build->extract_tarball($dist_tarball_path, $build_dir);
      Perl::Build->install(
          src_path          => $dist_extracted_path,
          dst_path          => $dst_path,
          configure_options => $configure_options,
          test              => $args{test},
          jobs              => $args{jobs},
      );
  }
  
  sub install_from_tarball {
      my ($class, $dist_tarball_path, %args) = @_;
      $args{patchperl} && Carp::croak "The patchperl argument was deprected.";
  
      my $build_dir = $args{build_dir}
          || File::Temp::tempdir( CLEANUP => 1 );
      my $dst_path = $args{dst_path}
          or die "Missing mandatory parameter: dst_path";
      my $configure_options = $args{configure_options}
          || ['-de'];
  
      my $dist_extracted_path = Perl::Build->extract_tarball($dist_tarball_path, $build_dir);
      Perl::Build->install(
          src_path          => $dist_extracted_path,
          dst_path          => $dst_path,
          configure_options => $configure_options,
          test              => $args{test},
          jobs              => $args{jobs},
      );
  }
  
  sub install {
      my ($class, %args) = @_;
      $args{patchperl} && Carp::croak "The patchperl argument was deprected.";
  
      my $src_path = $args{src_path}
          or die "Missing mandatory parameter: src_path";
      my $dst_path = $args{dst_path}
          or die "Missing mandatory parameter: dst_path";
      my $configure_options = $args{configure_options}
          or die "Missing mandatory parameter: configure_options";
      my $jobs = $args{jobs}; # optional
      my $test = $args{test}; # optional
  
      unshift @$configure_options, qq(-Dprefix=$dst_path);
  
      # Perl5 installs public executable scripts(like `prove`) to /usr/local/share/
      # if it exists.
      #
      # This -A'eval:scriptdir=$prefix/bin' option avoid this feature.
      unless (grep { /eval:scriptdir=/} @$configure_options) {
          push @$configure_options, "-A'eval:scriptdir=${dst_path}/bin'";
      }
  
      # clean up environment
      delete $ENV{$_} for qw(PERL5LIB PERL5OPT);
  
      {
          my $dir = pushd($src_path);
  
          # determine_version is a public API.
          my $dist_version = Devel::PatchPerl->determine_version();
          print "Configuring perl '$dist_version'\n";
  
          # clean up
          $class->do_system("rm -f config.sh Policy.sh");
  
          # apply patches
          Devel::PatchPerl->patch_source();
  
          # configure
          $class->do_system(['sh', 'Configure', @$configure_options]);
          # patch for older perls
          # XXX is this needed? patchperl do this?
          # if (Perl::Build->perl_version_to_integer($dist_version) < Perl::Build->perl_version_to_integer( '5.8.9' )) {
          #     $class->do_system("$^X -i -nle 'print unless /command-line/' makefile x2p/makefile");
          # }
  
          # build
          my @make = qw(make);
          if ($ENV{PERL_BUILD_COMPILE_OPTIONS}) {
              push @make, $ENV{PERL_BUILD_COMPILE_OPTIONS};
          }
          if ($jobs) {
              push @make, '-j', $jobs;
          }
          $class->do_system(\@make);
          if ($test) {
              local $ENV{TEST_JOBS} = $jobs if $jobs;
              # Test via "make test_harness" if available so we'll get
              # automatic parallel testing via $HARNESS_OPTIONS. The
              # "test_harness" target was added in 5.7.3, which was the last
              # development release before 5.8.0.
              my $test_target = 'test';
              if ($dist_version && $dist_version =~ /^5\.([0-9]+)\.([0-9]+)/
                  && ($1 >= 8 || $1 == 7 && $2 == 3)) {
                  $test_target = "test_harness";
              }
              $class->do_system([@make, $test_target]);
          }
	  # XXX
	  @make = qw(make install);
	  if ($ENV{PERL_BUILD_INSTALL_OPTIONS}) {
	      push @make, $ENV{PERL_BUILD_INSTALL_OPTIONS};
	  }
          $class->do_system(\@make);
      }
      return Perl::Build::Built->new({
          installed_path => $dst_path,
      });
  }
  
  sub do_system {
      my ($class, $cmd) = @_;
  
      if (ref $cmd eq 'ARRAY') {
          $class->info(join(' ', @$cmd));
          system(@$cmd) == 0
              or die "Installation failure: @$cmd";
      } else {
          $class->info($cmd);
          system($cmd) == 0
              or die "Installation failure: $cmd";
      }
  }
  
  sub symlink_devel_executables {
      my ($class, $bin_dir) = @_;
  
      for my $executable (glob("$bin_dir/*")) {
          my ($name, $version) = basename( $executable ) =~ m/(.+?)(5\.\d.*)?$/;
          if ($version) {
              my $cmd = "ln -fs $executable $bin_dir/$name";
              $class->info($cmd);
              system($cmd);
          }
      }
  }
  
  sub info {
      my ($class, @msg) = @_;
      print @msg, "\n";
  }
  
  1;
  __END__
  
  =encoding utf8
  
  =for stopwords tarball Optional symlinks patchperl
  
  =head1 NAME
  
  Perl::Build - perl builder
  
  =head1 SYNOPSIS
  
  =head1 Install as plenv plugin (Recommended)
  
      % git clone git://github.com/tokuhirom/Perl-Build.git ~/.plenv/plugins/perl-build/
  
  =head1 CLI interface without dependencies
  
      # perl-build command is FatPacker ready
      % curl https://raw.githubusercontent.com/tokuhirom/Perl-Build/master/perl-build | perl - 5.16.2 /opt/perl-5.16/
  
  =head1 CLI interface
  
      % cpanm Perl::Build
      % perl-build 5.16.2 /opt/perl-5.16/
  
  =head2 Programmable interface
  
      # install perl from CPAN
      my $result = Perl::Build->install_from_cpan(
          '5.16.2' => (
              dst_path          => '/path/to/perl-5.16.2/',
              configure_options => ['-des'],
          )
      );
  
      # install perl from tar ball
      my $result = Perl::Build->install_from_cpan(
          'path/to/perl-5.16.2.tar.gz' => (
              dst_path          => '/path/to/perl-5.16.2/',
              configure_options => ['-des'],
          )
      );
  
  =head1 DESCRIPTION
  
  This is yet another perl builder module.
  
  B<THIS IS A DEVELOPMENT RELEASE. API MAY CHANGE WITHOUT NOTICE>.
  
  =head1 METHODS
  
  =over 4
  
  =item C<< Perl::Build->install_from_cpan($version, %args) >>
  
  Install C<< $version >> perl from CPAN. This method fetches tar ball from CPAN, build, and install it.
  
  You can pass following options in C<< %args >>.
  
  =over 4
  
  =item C<< dst_path >>
  
  Destination directory to install perl.
  
  =item C<< configure_options : ArrayRef(Optional) >>
  
  Command line arguments for C<< ./Configure >>.
  
  (Default: C<< ['-de'] >>)
  
  =item C<< tarball_dir >> (Optional)
  
  Temporary directory to put tar ball.
  
  =item C<< build_dir >> (Optional)
  
  Temporary directory to build binary.
  
  =item C<< jobs: Int >> (Optional)
  
  Parallel building and testing.
  
  (Default: C<1>)
  
  =back
  
  =item C<< Perl::Build->install_from_tarball($dist_tarball_path, %args) >>
  
  Install perl from tar ball. This method extracts tar ball, build, and install.
  
  You can pass following options in C<< %args >>.
  
  =over 4
  
  =item C<< dst_path >> (Required)
  
  Destination directory to install perl.
  
  =item C<< configure_options : ArrayRef >> (Optional)
  
  Command line arguments for C<< ./Configure >>.
  
  (Default: C<< ['-de'] >>)
  
  =item C<< build_dir >> (Optional)
  
  Temporary directory to build binary.
  
  =item C<< jobs: Int >> (Optional)
  
  Parallel building and testing.
  
  (Default: C<1>)
  
  =back
  
  =item C<< Perl::Build->install(%args) >>
  
  Build and install Perl5 from extracted source directory.
  
  =over 4
  
  =item C<< src_path >> (Required)
  
  Source code directory to build.  That contains extracted Perl5 source code.
  
  =item C<< dst_path >> (Required)
  
  Destination directory to install perl.
  
  =item C<< configure_options : ArrayRef >> (Optional)
  
  Command line arguments for C<< ./Configure >>.
  
  (Default: C<< ['-de'] >>)
  
  =item C<< test: Bool >> (Optional)
  
  If you set this value as C<< true >>, C<< Perl::Build >> runs C<< make test >> after building.
  
  (Default: C<0>)
  
  =item C<< jobs: Int >> (Optional)
  
  Parallel building and testing.
  
  (Default: C<1>)
  
  =back
  
  Returns an instance of L<Perl::Build::Built> to facilitate using the built perl from code.
  
  =item C<< Perl::Build->symlink_devel_executables($bin_dir:Str) >>
  
  Perl5 binary generated with C<< -Dusedevel >>, is "perl-5.12.2" form. This method symlinks "perl-5.12.2" to "perl".
  
  =back
  
  =head1 FAQ
  
  =over 4
  
  =item How can I use patchperl plugins?
  
  If you want to use patchperl plugins, please Google "PERL5_PATCHPERL_PLUGIN".
  
  =item What's the difference between C<< perlbrew >>?
  
  L<perlbrew> is a perl5 installation manager. But perl-build is a simple perl5 compilation and installation assistant tool.
  It makes perl5 installation easily. That's all. perl-build doesn't care about the user's environment.
  
  So, perl-build is just a installer.
  
  =back
  
  =head1 THANKS TO
  
  Most of the code was taken from L<< C<App::perlbrew> >>.
  
  TYPESTER - suggests C<< --patches >> option
  
  Thanks
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno E<lt>tokuhirom@gmail.comE<gt>
  
  
  =head1 LICENSE
  
  Copyright (C) Tokuhiro Matsuno
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  This software takes lot of the code from L<App::perlbrew>. App::perlbrew's license is:
  
      The MIT License
  
      Copyright (c) 2010,2011 Kang-min Liu
  
      Permission is hereby granted, free of charge, to any person obtaining a copy
      of this software and associated documentation files (the "Software"), to deal
      in the Software without restriction, including without limitation the rights
      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the Software is
      furnished to do so, subject to the following conditions:
  
      The above copyright notice and this permission notice shall be included in
      all copies or substantial portions of the Software.
  
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
      THE SOFTWARE.
  
  
PERL_BUILD

$fatpacked{"Perl/Build/Built.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_BUILD_BUILT';
  package Perl::Build::Built;
  
  use strict;
  use warnings;
  use utf8;
  
  use 5.008002;
  our $VERSION = '1.13';
  
  use Carp ();
  use File::Spec::Functions qw( catdir catfile );
  
  sub run_env {
      my ( $self, @args ) = @_;
      my $config = {};
      if ( ref $args[0] eq 'HASH' ) {
          $config = %{ shift @args };
      }
      if ( $args[0] and ref $args[0] eq 'CODE' ) {
          $config->{code} = shift @args;
      }
      if (@args) {
          Carp::croak( '->run_env(\%config,\&code)'
                . ' or ->run_env(\&code)'
                . ' or ->run_env(\%config)' );
      }
      local $ENV{PATH}    = $self->combined_bin_path;
      local $ENV{MANPATH} = $self->combined_man_path;
      delete local $ENV{PERL5LIB};
      return $config->{code}->();
  }
  
  sub new {
      my ( $self, $args ) = @_;
      $args = {} unless defined $args;
      Carp::croak '->new(\%config) required' if not ref $args eq 'HASH';
      Carp::croak 'installed_path is a mandatory parameter'
        unless exists $args->{installed_path};
      return bless $args, $self;
  }
  
  sub installed_path {
      return $_[0]->{installed_path};
  }
  
  sub bin_path {
      return catdir( $_[0]->{installed_path}, 'bin' );
  }
  
  sub man_path {
      return catdir( $_[0]->{installed_path}, 'man' );
  }
  
  sub combined_bin_path {
      return $_[0]->bin_path . ':' . $ENV{PATH};
  }
  
  sub combined_man_path {
      if ( -d $_[0]->man_path ) {
          return $_[0]->man_path . ':' . $ENV{MANPATH};
      }
      return $ENV{MANPATH};
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf8
  
  =for stopwords dir
  
  =head1 NAME
  
  Perl::Build::Built - A utility class to work with recently built perl installs.
  
  =head1 SYNOPSIS
  
      my $result = Perl::Build->install( ... );
      $result->run_env(sub{
          # Run code on the installed perl
          system('perl', .... );
      });
  
  =head1 METHODS
  
  =over 4
  
  =item $instance->run_env(\&code)
  
  Run C<&code> inside an environment configured to use the built perl.
  
      $instance->run_env(sub{
          my $cpanm_path = catfile( $instance->bin_path , 'cpanm' );
          system('wget','-O', $cpanm_path, 'http://path/to/cpanm');
          system('chmod', 'u+x', $cpanm_path );
          system('cpanm', "App::cpanoutdated");
          system('perl',.... );
      });
  
  =item Perl::Build::Built->new( \%params )
  
  You probably don't need to call this, ever.
  
  =item $instance->installed_path
  
  Returns the path the Perl was installed to ( Just whatever was passed to C<new> )
  
  =item $instance->bin_path
  
  Returns the path to the 'bin' dir inside the installed Perl target directory.
  
  =item $instance->man_path
  
  Returns the path to the 'man' dir inside the installed Perl target directory.
  
  =item $instance->combined_bin_path
  
  C<bin_path> prefixed onto C<$ENV{PATH}>
  
  =item $instance->combined_man_path
  
  C<man_path> prefixed onto C<$ENV{MANPATH}>
  
  =back
  
  =head1 AUTHOR
  
  =over 4
  
  =item Kent Fredric E<lt>kentnl@cpan.orgE<gt>
  
  =item Tokuhiro Matsuno E<lt>tokuhirom@gmail.comE<gt>
  
  =back
  
  =head1 LICENSE
  
  Copyright (C) Tokuhiro Matsuno
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
PERL_BUILD_BUILT

$fatpacked{"Pod/Escapes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ESCAPES';
  package Pod::Escapes;use strict;use warnings;use 5.006;use vars qw(%Code2USASCII %Name2character %Name2character_number %Latin1Code_to_fallback %Latin1Char_to_fallback $FAR_CHAR $FAR_CHAR_NUMBER $NOT_ASCII @ISA $VERSION @EXPORT_OK %EXPORT_TAGS);require Exporter;@ISA=('Exporter');$VERSION='1.07';@EXPORT_OK=qw(%Code2USASCII %Name2character %Name2character_number %Latin1Code_to_fallback %Latin1Char_to_fallback e2char e2charnum);%EXPORT_TAGS=('ALL'=>\@EXPORT_OK);$FAR_CHAR="?" unless defined$FAR_CHAR;$FAR_CHAR_NUMBER=ord($FAR_CHAR)unless defined$FAR_CHAR_NUMBER;$NOT_ASCII='A' ne chr(65)unless defined$NOT_ASCII;sub e2char {my$in=$_[0];return undef unless defined$in and length$in;if($in =~ m/^(0[0-7]*)$/s){$in=oct$in}elsif($in =~ m/^0?x([0-9a-fA-F]+)$/s){$in=hex $1}if($in =~ m/^\d+$/s){if($] < 5.007 and $in > 255){return$FAR_CHAR}elsif ($] >= 5.007003){return chr(utf8::unicode_to_native($in))}elsif ($NOT_ASCII){return$Code2USASCII{$in}|| $Latin1Code_to_fallback{$in}|| $FAR_CHAR}else {return chr($in)}}else {return$Name2character{$in}}}sub e2charnum {my$in=$_[0];return undef unless defined$in and length$in;if($in =~ m/^(0[0-7]*)$/s){$in=oct$in}elsif($in =~ m/^0?x([0-9a-fA-F]+)$/s){$in=hex $1}if($in =~ m/^[0-9]+$/s){return 0 + $in}else {return$Name2character_number{$in}}}%Code2USASCII=(32,' ',33,'!',34,'"',35,'#',36,'$',37,'%',38,'&',39,"'",40,'(',41,')',42,'*',43,'+',44,',',45,'-',46,'.',47,'/',48,'0',49,'1',50,'2',51,'3',52,'4',53,'5',54,'6',55,'7',56,'8',57,'9',58,':',59,';',60,'<',61,'=',62,'>',63,'?',64,'@',65,'A',66,'B',67,'C',68,'D',69,'E',70,'F',71,'G',72,'H',73,'I',74,'J',75,'K',76,'L',77,'M',78,'N',79,'O',80,'P',81,'Q',82,'R',83,'S',84,'T',85,'U',86,'V',87,'W',88,'X',89,'Y',90,'Z',91,'[',92,"\\",93,']',94,'^',95,'_',96,'`',97,'a',98,'b',99,'c',100,'d',101,'e',102,'f',103,'g',104,'h',105,'i',106,'j',107,'k',108,'l',109,'m',110,'n',111,'o',112,'p',113,'q',114,'r',115,'s',116,'t',117,'u',118,'v',119,'w',120,'x',121,'y',122,'z',123,'{',124,'|',125,'}',126,'~',);%Latin1Code_to_fallback=();@Latin1Code_to_fallback{0xA0 .. 0xFF}=(' ',qq{!},qq{C/},'PS',qq{\$?},qq{Y=},qq{|},'SS',qq{"},qq{(c)},'a',qq{<<},qq{!},"",qq{(r)},qq{-},'deg',qq{+-},'2','3',qq{'},'u','P',qq{*},qq{,},'1','o',qq{>>},qq{1/4},qq{1/2},qq{3/4},qq{?},'A','A','A','A','A','A','AE','C','E','E','E','E','I','I','I','I','D','N','O','O','O','O','O','x','O','U','U','U','U','U','Th','ss','a','a','a','a','a','a','ae','c','e','e','e','e','i','i','i','i','d','n','o','o','o','o','o',qq{/},'o','u','u','u','u','y','th','y',);{%Latin1Char_to_fallback=();my($k,$v);while(($k,$v)=each%Latin1Code_to_fallback){$Latin1Char_to_fallback{chr$k}=$v}}%Name2character_number=('lt'=>60,'gt'=>62,'quot'=>34,'amp'=>38,'apos'=>39,'sol'=>47,'verbar'=>124,'lchevron'=>171,'rchevron'=>187,'nbsp',160,'iexcl',161,'cent',162,'pound',163,'curren',164,'yen',165,'brvbar',166,'sect',167,'uml',168,'copy',169,'ordf',170,'laquo',171,'not',172,'shy',173,'reg',174,'macr',175,'deg',176,'plusmn',177,'sup2',178,'sup3',179,'acute',180,'micro',181,'para',182,'middot',183,'cedil',184,'sup1',185,'ordm',186,'raquo',187,'frac14',188,'frac12',189,'frac34',190,'iquest',191,'Agrave',192,'Aacute',193,'Acirc',194,'Atilde',195,'Auml',196,'Aring',197,'AElig',198,'Ccedil',199,'Egrave',200,'Eacute',201,'Ecirc',202,'Euml',203,'Igrave',204,'Iacute',205,'Icirc',206,'Iuml',207,'ETH',208,'Ntilde',209,'Ograve',210,'Oacute',211,'Ocirc',212,'Otilde',213,'Ouml',214,'times',215,'Oslash',216,'Ugrave',217,'Uacute',218,'Ucirc',219,'Uuml',220,'Yacute',221,'THORN',222,'szlig',223,'agrave',224,'aacute',225,'acirc',226,'atilde',227,'auml',228,'aring',229,'aelig',230,'ccedil',231,'egrave',232,'eacute',233,'ecirc',234,'euml',235,'igrave',236,'iacute',237,'icirc',238,'iuml',239,'eth',240,'ntilde',241,'ograve',242,'oacute',243,'ocirc',244,'otilde',245,'ouml',246,'divide',247,'oslash',248,'ugrave',249,'uacute',250,'ucirc',251,'uuml',252,'yacute',253,'thorn',254,'yuml',255,'fnof',402,'Alpha',913,'Beta',914,'Gamma',915,'Delta',916,'Epsilon',917,'Zeta',918,'Eta',919,'Theta',920,'Iota',921,'Kappa',922,'Lambda',923,'Mu',924,'Nu',925,'Xi',926,'Omicron',927,'Pi',928,'Rho',929,'Sigma',931,'Tau',932,'Upsilon',933,'Phi',934,'Chi',935,'Psi',936,'Omega',937,'alpha',945,'beta',946,'gamma',947,'delta',948,'epsilon',949,'zeta',950,'eta',951,'theta',952,'iota',953,'kappa',954,'lambda',955,'mu',956,'nu',957,'xi',958,'omicron',959,'pi',960,'rho',961,'sigmaf',962,'sigma',963,'tau',964,'upsilon',965,'phi',966,'chi',967,'psi',968,'omega',969,'thetasym',977,'upsih',978,'piv',982,'bull',8226,'hellip',8230,'prime',8242,'Prime',8243,'oline',8254,'frasl',8260,'weierp',8472,'image',8465,'real',8476,'trade',8482,'alefsym',8501,'larr',8592,'uarr',8593,'rarr',8594,'darr',8595,'harr',8596,'crarr',8629,'lArr',8656,'uArr',8657,'rArr',8658,'dArr',8659,'hArr',8660,'forall',8704,'part',8706,'exist',8707,'empty',8709,'nabla',8711,'isin',8712,'notin',8713,'ni',8715,'prod',8719,'sum',8721,'minus',8722,'lowast',8727,'radic',8730,'prop',8733,'infin',8734,'ang',8736,'and',8743,'or',8744,'cap',8745,'cup',8746,'int',8747,'there4',8756,'sim',8764,'cong',8773,'asymp',8776,'ne',8800,'equiv',8801,'le',8804,'ge',8805,'sub',8834,'sup',8835,'nsub',8836,'sube',8838,'supe',8839,'oplus',8853,'otimes',8855,'perp',8869,'sdot',8901,'lceil',8968,'rceil',8969,'lfloor',8970,'rfloor',8971,'lang',9001,'rang',9002,'loz',9674,'spades',9824,'clubs',9827,'hearts',9829,'diams',9830,'OElig',338,'oelig',339,'Scaron',352,'scaron',353,'Yuml',376,'circ',710,'tilde',732,'ensp',8194,'emsp',8195,'thinsp',8201,'zwnj',8204,'zwj',8205,'lrm',8206,'rlm',8207,'ndash',8211,'mdash',8212,'lsquo',8216,'rsquo',8217,'sbquo',8218,'ldquo',8220,'rdquo',8221,'bdquo',8222,'dagger',8224,'Dagger',8225,'permil',8240,'lsaquo',8249,'rsaquo',8250,'euro',8364,);{%Name2character=();my($name,$number);while(($name,$number)=each%Name2character_number){if($] < 5.007 and $number > 255){$Name2character{$name}=$FAR_CHAR}elsif ($] >= 5.007003){$Name2character{$name}=chr utf8::unicode_to_native($number)}elsif (exists$Code2USASCII{$number}){$Name2character{$name}=$Code2USASCII{$number}}elsif ($NOT_ASCII && $number > 127 && $number < 256){if (exists$Latin1Code_to_fallback{$number}){$Name2character{$name}=$Latin1Code_to_fallback{$number}}else {$Name2character{$name}=$FAR_CHAR}}else {$Name2character{$name}=chr$number}}}1;
POD_ESCAPES

$fatpacked{"Pod/Man.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_MAN';
  package Pod::Man;use 5.006;use strict;use warnings;use subs qw(makespace);use vars qw(@ISA %ESCAPES $PREAMBLE $VERSION);use Carp qw(carp croak);use Pod::Simple ();our$HAS_ENCODE;BEGIN {$HAS_ENCODE=eval {require Encode}}@ISA=qw(Pod::Simple);$VERSION='4.09';BEGIN {my$parent=defined (&Pod::Simple::DEBUG)? \&Pod::Simple::DEBUG : undef;unless (defined&DEBUG){*DEBUG=$parent || sub () {10}}}BEGIN {*ASCII=\&Pod::Simple::ASCII}BEGIN {*pretty=\&Pod::Simple::pretty}my%FORMATTING=(DEFAULT=>{cleanup=>1,convert=>1,guesswork=>1,literal=>0 },Data=>{cleanup=>0,convert=>0,guesswork=>0,literal=>0 },Verbatim=>{guesswork=>0,literal=>1 },C=>{guesswork=>0,literal=>1 },X=>{cleanup=>0,guesswork=>0 },);sub new {my$class=shift;my$self=$class->SUPER::new;$self->nbsp_for_S (1);if (my$preserve_whitespace=$self->can ('preserve_whitespace')){$self->$preserve_whitespace (1)}else {$self->fullstop_space_harden (1)}$self->accept_targets (qw/man MAN roff ROFF/);$self->merge_text (1);%$self=(%$self,@_);if ($$self{stderr}and not $$self{errors}){$$self{errors}='stderr'}delete $$self{stderr};if (not defined $$self{errors}){$$self{errors}='pod'}if ($$self{errors}eq 'stderr' || $$self{errors}eq 'die'){$self->no_errata_section (1);$self->complain_stderr (1);if ($$self{errors}eq 'die'){$$self{complain_die}=1}}elsif ($$self{errors}eq 'pod'){$self->no_errata_section (0);$self->complain_stderr (0)}elsif ($$self{errors}eq 'none'){$self->no_whining (1)}else {croak (qq(Invalid errors setting: "$$self{errors}"))}delete $$self{errors};if ($$self{utf8}and!$HAS_ENCODE){if (!$ENV{PERL_CORE}){carp ('utf8 mode requested but Encode module not available,' .' falling back to non-utf8')}delete $$self{utf8}}$self->init_fonts;$self->init_quotes;$self->init_page;$$self{MAGIC_CPP}=1;$$self{MAGIC_EMDASH}=1;$$self{MAGIC_FUNC}=1;$$self{MAGIC_MANREF}=1;$$self{MAGIC_SMALLCAPS}=1;$$self{MAGIC_VARS}=1;return$self}sub toescape {(length ($_[0])> 1 ? '\f(' : '\f').$_[0]}sub init_fonts {my ($self)=@_;for (qw/fixed fixedbold fixeditalic fixedbolditalic/){my$font=$$self{$_};if (defined ($font)&& (length ($font)< 1 || length ($font)> 2)){croak qq(roff font should be 1 or 2 chars, not "$font")}}$$self{fixed}||= 'CW';$$self{fixedbold}||= 'CB';$$self{fixeditalic}||= 'CI';$$self{fixedbolditalic}||= 'CB';$$self{FONTS}={'000'=>'\fR','001'=>'\fI','010'=>'\fB','011'=>'\f(BI','100'=>toescape ($$self{fixed}),'101'=>toescape ($$self{fixeditalic}),'110'=>toescape ($$self{fixedbold}),'111'=>toescape ($$self{fixedbolditalic})}}sub init_quotes {my ($self)=(@_);$$self{quotes}||= '"';if ($$self{quotes}eq 'none'){$$self{LQUOTE}=$$self{RQUOTE}=''}elsif (length ($$self{quotes})==1){$$self{LQUOTE}=$$self{RQUOTE}=$$self{quotes}}elsif (length ($$self{quotes})% 2==0){my$length=length ($$self{quotes})/ 2;$$self{LQUOTE}=substr ($$self{quotes},0,$length);$$self{RQUOTE}=substr ($$self{quotes},$length)}else {croak(qq(Invalid quote specification "$$self{quotes}"))}if (defined $$self{lquote}){$$self{LQUOTE}=$$self{lquote}eq 'none' ? q{} : $$self{lquote}}if (defined $$self{rquote}){$$self{RQUOTE}=$$self{rquote}eq 'none' ? q{} : $$self{rquote}}$$self{LQUOTE}=~ s/\"/\"\"/;$$self{RQUOTE}=~ s/\"/\"\"/}sub init_page {my ($self)=@_;my@version=($] =~ /^(\d+)\.(\d{3})(\d{0,3})$/);$version[2]||= 0;$version[2]*= 10 ** (3 - length$version[2]);for (@version){$_ += 0}my$version=join ('.',@version);$$self{center}='User Contributed Perl Documentation' unless defined $$self{center};$$self{release}='perl v' .$version unless defined $$self{release};$$self{indent}=4 unless defined $$self{indent};for (qw/center release/){$$self{$_}=~ s/\"/\"\"/g if $$self{$_}}}sub _handle_text {my ($self,$text)=@_;DEBUG > 3 and print "== $text\n";my$tag=$$self{PENDING}[-1];$$tag[2].= $self->format_text ($$tag[1],$text)}sub method_for_element {my ($self,$element)=@_;$element =~ tr/A-Z-/a-z_/;$element =~ tr/_a-z0-9//cd;return$element}sub _handle_element_start {my ($self,$element,$attrs)=@_;DEBUG > 3 and print "++ $element (<",join ('> <',%$attrs),">)\n";my$method=$self->method_for_element ($element);if ($self->can ("cmd_$method")){DEBUG > 2 and print "<$element> starts saving a tag\n";$$self{IN_NAME}=0 if ($element ne 'Para' && length ($element)> 1);my$formatting={%{$$self{PENDING}[-1][1]|| $FORMATTING{DEFAULT}},%{$FORMATTING{$element}|| {}},};push (@{$$self{PENDING}},[$attrs,$formatting,'' ]);DEBUG > 4 and print "Pending: [",pretty ($$self{PENDING}),"]\n"}elsif (my$start_method=$self->can ("start_$method")){$self->$start_method ($attrs,'')}else {DEBUG > 2 and print "No $method start method, skipping\n"}}sub _handle_element_end {my ($self,$element)=@_;DEBUG > 3 and print "-- $element\n";my$method=$self->method_for_element ($element);if (my$cmd_method=$self->can ("cmd_$method")){DEBUG > 2 and print "</$element> stops saving a tag\n";my$tag=pop @{$$self{PENDING}};DEBUG > 4 and print "Popped: [",pretty ($tag),"]\n";DEBUG > 4 and print "Pending: [",pretty ($$self{PENDING}),"]\n";my$text=$self->$cmd_method ($$tag[0],$$tag[2]);if (defined$text){if (@{$$self{PENDING}}> 1){$$self{PENDING}[-1][2].= $text}else {$self->output ($text)}}}elsif (my$end_method=$self->can ("end_$method")){$self->$end_method ()}else {DEBUG > 2 and print "No $method end method, skipping\n"}}sub format_text {my ($self,$options,$text)=@_;my$guesswork=$$options{guesswork}&&!$$self{IN_NAME};my$cleanup=$$options{cleanup};my$convert=$$options{convert};my$literal=$$options{literal};if ($cleanup){$text =~ s/\\/\\e/g;$text =~ s/-/\\-/g;$text =~ s/_(?=_)/_\\|/g}if ($convert &&!$$self{utf8}&& ASCII){$text =~ s/([^\x00-\x7F])/$ESCAPES{ord ($1)} || "X"/eg}if ($literal){$text =~ s/(?<!\\\*)\'/\\*\(Aq/g;$text =~ s/(?<!\\\*)\`/\\\`/g}if ($guesswork){$text=$self->guesswork ($text)}return$text}sub quote_literal {my$self=shift;local $_=shift;my$index='(?: \[.*\] | \{.*\} )?';return qq{"$_"} if $$self{IN_NAME};m{
        ^\s*
        (?:
           ( [\'\`\"] ) .* \1                             # already quoted
         | \\\*\(Aq .* \\\*\(Aq                           # quoted and escaped
         | \\?\` .* ( \' | \\\*\(Aq )                     # `quoted'
         | \$+ [\#^]? \S $index                           # special ($^Foo, $")
         | [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
         | [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
         | [-+]? ( \d[\d.]* | \.\d+ ) (?: [eE][-+]?\d+ )? # a number
         | 0x [a-fA-F\d]+                                 # a hex constant
        )
        \s*\z
       }xso and return '\f(FS' .$_ .'\f(FE';return '\f(FS\*(C`' .$_ ."\\*(C'\\f(FE"}sub guesswork {my$self=shift;local $_=shift;DEBUG > 5 and print "   Guesswork called on [$_]\n";s{
          ( (?:\G|^|\s) [\(\"]* [a-zA-Z] ) ( \\- )?
          ( (?: [a-zA-Z\']+ \\-)+ )
          ( [a-zA-Z\']+ ) (?= [\)\".?!,;:]* (?:\s|\Z|\\\ ) )
          \b
      } {
          my ($prefix, $hyphen, $main, $suffix) = ($1, $2, $3, $4);
          $hyphen ||= '';
          $main =~ s/\\-/-/g;
          $prefix . $hyphen . $main . $suffix;
      }egx;if ($$self{MAGIC_EMDASH}){s{          (\s) \\-\\- (\s)                } { $1 . '\*(--' . $2 }egx;s{ (\b[a-zA-Z]+) \\-\\- (\s|\Z|[a-zA-Z]+\b) } { $1 . '\*(--' . $2 }egx}if ($$self{MAGIC_SMALLCAPS}){s{
              ( ^ | [\s\(\"\'\`\[\{<>] | \\[ ]  )                           # (1)
              ( [A-Z] [A-Z] (?: \s? [/A-Z+:\d_\$&] | \\- | \s? [.,\"] )* )  # (2)
              (?= [\s>\}\]\(\)\'\".?!,;] | \\*\(-- | \\[ ] | $ )            # (3)
          } {
              $1 . '\s-1' . $2 . '\s0'
          }egx}if ($$self{MAGIC_FUNC}){s{
              ( \b | \\s-1 )
              ( [A-Za-z_] ([:\w] | \\s-?[01])+ \(\) )
          } {
              $1 . '\f(IS' . $2 . '\f(IE'
          }egx}if ($$self{MAGIC_MANREF}){s{
              ( \b | \\s-1 )
              (?<! \\ )                                   # rule out \s0(1)
              ( [A-Za-z_] (?:[.:\w] | \\- | \\s-?[01])+ )
              ( \( \d [a-z]* \) )
          } {
              $1 . '\f(IS' . $2 . '\f(IE\|' . $3
          }egx}if ($$self{MAGIC_VARS}){s{
             ( ^ | \s+ )
             ( [\$\@%] [\w:]+ )
             (?! \( )
          } {
              $1 . '\f(FS' . $2 . '\f(FE'
          }egx}s{ \" ([^\"]+) \" } { '\*(L"' . $1 . '\*(R"' }egx;if ($$self{MAGIC_CPP}){s{ \b C\+\+ } {\\*\(C+}gx}DEBUG > 5 and print "   Guesswork returning [$_]\n";return $_}sub mapfonts {my ($self,$text)=@_;my ($fixed,$bold,$italic)=(0,0,0);my%magic=(F=>\$fixed,B=>\$bold,I=>\$italic);my$last='\fR';$text =~ s<
          \\f\((.)(.)
      > <
          my $sequence = '';
          my $f;
          if ($last ne '\fR') { $sequence = '\fP' }
          ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
          $f = $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
          if ($f eq $last) {
              '';
          } else {
              if ($f ne '\fR') { $sequence .= $f }
              $last = $f;
              $sequence;
          }
      >gxe;return$text}sub textmapfonts {my ($self,$text)=@_;my ($fixed,$bold,$italic)=(0,0,0);my%magic=(F=>\$fixed,B=>\$bold,I=>\$italic);$text =~ s<
          \\f\((.)(.)
      > <
          ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
          $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
      >gxe;return$text}sub switchquotes {my ($self,$command,$text,$extra)=@_;$text =~ s/\\\*\([LR]\"/\"/g;my$c_is_quote=($$self{LQUOTE}=~ /\"/)|| ($$self{RQUOTE}=~ /\"/);my$fixedpat=join '|',@{$$self{FONTS}}{'100','101','110','111'};$fixedpat =~ s/\\/\\\\/g;$fixedpat =~ s/\(/\\\(/g;if ($text =~ m/\"/ || $text =~ m/$fixedpat/){$text =~ s/\"/\"\"/g;my$nroff=$text;my$troff=$text;$troff =~ s/\"\"([^\"]*)\"\"/\`\`$1\'\'/g;if ($c_is_quote and $text =~ m/\\\*\(C[\'\`]/){$nroff =~ s/\\\*\(C\`/$$self{LQUOTE}/g;$nroff =~ s/\\\*\(C\'/$$self{RQUOTE}/g;$troff =~ s/\\\*\(C[\'\`]//g}$nroff=qq("$nroff") .($extra ? " $extra" : '');$troff=qq("$troff") .($extra ? " $extra" : '');my$font_end="(?:\\f[PR]|\Q$$self{FONTS}{100}\E)";$nroff =~ s/\Q$$self{FONTS}{100}\E(.*?)\\f([PR])/$1/g;$nroff =~ s/\Q$$self{FONTS}{101}\E(.*?)$font_end/\\fI$1\\fP/g;$nroff =~ s/\Q$$self{FONTS}{110}\E(.*?)$font_end/\\fB$1\\fP/g;$nroff =~ s/\Q$$self{FONTS}{111}\E(.*?)$font_end/\\f\(BI$1\\fP/g;if ($nroff ne $troff){return ".ie n $command $nroff\n.el $command $troff\n"}else {return "$command $nroff\n"}}else {$text=qq("$text") .($extra ? " $extra" : '');return "$command $text\n"}}sub protect {my ($self,$text)=@_;$text =~ s/^([.\'\\])/\\&$1/mg;return$text}sub makespace {my ($self)=@_;$self->output (".PD\n")if $$self{ITEMS}> 1;$$self{ITEMS}=0;$self->output ($$self{INDENT}> 0 ? ".Sp\n" : ".PP\n")if $$self{NEEDSPACE}}sub outindex {my ($self,$section,$index)=@_;my@entries=map {split m%\s*/\s*%}@{$$self{INDEX}};return unless ($section || @entries);$$self{INDEX}=[];my@output;if (@entries){push@output,['Xref',join (' ',@entries)]}if ($section){$index =~ s/\\-/-/g;$index =~ s/\\(?:s-?\d|.\(..|.)//g;push@output,[$section,$index ]}for (@output){my ($type,$entry)=@$_;$entry =~ s/\s+/ /g;$entry =~ s/\"/\"\"/g;$entry =~ s/\\/\\\\/g;$self->output (".IX $type " .'"' .$entry .'"' ."\n")}}sub output {my ($self,@text)=@_;if ($$self{ENCODE}){print {$$self{output_fh}}Encode::encode ('UTF-8',join ('',@text))}else {print {$$self{output_fh}}@text}}sub start_document {my ($self,$attrs)=@_;if ($$attrs{contentless}&&!$$self{ALWAYS_EMIT_SOMETHING}){DEBUG and print "Document is contentless\n";$$self{CONTENTLESS}=1}else {delete $$self{CONTENTLESS}}$$self{ENCODE}=0;if ($$self{utf8}){$$self{ENCODE}=1;eval {my@options=(output=>1,details=>1);my$flag=(PerlIO::get_layers ($$self{output_fh},@options))[-1];if ($flag & PerlIO::F_UTF8 ()){$$self{ENCODE}=0}}}if (!$$self{CONTENTLESS}){my ($name,$section);if (defined $$self{name}){$name=$$self{name};$section=$$self{section}|| 1}else {($name,$section)=$self->devise_title}my$date=defined($$self{date})? $$self{date}: $self->devise_date;$self->preamble ($name,$section,$date)unless$self->bare_output or DEBUG > 9}$$self{INDENT}=0;$$self{INDENTS}=[];$$self{INDEX}=[];$$self{IN_NAME}=0;$$self{ITEMS}=0;$$self{ITEMTYPES}=[];$$self{SHIFTWAIT}=0;$$self{SHIFTS}=[];$$self{PENDING}=[[]]}sub end_document {my ($self)=@_;if ($$self{complain_die}&& $self->errors_seen){croak ("POD document had syntax errors")}return if$self->bare_output;return if ($$self{CONTENTLESS}&&!$$self{ALWAYS_EMIT_SOMETHING});$self->output (q(.\" [End document]) ."\n")if DEBUG}sub devise_title {my ($self)=@_;my$name=$self->source_filename || '';my$section=$$self{section}|| 1;$section=3 if (!$$self{section}&& $name =~ /\.pm\z/i);$name =~ s/\.p(od|[lm])\z//i;if ($name =~ /^IO::File(?:=\w+)\(0x[\da-f]+\)$/i){$name=''}if ($name eq ''){$name='STDIN'}if ($section !~ /^3/){require File::Basename;$name=uc File::Basename::basename ($name)}else {require File::Spec;my ($volume,$dirs,$file)=File::Spec->splitpath ($name);my@dirs=File::Spec->splitdir ($dirs);if (@dirs){my$cut=0;my$i;for ($i=0;$i < @dirs;$i++){if ($dirs[$i]=~ /perl/){$cut=$i + 1;$cut++ if ($dirs[$i + 1]&& $dirs[$i + 1]eq 'lib');last}}if ($cut > 0){splice (@dirs,0,$cut);shift@dirs if ($dirs[0]=~ /^(site|vendor)(_perl)?$/);shift@dirs if ($dirs[0]=~ /^[\d.]+$/);shift@dirs if ($dirs[0]=~ /^(.*-$^O|$^O-.*|$^O)$/)}shift@dirs if$dirs[0]eq 'lib';splice (@dirs,0,2)if ($dirs[0]eq 'blib' && $dirs[1]eq 'lib')}$name=join ('::',(grep {$_ ? $_ : ()}@dirs),$file)}return ($name,$section)}sub devise_date {my ($self)=@_;if (defined($ENV{POD_MAN_DATE})){return$ENV{POD_MAN_DATE}}my$time;if (defined($ENV{SOURCE_DATE_EPOCH})&& $ENV{SOURCE_DATE_EPOCH}!~ /\D/){$time=$ENV{SOURCE_DATE_EPOCH}}if (!defined$time){my$input=$self->source_filename;if ($input){$time=(stat($input))[9]|| time()}else {$time=time()}}my ($year,$month,$day)=(gmtime($time))[5,4,3];return sprintf("%04d-%02d-%02d",$year + 1900,$month + 1,$day)}sub preamble {my ($self,$name,$section,$date)=@_;my$preamble=$self->preamble_template (!$$self{utf8});my$index="$name $section";$index =~ s/\"/\"\"/g;for ($name,$section){if (/\s/){s/\"/\"\"/g;$_='"' .$_ .'"'}}$date =~ s/\"/\"\"/g;$preamble =~ s/\@CFONT\@/$$self{fixed}/;$preamble =~ s/\@LQUOTE\@/$$self{LQUOTE}/;$preamble =~ s/\@RQUOTE\@/$$self{RQUOTE}/;chomp$preamble;my$version=$self->version_report;$self->output (<<"----END OF HEADER----");$self->output (".\\\" [End of preamble]\n")if DEBUG}sub cmd_para {my ($self,$attrs,$text)=@_;my$line=$$attrs{start_line};$self->makespace;if ($$self{SHIFTWAIT}){$self->output (".RS $$self{INDENT}\n");push (@{$$self{SHIFTS}},$$self{INDENT});$$self{SHIFTWAIT}=0}$self->output (".\\\" [At source line $line]\n")if defined ($line)&& DEBUG &&!$$self{IN_NAME};$text=reverse$text;$text =~ s/\A\s*?(?= \\|\S|\z)/\n/;$text=reverse$text;$self->output ($self->protect ($self->textmapfonts ($text)));$self->outindex;$$self{NEEDSPACE}=1;return ''}sub cmd_verbatim {my ($self,$attrs,$text)=@_;return unless$text =~ /\S/;$text=reverse$text;$text =~ s/\A\s*/\n/;$text=reverse$text;my@lines=split (/\n/,$text);my$unbroken=0;for (@lines){last if /^\s*$/;$unbroken++}$unbroken=10 if ($unbroken > 12 &&!$$self{MAGIC_VNOPAGEBREAK_LIMIT});$text =~ s/^/\\&/gm;$self->makespace;$self->output (".Vb $unbroken\n$text.Ve\n");$$self{NEEDSPACE}=1;return ''}sub cmd_data {my ($self,$attrs,$text)=@_;$text =~ s/^\n+//;$text =~ s/\n{0,2}$/\n/;$self->output ($text);return ''}sub heading_common {my ($self,$text,$line)=@_;$text =~ s/\s+$//;$text =~ s/\s*\n\s*/ /g;if ($$self{ITEMS}> 1){$$self{ITEMS}=0;$self->output (".PD\n")}$self->output (".\\\" [At source line $line]\n")if defined ($line)&& DEBUG;return$text}sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\\s-?\d//g;$text=$self->heading_common ($text,$$attrs{start_line});my$isname=($text eq 'NAME' || $text =~ /\(NAME\)/);$self->output ($self->switchquotes ('.SH',$self->mapfonts ($text)));$self->outindex ('Header',$text)unless$isname;$$self{NEEDSPACE}=0;$$self{IN_NAME}=$isname;return ''}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text=$self->heading_common ($text,$$attrs{start_line});$self->output ($self->switchquotes ('.SS',$self->mapfonts ($text)));$self->outindex ('Subsection',$text);$$self{NEEDSPACE}=0;return ''}sub cmd_head3 {my ($self,$attrs,$text)=@_;$text=$self->heading_common ($text,$$attrs{start_line});$self->makespace;$self->output ($self->textmapfonts ('\f(IS' .$text .'\f(IE')."\n");$self->outindex ('Subsection',$text);$$self{NEEDSPACE}=1;return ''}sub cmd_head4 {my ($self,$attrs,$text)=@_;$text=$self->heading_common ($text,$$attrs{start_line});$self->makespace;$self->output ($self->textmapfonts ($text)."\n");$self->outindex ('Subsection',$text);$$self{NEEDSPACE}=1;return ''}sub cmd_b {return $_[0]->{IN_NAME}? $_[2]: '\f(BS' .$_[2].'\f(BE'}sub cmd_i {return $_[0]->{IN_NAME}? $_[2]: '\f(IS' .$_[2].'\f(IE'}sub cmd_f {return $_[0]->{IN_NAME}? $_[2]: '\f(IS' .$_[2].'\f(IE'}sub cmd_c {return $_[0]->quote_literal ($_[2])}sub cmd_x {my ($self,$attrs,$text)=@_;push (@{$$self{INDEX}},$text);return ''}sub cmd_l {my ($self,$attrs,$text)=@_;if ($$attrs{type}eq 'url'){my$to=$$attrs{to};if (defined$to){my$tag=$$self{PENDING}[-1];$to=$self->format_text ($$tag[1],$to)}if (not defined ($to)or $to eq $text){return "<$text>"}elsif ($$self{nourls}){return$text}else {return "$text <$$attrs{to}>"}}else {return$text}}sub over_common_start {my ($self,$type,$attrs)=@_;my$line=$$attrs{start_line};my$indent=$$attrs{indent};DEBUG > 3 and print " Starting =over $type (line $line, indent ",($indent || '?'),"\n";unless (defined ($indent)&& $indent =~ /^[-+]?\d{1,4}\s*$/){$indent=$$self{indent}}if (@{$$self{SHIFTS}}< @{$$self{INDENTS}}){$self->output (".RS $$self{INDENT}\n");push (@{$$self{SHIFTS}},$$self{INDENT})}push (@{$$self{INDENTS}},$$self{INDENT});push (@{$$self{ITEMTYPES}},$type);$$self{INDENT}=$indent + 0;$$self{SHIFTWAIT}=1}sub over_common_end {my ($self)=@_;DEBUG > 3 and print " Ending =over\n";$$self{INDENT}=pop @{$$self{INDENTS}};pop @{$$self{ITEMTYPES}};if (@{$$self{SHIFTS}}> @{$$self{INDENTS}}){$self->output (".RE\n");pop @{$$self{SHIFTS}}}if (@{$$self{INDENTS}}> 0){$self->output (".RE\n");$self->output (".RS $$self{INDENT}\n")}$$self{NEEDSPACE}=1;$$self{SHIFTWAIT}=0}sub start_over_bullet {my$s=shift;$s->over_common_start ('bullet',@_)}sub start_over_number {my$s=shift;$s->over_common_start ('number',@_)}sub start_over_text {my$s=shift;$s->over_common_start ('text',@_)}sub start_over_block {my$s=shift;$s->over_common_start ('block',@_)}sub end_over_bullet {$_[0]->over_common_end}sub end_over_number {$_[0]->over_common_end}sub end_over_text {$_[0]->over_common_end}sub end_over_block {$_[0]->over_common_end}sub item_common {my ($self,$type,$attrs,$text)=@_;my$line=$$attrs{start_line};DEBUG > 3 and print "  $type item (line $line): $text\n";$text =~ s/\s+$//;my ($item,$index);if ($type eq 'bullet'){$item="\\\(bu";$text =~ s/\n*$/\n/}elsif ($type eq 'number'){$item=$$attrs{number}.'.'}else {$item=$text;$item =~ s/\s*\n\s*/ /g;$text='';$index=$item if ($item =~ /\w/)}if (@{$$self{SHIFTS}}==@{$$self{INDENTS}}){$self->output (".RE\n");pop @{$$self{SHIFTS}}}$self->output (".PD 0\n")if ($$self{ITEMS}==1);$item=$self->textmapfonts ($item);$self->output ($self->switchquotes ('.IP',$item,$$self{INDENT}));$$self{NEEDSPACE}=0;$$self{ITEMS}++;$$self{SHIFTWAIT}=0;if ($text){$text =~ s/\s*$/\n/;$self->makespace;$self->output ($self->protect ($self->textmapfonts ($text)));$$self{NEEDSPACE}=1}$self->outindex ($index ? ('Item',$index): ())}sub cmd_item_bullet {my$self=shift;$self->item_common ('bullet',@_)}sub cmd_item_number {my$self=shift;$self->item_common ('number',@_)}sub cmd_item_text {my$self=shift;$self->item_common ('text',@_)}sub cmd_item_block {my$self=shift;$self->item_common ('block',@_)}sub parse_from_file {my$self=shift;$self->reinit;if (ref ($_[0])eq 'HASH'){my$opts=shift @_;if (defined ($$opts{-cutting})&&!$$opts{-cutting}){$$self{in_pod}=1;$$self{last_was_blank}=1}}my$retval=$self->SUPER::parse_from_file (@_);my$fh=$self->output_fh ();my$oldfh=select$fh;my$oldflush=$|;$|=1;print$fh '';$|=$oldflush;select$oldfh;return$retval}sub parse_from_filehandle {my$self=shift;return$self->parse_from_file (@_)}sub parse_file {my ($self,$in)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_file ($in)}sub parse_lines {my ($self,@lines)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_lines (@lines)}sub parse_string_document {my ($self,$doc)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_string_document ($doc)}@ESCAPES{0xA0 .. 0xFF}=("\\ ",undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,"\\%",undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,"A\\*`","A\\*'","A\\*^","A\\*~","A\\*:","A\\*o","\\*(Ae","C\\*,","E\\*`","E\\*'","E\\*^","E\\*:","I\\*`","I\\*'","I\\*^","I\\*:","\\*(D-","N\\*~","O\\*`","O\\*'","O\\*^","O\\*~","O\\*:",undef,"O\\*/","U\\*`","U\\*'","U\\*^","U\\*:","Y\\*'","\\*(Th","\\*8","a\\*`","a\\*'","a\\*^","a\\*~","a\\*:","a\\*o","\\*(ae","c\\*,","e\\*`","e\\*'","e\\*^","e\\*:","i\\*`","i\\*'","i\\*^","i\\*:","\\*(d-","n\\*~","o\\*`","o\\*'","o\\*^","o\\*~","o\\*:",undef,"o\\*/","u\\*`","u\\*'","u\\*^","u\\*:","y\\*'","\\*(th","y\\*:",)if ASCII;sub preamble_template {my ($self,$accents)=@_;my$preamble=<<'----END OF PREAMBLE----';if ($accents){$preamble .= <<'----END OF PREAMBLE----'}return$preamble}1;
  .\\" Automatically generated by $version
  .\\"
  .\\" Standard preamble:
  .\\" ========================================================================
  $preamble
  .\\" ========================================================================
  .\\"
  .IX Title "$index"
  .TH $name $section "$date" "$$self{release}" "$$self{center}"
  .\\" For nroff, turn off justification.  Always turn off hyphenation; it makes
  .\\" way too many mistakes in technical documents.
  .if n .ad l
  .nh
  ----END OF HEADER----
  .de Sp \" Vertical space (when we can't use .PP)
  .if t .sp .5v
  .if n .sp
  ..
  .de Vb \" Begin verbatim text
  .ft @CFONT@
  .nf
  .ne \\$1
  ..
  .de Ve \" End verbatim text
  .ft R
  .fi
  ..
  .\" Set up some character translations and predefined strings.  \*(-- will
  .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
  .\" double quote, and \*(R" will give a right double quote.  \*(C+ will
  .\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
  .\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
  .\" nothing in troff, for use with C<>.
  .tr \(*W-
  .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
  .ie n \{\
  .    ds -- \(*W-
  .    ds PI pi
  .    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
  .    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
  .    ds L" ""
  .    ds R" ""
  .    ds C` @LQUOTE@
  .    ds C' @RQUOTE@
  'br\}
  .el\{\
  .    ds -- \|\(em\|
  .    ds PI \(*p
  .    ds L" ``
  .    ds R" ''
  .    ds C`
  .    ds C'
  'br\}
  .\"
  .\" Escape single quotes in literal strings from groff's Unicode transform.
  .ie \n(.g .ds Aq \(aq
  .el       .ds Aq '
  .\"
  .\" If the F register is >0, we'll generate index entries on stderr for
  .\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
  .\" entries marked with X<> in POD.  Of course, you'll have to process the
  .\" output yourself in some meaningful fashion.
  .\"
  .\" Avoid warning from groff about undefined register 'F'.
  .de IX
  ..
  .if !\nF .nr F 0
  .if \nF>0 \{\
  .    de IX
  .    tm Index:\\$1\t\\n%\t"\\$2"
  ..
  .    if !\nF==2 \{\
  .        nr % 0
  .        nr F 2
  .    \}
  .\}
  ----END OF PREAMBLE----
  .\"
  .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
  .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
  .    \" fudge factors for nroff and troff
  .if n \{\
  .    ds #H 0
  .    ds #V .8m
  .    ds #F .3m
  .    ds #[ \f1
  .    ds #] \fP
  .\}
  .if t \{\
  .    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
  .    ds #V .6m
  .    ds #F 0
  .    ds #[ \&
  .    ds #] \&
  .\}
  .    \" simple accents for nroff and troff
  .if n \{\
  .    ds ' \&
  .    ds ` \&
  .    ds ^ \&
  .    ds , \&
  .    ds ~ ~
  .    ds /
  .\}
  .if t \{\
  .    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
  .    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
  .    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
  .    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
  .    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
  .    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
  .\}
  .    \" troff and (daisy-wheel) nroff accents
  .ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
  .ds 8 \h'\*(#H'\(*b\h'-\*(#H'
  .ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
  .ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
  .ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
  .ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
  .ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
  .ds ae a\h'-(\w'a'u*4/10)'e
  .ds Ae A\h'-(\w'A'u*4/10)'E
  .    \" corrections for vroff
  .if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
  .if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
  .    \" for low resolution devices (crt and lpr)
  .if \n(.H>23 .if \n(.V>19 \
  \{\
  .    ds : e
  .    ds 8 ss
  .    ds o a
  .    ds d- d\h'-1'\(ga
  .    ds D- D\h'-1'\(hy
  .    ds th \o'bp'
  .    ds Th \o'LP'
  .    ds ae ae
  .    ds Ae AE
  .\}
  .rm #[ #] #H #V #F C
  ----END OF PREAMBLE----
POD_MAN

$fatpacked{"Pod/ParseLink.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PARSELINK';
  package Pod::ParseLink;use 5.006;use strict;use warnings;use vars qw(@EXPORT @ISA $VERSION);use Exporter;@ISA=qw(Exporter);@EXPORT=qw(parselink);$VERSION='4.09';sub _parse_section {my ($link)=@_;$link =~ s/^\s+//;$link =~ s/\s+$//;return (undef,$1)if ($link =~ /^"\s*(.*?)\s*"$/);my ($page,$section)=split (/\s*\/\s*/,$link,2);$section =~ s/^"\s*(.*?)\s*"$/$1/ if$section;if ($page && $page =~ / / &&!defined ($section)){$section=$page;$page=undef}else {$page=undef unless$page;$section=undef unless$section}return ($page,$section)}sub _infer_text {my ($page,$section)=@_;my$inferred;if ($page &&!$section){$inferred=$page}elsif (!$page && $section){$inferred='"' .$section .'"'}elsif ($page && $section){$inferred='"' .$section .'" in ' .$page}return$inferred}sub parselink {my ($link)=@_;$link =~ s/\s+/ /g;my$text;if ($link =~ /\|/){($text,$link)=split (/\|/,$link,2)}if ($link =~ /\A\w+:[^:\s]\S*\Z/){my$inferred;if (defined ($text)&& length ($text)> 0){return ($text,$text,$link,undef,'url')}else {return ($text,$link,$link,undef,'url')}}else {my ($name,$section)=_parse_section ($link);my$inferred;if (defined ($text)&& length ($text)> 0){$inferred=$text}else {$inferred=_infer_text ($name,$section)}my$type=($name && $name =~ /\(\S*\)/)? 'man' : 'pod';return ($text,$inferred,$name,$section,$type)}}1;
POD_PARSELINK

$fatpacked{"Pod/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE';
  require 5;package Pod::Simple;use strict;use Carp ();BEGIN {*DEBUG=sub () {0}unless defined&DEBUG}use integer;use Pod::Escapes 1.04 ();use Pod::Simple::LinkSection ();use Pod::Simple::BlackBox ();use vars qw($VERSION @ISA @Known_formatting_codes @Known_directives %Known_formatting_codes %Known_directives $NL);@ISA=('Pod::Simple::BlackBox');$VERSION='3.35';@Known_formatting_codes=qw(I B C L E F S X Z);%Known_formatting_codes=map(($_=>1),@Known_formatting_codes);@Known_directives=qw(head1 head2 head3 head4 item over back);%Known_directives=map(($_=>'Plain'),@Known_directives);$NL=$/ unless defined$NL;BEGIN {if(defined&ASCII){}elsif(chr(65)eq 'A'){*ASCII=sub () {1}}else {*ASCII=sub () {''}}unless(defined&MANY_LINES){*MANY_LINES=sub () {20}}DEBUG > 4 and print STDERR "MANY_LINES is ",MANY_LINES(),"\n";unless(MANY_LINES()>= 1){die "MANY_LINES is too small (",MANY_LINES(),")!\nAborting"}if(defined&UNICODE){}elsif($] >= 5.008){*UNICODE=sub() {1}}else {*UNICODE=sub() {''}}}if(DEBUG > 2){print STDERR "# We are ",ASCII ? '' : 'not ',"in ASCII-land\n";print STDERR "# We are under a Unicode-safe Perl.\n"}if ($] ge 5.007_003){$Pod::Simple::nbsp=chr utf8::unicode_to_native(0xA0);$Pod::Simple::shy=chr utf8::unicode_to_native(0xAD)}elsif (Pod::Simple::ASCII){$Pod::Simple::nbsp="\xA0";$Pod::Simple::shy="\xAD"}else {$Pod::Simple::nbsp="\x41";$Pod::Simple::shy="\xCA"}__PACKAGE__->_accessorize('nbsp_for_S','source_filename','source_dead','output_fh','hide_line_numbers','line_count','pod_para_count','no_whining','no_errata_section','complain_stderr','doc_has_started','bare_output','keep_encoding_directive','nix_X_codes','merge_text','preserve_whitespace','strip_verbatim_indent','parse_characters','content_seen','errors_seen','codes_in_verbatim','code_handler','cut_handler','pod_handler','whiteline_handler','parse_empty_lists','raw_mode',);sub any_errata_seen {return shift->{'errors_seen'}|| 0}sub errata_seen {return shift->{'all_errata'}|| {}}sub detected_encoding {return shift->{'detected_encoding'}}sub encoding {my$this=shift;return$this->{'encoding'}unless @_;$this->_handle_encoding_line("=encoding $_[0]");if ($this->{'_processed_encoding'}){delete$this->{'_processed_encoding'};if(!$this->{'encoding_command_statuses'}){DEBUG > 2 and print STDERR " CRAZY ERROR: encoding wasn't really handled?!\n"}elsif($this->{'encoding_command_statuses'}[-1]){$this->scream("=encoding $_[0]",sprintf "Couldn't do %s: %s",$this->{'encoding_command_reqs' }[-1],$this->{'encoding_command_statuses'}[-1],)}else {DEBUG > 2 and print STDERR " (encoding successfully handled.)\n"}return$this->{'encoding'}}else {return undef}}BEGIN {*pretty=\&Pod::Simple::BlackBox::pretty;*stringify_lol=\&Pod::Simple::BlackBox::stringify_lol}sub version_report {my$class=ref($_[0])|| $_[0];if($class eq __PACKAGE__){return "$class $VERSION"}else {my$v=$class->VERSION;return "$class $v (" .__PACKAGE__ ." $VERSION)"}}sub output_string {my$this=shift;return$this->{'output_string'}unless @_;require Pod::Simple::TiedOutFH;my$x=(defined($_[0])and ref($_[0]))? $_[0]: \($_[0]);$$x='' unless defined $$x;DEBUG > 4 and print STDERR "# Output string set to $x ($$x)\n";$this->{'output_fh'}=Pod::Simple::TiedOutFH->handle_on($_[0]);return $this->{'output_string'}=$_[0]}sub abandon_output_string {$_[0]->abandon_output_fh;delete $_[0]{'output_string'}}sub abandon_output_fh {$_[0]->output_fh(undef)}sub new {my$class=ref($_[0])|| $_[0];return bless {'accept_codes'=>{map(($_=>$_),@Known_formatting_codes)},'accept_directives'=>{%Known_directives },'accept_targets'=>{},},$class}sub _handle_element_start {my($self,$element_name,$attr_hash_r)=@_;return}sub _handle_element_end {my($self,$element_name)=@_;return}sub _handle_text {my($self,$text)=@_;return}sub accept_directive_as_verbatim {shift->_accept_directives('Verbatim',@_)}sub accept_directive_as_data {shift->_accept_directives('Data',@_)}sub accept_directive_as_processed {shift->_accept_directives('Plain',@_)}sub _accept_directives {my($this,$type)=splice @_,0,2;for my$d (@_){next unless defined$d and length$d;Carp::croak "\"$d\" isn't a valid directive name" unless$d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;Carp::croak "\"$d\" is already a reserved Pod directive name" if exists$Known_directives{$d};$this->{'accept_directives'}{$d}=$type;DEBUG > 2 and print STDERR "Learning to accept \"=$d\" as directive of type $type\n"}DEBUG > 6 and print STDERR "$this\'s accept_directives : ",pretty($this->{'accept_directives'}),"\n";return sort keys %{$this->{'accept_directives'}}if wantarray;return}sub unaccept_directive {shift->unaccept_directives(@_)};sub unaccept_directives {my$this=shift;for my$d (@_){next unless defined$d and length$d;Carp::croak "\"$d\" isn't a valid directive name" unless$d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;Carp::croak "But you must accept \"$d\" directives -- it's a builtin!" if exists$Known_directives{$d};delete$this->{'accept_directives'}{$d};DEBUG > 2 and print STDERR "OK, won't accept \"=$d\" as directive.\n"}return sort keys %{$this->{'accept_directives'}}if wantarray;return}sub accept_target {shift->accept_targets(@_)}sub accept_target_as_text {shift->accept_targets_as_text(@_)}sub accept_targets {shift->_accept_targets('1',@_)}sub accept_targets_as_text {shift->_accept_targets('force_resolve',@_)}sub _accept_targets {my($this,$type)=splice @_,0,2;for my$t (@_){next unless defined$t and length$t;$this->{'accept_targets'}{$t}=$type;DEBUG > 2 and print STDERR "Learning to accept \"$t\" as target of type $type\n"}return sort keys %{$this->{'accept_targets'}}if wantarray;return}sub unaccept_target {shift->unaccept_targets(@_)}sub unaccept_targets {my$this=shift;for my$t (@_){next unless defined$t and length$t;delete$this->{'accept_targets'}{$t};DEBUG > 2 and print STDERR "OK, won't accept \"$t\" as target.\n"}return sort keys %{$this->{'accept_targets'}}if wantarray;return}my$xml_name_re=eval "qr/[^-.0-8:A-Z_a-z[:^ascii:]]/";if (!defined$xml_name_re){$xml_name_re=qr/[\x00-\x2C\x2F\x39\x3B-\x40\x5B-\x5E\x60\x7B-\x7F]/}sub accept_code {shift->accept_codes(@_)}sub accept_codes {my$this=shift;for my$new_code (@_){next unless defined$new_code and length$new_code;Carp::croak "\"$new_code\" isn't a valid element name" if$new_code =~ $xml_name_re or $new_code =~ m/^[-\.0-9]/s or $new_code =~ m/:[-\.0-9]/s;$this->{'accept_codes'}{$new_code}=$new_code}return}sub unaccept_code {shift->unaccept_codes(@_)}sub unaccept_codes {my$this=shift;for my$new_code (@_){next unless defined$new_code and length$new_code;Carp::croak "\"$new_code\" isn't a valid element name" if$new_code =~ $xml_name_re or $new_code =~ m/^[-\.0-9]/s or $new_code =~ m/:[-\.0-9]/s;Carp::croak "But you must accept \"$new_code\" codes -- it's a builtin!" if grep$new_code eq $_,@Known_formatting_codes;delete$this->{'accept_codes'}{$new_code};DEBUG > 2 and print STDERR "OK, won't accept the code $new_code<...>.\n"}return}sub parse_string_document {my$self=shift;my@lines;for my$line_group (@_){next unless defined$line_group and length$line_group;pos($line_group)=0;while($line_group =~ m/([^\n\r]*)(\r?\n?)/g){$self->parse_lines($1)if length($1)or length($2)or pos($line_group)!=length($line_group)}}$self->parse_lines(undef);return$self}sub _init_fh_source {my($self,$source)=@_;return}sub parse_file {my($self,$source)=(@_);if(!defined$source){Carp::croak("Can't use empty-string as a source for parse_file")}elsif(ref(\$source)eq 'GLOB'){$self->{'source_filename'}='' .($source)}elsif(ref$source){$self->{'source_filename'}='' .($source)}elsif(!length$source){Carp::croak("Can't use empty-string as a source for parse_file")}else {{local*PODSOURCE;open(PODSOURCE,"<$source")|| Carp::croak("Can't open $source: $!");$self->{'source_filename'}=$source;$source=*PODSOURCE{IO}}$self->_init_fh_source($source)}$self->{'source_fh'}=$source;my($i,@lines);until($self->{'source_dead'}){splice@lines;for($i=MANY_LINES;$i--;){local $/=$NL;push@lines,scalar(<$source>);last unless defined$lines[-1]}my$at_eof=!$lines[-1];pop@lines if$at_eof;s/\r\n?/\n/g for@lines;@lines=split(/(?<=\n)/,join('',@lines));push@lines,undef if$at_eof;$self->parse_lines(@lines)}delete($self->{'source_fh'});return$self}sub parse_from_file {my($self,$source,$to)=@_;$self=$self->new unless ref($self);if(!defined$source){$source=*STDIN{IO}}elsif(ref(\$source)eq 'GLOB'){}elsif(ref($source)){}elsif(!length$source or $source eq '-' or $source =~ m/^<&(?:STDIN|0)$/i){$source=*STDIN{IO}}if(!defined$to){$self->output_fh(*STDOUT{IO})}elsif(ref(\$to)eq 'GLOB'){$self->output_fh($to)}elsif(ref($to)){$self->output_fh($to)}elsif(!length$to or $to eq '-' or $to =~ m/^>&?(?:STDOUT|1)$/i){$self->output_fh(*STDOUT{IO})}elsif($to =~ m/^>&(?:STDERR|2)$/i){$self->output_fh(*STDERR{IO})}else {require Symbol;my$out_fh=Symbol::gensym();DEBUG and print STDERR "Write-opening to $to\n";open($out_fh,">$to")or Carp::croak "Can't write-open $to: $!";binmode($out_fh)if$self->can('write_with_binmode')and $self->write_with_binmode;$self->output_fh($out_fh)}return$self->parse_file($source)}sub whine {my$self=shift(@_);++$self->{'errors_seen'};if($self->{'no_whining'}){DEBUG > 9 and print STDERR "Discarding complaint (at line $_[0]) $_[1]\n because no_whining is on.\n";return}push @{$self->{'all_errata'}{$_[0]}},$_[1];return$self->_complain_warn(@_)if$self->{'complain_stderr'};return$self->_complain_errata(@_)}sub scream {my$self=shift(@_);++$self->{'errors_seen'};push @{$self->{'all_errata'}{$_[0]}},$_[1];return$self->_complain_warn(@_)if$self->{'complain_stderr'};return$self->_complain_errata(@_)}sub _complain_warn {my($self,$line,$complaint)=@_;return printf STDERR "%s around line %s: %s\n",$self->{'source_filename'}|| 'Pod input',$line,$complaint}sub _complain_errata {my($self,$line,$complaint)=@_;if($self->{'no_errata_section'}){DEBUG > 9 and print STDERR "Discarding erratum (at line $line) $complaint\n because no_errata_section is on.\n"}else {DEBUG > 9 and print STDERR "Queuing erratum (at line $line) $complaint\n";push @{$self->{'errata'}{$line}},$complaint}return 1}sub _get_initial_item_type {my($self,$para)=@_;return$para->[1]{'~type'}if$para->[1]{'~type'};return$para->[1]{'~type'}='text' if join("\n",@{$para}[2 .. $#$para])=~ m/^\s*(\d+)\.?\s*$/s and $1 ne '1';return$self->_get_item_type($para)}sub _get_item_type {my($self,$para)=@_;return$para->[1]{'~type'}if$para->[1]{'~type'};my$content=join "\n",@{$para}[2 .. $#$para];if($content =~ m/^\s*\*\s*$/s or $content =~ m/^\s*$/s){splice @$para,2;$para->[1]{'~orig_content'}=$content;return$para->[1]{'~type'}='bullet'}elsif($content =~ m/^\s*\*\s+(.+)/s){$para->[1]{'~orig_content'}=$content;$para->[1]{'~_freaky_para_hack'}=$1;DEBUG > 2 and print STDERR " Tolerating $$para[2] as =item *\\n\\n$1\n";splice @$para,2;return$para->[1]{'~type'}='bullet'}elsif($content =~ m/^\s*(\d+)\.?\s*$/s){$para->[1]{'~orig_content'}=$content;$para->[1]{'number'}=$1;splice @$para,2;return$para->[1]{'~type'}='number'}else {return$para->[1]{'~type'}='text'}}sub _make_treelet {my$self=shift;my$treelet;if(!@_){return ['']}if(ref $_[0]and ref $_[0][0]and $_[0][0][0]eq '~Top'){DEBUG and print STDERR "Applying precooked treelet hack to $_[0][0]\n";$treelet=$_[0][0];splice @$treelet,0,2;return$treelet}else {$treelet=$self->_treelet_from_formatting_codes(@_)}if($self->_remap_sequences($treelet)){$self->_treat_Zs($treelet);$self->_treat_Ls($treelet);$self->_treat_Es($treelet);$self->_treat_Ss($treelet);$self->_wrap_up($treelet)}else {DEBUG and print STDERR "Formatless treelet gets fast-tracked.\n"}splice @$treelet,0,2;return$treelet}sub _wrap_up {my($self,@stack)=@_;my$nixx=$self->{'nix_X_codes'};my$merge=$self->{'merge_text' };return unless$nixx or $merge;DEBUG > 2 and print STDERR "\nStarting _wrap_up traversal.\n",$merge ? (" Merge mode on\n"): (),$nixx ? (" Nix-X mode on\n"): (),;my($i,$treelet);while($treelet=shift@stack){DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";for($i=2;$i < @$treelet;++$i){DEBUG > 3 and print STDERR " Considering child at $i ",pretty($treelet->[$i]),"\n";if($nixx and ref$treelet->[$i]and $treelet->[$i][0]eq 'X'){DEBUG > 3 and print STDERR "   Nixing X node at $i\n";splice(@$treelet,$i,1);redo}elsif($merge and $i!=2 and !ref$treelet->[$i]and!ref$treelet->[$i - 1]){DEBUG > 3 and print STDERR "   Merging ",$i-1,":[$treelet->[$i-1]] and $i\:[$treelet->[$i]]\n";$treelet->[$i-1].= (splice(@$treelet,$i,1))[0];DEBUG > 4 and print STDERR "    Now: ",$i-1,":[$treelet->[$i-1]]\n";--$i;next}elsif(ref$treelet->[$i]){DEBUG > 4 and print STDERR "  Enqueuing ",pretty($treelet->[$i])," for traversal.\n";push@stack,$treelet->[$i];if($treelet->[$i][0]eq 'L'){my$thing;for my$attrname ('section','to'){if(defined($thing=$treelet->[$i][1]{$attrname})and ref$thing){unshift@stack,$thing;DEBUG > 4 and print STDERR "  +Enqueuing ",pretty($treelet->[$i][1]{$attrname})," as an attribute value to tweak.\n"}}}}}}DEBUG > 2 and print STDERR "End of _wrap_up traversal.\n\n";return}sub _remap_sequences {my($self,@stack)=@_;if(@stack==1 and @{$stack[0]}==3 and!ref$stack[0][2]){DEBUG and print STDERR "Skipping _remap_sequences: formatless treelet.\n";return 0}my$map=($self->{'accept_codes'}|| die "NO accept_codes in $self?!?");my$start_line=$stack[0][1]{'start_line'};DEBUG > 2 and printf "\nAbout to start _remap_sequences on treelet from line %s.\n",$start_line || '[?]' ;DEBUG > 3 and print STDERR " Map: ",join('; ',map "$_=" .(ref($map->{$_})? join(",",@{$map->{$_}}): $map->{$_}),sort keys %$map),("B~C~E~F~I~L~S~X~Z" eq join '~',sort keys %$map)? "  (all normal)\n" : "\n" ;my($is,$was,$i,$treelet);while($treelet=shift@stack){DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";for($i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];DEBUG > 4 and print STDERR "  Noting child $i : $treelet->[$i][0]<...>\n";$is=$treelet->[$i][0]=$map->{$was=$treelet->[$i][0]};if(DEBUG > 3){if(!defined$is){print STDERR "   Code $was<> is UNKNOWN!\n"}elsif($is eq $was){DEBUG > 4 and print STDERR "   Code $was<> stays the same.\n"}else {print STDERR "   Code $was<> maps to ",ref($is)? ("tags ",map("$_<",@$is),'...',map('>',@$is),"\n"): "tag $is<...>.\n"}}if(!defined$is){$self->whine($start_line,"Deleting unknown formatting code $was<>");$is=$treelet->[$i][0]='1'}if(ref$is){my@dynasty=@$is;DEBUG > 4 and print STDERR "    Renaming $was node to $dynasty[-1]\n";$treelet->[$i][0]=pop@dynasty;my$nugget;while(@dynasty){DEBUG > 4 and printf "    Grafting a new %s node between %s and %s\n",$dynasty[-1],$treelet->[0],$treelet->[$i][0],;splice @$treelet,$i,1,[pop(@dynasty),{},$treelet->[$i]]}}elsif($is eq '0'){splice(@$treelet,$i,1);--$i}elsif($is eq '1'){splice(@$treelet,$i,1 =>splice @{$treelet->[$i]},2);--$i}else {unshift@stack,$treelet->[$i]}}}DEBUG > 2 and print STDERR "End of _remap_sequences traversal.\n\n";if(@_==2 and @{$_[1]}==3 and!ref $_[1][2]){DEBUG and print STDERR "Noting that the treelet is now formatless.\n";return 0}return 1}sub _ponder_extend {my($self,$para)=@_;my$content=join ' ',splice @$para,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;DEBUG > 2 and print STDERR "Ogling extensor: =extend $content\n";if($content =~ m/^
        (\S+)         # 1 : new item
        \s+
        (\S+)         # 2 : fallback(s)
        (?:\s+(\S+))? # 3 : element name(s)
        \s*
        $
      /xs){my$new_letter=$1;my$fallbacks_one=$2;my$elements_one;$elements_one=defined($3)? $3 : $1;DEBUG > 2 and print STDERR "Extensor has good syntax.\n";unless($new_letter =~ m/^[A-Z]$/s or $new_letter){DEBUG > 2 and print STDERR " $new_letter isn't a valid thing to entend.\n";$self->whine($para->[1]{'start_line'},"You can extend only formatting codes A-Z, not like \"$new_letter\"");return}if(grep$new_letter eq $_,@Known_formatting_codes){DEBUG > 2 and print STDERR " $new_letter isn't a good thing to extend, because known.\n";$self->whine($para->[1]{'start_line'},"You can't extend an established code like \"$new_letter\"");return}unless($fallbacks_one =~ m/^[A-Z](,[A-Z])*$/s or $fallbacks_one eq '0' or $fallbacks_one eq '1'){$self->whine($para->[1]{'start_line'},"Format for second =extend parameter must be like" ." M or 1 or 0 or M,N or M,N,O but you have it like " .$fallbacks_one);return}unless($elements_one =~ m/^[^ ,]+(,[^ ,]+)*$/s){$self->whine($para->[1]{'start_line'},"Format for third =extend parameter: like foo or bar,Baz,qu:ux but not like " .$elements_one);return}my@fallbacks=split ',',$fallbacks_one,-1;my@elements=split ',',$elements_one,-1;for my$f (@fallbacks){next if exists$Known_formatting_codes{$f}or $f eq '0' or $f eq '1';DEBUG > 2 and print STDERR "  Can't fall back on unknown code $f\n";$self->whine($para->[1]{'start_line'},"Can't use unknown formatting code '$f' as a fallback for '$new_letter'");return}DEBUG > 3 and printf STDERR "Extensor: Fallbacks <%s> Elements <%s>.\n",@fallbacks,@elements;my$canonical_form;for my$e (@elements){if(exists$self->{'accept_codes'}{$e}){DEBUG > 1 and print STDERR " Mapping '$new_letter' to known extension '$e'\n";$canonical_form=$e;last}else {DEBUG > 1 and print STDERR " Can't map '$new_letter' to unknown extension '$e'\n"}}if(defined$canonical_form){$self->{'accept_codes'}{$new_letter}=$canonical_form;DEBUG > 2 and print "Extensor maps $new_letter => known element $canonical_form.\n"}else {$self->{'accept_codes'}{$new_letter}=(@fallbacks==1)? $fallbacks[0]: \@fallbacks;DEBUG > 2 and print "Extensor maps $new_letter => fallbacks @fallbacks.\n"}}else {DEBUG > 2 and print STDERR "Extensor has bad syntax.\n";$self->whine($para->[1]{'start_line'},"Unknown =extend syntax: $content")}return}sub _treat_Zs {my($self,@stack)=@_;my($i,$treelet);my$start_line=$stack[0][1]{'start_line'};while($treelet=shift@stack){for($i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];unless($treelet->[$i][0]eq 'Z'){unshift@stack,$treelet->[$i];next}DEBUG > 1 and print STDERR "Nixing Z node @{$treelet->[$i]}\n";unless(@{$treelet->[$i]}==2 or (@{$treelet->[$i]}==3 and $treelet->[$i][2]eq '')){$self->whine($start_line,"A non-empty Z<>")}splice(@$treelet,$i,1);--$i}}return}sub _treat_Ls {my($self,@stack)=@_;my($i,$treelet);my$start_line=$stack[0][1]{'start_line'};while($treelet=shift@stack){for(my$i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];unless($treelet->[$i][0]eq 'L'){unshift@stack,$treelet->[$i];next}my$ell=$treelet->[$i];DEBUG > 1 and print STDERR "Ogling L node $ell\n";if(@{$ell}==2 or (@{$ell}==3 and $ell->[2]eq '')){$self->whine($start_line,"An empty L<>");$treelet->[$i]='L<>';next}if((!ref$ell->[2]&& $ell->[2]=~ /\A\s/)||(!ref$ell->[-1]&& $ell->[-1]=~ /\s\z/)){$self->whine($start_line,"L<> starts or ends with whitespace")}if (my ($url_index,$text_part,$url_part)=sub {for (2..$#$ell){next if ref$ell->[$_];next unless$ell->[$_]=~ m/^(?:([^|]*)\|)?(\w+:[^:\s]\S*)$/s;return ($_,$1,$2)}return}->()){$ell->[1]{'type'}='url';my@text=@{$ell}[2..$url_index-1];push@text,$text_part if defined$text_part;my@url=@{$ell}[$url_index+1..$#$ell];unshift@url,$url_part;unless (@text){$ell->[1]{'content-implicit'}='yes';@text=@url}$ell->[1]{to}=Pod::Simple::LinkSection->new(@url==1 ? $url[0]: ['',{},@url ],);splice @$ell,2,$#$ell,@text;next}if(@{$ell}==3 and!ref$ell->[2]){my$it=$ell->[2];if($it =~ m{^[^/|]+[(][-a-zA-Z0-9]+[)]$}s){DEBUG > 1 and print STDERR "Catching \"$it\" as manpage link.\n";$ell->[1]{'type'}='man';$ell->[1]{'content-implicit'}='yes';$ell->[1]{'to' }=Pod::Simple::LinkSection->new($it);next}if($it =~ m/^[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+(\:\:[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+)*$/s){DEBUG > 1 and print STDERR "Catching \"$it\" as ho-hum L<Modulename> link.\n";$ell->[1]{'type'}='pod';$ell->[1]{'content-implicit'}='yes';$ell->[1]{'to' }=Pod::Simple::LinkSection->new($it);next}}DEBUG > 1 and print STDERR "Running a real parse on this non-trivial L\n";my$link_text;my@ell_content=@$ell;splice@ell_content,0,2;DEBUG > 3 and print STDERR " Ell content to start: ",pretty(@ell_content),"\n";DEBUG > 3 and print STDERR "  Peering at L content for a '|' ...\n";for(my$j=0;$j < @ell_content;++$j){next if ref$ell_content[$j];DEBUG > 3 and print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '|'.\n";if($ell_content[$j]=~ m/^([^\|]*)\|(.*)$/s){my@link_text=($1);$ell_content[$j]=$2;DEBUG > 3 and print STDERR "     FOUND a '|' in it.  Splitting into [$1] + [$2]\n";if ($link_text[0]=~ m{[|/]}){$self->whine($start_line,"alternative text '$link_text[0]' contains non-escaped | or /")}unshift@link_text,splice@ell_content,0,$j;@ell_content=grep ref($_)||length($_),@ell_content ;$link_text=[grep ref($_)||length($_),@link_text ];DEBUG > 3 and printf "  So link text is %s\n  and remaining ell content is %s\n",pretty($link_text),pretty(@ell_content);last}}my$section_name;DEBUG > 3 and print STDERR "  Peering at L-content for a '/' ...\n";for(my$j=0;$j < @ell_content;++$j){next if ref$ell_content[$j];DEBUG > 3 and print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '/'.\n";if($ell_content[$j]=~ m/^([^\/]*)\/(.*)$/s){my@section_name=($2);$ell_content[$j]=$1;DEBUG > 3 and print STDERR "     FOUND a '/' in it.","  Splitting to page [...$1] + section [$2...]\n";push@section_name,splice@ell_content,1+$j;@ell_content=grep ref($_)||length($_),@ell_content ;@section_name=grep ref($_)||length($_),@section_name ;if(@section_name and!ref($section_name[0])and!ref($section_name[-1])and $section_name[0]=~ m/^\"/s and $section_name[-1]=~ m/\"$/s and!(@section_name==1 and $section_name[0]eq '"')){$section_name[0]=~ s/^\"//s;$section_name[-1]=~ s/\"$//s;DEBUG > 3 and print STDERR "     Quotes removed: ",pretty(@section_name),"\n"}else {DEBUG > 3 and print STDERR "     No need to remove quotes in ",pretty(@section_name),"\n"}$section_name=\@section_name;last}}if(!$section_name and @ell_content and!ref($ell_content[0])and!ref($ell_content[-1])and $ell_content[0]=~ m/^\"/s and $ell_content[-1]=~ m/\"$/s and!(@ell_content==1 and $ell_content[0]eq '"')){$section_name=[splice@ell_content];$section_name->[0]=~ s/^\"//s;$section_name->[-1]=~ s/\"$//s}if(!$section_name and!$link_text and @ell_content and grep!ref($_)&& m/ /s,@ell_content){$section_name=[splice@ell_content]}unless($link_text){$ell->[1]{'content-implicit'}='yes';$link_text=[];push @$link_text,'"',@$section_name,'"' if$section_name;if(@ell_content){$link_text->[-1].= ' in ' if$section_name;push @$link_text,@ell_content}}if(@ell_content==1 and!ref($ell_content[0])and $ell_content[0]=~ m{^[^/]+[(][-a-zA-Z0-9]+[)]$}s){$ell->[1]{'type'}='man';DEBUG > 3 and print STDERR "Considering this ($ell_content[0]) a man link.\n"}else {$ell->[1]{'type'}='pod';DEBUG > 3 and print STDERR "Considering this a pod link (not man or url).\n"}if(defined$section_name){$ell->[1]{'section'}=Pod::Simple::LinkSection->new(['',{},@$section_name]);DEBUG > 3 and print STDERR "L-section content: ",pretty($ell->[1]{'section'}),"\n"}if(@ell_content){$ell->[1]{'to'}=Pod::Simple::LinkSection->new(['',{},@ell_content]);DEBUG > 3 and print STDERR "L-to content: ",pretty($ell->[1]{'to'}),"\n"}@$ell=(@$ell[0,1],defined($link_text)? splice(@$link_text): '');DEBUG > 2 and print STDERR "End of L-parsing for this node $treelet->[$i]\n";unshift@stack,$treelet->[$i]}}return}sub _treat_Es {my($self,@stack)=@_;my($i,$treelet,$content,$replacer,$charnum);my$start_line=$stack[0][1]{'start_line'};while($treelet=shift@stack){for(my$i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];if($treelet->[$i][0]eq 'L'){my$thing;for my$attrname ('section','to'){if(defined($thing=$treelet->[$i][1]{$attrname})and ref$thing){unshift@stack,$thing;DEBUG > 2 and print STDERR "  Enqueuing ",pretty($treelet->[$i][1]{$attrname})," as an attribute value to tweak.\n"}}unshift@stack,$treelet->[$i];next}elsif($treelet->[$i][0]ne 'E'){unshift@stack,$treelet->[$i];next}DEBUG > 1 and print STDERR "Ogling E node ",pretty($treelet->[$i]),"\n";if(@{$treelet->[$i]}==2 or (@{$treelet->[$i]}==3 and $treelet->[$i][2]eq '')){$self->whine($start_line,"An empty E<>");$treelet->[$i]='E<>';next}unless(@{$treelet->[$i]}==3 and!ref($content=$treelet->[$i][2])){$self->whine($start_line,"An E<...> surrounding strange content");$replacer=$treelet->[$i];splice(@$treelet,$i,1,'E<',splice(@$replacer,2),'>');next}DEBUG > 1 and print STDERR "Ogling E<$content>\n";$charnum=Pod::Escapes::e2charnum($content);DEBUG > 1 and print STDERR " Considering E<$content> with char ",defined($charnum)? $charnum : "undef",".\n";if(!defined($charnum)){DEBUG > 1 and print STDERR "I don't know how to deal with E<$content>.\n";$self->whine($start_line,"Unknown E content in E<$content>");$replacer="E<$content>"}elsif($charnum >= 255 and!UNICODE){$replacer=ASCII ? "\xA4" : "?";DEBUG > 1 and print STDERR "This Perl version can't handle ","E<$content> (chr $charnum), so replacing with $replacer\n"}else {$replacer=Pod::Escapes::e2char($content);DEBUG > 1 and print STDERR " Replacing E<$content> with $replacer\n"}splice(@$treelet,$i,1,$replacer)}}return}sub _treat_Ss {my($self,$treelet)=@_;_change_S_to_nbsp($treelet,0)if$self->{'nbsp_for_S'};return}sub _change_S_to_nbsp {my($treelet,$in_s)=@_;my$is_s=('S' eq $treelet->[0]);$in_s ||= $is_s;for(my$i=2;$i < @$treelet;++$i){if(ref$treelet->[$i]){if(_change_S_to_nbsp($treelet->[$i],$in_s)){my$to_pull_up=$treelet->[$i];splice @$to_pull_up,0,2;splice @$treelet,$i,1,@$to_pull_up;$i += @$to_pull_up - 1}}else {$treelet->[$i]=~ s/\s/$Pod::Simple::nbsp/g if$in_s}}return$is_s}sub _accessorize {no strict 'refs';for my$attrname (@_){next if$attrname =~ m/::/;*{caller().'::' .$attrname}=sub {use strict;$Carp::CarpLevel=1,Carp::croak("Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)")unless (@_==1 or @_==2)and ref $_[0];(@_==1)? $_[0]->{$attrname}: ($_[0]->{$attrname}=$_[1])}}return}sub filter {my($class,$source)=@_;my$new=$class->new;$new->output_fh(*STDOUT{IO});if(ref($source || '')eq 'SCALAR'){$new->parse_string_document($$source)}elsif(ref($source)){$new->parse_file($source)}else {$new->parse_file($source)}return$new}sub _out {my$class=shift(@_);my$mutor=shift(@_)if @_ and ref($_[0]|| '')eq 'CODE';DEBUG and print STDERR "\n\n",'#' x 76,"\nAbout to parse source: {{\n$_[0]\n}}\n\n";my$parser=ref$class && $class->isa(__PACKAGE__)? $class : $class->new;$parser->hide_line_numbers(1);my$out='';$parser->output_string(\$out);DEBUG and print STDERR " _out to ",\$out,"\n";$mutor->($parser)if$mutor;$parser->parse_string_document($_[0]);return$out}sub _duo {my$class=shift(@_);Carp::croak "But $class->_duo is useful only in list context!" unless wantarray;my$mutor=shift(@_)if @_ and ref($_[0]|| '')eq 'CODE';Carp::croak "But $class->_duo takes two parameters, not: @_" unless @_==2;my(@out);while(@_){my$parser=$class->new;push@out,'';$parser->output_string(\($out[-1]));DEBUG and print STDERR " _duo out to ",$parser->output_string()," = $parser->{'output_string'}\n";$parser->hide_line_numbers(1);$mutor->($parser)if$mutor;$parser->parse_string_document(shift(@_))}return@out}1;
POD_SIMPLE

$fatpacked{"Pod/Simple/BlackBox.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_BLACKBOX';
  package Pod::Simple::BlackBox;
  #
  # "What's in the box?"  "Pain."
  #
  ###########################################################################
  #
  # This is where all the scary things happen: parsing lines into
  #  paragraphs; and then into directives, verbatims, and then also
  #  turning formatting sequences into treelets.
  #
  # Are you really sure you want to read this code?
  #
  #-----------------------------------------------------------------------------
  #
  # The basic work of this module Pod::Simple::BlackBox is doing the dirty work
  # of parsing Pod into treelets (generally one per non-verbatim paragraph), and
  # to call the proper callbacks on the treelets.
  #
  # Every node in a treelet is a ['name', {attrhash}, ...children...]
  
  use integer; # vroom!
  use strict;
  use Carp ();
  use vars qw($VERSION );
  $VERSION = '3.35';
  #use constant DEBUG => 7;
  BEGIN {
    require Pod::Simple;
    *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG
  }
  
  # Matches a character iff the character will have a different meaning
  # if we choose CP1252 vs UTF-8 if there is no =encoding line.
  # This is broken for early Perls on non-ASCII platforms.
  my $non_ascii_re = eval "qr/[[:^ascii:]]/";
  $non_ascii_re = qr/[\x80-\xFF]/ if ! defined $non_ascii_re;
  
  my $utf8_bom;
  if (($] ge 5.007_003)) {
    $utf8_bom = "\x{FEFF}";
    utf8::encode($utf8_bom);
  } else {
    $utf8_bom = "\xEF\xBB\xBF";   # No EBCDIC BOM detection for early Perls.
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub parse_line { shift->parse_lines(@_) } # alias
  
  # - - -  Turn back now!  Run away!  - - -
  
  sub parse_lines {             # Usage: $parser->parse_lines(@lines)
    # an undef means end-of-stream
    my $self = shift;
  
    my $code_handler = $self->{'code_handler'};
    my $cut_handler  = $self->{'cut_handler'};
    my $wl_handler   = $self->{'whiteline_handler'};
    $self->{'line_count'} ||= 0;
   
    my $scratch;
  
    DEBUG > 4 and 
     print STDERR "# Parsing starting at line ", $self->{'line_count'}, ".\n";
  
    DEBUG > 5 and
     print STDERR "#  About to parse lines: ",
       join(' ', map defined($_) ? "[$_]" : "EOF", @_), "\n";
  
    my $paras = ($self->{'paras'} ||= []);
     # paragraph buffer.  Because we need to defer processing of =over
     # directives and verbatim paragraphs.  We call _ponder_paragraph_buffer
     # to process this.
    
    $self->{'pod_para_count'} ||= 0;
  
    my $line;
    foreach my $source_line (@_) {
      if( $self->{'source_dead'} ) {
        DEBUG > 4 and print STDERR "# Source is dead.\n";
        last;
      }
  
      unless( defined $source_line ) {
        DEBUG > 4 and print STDERR "# Undef-line seen.\n";
  
        push @$paras, ['~end', {'start_line' => $self->{'line_count'}}];
        push @$paras, $paras->[-1], $paras->[-1];
         # So that it definitely fills the buffer.
        $self->{'source_dead'} = 1;
        $self->_ponder_paragraph_buffer;
        next;
      }
  
  
      if( $self->{'line_count'}++ ) {
        ($line = $source_line) =~ tr/\n\r//d;
         # If we don't have two vars, we'll end up with that there
         # tr/// modding the (potentially read-only) original source line!
      
      } else {
        DEBUG > 2 and print STDERR "First line: [$source_line]\n";
  
        if( ($line = $source_line) =~ s/^$utf8_bom//s ) {
          DEBUG and print STDERR "UTF-8 BOM seen.  Faking a '=encoding utf8'.\n";
          $self->_handle_encoding_line( "=encoding utf8" );
          delete $self->{'_processed_encoding'};
          $line =~ tr/\n\r//d;
          
        } elsif( $line =~ s/^\xFE\xFF//s ) {
          DEBUG and print STDERR "Big-endian UTF-16 BOM seen.  Aborting parsing.\n";
          $self->scream(
            $self->{'line_count'},
            "UTF16-BE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet."
          );
          splice @_;
          push @_, undef;
          next;
  
          # TODO: implement somehow?
  
        } elsif( $line =~ s/^\xFF\xFE//s ) {
          DEBUG and print STDERR "Little-endian UTF-16 BOM seen.  Aborting parsing.\n";
          $self->scream(
            $self->{'line_count'},
            "UTF16-LE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet."
          );
          splice @_;
          push @_, undef;
          next;
  
          # TODO: implement somehow?
          
        } else {
          DEBUG > 2 and print STDERR "First line is BOM-less.\n";
          ($line = $source_line) =~ tr/\n\r//d;
        }
      }
  
      if(!$self->{'parse_characters'} && !$self->{'encoding'}
        && ($self->{'in_pod'} || $line =~ /^=/s)
        && $line =~ /$non_ascii_re/
      ) {
  
        my $encoding;
  
        # No =encoding line, and we are at the first line in the input that
        # contains a non-ascii byte, that is one whose meaning varies depending
        # on whether the file is encoded in UTF-8 or CP1252, which are the two
        # possibilities permitted by the pod spec.  (ASCII is assumed if the
        # file only contains ASCII bytes.)  In order to process this line, we
        # need to figure out what encoding we will use for the file.
        #
        # Strictly speaking ISO 8859-1 (Latin 1) refers to the code points
        # 160-255, but it is used here, as it often colloquially is, to refer to
        # the complete set of code points 0-255, including ASCII (0-127), the C1
        # controls (128-159), and strict Latin 1 (160-255).
        #
        # CP1252 is effectively a superset of Latin 1, because it differs only
        # from colloquial 8859-1 in the C1 controls, which are very unlikely to
        # actually be present in 8859-1 files, so can be used for other purposes
        # without conflict.  CP 1252 uses most of them for graphic characters.
        #
        # Note that all ASCII-range bytes represent their corresponding code
        # points in CP1252 and UTF-8.  In ASCII platform UTF-8 all other code
        # points require multiple (non-ASCII) bytes to represent.  (A separate
        # paragraph for EBCDIC is below.)  The multi-byte representation is
        # quite structured.  If we find an isolated byte that requires multiple
        # bytes to represent in UTF-8, we know that the encoding is not UTF-8.
        # If we find a sequence of bytes that violates the UTF-8 structure, we
        # also can presume the encoding isn't UTF-8, and hence must be 1252.
        #
        # But there are ambiguous cases where we could guess wrong.  If so, the
        # user will end up having to supply an =encoding line.  We use all
        # readily available information to improve our chances of guessing
        # right.  The odds of something not being UTF-8, but still passing a
        # UTF-8 validity test go down very rapidly with increasing length of the
        # sequence.  Therefore we look at all the maximal length non-ascii
        # sequences on the line.  If any of the sequences can't be UTF-8, we
        # quit there and choose CP1252.  If all could be UTF-8, we guess UTF-8.
        #
        # On EBCDIC platforms, the situation is somewhat different.  In
        # UTF-EBCDIC, not only do ASCII-range bytes represent their code points,
        # but so do the bytes that are for the C1 controls.  Recall that these
        # correspond to the unused portion of 8859-1 that 1252 mostly takes
        # over.  That means that there are fewer code points that are
        # represented by multi-bytes.  But, note that the these controls are
        # very unlikely to be in pod text.  So if we encounter one of them, it
        # means that it is quite likely CP1252 and not UTF-8.  The net result is
        # the same code below is used for both platforms.
        while ($line =~ m/($non_ascii_re+)/g) {
          my $non_ascii_seq = $1;
  
          if (length $non_ascii_seq == 1) {
            $encoding = 'CP1252';
            goto guessed;
          } elsif ($] ge 5.007_003) {
  
            # On Perls that have this function, we can see if the sequence is
            # valid UTF-8 or not.
            my $is_utf8;
            {
              no warnings 'utf8';
              $is_utf8 = utf8::decode($non_ascii_seq);
            }
            if (! $is_utf8) {
              $encoding = 'CP1252';
              goto guessed;
            }
          } elsif (ord("A") == 65) {  # An early Perl, ASCII platform
  
            # Without utf8::decode, it's a lot harder to do a rigorous check
            # (though some early releases had a different function that
            # accomplished the same thing).  Since these are ancient Perls, not
            # likely to be in use today, we take the easy way out, and look at
            # just the first two bytes of the sequence to see if they are the
            # start of a UTF-8 character.  In ASCII UTF-8, continuation bytes
            # must be between 0x80 and 0xBF.  Start bytes can range from 0xC2
            # through 0xFF, but anything above 0xF4 is not Unicode, and hence
            # extremely unlikely to be in a pod.
            if ($non_ascii_seq !~ /^[\xC2-\xF4][\x80-\xBF]/) {
              $encoding = 'CP1252';
              goto guessed;
            }
  
            # We don't bother doing anything special for EBCDIC on early Perls.
            # If there is a solitary variant, CP1252 will be chosen; otherwise
            # UTF-8.
          }
        } # End of loop through all variant sequences on the line
  
        # All sequences in the line could be UTF-8.  Guess that.
        $encoding = 'UTF-8';
  
      guessed:
        $self->_handle_encoding_line( "=encoding $encoding" );
        delete $self->{'_processed_encoding'};
        $self->{'_transcoder'} && $self->{'_transcoder'}->($line);
  
        my ($word) = $line =~ /(\S*$non_ascii_re\S*)/;
  
        $self->whine(
          $self->{'line_count'},
          "Non-ASCII character seen before =encoding in '$word'. Assuming $encoding"
        );
      }
  
      DEBUG > 5 and print STDERR "# Parsing line: [$line]\n";
  
      if(!$self->{'in_pod'}) {
        if($line =~ m/^=([a-zA-Z][a-zA-Z0-9]*)(?:\s|$)/s) {
          if($1 eq 'cut') {
            $self->scream(
              $self->{'line_count'},
              "=cut found outside a pod block.  Skipping to next block."
            );
            
            ## Before there were errata sections in the world, it was
            ## least-pessimal to abort processing the file.  But now we can
            ## just barrel on thru (but still not start a pod block).
            #splice @_;
            #push @_, undef;
            
            next;
          } else {
            $self->{'in_pod'} = $self->{'start_of_pod_block'}
                              = $self->{'last_was_blank'}     = 1;
            # And fall thru to the pod-mode block further down
          }
        } else {
          DEBUG > 5 and print STDERR "# It's a code-line.\n";
          $code_handler->(map $_, $line, $self->{'line_count'}, $self)
           if $code_handler;
          # Note: this may cause code to be processed out of order relative
          #  to pods, but in order relative to cuts.
          
          # Note also that we haven't yet applied the transcoding to $line
          #  by time we call $code_handler!
  
          if( $line =~ m/^#\s*line\s+(\d+)\s*(?:\s"([^"]+)")?\s*$/ ) {
            # That RE is from perlsyn, section "Plain Old Comments (Not!)",
            #$fname = $2 if defined $2;
            #DEBUG > 1 and defined $2 and print STDERR "# Setting fname to \"$fname\"\n";
            DEBUG > 1 and print STDERR "# Setting nextline to $1\n";
            $self->{'line_count'} = $1 - 1;
          }
          
          next;
        }
      }
      
      # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
      # Else we're in pod mode:
  
      # Apply any necessary transcoding:
      $self->{'_transcoder'} && $self->{'_transcoder'}->($line);
  
      # HERE WE CATCH =encoding EARLY!
      if( $line =~ m/^=encoding\s+\S+\s*$/s ) {
        next if $self->parse_characters;   # Ignore this line
        $line = $self->_handle_encoding_line( $line );
      }
  
      if($line =~ m/^=cut/s) {
        # here ends the pod block, and therefore the previous pod para
        DEBUG > 1 and print STDERR "Noting =cut at line ${$self}{'line_count'}\n";
        $self->{'in_pod'} = 0;
        # ++$self->{'pod_para_count'};
        $self->_ponder_paragraph_buffer();
         # by now it's safe to consider the previous paragraph as done.
        $cut_handler->(map $_, $line, $self->{'line_count'}, $self)
         if $cut_handler;
  
        # TODO: add to docs: Note: this may cause cuts to be processed out
        #  of order relative to pods, but in order relative to code.
        
      } elsif($line =~ m/^(\s*)$/s) {  # it's a blank line
        if (defined $1 and $1 =~ /[^\S\r\n]/) { # it's a white line
          $wl_handler->(map $_, $line, $self->{'line_count'}, $self)
            if $wl_handler;
        }
  
        if(!$self->{'start_of_pod_block'} and @$paras and $paras->[-1][0] eq '~Verbatim') {
          DEBUG > 1 and print STDERR "Saving blank line at line ${$self}{'line_count'}\n";
          push @{$paras->[-1]}, $line;
        }  # otherwise it's not interesting
        
        if(!$self->{'start_of_pod_block'} and !$self->{'last_was_blank'}) {
          DEBUG > 1 and print STDERR "Noting para ends with blank line at ${$self}{'line_count'}\n";
        }
        
        $self->{'last_was_blank'} = 1;
        
      } elsif($self->{'last_was_blank'}) {  # A non-blank line starting a new para...
        
        if($line =~ m/^(=[a-zA-Z][a-zA-Z0-9]*)(?:\s+|$)(.*)/s) {
          # THIS IS THE ONE PLACE WHERE WE CONSTRUCT NEW DIRECTIVE OBJECTS
          my $new = [$1, {'start_line' => $self->{'line_count'}}, $2];
           # Note that in "=head1 foo", the WS is lost.
           # Example: ['=head1', {'start_line' => 123}, ' foo']
          
          ++$self->{'pod_para_count'};
          
          $self->_ponder_paragraph_buffer();
           # by now it's safe to consider the previous paragraph as done.
                  
          push @$paras, $new; # the new incipient paragraph
          DEBUG > 1 and print STDERR "Starting new ${$paras}[-1][0] para at line ${$self}{'line_count'}\n";
          
        } elsif($line =~ m/^\s/s) {
  
          if(!$self->{'start_of_pod_block'} and @$paras and $paras->[-1][0] eq '~Verbatim') {
            DEBUG > 1 and print STDERR "Resuming verbatim para at line ${$self}{'line_count'}\n";
            push @{$paras->[-1]}, $line;
          } else {
            ++$self->{'pod_para_count'};
            $self->_ponder_paragraph_buffer();
             # by now it's safe to consider the previous paragraph as done.
            DEBUG > 1 and print STDERR "Starting verbatim para at line ${$self}{'line_count'}\n";
            push @$paras, ['~Verbatim', {'start_line' => $self->{'line_count'}}, $line];
          }
        } else {
          ++$self->{'pod_para_count'};
          $self->_ponder_paragraph_buffer();
           # by now it's safe to consider the previous paragraph as done.
          push @$paras, ['~Para',  {'start_line' => $self->{'line_count'}}, $line];
          DEBUG > 1 and print STDERR "Starting plain para at line ${$self}{'line_count'}\n";
        }
        $self->{'last_was_blank'} = $self->{'start_of_pod_block'} = 0;
  
      } else {
        # It's a non-blank line /continuing/ the current para
        if(@$paras) {
          DEBUG > 2 and print STDERR "Line ${$self}{'line_count'} continues current paragraph\n";
          push @{$paras->[-1]}, $line;
        } else {
          # Unexpected case!
          die "Continuing a paragraph but \@\$paras is empty?";
        }
        $self->{'last_was_blank'} = $self->{'start_of_pod_block'} = 0;
      }
      
    } # ends the big while loop
  
    DEBUG > 1 and print STDERR (pretty(@$paras), "\n");
    return $self;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_encoding_line {
    my($self, $line) = @_;
    
    return if $self->parse_characters;
  
    # The point of this routine is to set $self->{'_transcoder'} as indicated.
  
    return $line unless $line =~ m/^=encoding\s+(\S+)\s*$/s;
    DEBUG > 1 and print STDERR "Found an encoding line \"=encoding $1\"\n";
  
    my $e    = $1;
    my $orig = $e;
    push @{ $self->{'encoding_command_reqs'} }, "=encoding $orig";
  
    my $enc_error;
  
    # Cf.   perldoc Encode   and   perldoc Encode::Supported
  
    require Pod::Simple::Transcode;
  
    if( $self->{'encoding'} ) {
      my $norm_current = $self->{'encoding'};
      my $norm_e = $e;
      foreach my $that ($norm_current, $norm_e) {
        $that =  lc($that);
        $that =~ s/[-_]//g;
      }
      if($norm_current eq $norm_e) {
        DEBUG > 1 and print STDERR "The '=encoding $orig' line is ",
         "redundant.  ($norm_current eq $norm_e).  Ignoring.\n";
        $enc_error = '';
         # But that doesn't necessarily mean that the earlier one went okay
      } else {
        $enc_error = "Encoding is already set to " . $self->{'encoding'};
        DEBUG > 1 and print STDERR $enc_error;
      }
    } elsif (
      # OK, let's turn on the encoding
      do {
        DEBUG > 1 and print STDERR " Setting encoding to $e\n";
        $self->{'encoding'} = $e;
        1;
      }
      and $e eq 'HACKRAW'
    ) {
      DEBUG and print STDERR " Putting in HACKRAW (no-op) encoding mode.\n";
  
    } elsif( Pod::Simple::Transcode::->encoding_is_available($e) ) {
  
      die($enc_error = "WHAT? _transcoder is already set?!")
       if $self->{'_transcoder'};   # should never happen
      require Pod::Simple::Transcode;
      $self->{'_transcoder'} = Pod::Simple::Transcode::->make_transcoder($e);
      eval {
        my @x = ('', "abc", "123");
        $self->{'_transcoder'}->(@x);
      };
      $@ && die( $enc_error =
        "Really unexpected error setting up encoding $e: $@\nAborting"
      );
      $self->{'detected_encoding'} = $e;
  
    } else {
      my @supported = Pod::Simple::Transcode::->all_encodings;
  
      # Note unsupported, and complain
      DEBUG and print STDERR " Encoding [$e] is unsupported.",
        "\nSupporteds: @supported\n";
      my $suggestion = '';
  
      # Look for a near match:
      my $norm = lc($e);
      $norm =~ tr[-_][]d;
      my $n;
      foreach my $enc (@supported) {
        $n = lc($enc);
        $n =~ tr[-_][]d;
        next unless $n eq $norm;
        $suggestion = "  (Maybe \"$e\" should be \"$enc\"?)";
        last;
      }
      my $encmodver = Pod::Simple::Transcode::->encmodver;
      $enc_error = join '' =>
        "This document probably does not appear as it should, because its ",
        "\"=encoding $e\" line calls for an unsupported encoding.",
        $suggestion, "  [$encmodver\'s supported encodings are: @supported]"
      ;
  
      $self->scream( $self->{'line_count'}, $enc_error );
    }
    push @{ $self->{'encoding_command_statuses'} }, $enc_error;
    if (defined($self->{'_processed_encoding'})) {
      # Double declaration.
      $self->scream( $self->{'line_count'}, 'Cannot have multiple =encoding directives');
    }
    $self->{'_processed_encoding'} = $orig;
  
    return $line;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _handle_encoding_second_level {
    # By time this is called, the encoding (if well formed) will already
    #  have been acted one.
    my($self, $para) = @_;
    my @x = @$para;
    my $content = join ' ', splice @x, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
  
    DEBUG > 2 and print STDERR "Ogling encoding directive: =encoding $content\n";
    
    if (defined($self->{'_processed_encoding'})) {
      #if($content ne $self->{'_processed_encoding'}) {
      #  Could it happen?
      #}
      delete $self->{'_processed_encoding'};
      # It's already been handled.  Check for errors.
      if(! $self->{'encoding_command_statuses'} ) {
        DEBUG > 2 and print STDERR " CRAZY ERROR: It wasn't really handled?!\n";
      } elsif( $self->{'encoding_command_statuses'}[-1] ) {
        $self->whine( $para->[1]{'start_line'},
          sprintf "Couldn't do %s: %s",
            $self->{'encoding_command_reqs'  }[-1],
            $self->{'encoding_command_statuses'}[-1],
        );
      } else {
        DEBUG > 2 and print STDERR " (Yup, it was successfully handled already.)\n";
      }
      
    } else {
      # Otherwise it's a syntax error
      $self->whine( $para->[1]{'start_line'},
        "Invalid =encoding syntax: $content"
      );
    }
    
    return;
  }
  
  #~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`
  
  {
  my $m = -321;   # magic line number
  
  sub _gen_errata {
    my $self = $_[0];
    # Return 0 or more fake-o paragraphs explaining the accumulated
    #  errors on this document.
  
    return() unless $self->{'errata'} and keys %{$self->{'errata'}};
  
    my @out;
    
    foreach my $line (sort {$a <=> $b} keys %{$self->{'errata'}}) {
      push @out,
        ['=item', {'start_line' => $m}, "Around line $line:"],
        map( ['~Para', {'start_line' => $m, '~cooked' => 1},
          #['~Top', {'start_line' => $m},
          $_
          #]
          ],
          @{$self->{'errata'}{$line}}
        )
      ;
    }
    
    # TODO: report of unknown entities? unrenderable characters?
  
    unshift @out,
      ['=head1', {'start_line' => $m, 'errata' => 1}, 'POD ERRORS'],
      ['~Para', {'start_line' => $m, '~cooked' => 1, 'errata' => 1},
       "Hey! ",
       ['B', {},
        'The above document had some coding errors, which are explained below:'
       ]
      ],
      ['=over',  {'start_line' => $m, 'errata' => 1}, ''],
    ;
  
    push @out, 
      ['=back',  {'start_line' => $m, 'errata' => 1}, ''],
    ;
  
    DEBUG and print STDERR "\n<<\n", pretty(\@out), "\n>>\n\n";
  
    return @out;
  }
  
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  ##############################################################################
  ##
  ##  stop reading now stop reading now stop reading now stop reading now stop
  ##
  ##                         HERE IT BECOMES REALLY SCARY
  ##
  ##  stop reading now stop reading now stop reading now stop reading now stop
  ##
  ##############################################################################
  
  sub _ponder_paragraph_buffer {
  
    # Para-token types as found in the buffer.
    #   ~Verbatim, ~Para, ~end, =head1..4, =for, =begin, =end,
    #   =over, =back, =item
    #   and the null =pod (to be complained about if over one line)
    #
    # "~data" paragraphs are something we generate at this level, depending on
    # a currently open =over region
  
    # Events fired:  Begin and end for:
    #                   directivename (like head1 .. head4), item, extend,
    #                   for (from =begin...=end, =for),
    #                   over-bullet, over-number, over-text, over-block,
    #                   item-bullet, item-number, item-text,
    #                   Document,
    #                   Data, Para, Verbatim
    #                   B, C, longdirname (TODO -- wha?), etc. for all directives
    # 
  
    my $self = $_[0];
    my $paras;
    return unless @{$paras = $self->{'paras'}};
    my $curr_open = ($self->{'curr_open'} ||= []);
  
    my $scratch;
  
    DEBUG > 10 and print STDERR "# Paragraph buffer: <<", pretty($paras), ">>\n";
  
    # We have something in our buffer.  So apparently the document has started.
    unless($self->{'doc_has_started'}) {
      $self->{'doc_has_started'} = 1;
      
      my $starting_contentless;
      $starting_contentless =
       (
         !@$curr_open  
         and @$paras and ! grep $_->[0] ne '~end', @$paras
          # i.e., if the paras is all ~ends
       )
      ;
      DEBUG and print STDERR "# Starting ",
        $starting_contentless ? 'contentless' : 'contentful',
        " document\n"
      ;
      
      $self->_handle_element_start(
        ($scratch = 'Document'),
        {
          'start_line' => $paras->[0][1]{'start_line'},
          $starting_contentless ? ( 'contentless' => 1 ) : (),
        },
      );
    }
  
    my($para, $para_type);
    while(@$paras) {
      last if @$paras == 1 and
        ( $paras->[0][0] eq '=over' or $paras->[0][0] eq '~Verbatim'
          or $paras->[0][0] eq '=item' )
      ;
      # Those're the three kinds of paragraphs that require lookahead.
      #   Actually, an "=item Foo" inside an <over type=text> region
      #   and any =item inside an <over type=block> region (rare)
      #   don't require any lookahead, but all others (bullets
      #   and numbers) do.
  
  # TODO: whinge about many kinds of directives in non-resolving =for regions?
  # TODO: many?  like what?  =head1 etc?
  
      $para = shift @$paras;
      $para_type = $para->[0];
  
      DEBUG > 1 and print STDERR "Pondering a $para_type paragraph, given the stack: (",
        $self->_dump_curr_open(), ")\n";
      
      if($para_type eq '=for') {
        next if $self->_ponder_for($para,$curr_open,$paras);
  
      } elsif($para_type eq '=begin') {
        next if $self->_ponder_begin($para,$curr_open,$paras);
  
      } elsif($para_type eq '=end') {
        next if $self->_ponder_end($para,$curr_open,$paras);
  
      } elsif($para_type eq '~end') { # The virtual end-document signal
        next if $self->_ponder_doc_end($para,$curr_open,$paras);
      }
  
  
      # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      #~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      if(grep $_->[1]{'~ignore'}, @$curr_open) {
        DEBUG > 1 and
         print STDERR "Skipping $para_type paragraph because in ignore mode.\n";
        next;
      }
      #~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  
      if($para_type eq '=pod') {
        $self->_ponder_pod($para,$curr_open,$paras);
  
      } elsif($para_type eq '=over') {
        next if $self->_ponder_over($para,$curr_open,$paras);
  
      } elsif($para_type eq '=back') {
        next if $self->_ponder_back($para,$curr_open,$paras);
  
      } else {
  
        # All non-magical codes!!!
        
        # Here we start using $para_type for our own twisted purposes, to
        #  mean how it should get treated, not as what the element name
        #  should be.
  
        DEBUG > 1 and print STDERR "Pondering non-magical $para_type\n";
  
        my $i;
  
        # Enforce some =headN discipline
        if($para_type =~ m/^=head\d$/s
           and ! $self->{'accept_heads_anywhere'}
           and @$curr_open
           and $curr_open->[-1][0] eq '=over'
        ) {
          DEBUG > 2 and print STDERR "'=$para_type' inside an '=over'!\n";
          $self->whine(
            $para->[1]{'start_line'},
            "You forgot a '=back' before '$para_type'"
          );
          unshift @$paras, ['=back', {}, ''], $para;   # close the =over
          next;
        }
  
  
        if($para_type eq '=item') {
  
          my $over;
          unless(@$curr_open and
                 $over = (grep { $_->[0] eq '=over' } @$curr_open)[-1]) {
            $self->whine(
              $para->[1]{'start_line'},
              "'=item' outside of any '=over'"
            );
            unshift @$paras,
              ['=over', {'start_line' => $para->[1]{'start_line'}}, ''],
              $para
            ;
            next;
          }
          
          
          my $over_type = $over->[1]{'~type'};
          
          if(!$over_type) {
            # Shouldn't happen1
            die "Typeless over in stack, starting at line "
             . $over->[1]{'start_line'};
  
          } elsif($over_type eq 'block') {
            unless($curr_open->[-1][1]{'~bitched_about'}) {
              $curr_open->[-1][1]{'~bitched_about'} = 1;
              $self->whine(
                $curr_open->[-1][1]{'start_line'},
                "You can't have =items (as at line "
                . $para->[1]{'start_line'}
                . ") unless the first thing after the =over is an =item"
              );
            }
            # Just turn it into a paragraph and reconsider it
            $para->[0] = '~Para';
            unshift @$paras, $para;
            next;
  
          } elsif($over_type eq 'text') {
            my $item_type = $self->_get_item_type($para);
              # That kills the content of the item if it's a number or bullet.
            DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
            
            if($item_type eq 'text') {
              # Nothing special needs doing for 'text'
            } elsif($item_type eq 'number' or $item_type eq 'bullet') {
              $self->whine(
                $para->[1]{'start_line'},
                "Expected text after =item, not a $item_type"
              );
              # Undo our clobbering:
              push @$para, $para->[1]{'~orig_content'};
              delete $para->[1]{'number'};
               # Only a PROPER item-number element is allowed
               #  to have a number attribute.
            } else {
              die "Unhandled item type $item_type"; # should never happen
            }
            
            # =item-text thingies don't need any assimilation, it seems.
  
          } elsif($over_type eq 'number') {
            my $item_type = $self->_get_item_type($para);
              # That kills the content of the item if it's a number or bullet.
            DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
            
            my $expected_value = ++ $curr_open->[-1][1]{'~counter'};
            
            if($item_type eq 'bullet') {
              # Hm, it's not numeric.  Correct for this.
              $para->[1]{'number'} = $expected_value;
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item $expected_value'"
              );
              push @$para, $para->[1]{'~orig_content'};
                # restore the bullet, blocking the assimilation of next para
  
            } elsif($item_type eq 'text') {
              # Hm, it's not numeric.  Correct for this.
              $para->[1]{'number'} = $expected_value;
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item $expected_value'"
              );
              # Text content will still be there and will block next ~Para
  
            } elsif($item_type ne 'number') {
              die "Unknown item type $item_type"; # should never happen
  
            } elsif($expected_value == $para->[1]{'number'}) {
              DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n";
              
            } else {
              DEBUG > 1 and print STDERR " Numeric item has ", $para->[1]{'number'},
               " instead of the expected value of $expected_value\n";
              $self->whine(
                $para->[1]{'start_line'},
                "You have '=item " . $para->[1]{'number'} .
                "' instead of the expected '=item $expected_value'"
              );
              $para->[1]{'number'} = $expected_value;  # correcting!!
            }
              
            if(@$para == 2) {
              # For the cases where we /didn't/ push to @$para
              if($paras->[0][0] eq '~Para') {
                DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
                push @$para, splice @{shift @$paras},2;
              } else {
                DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
                push @$para, '';  # Just so it's not contentless
              }
            }
  
  
          } elsif($over_type eq 'bullet') {
            my $item_type = $self->_get_item_type($para);
              # That kills the content of the item if it's a number or bullet.
            DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
            
            if($item_type eq 'bullet') {
              # as expected!
  
              if( $para->[1]{'~_freaky_para_hack'} ) {
                DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";
                push @$para, delete $para->[1]{'~_freaky_para_hack'};
              }
  
            } elsif($item_type eq 'number') {
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item *'"
              );
              push @$para, $para->[1]{'~orig_content'};
               # and block assimilation of the next paragraph
              delete $para->[1]{'number'};
               # Only a PROPER item-number element is allowed
               #  to have a number attribute.
            } elsif($item_type eq 'text') {
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item *'"
              );
               # But doesn't need processing.  But it'll block assimilation
               #  of the next para.
            } else {
              die "Unhandled item type $item_type"; # should never happen
            }
  
            if(@$para == 2) {
              # For the cases where we /didn't/ push to @$para
              if($paras->[0][0] eq '~Para') {
                DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
                push @$para, splice @{shift @$paras},2;
              } else {
                DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
                push @$para, '';  # Just so it's not contentless
              }
            }
  
          } else {
            die "Unhandled =over type \"$over_type\"?";
            # Shouldn't happen!
          }
  
          $para_type = 'Plain';
          $para->[0] .= '-' . $over_type;
          # Whew.  Now fall thru and process it.
  
  
        } elsif($para_type eq '=extend') {
          # Well, might as well implement it here.
          $self->_ponder_extend($para);
          next;  # and skip
        } elsif($para_type eq '=encoding') {
          # Not actually acted on here, but we catch errors here.
          $self->_handle_encoding_second_level($para);
          next unless $self->keep_encoding_directive;
          $para_type = 'Plain';
        } elsif($para_type eq '~Verbatim') {
          $para->[0] = 'Verbatim';
          $para_type = '?Verbatim';
        } elsif($para_type eq '~Para') {
          $para->[0] = 'Para';
          $para_type = '?Plain';
        } elsif($para_type eq 'Data') {
          $para->[0] = 'Data';
          $para_type = '?Data';
        } elsif( $para_type =~ s/^=//s
          and defined( $para_type = $self->{'accept_directives'}{$para_type} )
        ) {
          DEBUG > 1 and print STDERR " Pondering known directive ${$para}[0] as $para_type\n";
        } else {
          # An unknown directive!
          DEBUG > 1 and printf STDERR "Unhandled directive %s (Handled: %s)\n",
           $para->[0], join(' ', sort keys %{$self->{'accept_directives'}} )
          ;
          $self->whine(
            $para->[1]{'start_line'},
            "Unknown directive: $para->[0]"
          );
  
          # And maybe treat it as text instead of just letting it go?
          next;
        }
  
        if($para_type =~ s/^\?//s) {
          if(! @$curr_open) {  # usual case
            DEBUG and print STDERR "Treating $para_type paragraph as such because stack is empty.\n";
          } else {
            my @fors = grep $_->[0] eq '=for', @$curr_open;
            DEBUG > 1 and print STDERR "Containing fors: ",
              join(',', map $_->[1]{'target'}, @fors), "\n";
            
            if(! @fors) {
              DEBUG and print STDERR "Treating $para_type paragraph as such because stack has no =for's\n";
              
            #} elsif(grep $_->[1]{'~resolve'}, @fors) {
            #} elsif(not grep !$_->[1]{'~resolve'}, @fors) {
            } elsif( $fors[-1][1]{'~resolve'} ) {
              # Look to the immediately containing for
            
              if($para_type eq 'Data') {
                DEBUG and print STDERR "Treating Data paragraph as Plain/Verbatim because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";
                $para->[0] = 'Para';
                $para_type = 'Plain';
              } else {
                DEBUG and print STDERR "Treating $para_type paragraph as such because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";
              }
            } else {
              DEBUG and print STDERR "Treating $para_type paragraph as Data because the containing =for ($fors[-1][1]{'target'}) is a non-resolver\n";
              $para->[0] = $para_type = 'Data';
            }
          }
        }
  
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if($para_type eq 'Plain') {
          $self->_ponder_Plain($para);
        } elsif($para_type eq 'Verbatim') {
          $self->_ponder_Verbatim($para);        
        } elsif($para_type eq 'Data') {
          $self->_ponder_Data($para);
        } else {
          die "\$para type is $para_type -- how did that happen?";
          # Shouldn't happen.
        }
  
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        $para->[0] =~ s/^[~=]//s;
  
        DEBUG and print STDERR "\n", pretty($para), "\n";
  
        # traverse the treelet (which might well be just one string scalar)
        $self->{'content_seen'} ||= 1;
        $self->_traverse_treelet_bit(@$para);
      }
    }
    
    return;
  }
  
  ###########################################################################
  # The sub-ponderers...
  
  
  
  sub _ponder_for {
    my ($self,$para,$curr_open,$paras) = @_;
  
    # Fake it out as a begin/end
    my $target;
  
    if(grep $_->[1]{'~ignore'}, @$curr_open) {
      DEBUG > 1 and print STDERR "Ignoring ignorable =for\n";
      return 1;
    }
  
    for(my $i = 2; $i < @$para; ++$i) {
      if($para->[$i] =~ s/^\s*(\S+)\s*//s) {
        $target = $1;
        last;
      }
    }
    unless(defined $target) {
      $self->whine(
        $para->[1]{'start_line'},
        "=for without a target?"
      );
      return 1;
    }
    DEBUG > 1 and
     print STDERR "Faking out a =for $target as a =begin $target / =end $target\n";
    
    $para->[0] = 'Data';
    
    unshift @$paras,
      ['=begin',
        {'start_line' => $para->[1]{'start_line'}, '~really' => '=for'},
        $target,
      ],
      $para,
      ['=end',
        {'start_line' => $para->[1]{'start_line'}, '~really' => '=for'},
        $target,
      ],
    ;
    
    return 1;
  }
  
  sub _ponder_begin {
    my ($self,$para,$curr_open,$paras) = @_;
    my $content = join ' ', splice @$para, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
    unless(length($content)) {
      $self->whine(
        $para->[1]{'start_line'},
        "=begin without a target?"
      );
      DEBUG and print STDERR "Ignoring targetless =begin\n";
      return 1;
    }
    
    my ($target, $title) = $content =~ m/^(\S+)\s*(.*)$/;
    $para->[1]{'title'} = $title if ($title);
    $para->[1]{'target'} = $target;  # without any ':'
    $content = $target; # strip off the title
    
    $content =~ s/^:!/!:/s;
    my $neg;  # whether this is a negation-match
    $neg = 1        if $content =~ s/^!//s;
    my $to_resolve;  # whether to process formatting codes
    $to_resolve = 1 if $content =~ s/^://s;
    
    my $dont_ignore; # whether this target matches us
    
    foreach my $target_name (
      split(',', $content, -1),
      $neg ? () : '*'
    ) {
      DEBUG > 2 and
       print STDERR " Considering whether =begin $content matches $target_name\n";
      next unless $self->{'accept_targets'}{$target_name};
      
      DEBUG > 2 and
       print STDERR "  It DOES match the acceptable target $target_name!\n";
      $to_resolve = 1
        if $self->{'accept_targets'}{$target_name} eq 'force_resolve';
      $dont_ignore = 1;
      $para->[1]{'target_matching'} = $target_name;
      last; # stop looking at other target names
    }
  
    if($neg) {
      if( $dont_ignore ) {
        $dont_ignore = '';
        delete $para->[1]{'target_matching'};
        DEBUG > 2 and print STDERR " But the leading ! means that this is a NON-match!\n";
      } else {
        $dont_ignore = 1;
        $para->[1]{'target_matching'} = '!';
        DEBUG > 2 and print STDERR " But the leading ! means that this IS a match!\n";
      }
    }
  
    $para->[0] = '=for';  # Just what we happen to call these, internally
    $para->[1]{'~really'} ||= '=begin';
    $para->[1]{'~ignore'}   = (! $dont_ignore) || 0;
    $para->[1]{'~resolve'}  = $to_resolve || 0;
  
    DEBUG > 1 and print STDERR " Making note to ", $dont_ignore ? 'not ' : '',
      "ignore contents of this region\n";
    DEBUG > 1 and $dont_ignore and print STDERR " Making note to treat contents as ",
      ($to_resolve ? 'verbatim/plain' : 'data'), " paragraphs\n";
    DEBUG > 1 and print STDERR " (Stack now: ", $self->_dump_curr_open(), ")\n";
  
    push @$curr_open, $para;
    if(!$dont_ignore or scalar grep $_->[1]{'~ignore'}, @$curr_open) {
      DEBUG > 1 and print STDERR "Ignoring ignorable =begin\n";
    } else {
      $self->{'content_seen'} ||= 1;
      $self->_handle_element_start((my $scratch='for'), $para->[1]);
    }
  
    return 1;
  }
  
  sub _ponder_end {
    my ($self,$para,$curr_open,$paras) = @_;
    my $content = join ' ', splice @$para, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
    DEBUG and print STDERR "Ogling '=end $content' directive\n";
  
    unless(length($content)) {
      $self->whine(
        $para->[1]{'start_line'},
        "'=end' without a target?" . (
          ( @$curr_open and $curr_open->[-1][0] eq '=for' )
          ? ( " (Should be \"=end " . $curr_open->[-1][1]{'target'} . '")' )
          : ''
        )
      );
      DEBUG and print STDERR "Ignoring targetless =end\n";
      return 1;
    }
    
    unless($content =~ m/^\S+$/) {  # i.e., unless it's one word
      $self->whine(
        $para->[1]{'start_line'},
        "'=end $content' is invalid.  (Stack: "
        . $self->_dump_curr_open() . ')'
      );
      DEBUG and print STDERR "Ignoring mistargetted =end $content\n";
      return 1;
    }
    
    unless(@$curr_open and $curr_open->[-1][0] eq '=for') {
      $self->whine(
        $para->[1]{'start_line'},
        "=end $content without matching =begin.  (Stack: "
        . $self->_dump_curr_open() . ')'
      );
      DEBUG and print STDERR "Ignoring mistargetted =end $content\n";
      return 1;
    }
    
    unless($content eq $curr_open->[-1][1]{'target'}) {
      $self->whine(
        $para->[1]{'start_line'},
        "=end $content doesn't match =begin " 
        . $curr_open->[-1][1]{'target'}
        . ".  (Stack: "
        . $self->_dump_curr_open() . ')'
      );
      DEBUG and print STDERR "Ignoring mistargetted =end $content at line $para->[1]{'start_line'}\n";
      return 1;
    }
  
    # Else it's okay to close...
    if(grep $_->[1]{'~ignore'}, @$curr_open) {
      DEBUG > 1 and print STDERR "Not firing any event for this =end $content because in an ignored region\n";
      # And that may be because of this to-be-closed =for region, or some
      #  other one, but it doesn't matter.
    } else {
      $curr_open->[-1][1]{'start_line'} = $para->[1]{'start_line'};
        # what's that for?
      
      $self->{'content_seen'} ||= 1;
      $self->_handle_element_end( my $scratch = 'for', $para->[1]);
    }
    DEBUG > 1 and print STDERR "Popping $curr_open->[-1][0] $curr_open->[-1][1]{'target'} because of =end $content\n";
    pop @$curr_open;
  
    return 1;
  } 
  
  sub _ponder_doc_end {
    my ($self,$para,$curr_open,$paras) = @_;
    if(@$curr_open) { # Deal with things left open
      DEBUG and print STDERR "Stack is nonempty at end-document: (",
        $self->_dump_curr_open(), ")\n";
        
      DEBUG > 9 and print STDERR "Stack: ", pretty($curr_open), "\n";
      unshift @$paras, $self->_closers_for_all_curr_open;
      # Make sure there is exactly one ~end in the parastack, at the end:
      @$paras = grep $_->[0] ne '~end', @$paras;
      push @$paras, $para, $para;
       # We need two -- once for the next cycle where we
       #  generate errata, and then another to be at the end
       #  when that loop back around to process the errata.
      return 1;
      
    } else {
      DEBUG and print STDERR "Okay, stack is empty now.\n";
    }
    
    # Try generating errata section, if applicable
    unless($self->{'~tried_gen_errata'}) {
      $self->{'~tried_gen_errata'} = 1;
      my @extras = $self->_gen_errata();
      if(@extras) {
        unshift @$paras, @extras;
        DEBUG and print STDERR "Generated errata... relooping...\n";
        return 1;  # I.e., loop around again to process these fake-o paragraphs
      }
    }
    
    splice @$paras; # Well, that's that for this paragraph buffer.
    DEBUG and print STDERR "Throwing end-document event.\n";
  
    $self->_handle_element_end( my $scratch = 'Document' );
    return 1; # Hasta la byebye
  }
  
  sub _ponder_pod {
    my ($self,$para,$curr_open,$paras) = @_;
    $self->whine(
      $para->[1]{'start_line'},
      "=pod directives shouldn't be over one line long!  Ignoring all "
       . (@$para - 2) . " lines of content"
    ) if @$para > 3;
  
    # Content ignored unless 'pod_handler' is set
    if (my $pod_handler = $self->{'pod_handler'}) {
        my ($line_num, $line) = map $_, $para->[1]{'start_line'}, $para->[2];
        $line = $line eq '' ? "=pod" : "=pod $line"; # imitate cut_handler output
        $pod_handler->($line, $line_num, $self);
    }
  
    # The surrounding methods set content_seen, so let us remain consistent.
    # I do not know why it was not here before -- should it not be here?
    # $self->{'content_seen'} ||= 1;
  
    return;
  }
  
  sub _ponder_over {
    my ($self,$para,$curr_open,$paras) = @_;
    return 1 unless @$paras;
    my $list_type;
  
    if($paras->[0][0] eq '=item') { # most common case
      $list_type = $self->_get_initial_item_type($paras->[0]);
  
    } elsif($paras->[0][0] eq '=back') {
      # Ignore empty lists by default
      if ($self->{'parse_empty_lists'}) {
        $list_type = 'empty';
      } else {
        shift @$paras;
        return 1;
      }
    } elsif($paras->[0][0] eq '~end') {
      $self->whine(
        $para->[1]{'start_line'},
        "=over is the last thing in the document?!"
      );
      return 1; # But feh, ignore it.
    } else {
      $list_type = 'block';
    }
    $para->[1]{'~type'} = $list_type;
    push @$curr_open, $para;
     # yes, we reuse the paragraph as a stack item
    
    my $content = join ' ', splice @$para, 2;
    my $overness;
    if($content =~ m/^\s*$/s) {
      $para->[1]{'indent'} = 4;
    } elsif($content =~ m/^\s*((?:\d*\.)?\d+)\s*$/s) {
      no integer;
      $para->[1]{'indent'} = $1;
      if($1 == 0) {
        $self->whine(
          $para->[1]{'start_line'},
          "Can't have a 0 in =over $content"
        );
        $para->[1]{'indent'} = 4;
      }
    } else {
      $self->whine(
        $para->[1]{'start_line'},
        "=over should be: '=over' or '=over positive_number'"
      );
      $para->[1]{'indent'} = 4;
    }
    DEBUG > 1 and print STDERR "=over found of type $list_type\n";
    
    $self->{'content_seen'} ||= 1;
    $self->_handle_element_start((my $scratch = 'over-' . $list_type), $para->[1]);
  
    return;
  }
        
  sub _ponder_back {
    my ($self,$para,$curr_open,$paras) = @_;
    # TODO: fire off </item-number> or </item-bullet> or </item-text> ??
  
    my $content = join ' ', splice @$para, 2;
    if($content =~ m/\S/) {
      $self->whine(
        $para->[1]{'start_line'},
        "=back doesn't take any parameters, but you said =back $content"
      );
    }
  
    if(@$curr_open and $curr_open->[-1][0] eq '=over') {
      DEBUG > 1 and print STDERR "=back happily closes matching =over\n";
      # Expected case: we're closing the most recently opened thing
      #my $over = pop @$curr_open;
      $self->{'content_seen'} ||= 1;
      $self->_handle_element_end( my $scratch =
        'over-' . ( (pop @$curr_open)->[1]{'~type'} ), $para->[1]
      );
    } else {
      DEBUG > 1 and print STDERR "=back found without a matching =over.  Stack: (",
          join(', ', map $_->[0], @$curr_open), ").\n";
      $self->whine(
        $para->[1]{'start_line'},
        '=back without =over'
      );
      return 1; # and ignore it
    }
  }
  
  sub _ponder_item {
    my ($self,$para,$curr_open,$paras) = @_;
    my $over;
    unless(@$curr_open and
           $over = (grep { $_->[0] eq '=over' } @$curr_open)[-1]) {
      $self->whine(
        $para->[1]{'start_line'},
        "'=item' outside of any '=over'"
      );
      unshift @$paras,
        ['=over', {'start_line' => $para->[1]{'start_line'}}, ''],
        $para
      ;
      return 1;
    }
    
    
    my $over_type = $over->[1]{'~type'};
    
    if(!$over_type) {
      # Shouldn't happen1
      die "Typeless over in stack, starting at line "
       . $over->[1]{'start_line'};
  
    } elsif($over_type eq 'block') {
      unless($curr_open->[-1][1]{'~bitched_about'}) {
        $curr_open->[-1][1]{'~bitched_about'} = 1;
        $self->whine(
          $curr_open->[-1][1]{'start_line'},
          "You can't have =items (as at line "
          . $para->[1]{'start_line'}
          . ") unless the first thing after the =over is an =item"
        );
      }
      # Just turn it into a paragraph and reconsider it
      $para->[0] = '~Para';
      unshift @$paras, $para;
      return 1;
  
    } elsif($over_type eq 'text') {
      my $item_type = $self->_get_item_type($para);
        # That kills the content of the item if it's a number or bullet.
      DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
      
      if($item_type eq 'text') {
        # Nothing special needs doing for 'text'
      } elsif($item_type eq 'number' or $item_type eq 'bullet') {
        $self->whine(
            $para->[1]{'start_line'},
            "Expected text after =item, not a $item_type"
        );
        # Undo our clobbering:
        push @$para, $para->[1]{'~orig_content'};
        delete $para->[1]{'number'};
         # Only a PROPER item-number element is allowed
         #  to have a number attribute.
      } else {
        die "Unhandled item type $item_type"; # should never happen
      }
      
      # =item-text thingies don't need any assimilation, it seems.
  
    } elsif($over_type eq 'number') {
      my $item_type = $self->_get_item_type($para);
        # That kills the content of the item if it's a number or bullet.
      DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
      
      my $expected_value = ++ $curr_open->[-1][1]{'~counter'};
      
      if($item_type eq 'bullet') {
        # Hm, it's not numeric.  Correct for this.
        $para->[1]{'number'} = $expected_value;
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item $expected_value'"
        );
        push @$para, $para->[1]{'~orig_content'};
          # restore the bullet, blocking the assimilation of next para
  
      } elsif($item_type eq 'text') {
        # Hm, it's not numeric.  Correct for this.
        $para->[1]{'number'} = $expected_value;
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item $expected_value'"
        );
        # Text content will still be there and will block next ~Para
  
      } elsif($item_type ne 'number') {
        die "Unknown item type $item_type"; # should never happen
  
      } elsif($expected_value == $para->[1]{'number'}) {
        DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n";
        
      } else {
        DEBUG > 1 and print STDERR " Numeric item has ", $para->[1]{'number'},
         " instead of the expected value of $expected_value\n";
        $self->whine(
          $para->[1]{'start_line'},
          "You have '=item " . $para->[1]{'number'} .
          "' instead of the expected '=item $expected_value'"
        );
        $para->[1]{'number'} = $expected_value;  # correcting!!
      }
        
      if(@$para == 2) {
        # For the cases where we /didn't/ push to @$para
        if($paras->[0][0] eq '~Para') {
          DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
          push @$para, splice @{shift @$paras},2;
        } else {
          DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
          push @$para, '';  # Just so it's not contentless
        }
      }
  
  
    } elsif($over_type eq 'bullet') {
      my $item_type = $self->_get_item_type($para);
        # That kills the content of the item if it's a number or bullet.
      DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
      
      if($item_type eq 'bullet') {
        # as expected!
  
        if( $para->[1]{'~_freaky_para_hack'} ) {
          DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";
          push @$para, delete $para->[1]{'~_freaky_para_hack'};
        }
  
      } elsif($item_type eq 'number') {
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item *'"
        );
        push @$para, $para->[1]{'~orig_content'};
         # and block assimilation of the next paragraph
        delete $para->[1]{'number'};
         # Only a PROPER item-number element is allowed
         #  to have a number attribute.
      } elsif($item_type eq 'text') {
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item *'"
        );
         # But doesn't need processing.  But it'll block assimilation
         #  of the next para.
      } else {
        die "Unhandled item type $item_type"; # should never happen
      }
  
      if(@$para == 2) {
        # For the cases where we /didn't/ push to @$para
        if($paras->[0][0] eq '~Para') {
          DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
          push @$para, splice @{shift @$paras},2;
        } else {
          DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
          push @$para, '';  # Just so it's not contentless
        }
      }
  
    } else {
      die "Unhandled =over type \"$over_type\"?";
      # Shouldn't happen!
    }
    $para->[0] .= '-' . $over_type;
  
    return;
  }
  
  sub _ponder_Plain {
    my ($self,$para) = @_;
    DEBUG and print STDERR " giving plain treatment...\n";
    unless( @$para == 2 or ( @$para == 3 and $para->[2] eq '' )
      or $para->[1]{'~cooked'}
    ) {
      push @$para,
      @{$self->_make_treelet(
        join("\n", splice(@$para, 2)),
        $para->[1]{'start_line'}
      )};
    }
    # Empty paragraphs don't need a treelet for any reason I can see.
    # And precooked paragraphs already have a treelet.
    return;
  }
  
  sub _ponder_Verbatim {
    my ($self,$para) = @_;
    DEBUG and print STDERR " giving verbatim treatment...\n";
  
    $para->[1]{'xml:space'} = 'preserve';
  
    my $indent = $self->strip_verbatim_indent;
    if ($indent && ref $indent eq 'CODE') {
        my @shifted = (shift @{$para}, shift @{$para});
        $indent = $indent->($para);
        unshift @{$para}, @shifted;
    }
  
    for(my $i = 2; $i < @$para; $i++) {
      foreach my $line ($para->[$i]) { # just for aliasing
        # Strip indentation.
        $line =~ s/^\Q$indent// if $indent
            && !($self->{accept_codes} && $self->{accept_codes}{VerbatimFormatted});
        while( $line =~
          # Sort of adapted from Text::Tabs -- yes, it's hardwired in that
          # tabs are at every EIGHTH column.  For portability, it has to be
          # one setting everywhere, and 8th wins.
          s/^([^\t]*)(\t+)/$1.(" " x ((length($2)<<3)-(length($1)&7)))/e
        ) {}
  
        # TODO: whinge about (or otherwise treat) unindented or overlong lines
  
      }
    }
    
    # Now the VerbatimFormatted hoodoo...
    if( $self->{'accept_codes'} and
        $self->{'accept_codes'}{'VerbatimFormatted'}
    ) {
      while(@$para > 3 and $para->[-1] !~ m/\S/) { pop @$para }
       # Kill any number of terminal newlines
      $self->_verbatim_format($para);
    } elsif ($self->{'codes_in_verbatim'}) {
      push @$para,
      @{$self->_make_treelet(
        join("\n", splice(@$para, 2)),
        $para->[1]{'start_line'}, $para->[1]{'xml:space'}
      )};
      $para->[-1] =~ s/\n+$//s; # Kill any number of terminal newlines
    } else {
      push @$para, join "\n", splice(@$para, 2) if @$para > 3;
      $para->[-1] =~ s/\n+$//s; # Kill any number of terminal newlines
    }
    return;
  }
  
  sub _ponder_Data {
    my ($self,$para) = @_;
    DEBUG and print STDERR " giving data treatment...\n";
    $para->[1]{'xml:space'} = 'preserve';
    push @$para, join "\n", splice(@$para, 2) if @$para > 3;
    return;
  }
  
  
  
  
  ###########################################################################
  
  sub _traverse_treelet_bit {  # for use only by the routine above
    my($self, $name) = splice @_,0,2;
  
    my $scratch;
    $self->_handle_element_start(($scratch=$name), shift @_);
    
    while (@_) {
      my $x = shift;
      if (ref($x)) {
        &_traverse_treelet_bit($self, @$x);
      } else {
        $x .= shift while @_ && !ref($_[0]);
        $self->_handle_text($x);
      }
    }
    
    $self->_handle_element_end($scratch=$name);
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _closers_for_all_curr_open {
    my $self = $_[0];
    my @closers;
    foreach my $still_open (@{  $self->{'curr_open'} || return  }) {
      my @copy = @$still_open;
      $copy[1] = {%{ $copy[1] }};
      #$copy[1]{'start_line'} = -1;
      if($copy[0] eq '=for') {
        $copy[0] = '=end';
      } elsif($copy[0] eq '=over') {
        $self->whine(
          $still_open->[1]{start_line} ,
          "=over without closing =back"
        );
  
        $copy[0] = '=back';
      } else {
        die "I don't know how to auto-close an open $copy[0] region";
      }
  
      unless( @copy > 2 ) {
        push @copy, $copy[1]{'target'};
        $copy[-1] = '' unless defined $copy[-1];
         # since =over's don't have targets
      }
  
      $copy[1]{'fake-closer'} = 1;
  
      DEBUG and print STDERR "Queuing up fake-o event: ", pretty(\@copy), "\n";
      unshift @closers, \@copy;
    }
    return @closers;
  }
  
  #--------------------------------------------------------------------------
  
  sub _verbatim_format {
    my($it, $p) = @_;
    
    my $formatting;
  
    for(my $i = 2; $i < @$p; $i++) { # work backwards over the lines
      DEBUG and print STDERR "_verbatim_format appends a newline to $i: $p->[$i]\n";
      $p->[$i] .= "\n";
       # Unlike with simple Verbatim blocks, we don't end up just doing
       # a join("\n", ...) on the contents, so we have to append a
       # newline to ever line, and then nix the last one later.
    }
  
    if( DEBUG > 4 ) {
      print STDERR "<<\n";
      for(my $i = $#$p; $i >= 2; $i--) { # work backwards over the lines
        print STDERR "_verbatim_format $i: $p->[$i]";
      }
      print STDERR ">>\n";
    }
  
    for(my $i = $#$p; $i > 2; $i--) {
      # work backwards over the lines, except the first (#2)
      
      #next unless $p->[$i]   =~ m{^#:([ \^\/\%]*)\n?$}s
      #        and $p->[$i-1] !~ m{^#:[ \^\/\%]*\n?$}s;
       # look at a formatty line preceding a nonformatty one
      DEBUG > 5 and print STDERR "Scrutinizing line $i: $$p[$i]\n";
      if($p->[$i]   =~ m{^#:([ \^\/\%]*)\n?$}s) {
        DEBUG > 5 and print STDERR "  It's a formatty line.  ",
         "Peeking at previous line ", $i-1, ": $$p[$i-1]: \n";
        
        if( $p->[$i-1] =~ m{^#:[ \^\/\%]*\n?$}s ) {
          DEBUG > 5 and print STDERR "  Previous line is formatty!  Skipping this one.\n";
          next;
        } else {
          DEBUG > 5 and print STDERR "  Previous line is non-formatty!  Yay!\n";
        }
      } else {
        DEBUG > 5 and print STDERR "  It's not a formatty line.  Ignoring\n";
        next;
      }
  
      # A formatty line has to have #: in the first two columns, and uses
      # "^" to mean bold, "/" to mean underline, and "%" to mean bold italic.
      # Example:
      #   What do you want?  i like pie. [or whatever]
      # #:^^^^^^^^^^^^^^^^^              /////////////         
      
  
      DEBUG > 4 and print STDERR "_verbatim_format considers:\n<$p->[$i-1]>\n<$p->[$i]>\n";
      
      $formatting = '  ' . $1;
      $formatting =~ s/\s+$//s; # nix trailing whitespace
      unless(length $formatting and $p->[$i-1] =~ m/\S/) { # no-op
        splice @$p,$i,1; # remove this line
        $i--; # don't consider next line
        next;
      }
  
      if( length($formatting) >= length($p->[$i-1]) ) {
        $formatting = substr($formatting, 0, length($p->[$i-1]) - 1) . ' ';
      } else {
        $formatting .= ' ' x (length($p->[$i-1]) - length($formatting));
      }
      # Make $formatting and the previous line be exactly the same length,
      # with $formatting having a " " as the last character.
   
      DEBUG > 4 and print STDERR "Formatting <$formatting>    on <", $p->[$i-1], ">\n";
  
  
      my @new_line;
      while( $formatting =~ m{\G(( +)|(\^+)|(\/+)|(\%+))}g ) {
        #print STDERR "Format matches $1\n";
  
        if($2) {
          #print STDERR "SKIPPING <$2>\n";
          push @new_line,
            substr($p->[$i-1], pos($formatting)-length($1), length($1));
        } else {
          #print STDERR "SNARING $+\n";
          push @new_line, [
            (
              $3 ? 'VerbatimB'  :
              $4 ? 'VerbatimI'  :
              $5 ? 'VerbatimBI' : die("Should never get called")
            ), {},
            substr($p->[$i-1], pos($formatting)-length($1), length($1))
          ];
          #print STDERR "Formatting <$new_line[-1][-1]> as $new_line[-1][0]\n";
        }
      }
      my @nixed =    
        splice @$p, $i-1, 2, @new_line; # replace myself and the next line
      DEBUG > 10 and print STDERR "Nixed count: ", scalar(@nixed), "\n";
      
      DEBUG > 6 and print STDERR "New version of the above line is these tokens (",
        scalar(@new_line), "):",
        map( ref($_)?"<@$_> ":"<$_>", @new_line ), "\n";
      $i--; # So the next line we scrutinize is the line before the one
            #  that we just went and formatted
    }
  
    $p->[0] = 'VerbatimFormatted';
  
    # Collapse adjacent text nodes, just for kicks.
    for( my $i = 2; $i > $#$p; $i++ ) { # work forwards over the tokens except for the last
      if( !ref($p->[$i]) and !ref($p->[$i + 1]) ) {
        DEBUG > 5 and print STDERR "_verbatim_format merges {$p->[$i]} and {$p->[$i+1]}\n";
        $p->[$i] .= splice @$p, $i+1, 1; # merge
        --$i;  # and back up
      }
    }
  
    # Now look for the last text token, and remove the terminal newline
    for( my $i = $#$p; $i >= 2; $i-- ) {
      # work backwards over the tokens, even the first
      if( !ref($p->[$i]) ) {
        if($p->[$i] =~ s/\n$//s) {
          DEBUG > 5 and print STDERR "_verbatim_format killed the terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]}\n";
        } else {
          DEBUG > 5 and print STDERR
           "No terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]} !?\n";
        }
        last; # we only want the next one
      }
    }
  
    return;
  }
  
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  
  sub _treelet_from_formatting_codes {
    # Given a paragraph, returns a treelet.  Full of scary tokenizing code.
    #  Like [ '~Top', {'start_line' => $start_line},
    #            "I like ",
    #            [ 'B', {}, "pie" ],
    #            "!"
    #       ]
    
    my($self, $para, $start_line, $preserve_space) = @_;
    
    my $treelet = ['~Top', {'start_line' => $start_line},];
    
    unless ($preserve_space || $self->{'preserve_whitespace'}) {
      $para =~ s/\s+/ /g; # collapse and trim all whitespace first.
      $para =~ s/ $//;
      $para =~ s/^ //;
    }
    
    # Only apparent problem the above code is that N<<  >> turns into
    # N<< >>.  But then, word wrapping does that too!  So don't do that!
    
    my @stack;
    my @lineage = ($treelet);
    my $raw = ''; # raw content of L<> fcode before splitting/processing
      # XXX 'raw' is not 100% accurate: all surrounding whitespace is condensed
      # into just 1 ' '. Is this the regex's doing or 'raw's?
    my $inL = 0;
  
    DEBUG > 4 and print STDERR "Paragraph:\n$para\n\n";
   
    # Here begins our frightening tokenizer RE.  The following regex matches
    # text in four main parts:
    #
    #  * Start-codes.  The first alternative matches C< or C<<, the latter
    #    followed by some whitespace.  $1 will hold the entire start code
    #    (including any space following a multiple-angle-bracket delimiter),
    #    and $2 will hold only the additional brackets past the first in a
    #    multiple-bracket delimiter.  length($2) + 1 will be the number of
    #    closing brackets we have to find.
    #
    #  * Closing brackets.  Match some amount of whitespace followed by
    #    multiple close brackets.  The logic to see if this closes anything
    #    is down below.  Note that in order to parse C<<  >> correctly, we
    #    have to use look-behind (?<=\s\s), since the match of the starting
    #    code will have consumed the whitespace.
    #
    #  * A single closing bracket, to close a simple code like C<>.
    #
    #  * Something that isn't a start or end code.  We have to be careful
    #    about accepting whitespace, since perlpodspec says that any whitespace
    #    before a multiple-bracket closing delimiter should be ignored.
    #
    while($para =~
      m/\G
        (?:
          # Match starting codes, including the whitespace following a
          # multiple-delimiter start code.  $1 gets the whole start code and
          # $2 gets all but one of the <s in the multiple-bracket case.
          ([A-Z]<(?:(<+)\s+)?)
          |
          # Match multiple-bracket end codes.  $3 gets the whitespace that
          # should be discarded before an end bracket but kept in other cases
          # and $4 gets the end brackets themselves.
          (\s+|(?<=\s\s))(>{2,})
          |
          (\s?>)          # $5: simple end-codes
          |
          (               # $6: stuff containing no start-codes or end-codes
            (?:
              [^A-Z\s>]
              |
              (?:
                [A-Z](?!<)
              )
              |
              # whitespace is ok, but we don't want to eat the whitespace before
              # a multiple-bracket end code.
              # NOTE: we may still have problems with e.g. S<<    >>
              (?:
                \s(?!\s*>{2,})
              )
            )+
          )
        )
      /xgo
    ) {
      DEBUG > 4 and print STDERR "\nParagraphic tokenstack = (@stack)\n";
      if(defined $1) {
        if(defined $2) {
          DEBUG > 3 and print STDERR "Found complex start-text code \"$1\"\n";
          push @stack, length($2) + 1; 
            # length of the necessary complex end-code string
        } else {
          DEBUG > 3 and print STDERR "Found simple start-text code \"$1\"\n";
          push @stack, 0;  # signal that we're looking for simple
        }
        push @lineage, [ substr($1,0,1), {}, ];  # new node object
        push @{ $lineage[-2] }, $lineage[-1];
        if ('L' eq substr($1,0,1)) {
          $raw = $inL ? $raw.$1 : ''; # reset raw content accumulator
          $inL = 1;
        } else {
          $raw .= $1 if $inL;
        }
  
      } elsif(defined $4) {
        DEBUG > 3 and print STDERR "Found apparent complex end-text code \"$3$4\"\n";
        # This is where it gets messy...
        if(! @stack) {
          # We saw " >>>>" but needed nothing.  This is ALL just stuff then.
          DEBUG > 4 and print STDERR " But it's really just stuff.\n";
          push @{ $lineage[-1] }, $3, $4;
          next;
        } elsif(!$stack[-1]) {
          # We saw " >>>>" but needed only ">".  Back pos up.
          DEBUG > 4 and print STDERR " And that's more than we needed to close simple.\n";
          push @{ $lineage[-1] }, $3; # That was a for-real space, too.
          pos($para) = pos($para) - length($4) + 1;
        } elsif($stack[-1] == length($4)) {
          # We found " >>>>", and it was exactly what we needed.  Commonest case.
          DEBUG > 4 and print STDERR " And that's exactly what we needed to close complex.\n";
        } elsif($stack[-1] < length($4)) {
          # We saw " >>>>" but needed only " >>".  Back pos up.
          DEBUG > 4 and print STDERR " And that's more than we needed to close complex.\n";
          pos($para) = pos($para) - length($4) + $stack[-1];
        } else {
          # We saw " >>>>" but needed " >>>>>>".  So this is all just stuff!
          DEBUG > 4 and print STDERR " But it's really just stuff, because we needed more.\n";
          push @{ $lineage[-1] }, $3, $4;
          next;
        }
        #print STDERR "\nHOOBOY ", scalar(@{$lineage[-1]}), "!!!\n";
  
        push @{ $lineage[-1] }, '' if 2 == @{ $lineage[-1] };
        # Keep the element from being childless
        
        pop @stack;
        pop @lineage;
  
        unless (@stack) { # not in an L if there are no open fcodes
          $inL = 0;
          if (ref $lineage[-1][-1] && $lineage[-1][-1][0] eq 'L') {
            $lineage[-1][-1][1]{'raw'} = $raw
          }
        }
        $raw .= $3.$4 if $inL;
        
      } elsif(defined $5) {
        DEBUG > 3 and print STDERR "Found apparent simple end-text code \"$5\"\n";
  
        if(@stack and ! $stack[-1]) {
          # We're indeed expecting a simple end-code
          DEBUG > 4 and print STDERR " It's indeed an end-code.\n";
  
          if(length($5) == 2) { # There was a space there: " >"
            push @{ $lineage[-1] }, ' ';
          } elsif( 2 == @{ $lineage[-1] } ) { # Closing a childless element
            push @{ $lineage[-1] }, ''; # keep it from being really childless
          }
  
          pop @stack;
          pop @lineage;
        } else {
          DEBUG > 4 and print STDERR " It's just stuff.\n";
          push @{ $lineage[-1] }, $5;
        }
  
        unless (@stack) { # not in an L if there are no open fcodes
          $inL = 0;
          if (ref $lineage[-1][-1] && $lineage[-1][-1][0] eq 'L') {
            $lineage[-1][-1][1]{'raw'} = $raw
          }
        }
        $raw .= $5 if $inL;
  
      } elsif(defined $6) {
        DEBUG > 3 and print STDERR "Found stuff \"$6\"\n";
        push @{ $lineage[-1] }, $6;
        $raw .= $6 if $inL;
          # XXX does not capture multiplace whitespaces -- 'raw' ends up with
          #     at most 1 leading/trailing whitespace, why not all of it?
  
      } else {
        # should never ever ever ever happen
        DEBUG and print STDERR "AYYAYAAAAA at line ", __LINE__, "\n";
        die "SPORK 512512!";
      }
    }
  
    if(@stack) { # Uhoh, some sequences weren't closed.
      my $x= "...";
      while(@stack) {
        push @{ $lineage[-1] }, '' if 2 == @{ $lineage[-1] };
        # Hmmmmm!
  
        my $code         = (pop @lineage)->[0];
        my $ender_length =  pop @stack;
        if($ender_length) {
          --$ender_length;
          $x = $code . ("<" x $ender_length) . " $x " . (">" x $ender_length);
        } else {
          $x = $code . "<$x>";
        }
      }
      DEBUG > 1 and print STDERR "Unterminated $x sequence\n";
      $self->whine($start_line,
        "Unterminated $x sequence",
      );
    }
  
    return $treelet;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub text_content_of_treelet {  # method: $parser->text_content_of_treelet($lol)
    return stringify_lol($_[1]);
  }
  
  sub stringify_lol {  # function: stringify_lol($lol)
    my $string_form = '';
    _stringify_lol( $_[0] => \$string_form );
    return $string_form;
  }
  
  sub _stringify_lol {  # the real recursor
    my($lol, $to) = @_;
    for(my $i = 2; $i < @$lol; ++$i) {
      if( ref($lol->[$i] || '') and UNIVERSAL::isa($lol->[$i], 'ARRAY') ) {
        _stringify_lol( $lol->[$i], $to);  # recurse!
      } else {
        $$to .= $lol->[$i];
      }
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _dump_curr_open { # return a string representation of the stack
    my $curr_open = $_[0]{'curr_open'};
  
    return '[empty]' unless @$curr_open;
    return join '; ',
      map {;
             ($_->[0] eq '=for')
               ? ( ($_->[1]{'~really'} || '=over')
                 . ' ' . $_->[1]{'target'})
               : $_->[0]
          }
      @$curr_open
    ;
  }
  
  ###########################################################################
  my %pretty_form = (
    "\a" => '\a', # ding!
    "\b" => '\b', # BS
    "\e" => '\e', # ESC
    "\f" => '\f', # FF
    "\t" => '\t', # tab
    "\cm" => '\cm',
    "\cj" => '\cj',
    "\n" => '\n', # probably overrides one of either \cm or \cj
    '"' => '\"',
    '\\' => '\\\\',
    '$' => '\\$',
    '@' => '\\@',
    '%' => '\\%',
    '#' => '\\#',
  );
  
  sub pretty { # adopted from Class::Classless
    # Not the most brilliant routine, but passable.
    # Don't give it a cyclic data structure!
    my @stuff = @_; # copy
    my $x;
    my $out =
      # join ",\n" .
      join ", ",
      map {;
      if(!defined($_)) {
        "undef";
      } elsif(ref($_) eq 'ARRAY' or ref($_) eq 'Pod::Simple::LinkSection') {
        $x = "[ " . pretty(@$_) . " ]" ;
        $x;
      } elsif(ref($_) eq 'SCALAR') {
        $x = "\\" . pretty($$_) ;
        $x;
      } elsif(ref($_) eq 'HASH') {
        my $hr = $_;
        $x = "{" . join(", ",
          map(pretty($_) . '=>' . pretty($hr->{$_}),
              sort keys %$hr ) ) . "}" ;
        $x;
      } elsif(!length($_)) { q{''} # empty string
      } elsif(
        $_ eq '0' # very common case
        or(
           m/^-?(?:[123456789]\d*|0)(?:\.\d+)?$/s
           and $_ ne '-0' # the strange case that RE lets thru
        )
      ) { $_;
      } else {
          # Yes, explicitly name every character desired. There are shorcuts one
          # could make, but I (Karl Williamson) was afraid that some Perl
          # releases would have bugs in some of them. For example [A-Z] works
          # even on EBCDIC platforms to match exactly the 26 uppercase English
          # letters, but I don't know if it has always worked without bugs. It
          # seemed safest just to list the characters.
          # s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
          s<([^ !#'()*+,\-./0123456789:;\<=\>?ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\]^_`abcdefghijklmnopqrstuvwxyz{|}~])>
           <$pretty_form{$1} || '\\x{'.sprintf("%x", ord($1)).'}'>eg;
           #<$pretty_form{$1} || '\\x'.(unpack("H2",$1))>eg;
        qq{"$_"};
      }
    } @stuff;
    # $out =~ s/\n */ /g if length($out) < 75;
    return $out;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  # A rather unsubtle method of blowing away all the state information
  # from a parser object so it can be reused. Provided as a utility for
  # backward compatibility in Pod::Man, etc. but not recommended for
  # general use.
  
  sub reinit {
    my $self = shift;
    foreach (qw(source_dead source_filename doc_has_started
  start_of_pod_block content_seen last_was_blank paras curr_open
  line_count pod_para_count in_pod ~tried_gen_errata all_errata errata errors_seen
  Title)) {
  
      delete $self->{$_};
    }
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
POD_SIMPLE_BLACKBOX

$fatpacked{"Pod/Simple/Checker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_CHECKER';
  require 5;package Pod::Simple::Checker;use strict;use Carp ();use Pod::Simple::Methody ();use Pod::Simple ();use vars qw(@ISA $VERSION);$VERSION='3.35';@ISA=('Pod::Simple::Methody');BEGIN {*DEBUG=defined(&Pod::Simple::DEBUG)? \&Pod::Simple::DEBUG : sub() {0}}use Text::Wrap 98.112902 ();$Text::Wrap::wrap='overflow';sub any_errata_seen {return $_[1]->{'Errata_seen'}}sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->nix_X_codes(1);$new->nbsp_for_S(1);$new->{'Thispara'}='';$new->{'Indent'}=0;$new->{'Indentstring'}='   ';$new->{'Errata_seen'}=0;return$new}sub handle_text {$_[0]{'Errata_seen'}and $_[0]{'Thispara'}.= $_[1]}sub start_Para {$_[0]{'Thispara'}=''}sub start_head1 {if($_[0]{'Errata_seen'}){$_[0]{'Thispara'}=''}else {if($_[1]{'errata'}){$_[0]{'Errata_seen'}=1;$_[0]{'Thispara'}=$_[0]{'source_filename'}? "$_[0]{'source_filename'} -- " : ''}}}sub start_head2 {$_[0]{'Thispara'}=''}sub start_head3 {$_[0]{'Thispara'}=''}sub start_head4 {$_[0]{'Thispara'}=''}sub start_Verbatim {$_[0]{'Thispara'}=''}sub start_item_bullet {$_[0]{'Thispara'}='* '}sub start_item_number {$_[0]{'Thispara'}="$_[1]{'number'}. "}sub start_item_text {$_[0]{'Thispara'}=''}sub start_over_bullet {++$_[0]{'Indent'}}sub start_over_number {++$_[0]{'Indent'}}sub start_over_text {++$_[0]{'Indent'}}sub start_over_block {++$_[0]{'Indent'}}sub end_over_bullet {--$_[0]{'Indent'}}sub end_over_number {--$_[0]{'Indent'}}sub end_over_text {--$_[0]{'Indent'}}sub end_over_block {--$_[0]{'Indent'}}sub end_head1 {$_[0]->emit_par(-4)}sub end_head2 {$_[0]->emit_par(-3)}sub end_head3 {$_[0]->emit_par(-2)}sub end_head4 {$_[0]->emit_par(-1)}sub end_Para {$_[0]->emit_par(0)}sub end_item_bullet {$_[0]->emit_par(0)}sub end_item_number {$_[0]->emit_par(0)}sub end_item_text {$_[0]->emit_par(-2)}sub emit_par {return unless $_[0]{'Errata_seen'};my($self,$tweak_indent)=splice(@_,0,2);my$indent=' ' x (2 * $self->{'Indent'}+ ($tweak_indent||0));$self->{'Thispara'}=~ s/$Pod::Simple::shy//g;my$out=Text::Wrap::wrap($indent,$indent,$self->{'Thispara'}.= "\n");$out =~ s/$Pod::Simple::nbsp/ /g;print {$self->{'output_fh'}}$out,;$self->{'Thispara'}='';return}sub end_Verbatim {return unless $_[0]{'Errata_seen'};my$self=shift;$self->{'Thispara'}=~ s/$Pod::Simple::nbsp/ /g;$self->{'Thispara'}=~ s/$Pod::Simple::shy//g;my$i=' ' x (2 * $self->{'Indent'}+ 4);$self->{'Thispara'}=~ s/^/$i/mg;print {$self->{'output_fh'}}'',$self->{'Thispara'},"\n\n" ;$self->{'Thispara'}='';return}1;
POD_SIMPLE_CHECKER

$fatpacked{"Pod/Simple/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DEBUG';
  require 5;package Pod::Simple::Debug;use strict;use vars qw($VERSION);$VERSION='3.35';sub import {my($value,$variable);if(@_==2){$value=$_[1]}elsif(@_==3){($variable,$value)=@_[1,2];($variable,$value)=($value,$variable)if defined$value and ref($value)eq 'SCALAR' and not(defined$variable and ref($variable)eq 'SCALAR');unless(defined$variable and ref($variable)eq 'SCALAR'){require Carp;Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor" ."\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting")}}else {require Carp;Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor" ."\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting")}if(defined&Pod::Simple::DEBUG){require Carp;Carp::croak("It's too late to call Pod::Simple::Debug -- " ."Pod::Simple has already loaded\nAborting")}$value=0 unless defined$value;unless($value =~ m/^-?\d+$/){require Carp;Carp::croak("$value isn't a numeric value." ."\nUsage:\n use Pod::Simple::Debug (NUMVAL)\nor" ."\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting")}if(defined$variable){*Pod::Simple::DEBUG=sub () {$$variable};$$variable=$value;print STDERR "# Starting Pod::Simple::DEBUG = non-constant $variable with val $value\n"}else {*Pod::Simple::DEBUG=eval " sub () { $value } ";print STDERR "# Starting Pod::Simple::DEBUG = $value\n"}require Pod::Simple;return}1;
POD_SIMPLE_DEBUG

$fatpacked{"Pod/Simple/DumpAsText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASTEXT';
  require 5;package Pod::Simple::DumpAsText;$VERSION='3.35';use Pod::Simple ();BEGIN {@ISA=('Pod::Simple')}use strict;use Carp ();BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->accept_codes('VerbatimFormatted');$new->keep_encoding_directive(1);return$new}sub _handle_element_start {my$fh=$_[0]{'output_fh'};my($key,$value);DEBUG and print STDERR "++ $_[1]\n";print$fh '  ' x ($_[0]{'indent'}|| 0),"++",$_[1],"\n";$_[0]{'indent'}++;while(($key,$value)=each %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_perly_escape($key);_perly_escape($value);printf$fh qq{%s \\ "%s" => "%s"\n},'  ' x ($_[0]{'indent'}|| 0),$key,$value}}return}sub _handle_text {DEBUG and print STDERR "== \"$_[1]\"\n";if(length $_[1]){my$indent='  ' x $_[0]{'indent'};my$text=$_[1];_perly_escape($text);$text =~ s/(
           [^\n]{55}         # Snare some characters from a line
           [^\n\ ]{0,50}     #  and finish any current word
          )
          \ {1,10}(?!\n)     # capture some spaces not at line-end
         /$1"\n$indent . "/gx ;print {$_[0]{'output_fh'}}$indent,'* "',$text,"\"\n"}return}sub _handle_element_end {DEBUG and print STDERR "-- $_[1]\n";print {$_[0]{'output_fh'}}'  ' x --$_[0]{'indent'},"--",$_[1],"\n";return}sub _perly_escape {for my$x (@_){$x =~ s/([^\x00-\xFF])/sprintf'\x{%X}',ord($1)/eg;$x =~ s/([^-\n\t \&\<\>\'!\#\%\(\)\*\+,\.\/\:\;=\?\~\[\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf'\x%02X',ord($1)/eg}return}1;
POD_SIMPLE_DUMPASTEXT

$fatpacked{"Pod/Simple/DumpAsXML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASXML';
  require 5;package Pod::Simple::DumpAsXML;$VERSION='3.35';use Pod::Simple ();BEGIN {@ISA=('Pod::Simple')}use strict;use Carp ();use Text::Wrap qw(wrap);BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->accept_codes('VerbatimFormatted');$new->keep_encoding_directive(1);return$new}sub _handle_element_start {my$fh=$_[0]{'output_fh'};my($key,$value);DEBUG and print STDERR "++ $_[1]\n";print$fh '  ' x ($_[0]{'indent'}|| 0),"<",$_[1];for my$key (sort keys %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_xml_escape($value=$_[2]{$key});print$fh ' ',$key,'="',$value,'"'}}print$fh ">\n";$_[0]{'indent'}++;return}sub _handle_text {DEBUG and print STDERR "== \"$_[1]\"\n";if(length $_[1]){my$indent='  ' x $_[0]{'indent'};my$text=$_[1];_xml_escape($text);local$Text::Wrap::huge='overflow';$text=wrap('',$indent,$text);print {$_[0]{'output_fh'}}$indent,$text,"\n"}return}sub _handle_element_end {DEBUG and print STDERR "-- $_[1]\n";print {$_[0]{'output_fh'}}'  ' x --$_[0]{'indent'},"</",$_[1],">\n";return}sub _xml_escape {for my$x (@_){if ($] ge 5.007_003){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg}else {$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}}return}1;
POD_SIMPLE_DUMPASXML

$fatpacked{"Pod/Simple/HTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTML';
  require 5;package Pod::Simple::HTML;use strict;use Pod::Simple::PullParser ();use vars qw(@ISA %Tagmap $Computerese $LamePad $Linearization_Limit $VERSION $Perldoc_URL_Prefix $Perldoc_URL_Postfix $Man_URL_Prefix $Man_URL_Postfix $Title_Prefix $Title_Postfix $HTML_EXTENSION %ToIndex $Doctype_decl $Content_decl);@ISA=('Pod::Simple::PullParser');$VERSION='3.35';BEGIN {if(defined&DEBUG){}elsif(defined&Pod::Simple::DEBUG){*DEBUG=\&Pod::Simple::DEBUG}else {*DEBUG=sub () {0}}}$Doctype_decl ||= '';$Content_decl ||= q{<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >};$HTML_EXTENSION='.html' unless defined$HTML_EXTENSION;$Computerese="" unless defined$Computerese;$LamePad='' unless defined$LamePad;$Linearization_Limit=120 unless defined$Linearization_Limit;$Perldoc_URL_Prefix='http://search.cpan.org/perldoc?' unless defined$Perldoc_URL_Prefix;$Perldoc_URL_Postfix='' unless defined$Perldoc_URL_Postfix;$Man_URL_Prefix='http://man.he.net/man';$Man_URL_Postfix='';$Title_Prefix='' unless defined$Title_Prefix;$Title_Postfix='' unless defined$Title_Postfix;%ToIndex=map {;$_=>1}qw(head1 head2 head3 head4);__PACKAGE__->_accessorize('perldoc_url_prefix','perldoc_url_postfix','man_url_prefix','man_url_postfix','batch_mode','batch_mode_current_level','title_prefix','title_postfix','html_h_level','html_header_before_title','html_header_after_title','html_footer','top_anchor','index','html_css','html_javascript','force_title','default_title',);my@_to_accept;%Tagmap=('Verbatim'=>"\n<pre$Computerese>",'/Verbatim'=>"</pre>\n",'VerbatimFormatted'=>"\n<pre$Computerese>",'/VerbatimFormatted'=>"</pre>\n",'VerbatimB'=>"<b>",'/VerbatimB'=>"</b>",'VerbatimI'=>"<i>",'/VerbatimI'=>"</i>",'VerbatimBI'=>"<b><i>",'/VerbatimBI'=>"</i></b>",'Data'=>"\n",'/Data'=>"\n",'head1'=>"\n<h1>",'head2'=>"\n<h2>",'head3'=>"\n<h3>",'head4'=>"\n<h4>",'/head1'=>"</a></h1>\n",'/head2'=>"</a></h2>\n",'/head3'=>"</a></h3>\n",'/head4'=>"</a></h4>\n",'X'=>"<!--\n\tINDEX: ",'/X'=>"\n-->",changes(qw(Para=p B=b I=i over-bullet=ul over-number=ol over-text=dl over-block=blockquote item-bullet=li item-number=li item-text=dt)),changes2(map {;m/^([-a-z]+)/s && push@_to_accept,$1;$_}qw[sample=samp definition=dfn keyboard=kbd variable=var citation=cite abbreviation=abbr acronym=acronym subscript=sub superscript=sup big=big small=small underline=u strikethrough=s preformat=pre teletype=tt]),'/item-bullet'=>"</li>$LamePad\n",'/item-number'=>"</li>$LamePad\n",'/item-text'=>"</a></dt>$LamePad\n",'item-body'=>"\n<dd>",'/item-body'=>"</dd>\n",'B'=>"<b>",'/B'=>"</b>",'I'=>"<i>",'/I'=>"</i>",'F'=>"<em$Computerese>",'/F'=>"</em>",'C'=>"<code$Computerese>",'/C'=>"</code>",'L'=>"<a href='YOU_SHOULD_NEVER_SEE_THIS'>",'/L'=>"</a>",);sub changes {return map {;m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s ? ($1,=>"\n<$2>","/$1",=>"</$2>\n"): die "Funky $_"}@_}sub changes2 {return map {;m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s ? ($1,=>"<$2>","/$1",=>"</$2>"): die "Funky $_"}@_}sub go {Pod::Simple::HTML->parse_from_file(@ARGV);exit 0}sub new {my$new=shift->SUPER::new(@_);$new->nbsp_for_S(1);$new->accept_targets('html','HTML');$new->accept_codes('VerbatimFormatted');$new->accept_codes(@_to_accept);DEBUG > 2 and print STDERR "To accept: ",join(' ',@_to_accept),"\n";$new->perldoc_url_prefix($Perldoc_URL_Prefix);$new->perldoc_url_postfix($Perldoc_URL_Postfix);$new->man_url_prefix($Man_URL_Prefix);$new->man_url_postfix($Man_URL_Postfix);$new->title_prefix($Title_Prefix);$new->title_postfix($Title_Postfix);$new->html_header_before_title(qq[$Doctype_decl<html><head><title>]);$new->html_header_after_title(join "\n"=>"</title>",$Content_decl,"</head>\n<body class='pod'>",$new->version_tag_comment,"<!-- start doc -->\n",);$new->html_footer(qq[\n<!-- end doc -->\n\n</body></html>\n]);$new->top_anchor("<a name='___top' class='dummyTopAnchor' ></a>\n");$new->{'Tagmap'}={%Tagmap};return$new}sub __adjust_html_h_levels {my ($self)=@_;my$Tagmap=$self->{'Tagmap'};my$add=$self->html_h_level;return unless defined$add;return if ($self->{'Adjusted_html_h_levels'}||0)==$add;$add -= 1;for (1 .. 4){$Tagmap->{"head$_"}=~ s/$_/$_ + $add/e;$Tagmap->{"/head$_"}=~ s/$_/$_ + $add/e}}sub batch_mode_page_object_init {my($self,$batchconvobj,$module,$infile,$outfile,$depth)=@_;DEBUG and print STDERR "Initting $self\n  for $module\n","  in $infile\n  out $outfile\n  depth $depth\n";$self->batch_mode(1);$self->batch_mode_current_level($depth);return$self}sub run {my$self=$_[0];return$self->do_middle if$self->bare_output;return $self->do_beginning && $self->do_middle && $self->do_end}sub do_beginning {my$self=$_[0];my$title;if(defined$self->force_title){$title=$self->force_title;DEBUG and print STDERR "Forcing title to be $title\n"}else {$title=$self->get_short_title();unless($self->content_seen){DEBUG and print STDERR "No content seen in search for title.\n";return}$self->{'Title'}=$title;if(defined$title and $title =~ m/\S/){$title=$self->title_prefix .esc($title).$self->title_postfix}else {$title=$self->default_title;$title='' unless defined$title;DEBUG and print STDERR "Title defaults to $title\n"}}my$after=$self->html_header_after_title || '';if($self->html_css){my$link=$self->html_css =~ m/</ ? $self->html_css : sprintf(qq[<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="%s">\n],$self->html_css,);$after =~ s{(</head>)}{$link\n$1}i}$self->_add_top_anchor(\$after);if($self->html_javascript){my$link=$self->html_javascript =~ m/</ ? $self->html_javascript : sprintf(qq[<script type="text/javascript" src="%s"></script>\n],$self->html_javascript,);$after =~ s{(</head>)}{$link\n$1}i}print {$self->{'output_fh'}}$self->html_header_before_title || '',$title,$after,;DEBUG and print STDERR "Returning from do_beginning...\n";return 1}sub _add_top_anchor {my($self,$text_r)=@_;unless($$text_r and $$text_r =~ m/name=['"]___top['"]/){$$text_r .= $self->top_anchor || ''}return}sub version_tag_comment {my$self=shift;return sprintf "<!--\n  generated by %s v%s,\n  using %s v%s,\n  under Perl v%s at %s GMT.\n\n %s\n\n-->\n",esc(ref($self),$self->VERSION(),$ISA[0],$ISA[0]->VERSION(),$],scalar(gmtime),),$self->_modnote(),}sub _modnote {my$class=ref($_[0])|| $_[0];return join "\n   "=>grep m/\S/,split "\n",qq{
  If you want to change this HTML document, you probably shouldn't do that
  by changing it directly.  Instead, see about changing the calling options
  to $class, and/or subclassing $class,
  then reconverting this document from the Pod source.
  When in doubt, email the author of $class for advice.
  See 'perldoc $class' for more info.
  }}sub do_end {my$self=$_[0];print {$self->{'output_fh'}}$self->html_footer || '';return 1}sub do_middle {my$self=$_[0];return$self->_do_middle_main_loop unless$self->index;if($self->output_string){my$out=$self->output_string;my$sneakytag="\f\f\e\e\b\bIndex Here\e\e\b\b\f\f\n";$$out .= $sneakytag;$self->_do_middle_main_loop;$sneakytag=quotemeta($sneakytag);my$index=$self->index_as_html();if($$out =~ s/$sneakytag/$index/s){DEBUG and print STDERR "Inserted ",length($index)," bytes of index HTML into $out.\n"}else {DEBUG and print STDERR "Odd, couldn't find where to insert the index in the output!\n"}return 1}unless($self->output_fh){require Carp;Carp::confess("Parser object \$p doesn't seem to have any output object!  I don't know how to deal with that.")}my$fh=$self->output_fh;my$content='';{$self->output_string(\$content);$self->_do_middle_main_loop;$self->abandon_output_string();$self->output_fh($fh)}print$fh $self->index_as_html();print$fh $content;return 1}sub index_as_html {my$self=$_[0];my$points=$self->{'PSHTML_index_points'}|| [];@$points > 1 or return qq[<div class='indexgroupEmpty'></div>\n];my(@out)=qq{\n<div class='indexgroup'>};my$level=0;my($target_level,$previous_tagname,$tagname,$text,$anchorname,$indent);for my$p (@$points,['head0','(end)']){($tagname,$text)=@$p;$anchorname=$self->section_escape($text);if($tagname =~ m{^head(\d+)$}){$target_level=0 + $1}else {if($previous_tagname =~ m{^head\d+$}){$target_level=$level + 1}else {$target_level=$level}}while($level > $target_level){--$level;push@out,("  " x $level)."</ul>"}while($level < $target_level){++$level;push@out,("  " x ($level-1))."<ul   class='indexList indexList$level'>"}$previous_tagname=$tagname;next unless$level;$indent='  ' x $level;push@out,sprintf "%s<li class='indexItem indexItem%s'><a href='#%s'>%s</a>",$indent,$level,esc($anchorname),esc($text)}push@out,"</div>\n";return join "\n",@out}sub _do_middle_main_loop {my$self=$_[0];my$fh=$self->{'output_fh'};my$tagmap=$self->{'Tagmap'};$self->__adjust_html_h_levels;my($token,$type,$tagname,$linkto,$linktype);my@stack;my$dont_wrap=0;while($token=$self->get_token){if(($type=$token->type)eq 'start'){if(($tagname=$token->tagname)eq 'L'){$linktype=$token->attr('type')|| 'insane';$linkto=$self->do_link($token);if(defined$linkto and length$linkto){esc($linkto);print$fh qq{<a href="$linkto" class="podlink$linktype"\n>}}else {print$fh "<a>"}}elsif ($tagname eq 'item-text' or $tagname =~ m/^head\d$/s){print$fh $tagmap->{$tagname}|| next;my@to_unget;while(1){push@to_unget,$self->get_token;last if$to_unget[-1]->is_end and $to_unget[-1]->tagname eq $tagname}my$name=$self->linearize_tokens(@to_unget);$name=$self->do_section($name,$token)if defined$name;print$fh "<a ";if ($tagname =~ m/^head\d$/s){print$fh "class='u'",$self->index ? " href='#___top' title='click to go to top of document'\n" : "\n"}if(defined$name){my$esc=esc($self->section_name_tidy($name));print$fh qq[name="$esc"];DEBUG and print STDERR "Linearized ",scalar(@to_unget)," tokens as \"$name\".\n";push @{$self->{'PSHTML_index_points'}},[$tagname,$name]if$ToIndex{$tagname }}else {DEBUG and print STDERR "Linearized ",scalar(@to_unget)," tokens, but it was too long, so nevermind.\n"}print$fh "\n>";$self->unget_token(@to_unget)}elsif ($tagname eq 'Data'){my$next=$self->get_token;next unless defined$next;unless($next->type eq 'text'){$self->unget_token($next);next}DEBUG and print STDERR "    raw text ",$next->text,"\n";(my$text=$next->text)=~ s/\n\z//;print$fh $text,"\n";next}else {if($tagname =~ m/^over-/s){push@stack,''}elsif($tagname =~ m/^item-/s and @stack and $stack[-1]){print$fh $stack[-1];$stack[-1]=''}print$fh $tagmap->{$tagname}|| next;++$dont_wrap if$tagname eq 'Verbatim' or $tagname eq "VerbatimFormatted" or $tagname eq 'X'}}elsif($type eq 'end'){if(($tagname=$token->tagname)=~ m/^over-/s){if(my$end=pop@stack){print$fh $end}}elsif($tagname =~ m/^item-/s and @stack){$stack[-1]=$tagmap->{"/$tagname"};if($tagname eq 'item-text' and defined(my$next=$self->get_token)){$self->unget_token($next);if($next->type eq 'start'){print$fh $tagmap->{"/item-text"},$tagmap->{"item-body"};$stack[-1]=$tagmap->{"/item-body"}}}next}print$fh $tagmap->{"/$tagname"}|| next;--$dont_wrap if$tagname eq 'Verbatim' or $tagname eq 'X'}elsif($type eq 'text'){esc($type=$token->text);$type =~ s/([\?\!\"\'\.\,]) /$1\n/g unless$dont_wrap;print$fh $type}}return 1}sub do_section {my($self,$name,$token)=@_;return$name}sub do_link {my($self,$token)=@_;my$type=$token->attr('type');if(!defined$type){$self->whine("Typeless L!?",$token->attr('start_line'))}elsif($type eq 'pod'){return$self->do_pod_link($token)}elsif($type eq 'url'){return$self->do_url_link($token)}elsif($type eq 'man'){return$self->do_man_link($token)}else {$self->whine("L of unknown type $type!?",$token->attr('start_line'))}return 'FNORG'}sub do_url_link {return $_[1]->attr('to')}sub do_man_link {my ($self,$link)=@_;my$to=$link->attr('to');my$frag=$link->attr('section');return undef unless defined$to and length$to;$frag=$self->section_escape($frag)if defined$frag and length($frag .= '');DEBUG and print STDERR "Resolving \"$to/$frag\"\n\n";return$self->resolve_man_page_link($to,$frag)}sub do_pod_link {my($self,$link)=@_;my$to=$link->attr('to');my$section=$link->attr('section');return undef unless((defined$to and length$to)or (defined$section and length$section));$section=$self->section_escape($section)if defined$section and length($section .= '');DEBUG and printf STDERR "Resolving \"%s\" \"%s\"...\n",$to || "(nil)",$section || "(nil)";{my$complete_url=$self->resolve_pod_link_by_table($to,$section);if($complete_url){DEBUG > 1 and print STDERR "resolve_pod_link_by_table(T,S) gives ",$complete_url,"\n  (Returning that.)\n";return$complete_url}else {DEBUG > 4 and print STDERR " resolve_pod_link_by_table(T,S)"," didn't return anything interesting.\n"}}if(defined$to and length$to){my$there=$self->resolve_pod_link_by_table($to);if(defined$there and length$there){DEBUG > 1 and print STDERR "resolve_pod_link_by_table(T) gives $there\n"}else {$there=$self->resolve_pod_page_link($to,$section);DEBUG > 1 and print STDERR "resolve_pod_page_link gives ",$there || "(nil)","\n";unless(defined$there and length$there){DEBUG and print STDERR "Can't resolve $to\n";return undef}}$to=$there}my$out=(defined$to and length$to)? $to : '';$out .= "#" .$section if defined$section and length$section;unless(length$out){DEBUG and printf STDERR "Oddly, couldn't resolve \"%s\" \"%s\"...\n",$to || "(nil)",$section || "(nil)";return undef}DEBUG and print STDERR "Resolved to $out\n";return$out}sub section_escape {my($self,$section)=@_;return$self->section_url_escape($self->section_name_tidy($section))}sub section_name_tidy {my($self,$section)=@_;$section =~ s/^\s+//;$section =~ s/\s+$//;$section =~ tr/ /_/;if ($] ge 5.006){$section =~ s/[[:cntrl:][:^ascii:]]//g}elsif ('A' eq chr(65)){$section =~ tr/\x00-\x1F\x80-\x9F//d}$section=$self->unicode_escape_url($section);$section='_' unless length$section;return$section}sub section_url_escape {shift->general_url_escape(@_)}sub pagepath_url_escape {shift->general_url_escape(@_)}sub manpage_url_escape {shift->general_url_escape(@_)}sub general_url_escape {my($self,$string)=@_;$string =~ s/([^\x00-\xFF])/join '', map sprintf('%%%02X',$_), unpack 'C*', $1/eg;if ($] ge 5.007_003){$string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',utf8::native_to_unicode(ord($1)))/eg}else {$string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',ord($1))/eg}return$string}sub resolve_pod_page_link {my$self=shift;return$self->batch_mode()? $self->resolve_pod_page_link_batch_mode(@_): $self->resolve_pod_page_link_singleton_mode(@_)}sub resolve_pod_page_link_singleton_mode {my($self,$it)=@_;return undef unless defined$it and length$it;my$url=$self->pagepath_url_escape($it);$url =~ s{::$}{}s;$url =~ s{::}{/}g unless$self->perldoc_url_prefix =~ m/\?/s;return undef unless length$url;return$self->perldoc_url_prefix .$url .$self->perldoc_url_postfix}sub resolve_pod_page_link_batch_mode {my($self,$to)=@_;DEBUG > 1 and print STDERR " During batch mode, resolving $to ...\n";my@path=grep length($_),split m/::/s,$to,-1;unless(@path){DEBUG and print STDERR "Very odd!  Splitting $to gives (nil)!\n";return undef}$self->batch_mode_rectify_path(\@path);my$out=join('/',map$self->pagepath_url_escape($_),@path).$HTML_EXTENSION;DEBUG > 1 and print STDERR " => $out\n";return$out}sub batch_mode_rectify_path {my($self,$pathbits)=@_;my$level=$self->batch_mode_current_level;$level--;if($level < 1){unshift @$pathbits,'.'}else {unshift @$pathbits,('..')x $level}return}sub resolve_man_page_link {my ($self,$to,$frag)=@_;my ($page,$section)=$to =~ /^([^(]+)(?:[(](\d+)[)])?$/;return undef unless defined$page and length$page;$section ||= 1;return$self->man_url_prefix ."$section/" .$self->manpage_url_escape($page).$self->man_url_postfix}sub resolve_pod_link_by_table {return unless $_[0]->{'podhtml_LOT'};my($self,$to,$section)=@_;if(defined$section){$to='' unless defined$to and length$to;return$self->{'podhtml_LOT'}{"$to#$section"}}else {return$self->{'podhtml_LOT'}{$to}}return}sub linearize_tokens {my$self=shift;my$out='';my$t;while($t=shift @_){if(!ref$t or!UNIVERSAL::can($t,'is_text')){$out .= $t}elsif($t->is_text){$out .= $t->text}elsif($t->is_start and $t->tag eq 'X'){my$x_open=1;while($x_open){next if(($t=shift @_)->is_text);if($t->is_start and $t->tag eq 'X'){++$x_open}elsif($t->is_end and $t->tag eq 'X'){--$x_open}}}}return undef if length$out > $Linearization_Limit;return$out}sub unicode_escape_url {my($self,$string)=@_;$string =~ s/([^\x00-\xFF])/'('.ord($1).')'/eg;return$string}sub esc {if(defined wantarray){if(wantarray){@_=splice @_}else {my$x=shift;if ($] ge 5.007_003){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg}else {$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}return$x}}for my$x (@_){if (defined$x){if ($] ge 5.007_003){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg}else {$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}}}return @_}1;
POD_SIMPLE_HTML

$fatpacked{"Pod/Simple/HTMLBatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLBATCH';
  require 5;package Pod::Simple::HTMLBatch;use strict;use vars qw($VERSION $HTML_RENDER_CLASS $HTML_EXTENSION $CSS $JAVASCRIPT $SLEEPY $SEARCH_CLASS @ISA);$VERSION='3.35';@ISA=();use Pod::Simple::HTML ();BEGIN {*esc=\&Pod::Simple::HTML::esc}use File::Spec ();use Pod::Simple::Search;$SEARCH_CLASS ||= 'Pod::Simple::Search';BEGIN {if(defined&DEBUG){}elsif(defined&Pod::Simple::DEBUG){*DEBUG=\&Pod::Simple::DEBUG}else {*DEBUG=sub () {0}}}$SLEEPY=1 if!defined$SLEEPY and $^O =~ /mswin|mac/i;$HTML_RENDER_CLASS ||= "Pod::Simple::HTML";Pod::Simple::_accessorize(__PACKAGE__,'verbose','html_render_class','search_class','contents_file','index','progress','contents_page_start','contents_page_end','css_flurry','_css_wad','javascript_flurry','_javascript_wad','no_contents_links','_contents',);sub go {@ARGV==2 or die sprintf("Usage: perl -M%s -e %s:go indirs outdir\n  (or use \"\@INC\" for indirs)\n",__PACKAGE__,__PACKAGE__,);if(defined($ARGV[1])and length($ARGV[1])){my$d=$ARGV[1];-e $d or die "I see no output directory named \"$d\"\nAborting";-d $d or die "But \"$d\" isn't a directory!\nAborting";-w $d or die "Directory \"$d\" isn't writeable!\nAborting"}__PACKAGE__->batch_convert(@ARGV)}sub new {my$new=bless {},ref($_[0])|| $_[0];$new->html_render_class($HTML_RENDER_CLASS);$new->search_class($SEARCH_CLASS);$new->verbose(1 + DEBUG);$new->_contents([]);$new->index(1);$new-> _css_wad([]);$new->css_flurry(1);$new->_javascript_wad([]);$new->javascript_flurry(1);$new->contents_file('index' .($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION));$new->contents_page_start(join "\n",grep $_,$Pod::Simple::HTML::Doctype_decl,"<html><head>","<title>Perl Documentation</title>",$Pod::Simple::HTML::Content_decl,"</head>","\n<body class='contentspage'>\n<h1>Perl Documentation</h1>\n");$new->contents_page_end(sprintf("\n\n<p class='contentsfooty'>Generated by %s v%s under Perl v%s\n<br >At %s GMT, which is %s local time.</p>\n\n</body></html>\n",esc(ref($new),eval {$new->VERSION}|| $VERSION,$],scalar(gmtime),scalar(localtime),)));return$new}sub muse {my$self=shift;if($self->verbose){print 'T+',int(time()- $self->{'_batch_start_time'}),"s: ",@_,"\n"}return 1}sub batch_convert {my($self,$dirs,$outdir)=@_;$self ||= __PACKAGE__;$self=$self->new unless ref$self;if(!defined($dirs)or $dirs eq '' or $dirs eq '@INC'){$dirs=''}elsif(ref$dirs){}else {require Config;my$ps=quotemeta($Config::Config{'path_sep'}|| ":");$dirs=[grep length($_),split qr/$ps/,$dirs ]}$outdir=$self->filespecsys->curdir unless defined$outdir and length$outdir;$self->_batch_convert_main($dirs,$outdir)}sub _batch_convert_main {my($self,$dirs,$outdir)=@_;$self->{'_batch_start_time'}||= time();$self->muse("= ",scalar(localtime));$self->muse("Starting batch conversion to \"$outdir\"");my$progress=$self->progress;if(!$progress and $self->verbose > 0 and $self->verbose()<= 5){require Pod::Simple::Progress;$progress=Pod::Simple::Progress->new(($self->verbose < 2)? (): ($self->verbose==2)? 1 : 0);$self->progress($progress)}if($dirs){$self->muse(scalar(@$dirs)," dirs to scan: @$dirs")}else {$self->muse("Scanning \@INC.  This could take a minute or two.")}my$mod2path=$self->find_all_pods($dirs ? $dirs : ());$self->muse("Done scanning.");my$total=keys %$mod2path;unless($total){$self->muse("No pod found.  Aborting batch conversion.\n");return$self}$progress and $progress->goal($total);$self->muse("Now converting pod files to HTML.",($total > 25)? "  This will take a while more." : ());$self->_spray_css($outdir);$self->_spray_javascript($outdir);$self->_do_all_batch_conversions($mod2path,$outdir);$progress and $progress->done(sprintf ("Done converting %d files.",$self->{"__batch_conv_page_count"}));return$self->_batch_convert_finish($outdir);return$self}sub _do_all_batch_conversions {my($self,$mod2path,$outdir)=@_;$self->{"__batch_conv_page_count"}=0;for my$module (sort {lc($a)cmp lc($b)}keys %$mod2path){$self->_do_one_batch_conversion($module,$mod2path,$outdir);sleep($SLEEPY - 1)if$SLEEPY}return}sub _batch_convert_finish {my($self,$outdir)=@_;$self->write_contents_file($outdir);$self->muse("Done with batch conversion.  $$self{'__batch_conv_page_count'} files done.");$self->muse("= ",scalar(localtime));$self->progress and $self->progress->done("All done!");return}sub _do_one_batch_conversion {my($self,$module,$mod2path,$outdir,$outfile)=@_;my$retval;my$total=scalar keys %$mod2path;my$infile=$mod2path->{$module};my@namelets=grep m/\S/,split "::",$module;my$depth=scalar@namelets;die "Contentless thingie?! $module $infile" unless@namelets;$outfile ||= do {my@n=@namelets;$n[-1].= $HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION;$self->filespecsys->catfile($outdir,@n)};my$progress=$self->progress;my$page=$self->html_render_class->new;if(DEBUG > 5){$self->muse($self->{"__batch_conv_page_count"}+ 1,"/$total: ",ref($page)," render ($depth) $module => $outfile")}elsif(DEBUG > 2){$self->muse($self->{"__batch_conv_page_count"}+ 1,"/$total: $module => $outfile")}$page->batch_mode_page_object_init($self,$module,$infile,$outfile,$depth)if$page->can('batch_mode_page_object_init');$self->batch_mode_page_object_init($page,$module,$infile,$outfile,$depth)if$self->can('batch_mode_page_object_init');$self->makepath($outdir=>\@namelets);$progress and $progress->reach($self->{"__batch_conv_page_count"},"Rendering $module");if($retval=$page->parse_from_file($infile,$outfile)){++ $self->{"__batch_conv_page_count"};$self->note_for_contents_file(\@namelets,$infile,$outfile)}else {$self->muse("Odd, parse_from_file(\"$infile\", \"$outfile\") returned false.")}$page->batch_mode_page_object_kill($self,$module,$infile,$outfile,$depth)if$page->can('batch_mode_page_object_kill');$self->batch_mode_page_object_kill($page,$module,$infile,$outfile,$depth)if$self->can('batch_mode_page_object_kill');DEBUG > 4 and printf STDERR "%s %sb < $infile %s %sb\n",$outfile,-s $outfile,$infile,-s $infile ;undef($page);return$retval}sub filespecsys {$_[0]{'_filespecsys'}|| 'File::Spec'}sub note_for_contents_file {my($self,$namelets,$infile,$outfile)=@_;if($self->contents_file){my$c=$self->_contents();push @$c,[join("::",@$namelets),$infile,$outfile,$namelets ];DEBUG > 3 and print STDERR "Noting @$c[-1]\n"}return}sub write_contents_file {my($self,$outdir)=@_;my$outfile=$self->_contents_filespec($outdir)|| return;$self->muse("Preparing list of modules for ToC");my($toplevel,$toplevel_form_freq,)=$self->_prep_contents_breakdown;my$Contents=eval {$self->_wopen($outfile)};if($Contents){$self->muse("Writing contents file $outfile")}else {warn "Couldn't write-open contents file $outfile: $!\nAbort writing to $outfile at all";return}$self->_write_contents_start($Contents,$outfile,);$self->_write_contents_middle($Contents,$outfile,$toplevel,$toplevel_form_freq);$self->_write_contents_end($Contents,$outfile,);return$outfile}sub _write_contents_start {my($self,$Contents,$outfile)=@_;my$starter=$self->contents_page_start || '';{my$css_wad=$self->_css_wad_to_markup(1);if($css_wad){$starter =~ s{(</head>)}{\n$css_wad\n$1}i}my$javascript_wad=$self->_javascript_wad_to_markup(1);if($javascript_wad){$starter =~ s{(</head>)}{\n$javascript_wad\n$1}i}}unless(print$Contents $starter,"<dl class='superindex'>\n"){warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";close($Contents);return 0}return 1}sub _write_contents_middle {my($self,$Contents,$outfile,$toplevel2submodules,$toplevel_form_freq)=@_;for my$t (sort keys %$toplevel2submodules){my@downlines=sort {$a->[-1]cmp $b->[-1]}@{$toplevel2submodules->{$t}};printf$Contents qq[<dt><a name="%s">%s</a></dt>\n<dd>\n],esc($t,$toplevel_form_freq->{$t});my($path,$name);for my$e (@downlines){$name=$e->[0];$path=join("/",'.',esc(@{$e->[3]})).($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION);print$Contents qq{  <a href="$path">},esc($name),"</a>&nbsp;&nbsp;\n"}print$Contents "</dd>\n\n"}return 1}sub _write_contents_end {my($self,$Contents,$outfile)=@_;unless(print$Contents "</dl>\n",$self->contents_page_end || '',){warn "Couldn't write to $outfile: $!"}close($Contents)or warn "Couldn't close $outfile: $!";return 1}sub _prep_contents_breakdown {my($self)=@_;my$contents=$self->_contents;my%toplevel;my%toplevel_form_freq;for my$entry (@$contents){my$toplevel=$entry->[0]=~ m/^perl\w*$/ ? 'perl_core_docs' : $entry->[3][0];++$toplevel_form_freq{lc$toplevel }{$toplevel };push @{$toplevel{lc$toplevel }},$entry;push @$entry,lc($entry->[0])}for my$toplevel (sort keys%toplevel){my$fgroup=$toplevel_form_freq{$toplevel};$toplevel_form_freq{$toplevel}=(sort {$fgroup->{$b}<=> $fgroup->{$a}or $a cmp $b}keys %$fgroup)[0]}return(\%toplevel,\%toplevel_form_freq)if wantarray;return \%toplevel}sub _contents_filespec {my($self,$outdir)=@_;my$outfile=$self->contents_file;return unless$outfile;return$self->filespecsys->catfile($outdir,$outfile)}sub makepath {my($self,$outdir,$namelets)=@_;return unless @$namelets > 1;for my$i (0 .. ($#$namelets - 1)){my$dir=$self->filespecsys->catdir($outdir,@$namelets[0 .. $i]);if(-e $dir){die "$dir exists but not as a directory!?" unless -d $dir;next}DEBUG > 3 and print STDERR "  Making $dir\n";mkdir$dir,0777 or die "Can't mkdir $dir: $!\nAborting" }return}sub batch_mode_page_object_init {my$self=shift;my($page,$module,$infile,$outfile,$depth)=@_;$page->default_title($module);$page->index($self->index);$page->html_css($self-> _css_wad_to_markup($depth));$page->html_javascript($self->_javascript_wad_to_markup($depth));$self->add_header_backlink($page,$module,$infile,$outfile,$depth);$self->add_footer_backlink($page,$module,$infile,$outfile,$depth);return$self}sub add_header_backlink {my$self=shift;return if$self->no_contents_links;my($page,$module,$infile,$outfile,$depth)=@_;$page->html_header_after_title(join '',$page->html_header_after_title || '',qq[<p class="backlinktop"><b><a name="___top" href="],$self->url_up_to_contents($depth),qq[" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>\n],)if$self->contents_file ;return}sub add_footer_backlink {my$self=shift;return if$self->no_contents_links;my($page,$module,$infile,$outfile,$depth)=@_;$page->html_footer(join '',qq[<p class="backlinkbottom"><b><a name="___bottom" href="],$self->url_up_to_contents($depth),qq[" title="All Documents">&lt;&lt;</a></b></p>\n],$page->html_footer || '',)if$self->contents_file ;return}sub url_up_to_contents {my($self,$depth)=@_;--$depth;return join '/',('..')x $depth,esc($self->contents_file)}sub find_all_pods {my($self,$dirs)=@_;return$self->modnames2paths($dirs)}sub modnames2paths {my($self,$dirs)=@_;my$m2p;{my$search=$self->search_class->new;DEBUG and print STDERR "Searching via $search\n";$search->verbose(1)if DEBUG > 10;$search->progress($self->progress->copy->goal(0))if$self->progress;$search->shadows(0);$search->inc($dirs ? 0 : 1);$search->survey($dirs ? @$dirs : ());$m2p=$search->name2path;die "What, no name2path?!" unless$m2p}$self->muse("That's odd... no modules found!")unless keys %$m2p;if(DEBUG > 4){print STDERR "Modules found (name => path):\n";for my$m (sort {lc($a)cmp lc($b)}keys %$m2p){print STDERR "  $m  $$m2p{$m}\n"}print STDERR "(total ",scalar(keys %$m2p),")\n\n"}elsif(DEBUG){print STDERR "Found ",scalar(keys %$m2p)," modules.\n"}$self->muse("Found ",scalar(keys %$m2p)," modules.");return$m2p}sub _wopen {my($self,$outpath)=@_;require Symbol;my$out_fh=Symbol::gensym();DEBUG > 5 and print STDERR "Write-opening to $outpath\n";return$out_fh if open($out_fh,"> $outpath");require Carp;Carp::croak("Can't write-open $outpath: $!")}sub add_css {my($self,$url,$is_default,$name,$content_type,$media,$_code)=@_;return unless$url;unless($name){$name=$url;if($name !~ m/\?/ and $name =~ m{([^/]+)$}s){$name=$1;$name =~ s/\.css//i}}$media ||= 'all';$content_type ||= 'text/css';my$bunch=[$url,$name,$content_type,$media,$_code];if($is_default){unshift @{$self->_css_wad},$bunch}else {push @{$self->_css_wad},$bunch}return}sub _spray_css {my($self,$outdir)=@_;return unless$self->css_flurry();$self->_gen_css_wad();my$lol=$self->_css_wad;for my$chunk (@$lol){my$url=$chunk->[0];my$outfile;if(ref($chunk->[-1])and $url =~ m{^(_[-a-z0-9_]+\.css$)}){$outfile=$self->filespecsys->catfile($outdir,"$1");DEBUG > 5 and print STDERR "Noting $$chunk[0] as a file I'll create.\n"}else {DEBUG > 5 and print STDERR "OK, noting $$chunk[0] as an external CSS.\n";next}my$Cssout=$self->_wopen($outfile);print$Cssout ${$chunk->[-1]}or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";close($Cssout);DEBUG > 5 and print STDERR "Wrote $outfile\n"}return}sub _css_wad_to_markup {my($self,$depth)=@_;my@css=@{$self->_css_wad || return ''};return '' unless@css;my$rel='stylesheet';my$out='';--$depth;my$uplink=$depth ? ('../' x $depth): '';for my$chunk (@css){next unless$chunk and @$chunk;my($url1,$url2,$title,$type,$media)=($self->_maybe_uplink($chunk->[0],$uplink),esc(grep!ref($_),@$chunk));$out .= qq{<link rel="$rel" title="$title" type="$type" href="$url1$url2" media="$media" >\n};$rel='alternate stylesheet'}return$out}sub _maybe_uplink {my($self,$url,$uplink)=@_;($url =~ m{^\./} or $url !~ m{[/\:]})? $uplink : ''}sub _gen_css_wad {my$self=$_[0];my$css_template=$self->_css_template;for my$variation ('110n=blkbluw','010n=blkmagw','100n=blkcynw','101=whtprpk','001=whtnavk','010a=grygrnk','010b=whtgrng','101an=blkgrng','101bn=grygrnw',){my$outname=$variation;my($flipmode,@swap)=(($4 || ''),$1,$2,$3)if$outname =~ s/^([012])([012])([[012])([a-z]*)=?//s;@swap=()if '010' eq join '',@swap;my$this_css="/* This file is autogenerated.  Do not edit.  $variation */\n\n" .$css_template;if($flipmode =~ m/n/){$this_css =~ s/(#[0-9a-fA-F]{3})\b/_color_negate($1)/eg;$this_css =~ s/\bthin\b/medium/g}$this_css =~ s<#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])\b>
                    < join '', '#', ($1,$2,$3)[@swap] >eg if@swap;if($flipmode =~ m/a/){$this_css =~ s/#fff\b/#999/gi}elsif($flipmode =~ m/b/){$this_css =~ s/#000\b/#666/gi}my$name=$outname;$name =~ tr/-_/  /;$self->add_css("_$outname.css",0,$name,0,0,\$this_css)}for my$variation ('blkbluw','whtpurk','whtgrng','grygrnw',){my$outname=$variation;my$this_css=join "\n","/* This file is autogenerated.  Do not edit.  $outname */\n","\@import url(\"./_$variation.css\");",".indexgroup { display: none; }","\n",;my$name=$outname;$name =~ tr/-_/  /;$self->add_css("_$outname.css",0,$name,0,0,\$this_css)}return}sub _color_negate {my$x=lc $_[0];$x =~ tr[0123456789abcdef]
            [fedcba9876543210];return$x}sub add_javascript {my($self,$url,$content_type,$_code)=@_;return unless$url;push @{$self->_javascript_wad},[$url,$content_type || 'text/javascript',$_code ];return}sub _spray_javascript {my($self,$outdir)=@_;return unless$self->javascript_flurry();$self->_gen_javascript_wad();my$lol=$self->_javascript_wad;for my$script (@$lol){my$url=$script->[0];my$outfile;if(ref($script->[-1])and $url =~ m{^(_[-a-z0-9_]+\.js$)}){$outfile=$self->filespecsys->catfile($outdir,"$1");DEBUG > 5 and print STDERR "Noting $$script[0] as a file I'll create.\n"}else {DEBUG > 5 and print STDERR "OK, noting $$script[0] as an external JavaScript.\n";next}my$Jsout=$self->_wopen($outfile);print$Jsout ${$script->[-1]}or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";close($Jsout);DEBUG > 5 and print STDERR "Wrote $outfile\n"}return}sub _gen_javascript_wad {my$self=$_[0];my$js_code=$self->_javascript || return;$self->add_javascript("_podly.js",0,\$js_code);return}sub _javascript_wad_to_markup {my($self,$depth)=@_;my@scripts=@{$self->_javascript_wad || return ''};return '' unless@scripts;my$out='';--$depth;my$uplink=$depth ? ('../' x $depth): '';for my$s (@scripts){next unless$s and @$s;my($url1,$url2,$type,$media)=($self->_maybe_uplink($s->[0],$uplink),esc(grep!ref($_),@$s));$out .= qq{<script type="$type" src="$url1$url2"></script>\n}}return$out}sub _css_template {return$CSS}sub _javascript {return$JAVASCRIPT}$CSS=<<'EOCSS';$JAVASCRIPT=<<'EOJAVASCRIPT';1;
  /* For accessibility reasons, never specify text sizes in px/pt/pc/in/cm/mm */
  
  @media all { .hide { display: none; } }
  
  @media print {
    .noprint, div.indexgroup, .backlinktop, .backlinkbottom { display: none }
  
    * {
      border-color: black !important;
      color: black !important;
      background-color: transparent !important;
      background-image: none !important;
    }
  
    dl.superindex > dd  {
      word-spacing: .6em;
    }
  }
  
  @media aural, braille, embossed {
    div.indexgroup  { display: none; }  /* Too noisy, don't you think? */
    dl.superindex > dt:before { content: "Group ";  }
    dl.superindex > dt:after  { content: " contains:"; }
    .backlinktop    a:before  { content: "Back to contents"; }
    .backlinkbottom a:before  { content: "Back to contents"; }
  }
  
  @media aural {
    dl.superindex > dt  { pause-before: 600ms; }
  }
  
  @media screen, tty, tv, projection {
    .noscreen { display: none; }
  
    a:link    { color: #7070ff; text-decoration: underline; }
    a:visited { color: #e030ff; text-decoration: underline; }
    a:active  { color: #800000; text-decoration: underline; }
    body.contentspage a            { text-decoration: none; }
    a.u { color: #fff !important; text-decoration: none; }
  
    body.pod {
      margin: 0 5px;
      color:            #fff;
      background-color: #000;
    }
  
    body.pod h1, body.pod h2, body.pod h3, body.pod h4  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      margin-top: 1.2em;
      margin-bottom: .1em;
      border-top: thin solid transparent;
      /* margin-left: -5px;  border-left: 2px #7070ff solid;  padding-left: 3px; */
    }
    
    body.pod h1  { border-top-color: #0a0; }
    body.pod h2  { border-top-color: #080; }
    body.pod h3  { border-top-color: #040; }
    body.pod h4  { border-top-color: #010; }
  
    p.backlinktop + h1 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h2 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h3 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h4 { border-top: none; margin-top: 0em;  }
  
    body.pod dt {
      font-size: 105%; /* just a wee bit more than normal */
    }
  
    .indexgroup { font-size: 80%; }
  
    .backlinktop,   .backlinkbottom    {
      margin-left:  -5px;
      margin-right: -5px;
      background-color:         #040;
      border-top:    thin solid #050;
      border-bottom: thin solid #050;
    }
    
    .backlinktop a, .backlinkbottom a  {
      text-decoration: none;
      color: #080;
      background-color:  #000;
      border: thin solid #0d0;
    }
    .backlinkbottom { margin-bottom: 0; padding-bottom: 0; }
    .backlinktop    { margin-top:    0; padding-top:    0; }
  
    body.contentspage {
      color:            #fff;
      background-color: #000;
    }
    
    body.contentspage h1  {
      color:            #0d0;
      margin-left: 1em;
      margin-right: 1em;
      text-indent: -.9em;
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      border-top:    thin solid #fff;
      border-bottom: thin solid #fff;
      text-align: center;
    }
  
    dl.superindex > dt  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      font-size: 90%;
      margin-top: .45em;
      /* margin-bottom: -.15em; */
    }
    dl.superindex > dd  {
      word-spacing: .6em;    /* most important rule here! */
    }
    dl.superindex > a:link  {
      text-decoration: none;
      color: #fff;
    }
  
    .contentsfooty {
      border-top: thin solid #999;
      font-size: 90%;
    }
    
  }
  
  /* The End */
  
  EOCSS
  
  // From http://www.alistapart.com/articles/alternate/
  
  function setActiveStyleSheet(title) {
    var i, a, main;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("title")) {
        a.disabled = true;
        if(a.getAttribute("title") == title) a.disabled = false;
      }
    }
  }
  
  function getActiveStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("title")
         && !a.disabled
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function getPreferredStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("rel").indexOf("alt") == -1
         && a.getAttribute("title")
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function createCookie(name,value,days) {
    if (days) {
      var date = new Date();
      date.setTime(date.getTime()+(days*24*60*60*1000));
      var expires = "; expires="+date.toGMTString();
    }
    else expires = "";
    document.cookie = name+"="+value+expires+"; path=/";
  }
  
  function readCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for(var i=0  ;  i < ca.length  ;  i++) {
      var c = ca[i];
      while (c.charAt(0)==' ') c = c.substring(1,c.length);
      if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
    }
    return null;
  }
  
  window.onload = function(e) {
    var cookie = readCookie("style");
    var title = cookie ? cookie : getPreferredStyleSheet();
    setActiveStyleSheet(title);
  }
  
  window.onunload = function(e) {
    var title = getActiveStyleSheet();
    createCookie("style", title, 365);
  }
  
  var cookie = readCookie("style");
  var title = cookie ? cookie : getPreferredStyleSheet();
  setActiveStyleSheet(title);
  
  // The End
  
  EOJAVASCRIPT
POD_SIMPLE_HTMLBATCH

$fatpacked{"Pod/Simple/HTMLLegacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLLEGACY';
  require 5;package Pod::Simple::HTMLLegacy;use strict;use vars qw($VERSION);use Getopt::Long;$VERSION="5.01";sub pod2html {my@args=(@_);my($verbose,$infile,$outfile,$title);my$index=1;{my($help);my($netscape);local@ARGV=@args;GetOptions("help"=>\$help,"verbose!"=>\$verbose,"infile=s"=>\$infile,"outfile=s"=>\$outfile,"title=s"=>\$title,"index!"=>\$index,"netscape!"=>\$netscape,)or return bad_opts(@args);bad_opts(@args)if@ARGV;return help_message()if$help}for($infile,$outfile){$_=undef unless defined and length}if($verbose){warn sprintf "%s version %s\n",__PACKAGE__,$VERSION;warn "OK, processed args [@args] ...\n";warn sprintf " Verbose: %s\n Index: %s\n Infile: %s\n Outfile: %s\n Title: %s\n",map defined($_)? $_ : "(nil)",$verbose,$index,$infile,$outfile,$title,;*Pod::Simple::HTML::DEBUG=sub(){1}}require Pod::Simple::HTML;Pod::Simple::HTML->VERSION(3);die "No such input file as $infile\n" if defined$infile and!-e $infile;my$pod=Pod::Simple::HTML->new;$pod->force_title($title)if defined$title;$pod->index($index);return$pod->parse_from_file($infile,$outfile)}sub bad_opts {die _help_message()}sub help_message {print STDOUT _help_message()}sub _help_message {join '',"[",__PACKAGE__," version ",$VERSION,qq~]
  Usage:  pod2html --help --infile=<name> --outfile=<name>
     --verbose --index --noindex
  
  Options:
    --help         - prints this message.
    --[no]index    - generate an index at the top of the resulting html
                     (default behavior).
    --infile       - filename for the pod to convert (input taken from stdin
                     by default).
    --outfile      - filename for the resulting html file (output sent to
                     stdout by default).
    --title        - title that will appear in resulting html file.
    --[no]verbose  - self-explanatory (off by default).
  
  Note that pod2html is DEPRECATED, and this version implements only
   some of the options known to older versions.
  For more information, see 'perldoc pod2html'.
  ~}1;
POD_SIMPLE_HTMLLEGACY

$fatpacked{"Pod/Simple/LinkSection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_LINKSECTION';
  require 5;package Pod::Simple::LinkSection;use vars qw($VERSION);$VERSION='3.35';use strict;use Pod::Simple::BlackBox;use vars qw($VERSION);$VERSION='3.35';use overload('""'=>\&Pod::Simple::BlackBox::stringify_lol,'bool'=>\&Pod::Simple::BlackBox::stringify_lol,'fallback'=>1,);sub tack_on {$_[0]=['',{},"$_[0]" ];return $_[0][2].= $_[1]}sub as_string {goto&Pod::Simple::BlackBox::stringify_lol}sub stringify {goto&Pod::Simple::BlackBox::stringify_lol}sub new {my$class=shift;$class=ref($class)|| $class;my$new;if(@_==1){if (!ref($_[0]|| '')){return bless ['',{},$_[0]],$class}elsif(ref($_[0]|| '')eq 'ARRAY'){$new=[@{$_[0]}]}else {Carp::croak("$class new() doesn't know to clone $new")}}else {$new=['',{},@_ ]}for my$x (@$new){if(ref($x || '')eq 'ARRAY'){$x=$class->new($x)}elsif(ref($x || '')eq 'HASH'){$x={%$x }}}return bless$new,$class}1;
POD_SIMPLE_LINKSECTION

$fatpacked{"Pod/Simple/Methody.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_METHODY';
  require 5;package Pod::Simple::Methody;use strict;use Pod::Simple ();use vars qw(@ISA $VERSION);$VERSION='3.35';@ISA=('Pod::Simple');sub _handle_element_start {$_[1]=~ tr/-:./__/;($_[0]->can('start_' .$_[1])|| return)->($_[0],$_[2])}sub _handle_text {($_[0]->can('handle_text')|| return)->(@_)}sub _handle_element_end {$_[1]=~ tr/-:./__/;($_[0]->can('end_' .$_[1])|| return)->($_[0],$_[2])}1;
POD_SIMPLE_METHODY

$fatpacked{"Pod/Simple/Progress.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PROGRESS';
  require 5;package Pod::Simple::Progress;$VERSION='3.35';use strict;sub new {my($class,$delay)=@_;my$self=bless {'quiet_until'=>1},ref($class)|| $class;$self->to(*STDOUT{IO});$self->delay(defined($delay)? $delay : 5);return$self}sub copy {my$orig=shift;bless {%$orig,'quiet_until'=>1},ref($orig)}sub reach {my($self,$point,$note)=@_;if((my$now=time)>= $self->{'quiet_until'}){my$goal;my$to=$self->{'to'};print$to join('',($self->{'quiet_until'}==1)? (): '... ',(defined$point)? ('#',($goal=$self->{'goal'})? (' ' x (length($goal)- length($point)),$point,'/',$goal,): $point,$note ? ': ' : (),): (),$note || '',"\n");$self->{'quiet_until'}=$now + $self->{'delay'}}return$self}sub done {my($self,$note)=@_;$self->{'quiet_until'}=1;return$self->reach(undef,$note)}sub delay {return $_[0]{'delay'}if @_==1;$_[0]{'delay'}=$_[1];return $_[0]}sub goal {return $_[0]{'goal' }if @_==1;$_[0]{'goal' }=$_[1];return $_[0]}sub to {return $_[0]{'to' }if @_==1;$_[0]{'to' }=$_[1];return $_[0]}unless(caller){my$p=__PACKAGE__->new->goal(5);$p->reach(1,"Primus!");sleep 1;$p->reach(2,"Secundus!");sleep 3;$p->reach(3,"Tertius!");sleep 5;$p->reach(4);$p->reach(5,"Quintus!");sleep 1;$p->done("All done")}1;
POD_SIMPLE_PROGRESS

$fatpacked{"Pod/Simple/PullParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSER';
  require 5;package Pod::Simple::PullParser;$VERSION='3.35';use Pod::Simple ();BEGIN {@ISA=('Pod::Simple')}use strict;use Carp ();use Pod::Simple::PullParserStartToken;use Pod::Simple::PullParserEndToken;use Pod::Simple::PullParserTextToken;BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}__PACKAGE__->_accessorize('source_fh','source_scalar_ref','source_arrayref',);sub filter {my($self,$source)=@_;$self=$self->new unless ref$self;$source=*STDIN{IO}unless defined$source;$self->set_source($source);$self->output_fh(*STDOUT{IO});$self->run;return$self}sub parse_string_document {my$this=shift;$this->set_source(\ $_[0]);$this->run}sub parse_file {my($this,$filename)=@_;$this->set_source($filename);$this->run}sub run {use Carp ();if(__PACKAGE__ eq ref($_[0])|| $_[0]){Carp::croak "You can call run() only on subclasses of " .__PACKAGE__}else {Carp::croak join '',"You can't call run() because ",ref($_[0])|| $_[0]," didn't define a run() method"}}sub parse_lines {use Carp ();Carp::croak "Use set_source with ",__PACKAGE__," and subclasses, not parse_lines"}sub parse_line {use Carp ();Carp::croak "Use set_source with ",__PACKAGE__," and subclasses, not parse_line"}sub new {my$class=shift;my$self=$class->SUPER::new(@_);die "Couldn't construct for $class" unless$self;$self->{'token_buffer'}||= [];$self->{'start_token_class'}||= 'Pod::Simple::PullParserStartToken';$self->{'text_token_class'}||= 'Pod::Simple::PullParserTextToken';$self->{'end_token_class'}||= 'Pod::Simple::PullParserEndToken';DEBUG > 1 and print STDERR "New pullparser object: $self\n";return$self}sub get_token {my$self=shift;DEBUG > 1 and print STDERR "\nget_token starting up on $self.\n";DEBUG > 2 and print STDERR " Items in token-buffer (",scalar(@{$self->{'token_buffer'}}),") :\n",map("    " .$_->dump ."\n",@{$self->{'token_buffer'}}),@{$self->{'token_buffer'}}? '' : '       (no tokens)',"\n" ;until(@{$self->{'token_buffer'}}){DEBUG > 3 and print STDERR "I need to get something into my empty token buffer...\n";if($self->{'source_dead'}){DEBUG and print STDERR "$self 's source is dead.\n";push @{$self->{'token_buffer'}},undef}elsif(exists$self->{'source_fh'}){my@lines;my$fh=$self->{'source_fh'}|| Carp::croak('You have to call set_source before you can call get_token');DEBUG and print STDERR "$self 's source is filehandle $fh.\n";for(my$i=Pod::Simple::MANY_LINES;$i--;){DEBUG > 3 and print STDERR " Fetching a line from source filehandle $fh...\n";local $/=$Pod::Simple::NL;push@lines,scalar(<$fh>);DEBUG > 3 and print STDERR "  Line is: ",defined($lines[-1])? $lines[-1]: "<undef>\n";unless(defined$lines[-1]){DEBUG and print STDERR "That's it for that source fh!  Killing.\n";delete$self->{'source_fh'};last}}if(DEBUG > 8){print STDERR "* I've gotten ",scalar(@lines)," lines:\n";for my$l (@lines){if(defined$l){print STDERR "  line {$l}\n"}else {print STDERR "  line undef\n"}}print STDERR "* end of ",scalar(@lines)," lines\n"}$self->SUPER::parse_lines(@lines)}elsif(exists$self->{'source_arrayref'}){DEBUG and print STDERR "$self 's source is arrayref $self->{'source_arrayref'}, with ",scalar(@{$self->{'source_arrayref'}})," items left in it.\n";DEBUG > 3 and print STDERR "  Fetching ",Pod::Simple::MANY_LINES," lines.\n";$self->SUPER::parse_lines(splice @{$self->{'source_arrayref'}},0,Pod::Simple::MANY_LINES);unless(@{$self->{'source_arrayref'}}){DEBUG and print STDERR "That's it for that source arrayref!  Killing.\n";$self->SUPER::parse_lines(undef);delete$self->{'source_arrayref'}}}elsif(exists$self->{'source_scalar_ref'}){DEBUG and print STDERR "$self 's source is scalarref $self->{'source_scalar_ref'}, with ",length(${$self->{'source_scalar_ref'}})- (pos(${$self->{'source_scalar_ref'}})|| 0)," characters left to parse.\n";DEBUG > 3 and print STDERR " Fetching a line from source-string...\n";if(${$self->{'source_scalar_ref'}}=~ m/([^\n\r]*)((?:\r?\n)?)/g){$self->SUPER::parse_lines($1)if length($1)or length($2)or pos(${$self->{'source_scalar_ref'}})!=length(${$self->{'source_scalar_ref'}})}else {$self->SUPER::parse_lines(undef);delete$self->{'source_scalar_ref'};DEBUG and print STDERR "That's it for that source scalarref!  Killing.\n"}}else {die "What source??"}}DEBUG and print STDERR "get_token about to return ",Pod::Simple::pretty(@{$self->{'token_buffer'}}? $self->{'token_buffer'}[-1]: undef),"\n";return shift @{$self->{'token_buffer'}}}sub unget_token {my$self=shift;DEBUG and print STDERR "Ungetting ",scalar(@_)," tokens: ",@_ ? "@_\n" : "().\n";for my$t (@_){Carp::croak "Can't unget that, because it's not a token -- it's undef!" unless defined$t;Carp::croak "Can't unget $t, because it's not a token -- it's a string!" unless ref$t;Carp::croak "Can't unget $t, because it's not a token object!" unless UNIVERSAL::can($t,'type')}unshift @{$self->{'token_buffer'}},@_;DEBUG > 1 and print STDERR "Token buffer now has ",scalar(@{$self->{'token_buffer'}})," items in it.\n";return}sub set_source {my$self=shift @_;return$self->{'source_fh'}unless @_;Carp::croak("Cannot assign new source to pull parser; create a new instance, instead")if$self->{'source_fh'}|| $self->{'source_scalar_ref'}|| $self->{'source_arrayref'};my$handle;if(!defined $_[0]){Carp::croak("Can't use empty-string as a source for set_source")}elsif(ref(\($_[0]))eq 'GLOB'){$self->{'source_filename'}='' .($handle=$_[0]);DEBUG and print STDERR "$self 's source is glob $_[0]\n"}elsif(ref($_[0])eq 'SCALAR'){$self->{'source_scalar_ref'}=$_[0];DEBUG and print STDERR "$self 's source is scalar ref $_[0]\n";return}elsif(ref($_[0])eq 'ARRAY'){$self->{'source_arrayref'}=$_[0];DEBUG and print STDERR "$self 's source is array ref $_[0]\n";return}elsif(ref $_[0]){$self->{'source_filename'}='' .($handle=$_[0]);DEBUG and print STDERR "$self 's source is fh-obj $_[0]\n"}elsif(!length $_[0]){Carp::croak("Can't use empty-string as a source for set_source")}else {DEBUG and print STDERR "$self 's source is filename $_[0]\n";{local*PODSOURCE;open(PODSOURCE,"<$_[0]")|| Carp::croak "Can't open $_[0]: $!";$handle=*PODSOURCE{IO}}$self->{'source_filename'}=$_[0];DEBUG and print STDERR "  Its name is $_[0].\n"}$self->{'source_fh'}=$handle;DEBUG and print STDERR "  Its handle is $handle\n";return 1}sub get_title_short {shift->get_short_title(@_)}sub get_short_title {my$title=shift->get_title(@_);$title=$1 if$title =~ m/^(\S{1,60})\s+--?\s+./s;return$title}sub get_title {shift->_get_titled_section('NAME',max_token=>50,desperate=>1,@_)}sub get_version {shift->_get_titled_section('VERSION',max_token=>400,accept_verbatim=>1,max_content_length=>3_000,@_,)}sub get_description {shift->_get_titled_section('DESCRIPTION',max_token=>400,max_content_length=>3_000,@_,)}sub get_authors {shift->get_author(@_)}sub get_author {my$this=shift;$this->_get_titled_section('AUTHOR',max_token=>10_000,@_)|| $this->_get_titled_section('AUTHORS',max_token=>10_000,@_)}sub _get_titled_section {my($self,$titlename,%options)=(@_);my$max_token=delete$options{'max_token'};my$desperate_for_title=delete$options{'desperate'};my$accept_verbatim=delete$options{'accept_verbatim'};my$max_content_length=delete$options{'max_content_length'};my$nocase=delete$options{'nocase'};$max_content_length=120 unless defined$max_content_length;Carp::croak("Unknown " .((1==keys%options)? "option: " : "options: ").join " ",map "[$_]",sort keys%options)if keys%options;my%content_containers;$content_containers{'Para'}=1;if($accept_verbatim){$content_containers{'Verbatim'}=1;$content_containers{'VerbatimFormatted'}=1}my$token_count=0;my$title;my@to_unget;my$state=0;my$depth=0;Carp::croak "What kind of titlename is \"$titlename\"?!" unless defined$titlename and $titlename =~ m/^[A-Z ]{1,60}$/s;my$titlename_re=quotemeta($titlename);my$head1_text_content;my$para_text_content;my$skipX;while(++$token_count <= ($max_token || 1_000_000)and defined(my$token=$self->get_token)){push@to_unget,$token;if ($state==0){if($token->is_start and $token->tagname eq 'head1'){DEBUG and print STDERR "  Found head1.  Seeking content...\n";++$state;$head1_text_content=''}}elsif($state==1){if($token->is_text){unless ($skipX){DEBUG and print STDERR "   Adding \"",$token->text,"\" to head1-content.\n";$head1_text_content .= $token->text}}elsif($token->is_tagname('X')){$skipX=$token->is_start;DEBUG and print STDERR +($skipX ? 'Start' : 'End'),'ing ignoring of X<> tag'}elsif($token->is_end and $token->tagname eq 'head1'){DEBUG and print STDERR "  Found end of head1.  Considering content...\n";$head1_text_content=uc$head1_text_content if$nocase;if($head1_text_content eq $titlename or $head1_text_content =~ m/\($titlename_re\)/s){DEBUG and print STDERR "  Yup, it was $titlename.  Seeking next para-content...\n";++$state}elsif($desperate_for_title and $head1_text_content =~ m/\S/ and $head1_text_content !~ m/^[ A-Z]+$/s and $head1_text_content !~ m/\((?:
               NAME | TITLE | VERSION | AUTHORS? | DESCRIPTION | SYNOPSIS
               | COPYRIGHT | LICENSE | NOTES? | FUNCTIONS? | METHODS?
               | CAVEATS? | BUGS? | SEE\ ALSO | SWITCHES | ENVIRONMENT
              )\)/sx and ($max_content_length ? (length($head1_text_content)<= $max_content_length): 1)){($title=$head1_text_content)=~ s/\s+$//;DEBUG and print STDERR "  It looks titular: \"$title\".\n\n  Using that.\n";last}else {--$state;DEBUG and print STDERR "  Didn't look titular ($head1_text_content).\n","\n  Dropping back to seeking-head1-content mode...\n"}}}elsif($state==2){if($token->is_start and $content_containers{$token->tagname }){DEBUG and print STDERR "  Found start of Para.  Accumulating content...\n";$para_text_content='';++$state}else {DEBUG and print "  Didn't see an immediately subsequent start-Para.  Reseeking H1\n";$state=0}}elsif($state==3){if($token->is_text){DEBUG and print STDERR "   Adding \"",$token->text,"\" to para-content.\n";$para_text_content .= $token->text}elsif($token->is_end and $content_containers{$token->tagname }){DEBUG and print STDERR "  Found end of Para.  Considering content: ",$para_text_content,"\n";if($para_text_content =~ m/\S/ and ($max_content_length ? (length($para_text_content)<= $max_content_length): 1)){DEBUG and print STDERR "  It looks contentworthy, I guess.  Using it.\n";$title=$para_text_content;last}else {DEBUG and print STDERR "  Doesn't look at all contentworthy!\n  Giving up.\n";undef$title;last}}}else {die "IMPOSSIBLE STATE $state!\n"}}$self->unget_token(@to_unget);if(DEBUG){if(defined$title){print STDERR "  Returning title <$title>\n"}else {print STDERR "Returning title <>\n"}}return '' unless defined$title;$title =~ s/^\s+//;return$title}sub _handle_element_start {my$self=shift;DEBUG > 2 and print STDERR "++ $_[0] (",map("<$_> ",%{$_[1]}),")\n";push @{$self->{'token_buffer'}},$self->{'start_token_class'}->new(@_);return}sub _handle_text {my$self=shift;DEBUG > 2 and print STDERR "== $_[0]\n";push @{$self->{'token_buffer'}},$self->{'text_token_class'}->new(@_);return}sub _handle_element_end {my$self=shift;DEBUG > 2 and print STDERR "-- $_[0]\n";push @{$self->{'token_buffer'}},$self->{'end_token_class'}->new(@_);return}1;
POD_SIMPLE_PULLPARSER

$fatpacked{"Pod/Simple/PullParserEndToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERENDTOKEN';
  require 5;package Pod::Simple::PullParserEndToken;use Pod::Simple::PullParserToken ();use strict;use vars qw(@ISA $VERSION);@ISA=('Pod::Simple::PullParserToken');$VERSION='3.35';sub new {my$class=shift;return bless ['end',@_],ref($class)|| $class}sub tagname {(@_==2)? ($_[0][1]=$_[1]): $_[0][1]}sub tag {shift->tagname(@_)}sub is_tagname {$_[0][1]eq $_[1]}sub is_tag {shift->is_tagname(@_)}1;
POD_SIMPLE_PULLPARSERENDTOKEN

$fatpacked{"Pod/Simple/PullParserStartToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERSTARTTOKEN';
  require 5;package Pod::Simple::PullParserStartToken;use Pod::Simple::PullParserToken ();use strict;use vars qw(@ISA $VERSION);@ISA=('Pod::Simple::PullParserToken');$VERSION='3.35';sub new {my$class=shift;return bless ['start',@_],ref($class)|| $class}sub tagname {(@_==2)? ($_[0][1]=$_[1]): $_[0][1]}sub tag {shift->tagname(@_)}sub is_tagname {$_[0][1]eq $_[1]}sub is_tag {shift->is_tagname(@_)}sub attr_hash {$_[0][2]||= {}}sub attr {if(@_==2){${$_[0][2]|| return undef}{$_[1]}}elsif(@_ > 2){${$_[0][2]||= {}}{$_[1]}=$_[2]}else {require Carp;Carp::croak('usage: $object->attr("val") or $object->attr("key", "newval")');return undef}}1;
POD_SIMPLE_PULLPARSERSTARTTOKEN

$fatpacked{"Pod/Simple/PullParserTextToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTEXTTOKEN';
  require 5;package Pod::Simple::PullParserTextToken;use Pod::Simple::PullParserToken ();use strict;use vars qw(@ISA $VERSION);@ISA=('Pod::Simple::PullParserToken');$VERSION='3.35';sub new {my$class=shift;return bless ['text',@_],ref($class)|| $class}sub text {(@_==2)? ($_[0][1]=$_[1]): $_[0][1]}sub text_r {\ $_[0][1]}1;
POD_SIMPLE_PULLPARSERTEXTTOKEN

$fatpacked{"Pod/Simple/PullParserToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTOKEN';
  require 5;package Pod::Simple::PullParserToken;@ISA=();$VERSION='3.35';use strict;sub new {my$class=shift;return bless [@_],ref($class)|| $class}sub type {$_[0][0]}sub dump {Pod::Simple::pretty([@{$_[0]}])}sub is_start {$_[0][0]eq 'start'}sub is_end {$_[0][0]eq 'end'}sub is_text {$_[0][0]eq 'text'}1;
POD_SIMPLE_PULLPARSERTOKEN

$fatpacked{"Pod/Simple/RTF.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_RTF';
  require 5;package Pod::Simple::RTF;use strict;use vars qw($VERSION @ISA %Escape $WRAP %Tagmap);$VERSION='3.35';use Pod::Simple::PullParser ();BEGIN {@ISA=('Pod::Simple::PullParser')}use Carp ();BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}$WRAP=1 unless defined$WRAP;my$cntrl='[:cntrl:]';$cntrl='\x00-\x1F\x7F' unless eval "qr/[$cntrl]/";my$not_ascii='[:^ascii:]';$not_ascii='\x80-\xFF' unless eval "qr/[$not_ascii]/";sub _openclose {return map {;m/^([-A-Za-z]+)=(\w[^\=]*)$/s or die "what's <$_>?";($1,"{\\$2\n","/$1","}")}@_}my@_to_accept;%Tagmap=(_openclose('B=cs18\b','I=cs16\i','C=cs19\f1\lang1024\noproof','F=cs17\i\lang1024\noproof','VerbatimI=cs26\i','VerbatimB=cs27\b','VerbatimBI=cs28\b\i',map {;m/^([-a-z]+)/s && push@_to_accept,$1;$_}qw[underline=ul smallcaps=scaps shadow=shad superscript=super subscript=sub strikethrough=strike outline=outl emboss=embo engrave=impr dotted-underline=uld dash-underline=uldash dot-dash-underline=uldashd dot-dot-dash-underline=uldashdd double-underline=uldb thick-underline=ulth word-underline=ulw wave-underline=ulwave]),'L=pod'=>'{\cs22\i'."\n",'L=url'=>'{\cs23\i'."\n",'L=man'=>'{\cs24\i'."\n",'/L'=>'}','Data'=>"\n",'/Data'=>"\n",'Verbatim'=>"\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",'/Verbatim'=>"\n\\par}\n",'VerbatimFormatted'=>"\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",'/VerbatimFormatted'=>"\n\\par}\n",'Para'=>"\n{\\pard\\li#rtfindent#\\sa180\n",'/Para'=>"\n\\par}\n",'head1'=>"\n{\\pard\\li#rtfindent#\\s31\\keepn\\sb90\\sa180\\f2\\fs#head1_halfpoint_size#\\ul{\n",'/head1'=>"\n}\\par}\n",'head2'=>"\n{\\pard\\li#rtfindent#\\s32\\keepn\\sb90\\sa180\\f2\\fs#head2_halfpoint_size#\\ul{\n",'/head2'=>"\n}\\par}\n",'head3'=>"\n{\\pard\\li#rtfindent#\\s33\\keepn\\sb90\\sa180\\f2\\fs#head3_halfpoint_size#\\ul{\n",'/head3'=>"\n}\\par}\n",'head4'=>"\n{\\pard\\li#rtfindent#\\s34\\keepn\\sb90\\sa180\\f2\\fs#head4_halfpoint_size#\\ul{\n",'/head4'=>"\n}\\par}\n",'item-bullet'=>"\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",'/item-bullet'=>"\n\\par}\n",'item-number'=>"\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",'/item-number'=>"\n\\par}\n",'item-text'=>"\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",'/item-text'=>"\n\\par}\n",);sub new {my$new=shift->SUPER::new(@_);$new->nix_X_codes(1);$new->nbsp_for_S(1);$new->accept_targets('rtf','RTF');$new->{'Tagmap'}={%Tagmap};$new->accept_codes(@_to_accept);$new->accept_codes('VerbatimFormatted');DEBUG > 2 and print STDERR "To accept: ",join(' ',@_to_accept),"\n";$new->doc_lang(($ENV{'RTFDEFLANG'}|| '')=~ m/^(\d{1,10})$/s ? $1 : ($ENV{'RTFDEFLANG'}|| '')=~ m/^0?x([a-fA-F0-9]{1,10})$/s ? hex($1): ($ENV{'RTFDEFLANG'}|| '')=~ m/^([a-fA-F0-9]{4})$/s ? hex($1): '1033');$new->head1_halfpoint_size(32);$new->head2_halfpoint_size(28);$new->head3_halfpoint_size(25);$new->head4_halfpoint_size(22);$new->codeblock_halfpoint_size(18);$new->header_halfpoint_size(17);$new->normal_halfpoint_size(25);return$new}__PACKAGE__->_accessorize('doc_lang','head1_halfpoint_size','head2_halfpoint_size','head3_halfpoint_size','head4_halfpoint_size','codeblock_halfpoint_size','header_halfpoint_size','normal_halfpoint_size','no_proofing_exemptions',);sub run {my$self=$_[0];return$self->do_middle if$self->bare_output;return $self->do_beginning && $self->do_middle && $self->do_end}sub do_middle {my$self=$_[0];my$fh=$self->{'output_fh'};my($token,$type,$tagname,$scratch);my@stack;my@indent_stack;$self->{'rtfindent'}=0 unless defined$self->{'rtfindent'};while($token=$self->get_token){if(($type=$token->type)eq 'text'){if($self->{'rtfverbatim'}){DEBUG > 1 and print STDERR "  $type ",$token->text," in verbatim!\n";rtf_esc_codely($scratch=$token->text);print$fh $scratch;next}DEBUG > 1 and print STDERR "  $type ",$token->text,"\n";$scratch=$token->text;$scratch =~ tr/\t\cb\cc/ /d;$self->{'no_proofing_exemptions'}or $scratch =~ s/(?:
             ^
             |
             (?<=[\r\n\t "\[\<\(])
           )   # start on whitespace, sequence-start, or quote
           ( # something looking like a Perl token:
            (?:
             [\$\@\:\<\*\\_]\S+  # either starting with a sigil, etc.
            )
            |
            # or starting alpha, but containing anything strange:
            (?:
             [a-zA-Z'${not_ascii}]+[\$\@\:_<>\(\\\*]\S+
            )
           )
          /\cb$1\cc/xsg ;rtf_esc($scratch);$scratch =~ s/(
              [^\r\n]{65}        # Snare 65 characters from a line
              [^\r\n ]{0,50}     #  and finish any current word
             )
             (\ {1,10})(?![\r\n]) # capture some spaces not at line-end
            /$1$2\n/gx if$WRAP;print$fh $scratch}elsif($type eq 'start'){DEBUG > 1 and print STDERR "  +$type ",$token->tagname," (",map("<$_> ",%{$token->attr_hash}),")\n";if(($tagname=$token->tagname)eq 'Verbatim' or $tagname eq 'VerbatimFormatted'){++$self->{'rtfverbatim'};my$next=$self->get_token;next unless defined$next;my$line_count=1;if($next->type eq 'text'){my$t=$next->text_r;while($$t =~ m/$/mg){last if ++$line_count > 15}DEBUG > 3 and print STDERR "    verbatim line count: $line_count\n"}$self->unget_token($next);$self->{'rtfkeep'}=($line_count > 15)? '' : '\keepn' }elsif($tagname =~ m/^item-/s){my@to_unget;my$text_count_here=0;$self->{'rtfitemkeepn'}='';while(1){push@to_unget,$self->get_token;pop(@to_unget),last unless defined$to_unget[-1];if($to_unget[-1]->type eq 'text'){if(($text_count_here += length ${$to_unget[-1]->text_r})> 150){DEBUG > 1 and print STDERR "    item-* is too long to be keepn'd.\n";last}}elsif (@to_unget > 1 and $to_unget[-2]->type eq 'end' and $to_unget[-2]->tagname =~ m/^item-/s){$self->{'rtfitemkeepn'}='\keepn' if $to_unget[-1]->type eq 'start' and $to_unget[-1]->tagname eq 'Para';DEBUG > 1 and printf STDERR "    item-* before %s(%s) %s keepn'd.\n",$to_unget[-1]->type,$to_unget[-1]->can('tagname')? $to_unget[-1]->tagname : '',$self->{'rtfitemkeepn'}? "gets" : "doesn't get";last}elsif (@to_unget > 40){DEBUG > 1 and print STDERR "    item-* now has too many tokens (",scalar(@to_unget),(DEBUG > 4)? (q<: >,map($_->dump,@to_unget)): (),") to be keepn'd.\n";last}}$self->unget_token(@to_unget)}elsif($tagname =~ m/^over-/s){push@stack,$1;push@indent_stack,int($token->attr('indent')* 4 * $self->normal_halfpoint_size);DEBUG and print STDERR "Indenting over $indent_stack[-1] twips.\n";$self->{'rtfindent'}+= $indent_stack[-1]}elsif ($tagname eq 'L'){$tagname .= '=' .($token->attr('type')|| 'pod')}elsif ($tagname eq 'Data'){my$next=$self->get_token;next unless defined$next;unless($next->type eq 'text'){$self->unget_token($next);next}DEBUG and print STDERR "    raw text ",$next->text,"\n";printf$fh "\n" .$next->text ."\n";next}defined($scratch=$self->{'Tagmap'}{$tagname})or next;$scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g;print$fh $scratch;if ($tagname eq 'item-number'){print$fh $token->attr('number'),". \n"}elsif ($tagname eq 'item-bullet'){print$fh "\\'",ord("_"),"\n"}}elsif($type eq 'end'){DEBUG > 1 and print STDERR "  -$type ",$token->tagname,"\n";if(($tagname=$token->tagname)=~ m/^over-/s){DEBUG and print STDERR "Indenting back $indent_stack[-1] twips.\n";$self->{'rtfindent'}-= pop@indent_stack;pop@stack}elsif($tagname eq 'Verbatim' or $tagname eq 'VerbatimFormatted'){--$self->{'rtfverbatim'}}defined($scratch=$self->{'Tagmap'}{"/$tagname"})or next;$scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g;print$fh $scratch}}return 1}sub do_beginning {my$self=$_[0];my$fh=$self->{'output_fh'};return print$fh join '',$self->doc_init,$self->font_table,$self->stylesheet,$self->color_table,$self->doc_info,$self->doc_start,"\n" }sub do_end {my$self=$_[0];my$fh=$self->{'output_fh'};return print$fh '}'}sub stylesheet {return sprintf <<'END',$_[0]->codeblock_halfpoint_size(),$_[0]->head1_halfpoint_size(),$_[0]->head2_halfpoint_size(),$_[0]->head3_halfpoint_size(),$_[0]->head4_halfpoint_size(),}sub font_table {return <<'END'}sub doc_init {return <<'END'}sub color_table {return <<'END'}sub doc_info {my$self=$_[0];my$class=ref($self)|| $self;my$tag=__PACKAGE__ .' ' .$VERSION;unless($class eq __PACKAGE__){$tag=" ($tag)";$tag=" v" .$self->VERSION .$tag if defined$self->VERSION;$tag=$class .$tag}return sprintf <<'END',$tag,$ISA[0],$ISA[0]->VERSION(),$],scalar(gmtime),}sub doc_start {my$self=$_[0];my$title=$self->get_short_title();DEBUG and print STDERR "Short Title: <$title>\n";$title .= ' ' if length$title;$title =~ s/ *$/ /s;$title =~ s/^ //s;$title =~ s/ $/, /s;my$is_obviously_module_name;$is_obviously_module_name=1 if$title =~ m/^\S+$/s and $title =~ m/::/s;DEBUG and print STDERR "Title0: <$title>\n";$title=rtf_esc($title);DEBUG and print STDERR "Title1: <$title>\n";$title='\lang1024\noproof ' .$title if$is_obviously_module_name;return sprintf <<'END',($self->doc_lang)x 2,$self->header_halfpoint_size,$title,$self->normal_halfpoint_size,}use integer;sub rtf_esc {my$x;if(!defined wantarray){for(@_){s/([F${cntrl}\-\\\{\}${not_ascii}])/$Escape{$1}/g;s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg}return}elsif(wantarray){return map {;($x=$_)=~ s/([F${cntrl}\-\\\{\}${not_ascii}])/$Escape{$1}/g;$x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;$x}@_}else {($x=((@_==1)? $_[0]: join '',@_))=~ s/([F${cntrl}\-\\\{\}${not_ascii}])/$Escape{$1}/g;$x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;return$x}}sub rtf_esc_codely {my$x;if(!defined wantarray){for(@_){s/([F${cntrl}\\\{\}${not_ascii}])/$Escape{$1}/g;s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg}return}elsif(wantarray){return map {;($x=$_)=~ s/([F${cntrl}\\\{\}${not_ascii}])/$Escape{$1}/g;$x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;$x}@_}else {($x=((@_==1)? $_[0]: join '',@_))=~ s/([F${cntrl}\\\{\}${not_ascii}])/$Escape{$1}/g;$x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;return$x}}%Escape=((($] lt 5.007_003)? (map((chr($_),chr($_)),0x20 .. 0x7E),map((chr($_),sprintf("\\'%02x",$_)),0x00 .. 0x1F,0x5c,0x7b,0x7d,0x7f .. 0xFF,0x46)): (map((chr(utf8::unicode_to_native($_)),chr(utf8::unicode_to_native($_))),0x20 .. 0x7E),map((chr($_),sprintf("\\'%02x",utf8::unicode_to_native($_))),0x00 .. 0x1F,0x5c,0x7b,0x7d,0x7f .. 0xFF,0x46))),"\r"=>"\n","\cj"=>"\n","\n"=>"\n\\line ","\t"=>"\\tab ","\f"=>"\n\\page\n","-"=>"\\_",$Pod::Simple::nbsp=>"\\~",$Pod::Simple::shy=>"\\-","\n"=>"\\line\n","\r"=>"\n","\cb"=>"{\n\\cs21\\lang1024\\noproof ","\cc"=>"}",);1;
  {\stylesheet
  {\snext0 Normal;}
  {\*\cs10 \additive Default Paragraph Font;}
  {\*\cs16 \additive \i \sbasedon10 pod-I;}
  {\*\cs17 \additive \i\lang1024\noproof \sbasedon10 pod-F;}
  {\*\cs18 \additive \b \sbasedon10 pod-B;}
  {\*\cs19 \additive \f1\lang1024\noproof\sbasedon10 pod-C;}
  {\s20\ql \li0\ri0\sa180\widctlpar\f1\fs%s\lang1024\noproof\sbasedon0 \snext0 pod-codeblock;}
  {\*\cs21 \additive \lang1024\noproof \sbasedon10 pod-computerese;}
  {\*\cs22 \additive \i\lang1024\noproof\sbasedon10 pod-L-pod;}
  {\*\cs23 \additive \i\lang1024\noproof\sbasedon10 pod-L-url;}
  {\*\cs24 \additive \i\lang1024\noproof\sbasedon10 pod-L-man;}
  
  {\*\cs25 \additive \f1\lang1024\noproof\sbasedon0 pod-codelbock-plain;}
  {\*\cs26 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-ital;}
  {\*\cs27 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold;}
  {\*\cs28 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold-ital;}
  
  {\s31\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head1;}
  {\s32\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head2;}
  {\s33\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head3;}
  {\s34\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head4;}
  }
  
  END
  {\fonttbl
  {\f0\froman Times New Roman;}
  {\f1\fmodern Courier New;}
  {\f2\fswiss Arial;}
  }
  
  END
  {\rtf1\ansi\deff0
  
  END
  {\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
  END
  {\info{\doccomm
  %s
   using %s v%s
   under Perl v%s at %s GMT}
  {\author [see doc]}{\company [see doc]}{\operator [see doc]}
  }
  
  END
  \deflang%s\plain\lang%s\widowctrl
  {\header\pard\qr\plain\f2\fs%s
  %s
  p.\chpgn\par}
  \fs%s
  
  END
POD_SIMPLE_RTF

$fatpacked{"Pod/Simple/Search.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SEARCH';
  require 5.005;package Pod::Simple::Search;use strict;use vars qw($VERSION $MAX_VERSION_WITHIN $SLEEPY);$VERSION='3.35';BEGIN {*DEBUG=sub () {0}unless defined&DEBUG}use Carp ();$SLEEPY=1 if!defined$SLEEPY and $^O =~ /mswin|mac/i;$MAX_VERSION_WITHIN ||= 60;my$IS_CASE_INSENSITIVE=-e uc __FILE__ && -e lc __FILE__;use File::Spec ();use File::Basename qw(basename dirname);use Config ();use Cwd qw(cwd);__PACKAGE__->_accessorize('callback','progress','dir_prefix','inc','laborious','limit_glob','limit_re','shadows','verbose','name2path','path2name','recurse','ciseen');sub new {my$class=shift;my$self=bless {},ref($class)|| $class;$self->init;return$self}sub init {my$self=shift;$self->inc(1);$self->recurse(1);$self->verbose(DEBUG);return$self}sub survey {my($self,@search_dirs)=@_;$self=$self->new unless ref$self;$self->_expand_inc(\@search_dirs);$self->{'_scan_count'}=0;$self->{'_dirs_visited'}={};$self->path2name({});$self->name2path({});$self->ciseen({});$self->limit_re($self->_limit_glob_to_limit_re)if$self->{'limit_glob'};my$cwd=cwd();my$verbose=$self->verbose;local $_;for my$try (@search_dirs){unless(File::Spec->file_name_is_absolute($try)){$try=File::Spec->catfile($cwd,$try)}$try=File::Spec->canonpath($try);my$start_in;my$modname_prefix;if($self->{'dir_prefix'}){$start_in=File::Spec->catdir($try,grep length($_),split '[\\/:]+',$self->{'dir_prefix'});$modname_prefix=[grep length($_),split m{[:/\\]},$self->{'dir_prefix'}];$verbose and print "Appending \"$self->{'dir_prefix'}\" to $try, ","giving $start_in (= @$modname_prefix)\n"}else {$start_in=$try}if($self->{'_dirs_visited'}{$start_in}){$verbose and print "Directory '$start_in' already seen, skipping.\n";next}else {$self->{'_dirs_visited'}{$start_in}=1}unless(-e $start_in){$verbose and print "Skipping non-existent $start_in\n";next}my$closure=$self->_make_search_callback;if(-d $start_in){$verbose and print "Beginning excursion under $start_in\n";$self->_recurse_dir($start_in,$closure,$modname_prefix);$verbose and print "Back from excursion under $start_in\n\n"}elsif(-f _){$_=basename($start_in);$verbose and print "Pondering $start_in ($_)\n";$closure->($start_in,$_,0,[])}else {$verbose and print "Skipping mysterious $start_in\n"}}$self->progress and $self->progress->done("Noted $$self{'_scan_count'} Pod files total");$self->ciseen({});return unless defined wantarray;return$self->name2path unless wantarray;return$self->name2path,$self->path2name}sub _make_search_callback {my$self=$_[0];my($laborious,$verbose,$shadows,$limit_re,$callback,$progress,$path2name,$name2path,$recurse,$ciseen)=map scalar($self->$_()),qw(laborious verbose shadows limit_re callback progress path2name name2path recurse ciseen);my ($seen,$remember,$files_for);if ($IS_CASE_INSENSITIVE){$seen=sub {$ciseen->{lc $_[0]}};$remember=sub {$name2path->{$_[0]}=$ciseen->{lc $_[0]}=$_[1]};$files_for=sub {my$n=lc $_[0];grep {lc$path2name->{$_}eq $n}%{$path2name}}}else {$seen=sub {$name2path->{$_[0]}};$remember=sub {$name2path->{$_[0]}=$_[1]};$files_for=sub {my$n=$_[0];grep {$path2name->{$_}eq $n}%{$path2name}}}my($file,$shortname,$isdir,$modname_bits);return sub {($file,$shortname,$isdir,$modname_bits)=@_;if($isdir){unless($recurse){$verbose and print "Not recursing into '$file' as per requested.\n";return 'PRUNE'}if($self->{'_dirs_visited'}{$file}){$verbose and print "Directory '$file' already seen, skipping.\n";return 'PRUNE'}print "Looking in dir $file\n" if$verbose;unless ($laborious){if(m/^(\d+\.[\d_]{3,})\z/s and do {my$x=$1;$x =~ tr/_//d;$x!=$]}){$verbose and print "Perl $] version mismatch on $_, skipping.\n";return 'PRUNE'}if(m/^([A-Za-z][a-zA-Z0-9_]*)\z/s){$verbose and print "$_ is a well-named module subdir.  Looking....\n"}else {$verbose and print "$_ is a fishy directory name.  Skipping.\n";return 'PRUNE'}}$self->{'_dirs_visited'}{$file}=1;return}if($laborious){unless(m/\.(pod|pm|plx?)\z/i || -x _ and -T _){$verbose > 1 and print " Brushing off uninteresting $file\n";return}}else {unless(m/^[-_a-zA-Z0-9]+\.(?:pod|pm|plx?)\z/is){$verbose > 1 and print " Brushing off oddly-named $file\n";return}}$verbose and print "Considering item $file\n";my$name=$self->_path2modname($file,$shortname,$modname_bits);$verbose > 0.01 and print " Nominating $file as $name\n";if($limit_re and $name !~ m/$limit_re/i){$verbose and print "Shunning $name as not matching $limit_re\n";return}if(!$shadows and $seen->($name)){$verbose and print "Not worth considering $file ","-- already saw $name as ",join(' ',$files_for->($name)),"\n";return}$progress and $progress->reach($self->{'_scan_count'},"Scanning $file");return unless$self->contains_pod($file);++ $self->{'_scan_count'};if (my$prev=$seen->($name)){$verbose and print "Duplicate POD found (shadowing?): $name ($file)\n","    Already seen in ",join(' ',$files_for->($name)),"\n"}else {$remember->($name,$file)}$verbose and print "  Noting $name = $file\n";if($callback){local $_=$_;$callback->($file,$name)}$path2name->{$file}=$name;return}}sub _path2modname {my($self,$file,$shortname,$modname_bits)=@_;my@m=@$modname_bits;my$x;my$verbose=$self->verbose;while(@m and defined($x=lc($m[0]))and($x eq 'site_perl' or($x eq 'pod' and @m==1 and $shortname =~ m{^perl.*\.pod$}s)or $x =~ m{\\d+\\.z\\d+([_.]?\\d+)?} or $x eq lc($Config::Config{'archname'}))){shift@m}my$name=join '::',@m,$shortname;$self->_simplify_base($name);if ($^O eq 'VMS' && ($name eq lc($name)|| $name eq uc($name))){open PODFILE,"<$file" or die "_path2modname: Can't open $file: $!";my$in_pod=0;my$in_name=0;my$line;while ($line=<PODFILE>){chomp$line;$in_pod=1 if ($line =~ m/^=\w/);$in_pod=0 if ($line =~ m/^=cut/);next unless$in_pod;next if ($line =~ m/^\s*\z/);next if ($in_pod && ($line =~ m/^X</));if ($in_name){if ($line =~ m/(\w+::)?(\w+)/){my$podname=$2;my$prefix=$1 || '';$verbose and print "Attempting case restore of '$name' from '$prefix$podname'\n";unless ($name =~ s/$prefix$podname/$prefix$podname/i){$verbose and print "Attempting case restore of '$name' from '$podname'\n";$name =~ s/$podname/$podname/i}last}}$in_name=1 if ($line =~ m/^=head1 NAME/)}close PODFILE}return$name}sub _recurse_dir {my($self,$startdir,$callback,$modname_bits)=@_;my$maxdepth=$self->{'fs_recursion_maxdepth'}|| 10;my$verbose=$self->verbose;my$here_string=File::Spec->curdir;my$up_string=File::Spec->updir;$modname_bits ||= [];my$recursor;$recursor=sub {my($dir_long,$dir_bare)=@_;if(@$modname_bits >= 10){$verbose and print "Too deep! [@$modname_bits]\n";return}unless(-d $dir_long){$verbose > 2 and print "But it's not a dir! $dir_long\n";return}unless(opendir(INDIR,$dir_long)){$verbose > 2 and print "Can't opendir $dir_long : $!\n";closedir(INDIR);return}my@items=map {$_->[0]}sort {$a->[1]cmp $b->[1]|| $b->[2]cmp $a->[2]}map {(my$t=$_)=~ s/[.]p(m|lx?|od)\z//;[$_,$t,lc($1 || 'z')]}readdir(INDIR);closedir(INDIR);push @$modname_bits,$dir_bare unless$dir_bare eq '';my$i_full;for my$i (@items){next if$i eq $here_string or $i eq $up_string or $i eq '';$i_full=File::Spec->catfile($dir_long,$i);if(!-r $i_full){$verbose and print "Skipping unreadable $i_full\n"}elsif(-f $i_full){$_=$i;$callback->($i_full,$i,0,$modname_bits)}elsif(-d _){$i =~ s/\.DIR\z//i if $^O eq 'VMS';$_=$i;my$rv=$callback->($i_full,$i,1,$modname_bits)|| '';if($rv eq 'PRUNE'){$verbose > 1 and print "OK, pruning"}else {$recursor->(File::Spec->catdir($dir_long,$i),$i)}}else {$verbose > 1 and print "Skipping oddity $i_full\n"}}pop @$modname_bits;return};;local $_;$recursor->($startdir,'');undef$recursor;return}sub run {my$self=__PACKAGE__->new;$self->limit_glob($ARGV[0])if@ARGV;$self->callback(sub {my($file,$name)=@_;my$version='';if($file =~ m/\.pod$/i){DEBUG and print "Not looking for \$VERSION in .pod $file\n"}elsif(!open(INPOD,$file)){DEBUG and print "Couldn't open $file: $!\n";close(INPOD)}else {my$lines=0;while(<INPOD>){last if$lines++ > $MAX_VERSION_WITHIN;if(s/^\s*\$VERSION\s*=\s*//s and m/\d/){DEBUG and print "Found version line (#$lines): $_";s/\s*\#.*//s;s/\;\s*$//s;s/\s+$//s;s/\t+/ /s;$_="v$1" if m{^v?["']?([0-9_]+(\.[0-9_]+)*)["']?$}s or m{\$Revision:\s*([0-9_]+(?:\.[0-9_]+)*)\s*\$}s ;$_=sprintf("v%d.%s",map {s/_//g;$_}$1 =~ m/-(\d+)_([\d_]+)/)if m{\$Name:\s*([^\$]+)\$}s ;$version=$_;DEBUG and print "Noting $version as version\n";last}}close(INPOD)}print "$name\t$version\t$file\n";return});$self->survey}sub simplify_name {my($self,$str)=@_;if ($^O eq 'MacOS'){$str =~ s{^.*:+}{}s}else {$str =~ s{^.*/+}{}s}$self->_simplify_base($str);return$str}sub _simplify_base {$_[1]=~ s/\.(pod|pm|plx?)\z//i;$_[1]=~ s/\.(bat|exe|cmd)\z//i if $^O =~ /mswin|os2/i;$_[1]=~ s/\.(com)\z//i if $^O eq 'VMS';return}sub _expand_inc {my($self,$search_dirs)=@_;return unless$self->{'inc'};my%seen=map {File::Spec->rel2abs($_)=>1}@{$search_dirs};if ($^O eq 'MacOS'){push @$search_dirs,grep {!$seen{File::Spec->rel2abs($_)}++}$self->_mac_whammy(@INC)}else {push @$search_dirs,grep {!$seen{File::Spec->rel2abs($_)}++}@INC}$self->{'laborious'}=0;return}sub _mac_whammy {my@them;(undef,@them)=@_;for $_ (@them){if ($_ eq '.'){$_=':'}elsif ($_ =~ s|^((?:\.\./)+)|':' x (length($1)/3)|e){$_=':'.$_}else {$_ =~ s|^\./|:|}}return@them}sub _limit_glob_to_limit_re {my$self=$_[0];my$limit_glob=$self->{'limit_glob'}|| return;my$limit_re='^' .quotemeta($limit_glob).'$';$limit_re =~ s/\\\?/./g;$limit_re =~ s/\\\*/.*?/g;$limit_re =~ s/\.\*\?\$$//s;$self->{'verbose'}and print "Turning limit_glob $limit_glob into re $limit_re\n";if(!exists($self->{'dir_prefix'})and $limit_glob =~ m/^(?:\w+\:\:)+/s){$self->{'dir_prefix'}=join "::",$limit_glob =~ m/^(?:\w+::)+/sg;$self->{'verbose'}and print " and setting dir_prefix to $self->{'dir_prefix'}\n"}return$limit_re}sub _actual_filenames {my$dir=shift;my$fn=lc shift;opendir my$dh,$dir or return;return map {File::Spec->catdir($dir,$_)}grep {lc $_ eq $fn}readdir$dh}sub find {my($self,$pod,@search_dirs)=@_;$self=$self->new unless ref$self;Carp::carp 'Usage: \$self->find($podname, ...)' unless defined$pod and length$pod;my$verbose=$self->verbose;my@parts=split /::/,$pod;$verbose and print "Chomping {$pod} => {@parts}\n";$self->_expand_inc(\@search_dirs);push@search_dirs,$Config::Config{'scriptdir'}if$self->inc;my%seen_dir;while (my$dir=shift@search_dirs){next unless defined$dir and length$dir;next if$seen_dir{$dir};$seen_dir{$dir}=1;unless(-d $dir){print "Directory $dir does not exist\n" if$verbose}print "Looking in directory $dir\n" if$verbose;my$fullname=File::Spec->catfile($dir,@parts);print "Filename is now $fullname\n" if$verbose;for my$ext ('','.pod','.pm','.pl'){my$fullext=$fullname .$ext;if (-f $fullext and $self->contains_pod($fullext)){print "FOUND: $fullext\n" if$verbose;if (@parts > 1 && lc$parts[0]eq 'pod' && $IS_CASE_INSENSITIVE && $ext eq '.pod'){my$subdir=dirname$fullext;unless (grep {$fullext eq $_}_actual_filenames$subdir,"$parts[-1].pod"){print "# Looking for alternate spelling in $subdir\n" if$verbose;my$pm=$fullname .'.pm';if (-f $pm and $self->contains_pod($pm)){if (grep {$pm eq $_}_actual_filenames$subdir,"$parts[-1].pm"){print "FOUND: $fullext\n" if$verbose;return$pm}}}}return$fullext}}for my$subdir (_actual_filenames($dir,'pod')){if (-d $subdir){$verbose and print "Noticing $subdir and looking there...\n";unshift@search_dirs,$subdir}}}return undef}sub contains_pod {my($self,$file)=@_;my$verbose=$self->{'verbose'};$verbose > 1 and print " Scanning $file for pod...\n";unless(open(MAYBEPOD,"<$file")){print "Error: $file is unreadable: $!\n";return undef}sleep($SLEEPY - 1)if$SLEEPY;local $_;while(<MAYBEPOD>){if(m/^=(head\d|pod|over|item)\b/s){close(MAYBEPOD)|| die "Bizarre error closing $file: $!\nAborting";chomp;$verbose > 1 and print "  Found some pod ($_) in $file\n";return 1}}close(MAYBEPOD)|| die "Bizarre error closing $file: $!\nAborting";$verbose > 1 and print "  No POD in $file, skipping.\n";return 0}sub _accessorize {shift;no strict 'refs';for my$attrname (@_){*{caller().'::' .$attrname}=sub {use strict;$Carp::CarpLevel=1,Carp::croak("Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)")unless (@_==1 or @_==2)and ref $_[0];return $_[0]->{$attrname}if @_==1;$_[0]->{$attrname}=$_[1];return $_[0]}}return}sub _state_as_string {my$self=$_[0];return '' unless ref$self;my@out="{\n  # State of $self ...\n";for my$k (sort keys %$self){push@out,"  ",_esc($k)," => ",_esc($self->{$k}),",\n"}push@out,"}\n";my$x=join '',@out;$x =~ s/^/#/mg;return$x}sub _esc {my$in=$_[0];return 'undef' unless defined$in;$in =~ s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
       <'\\x'.(unpack("H2",$1))>eg;return qq{"$in"}}run()unless caller;1;
POD_SIMPLE_SEARCH

$fatpacked{"Pod/Simple/SimpleTree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SIMPLETREE';
  require 5;package Pod::Simple::SimpleTree;use strict;use Carp ();use Pod::Simple ();use vars qw($ATTR_PAD @ISA $VERSION $SORT_ATTRS);$VERSION='3.35';BEGIN {@ISA=('Pod::Simple');*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}__PACKAGE__->_accessorize('root',);sub _handle_element_start {DEBUG > 2 and print STDERR "Handling $_[1] start-event\n";my$x=[$_[1],$_[2]];if($_[0]{'_currpos'}){push @{$_[0]{'_currpos'}[0]},$x;unshift @{$_[0]{'_currpos'}},$x}else {DEBUG and print STDERR " And oo, it gets to be root!\n";$_[0]{'_currpos'}=[$_[0]{'root'}=$x ]}DEBUG > 3 and print STDERR "Stack is now: ",join(">",map $_->[0],@{$_[0]{'_currpos'}}),"\n";return}sub _handle_element_end {DEBUG > 2 and print STDERR "Handling $_[1] end-event\n";shift @{$_[0]{'_currpos'}};DEBUG > 3 and print STDERR "Stack is now: ",join(">",map $_->[0],@{$_[0]{'_currpos'}}),"\n";return}sub _handle_text {DEBUG > 2 and print STDERR "Handling $_[1] text-event\n";push @{$_[0]{'_currpos'}[0]},$_[1];return}sub _traverse_treelet_bit {DEBUG > 2 and print STDERR "Handling $_[1] paragraph event\n";my$self=shift;push @{$self->{'_currpos'}[0]},[@_];return}1;
POD_SIMPLE_SIMPLETREE

$fatpacked{"Pod/Simple/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXT';
  require 5;package Pod::Simple::Text;use strict;use Carp ();use Pod::Simple::Methody ();use Pod::Simple ();use vars qw(@ISA $VERSION $FREAKYMODE);$VERSION='3.35';@ISA=('Pod::Simple::Methody');BEGIN {*DEBUG=defined(&Pod::Simple::DEBUG)? \&Pod::Simple::DEBUG : sub() {0}}use Text::Wrap 98.112902 ();$Text::Wrap::huge='overflow';sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->accept_target_as_text(qw(text plaintext plain));$new->nix_X_codes(1);$new->nbsp_for_S(1);$new->{'Thispara'}='';$new->{'Indent'}=0;$new->{'Indentstring'}='   ';return$new}sub handle_text {$_[0]{'Thispara'}.= $_[1]}sub start_Para {$_[0]{'Thispara'}=''}sub start_head1 {$_[0]{'Thispara'}=''}sub start_head2 {$_[0]{'Thispara'}=''}sub start_head3 {$_[0]{'Thispara'}=''}sub start_head4 {$_[0]{'Thispara'}=''}sub start_Verbatim {$_[0]{'Thispara'}=''}sub start_item_bullet {$_[0]{'Thispara'}=$FREAKYMODE ? '' : '* '}sub start_item_number {$_[0]{'Thispara'}=$FREAKYMODE ? '' : "$_[1]{'number'}. "}sub start_item_text {$_[0]{'Thispara'}=''}sub start_over_bullet {++$_[0]{'Indent'}}sub start_over_number {++$_[0]{'Indent'}}sub start_over_text {++$_[0]{'Indent'}}sub start_over_block {++$_[0]{'Indent'}}sub end_over_bullet {--$_[0]{'Indent'}}sub end_over_number {--$_[0]{'Indent'}}sub end_over_text {--$_[0]{'Indent'}}sub end_over_block {--$_[0]{'Indent'}}sub end_head1 {$_[0]->emit_par(-4)}sub end_head2 {$_[0]->emit_par(-3)}sub end_head3 {$_[0]->emit_par(-2)}sub end_head4 {$_[0]->emit_par(-1)}sub end_Para {$_[0]->emit_par(0)}sub end_item_bullet {$_[0]->emit_par(0)}sub end_item_number {$_[0]->emit_par(0)}sub end_item_text {$_[0]->emit_par(-2)}sub start_L {$_[0]{'Link'}=$_[1]if $_[1]->{type}eq 'url'}sub end_L {if (my$link=delete $_[0]{'Link'}){$_[0]{'Thispara'}.= " <$link->{to}>" unless $_[0]{'Thispara'}=~ /\b\Q$link->{to}/}}sub emit_par {my($self,$tweak_indent)=splice(@_,0,2);my$indent=' ' x (2 * $self->{'Indent'}+ 4 + ($tweak_indent||0));$self->{'Thispara'}=~ s/$Pod::Simple::shy//g;my$out=Text::Wrap::wrap($indent,$indent,$self->{'Thispara'}.= "\n");$out =~ s/$Pod::Simple::nbsp/ /g;print {$self->{'output_fh'}}$out,"\n";$self->{'Thispara'}='';return}sub end_Verbatim {my$self=shift;$self->{'Thispara'}=~ s/$Pod::Simple::nbsp/ /g;$self->{'Thispara'}=~ s/$Pod::Simple::shy//g;my$i=' ' x (2 * $self->{'Indent'}+ 4);$self->{'Thispara'}=~ s/^/$i/mg;print {$self->{'output_fh'}}'',$self->{'Thispara'},"\n\n" ;$self->{'Thispara'}='';return}1;
POD_SIMPLE_TEXT

$fatpacked{"Pod/Simple/TextContent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXTCONTENT';
  require 5;package Pod::Simple::TextContent;use strict;use Carp ();use Pod::Simple ();use vars qw(@ISA $VERSION);$VERSION='3.35';@ISA=('Pod::Simple');sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->nix_X_codes(1);return$new}sub _handle_element_start {print {$_[0]{'output_fh'}}"\n" unless $_[1]=~ m/^[A-Z]$/s;return}sub _handle_text {$_[1]=~ s/$Pod::Simple::shy//g;$_[1]=~ s/$Pod::Simple::nbsp/ /g;print {$_[0]{'output_fh'}}$_[1];return}sub _handle_element_end {print {$_[0]{'output_fh'}}"\n" unless $_[1]=~ m/^[A-Z]$/s;return}1;
POD_SIMPLE_TEXTCONTENT

$fatpacked{"Pod/Simple/TiedOutFH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TIEDOUTFH';
  use strict;package Pod::Simple::TiedOutFH;use Symbol ('gensym');use Carp ();use vars qw($VERSION);$VERSION='3.35';sub handle_on {my$class=shift;$class=ref($class)|| $class;Carp::croak "Usage: ${class}->handle_on(\$somescalar)" unless @_;my$x=(defined($_[0])and ref($_[0]))? $_[0]: (\($_[0]))[0];$$x='' unless defined $$x;my$new=gensym();tie *$new,$class,$x;return$new}sub TIEHANDLE {my($class,$scalar_ref)=@_;$$scalar_ref='' unless defined $$scalar_ref;return bless \$scalar_ref,ref($class)|| $class}sub PRINT {my$it=shift;for my$x (@_){$$$it .= $x}return 1}sub FETCH {return ${$_[0]}}sub PRINTF {my$it=shift;my$format=shift;$$$it .= sprintf$format,@_;return 1}sub FILENO {${$_[0]}+ 100}sub CLOSE {1}1;
POD_SIMPLE_TIEDOUTFH

$fatpacked{"Pod/Simple/Transcode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODE';
  require 5;package Pod::Simple::Transcode;use strict;use vars qw($VERSION @ISA);$VERSION='3.35';BEGIN {if(defined&DEBUG){}elsif(defined&Pod::Simple::DEBUG){*DEBUG=\&Pod::Simple::DEBUG}else {*DEBUG=sub () {0}}}for my$class ('Pod::Simple::TranscodeSmart','Pod::Simple::TranscodeDumb','',){$class or die "Couldn't load any encoding classes";DEBUG and print STDERR "About to try loading $class...\n";eval "require $class;";if($@){DEBUG and print STDERR "Couldn't load $class: $@\n"}else {DEBUG and print STDERR "OK, loaded $class.\n";@ISA=($class);last}}sub _blorp {return}1;
POD_SIMPLE_TRANSCODE

$fatpacked{"Pod/Simple/TranscodeDumb.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODEDUMB';
  require 5;package Pod::Simple::TranscodeDumb;use strict;use vars qw($VERSION %Supported);$VERSION='3.35';%Supported=('ascii'=>1,'ascii-ctrl'=>1,'iso-8859-1'=>1,'cp1252'=>1,'null'=>1,'latin1'=>1,'latin-1'=>1,%Supported,);sub is_dumb {1}sub is_smart {0}sub all_encodings {return sort keys%Supported}sub encoding_is_available {return exists$Supported{lc $_[1]}}sub encmodver {return __PACKAGE__ ." v" .($VERSION || '?')}sub make_transcoder {my ($e)=$_[1];die "WHAT ENCODING!?!?" unless$e;return sub {}if$e !~ /^cp-?1252$/i;return sub {my%ascii_for=("\x80"=>'e',"\x82"=>',',"\x83"=>'f',"\x84"=>',,',"\x85"=>'...',"\x86"=>'+',"\x87"=>'++',"\x88"=>'^',"\x89"=>'%',"\x8a"=>'S',"\x8b"=>'<',"\x8c"=>'OE',"\x8e"=>'Z',"\x91"=>"'","\x92"=>"'","\x93"=>'"',"\x94"=>'"',"\x95"=>'*',"\x96"=>'-',"\x97"=>'--',"\x98"=>'~',"\x99"=>'(tm)',"\x9a"=>'s',"\x9b"=>'>',"\x9c"=>'oe',"\x9e"=>'z',"\x9f"=>'Y',);s{([\x80-\x9f])}{$ascii_for{$1} || $1}emxsg for @_}}1;
POD_SIMPLE_TRANSCODEDUMB

$fatpacked{"Pod/Simple/TranscodeSmart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODESMART';
  require 5;use 5.008;package Pod::Simple::TranscodeSmart;use strict;use Pod::Simple;require Encode;use vars qw($VERSION);$VERSION='3.35';sub is_dumb {0}sub is_smart {1}sub all_encodings {return Encode::->encodings(':all')}sub encoding_is_available {return Encode::resolve_alias($_[1])}sub encmodver {return "Encode.pm v" .($Encode::VERSION || '?')}sub make_transcoder {my$e=Encode::find_encoding($_[1]);die "WHAT ENCODING!?!?" unless$e;my$x;return sub {for$x (@_){$x=$e->decode($x)unless Encode::is_utf8($x)}return}}1;
POD_SIMPLE_TRANSCODESMART

$fatpacked{"Pod/Simple/XHTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XHTML';
  package Pod::Simple::XHTML;use strict;use vars qw($VERSION @ISA $HAS_HTML_ENTITIES);$VERSION='3.35';use Pod::Simple::Methody ();@ISA=('Pod::Simple::Methody');BEGIN {$HAS_HTML_ENTITIES=eval "require HTML::Entities; 1"}my%entities=(q{>}=>'gt',q{<}=>'lt',q{'}=>'#39',q{"}=>'quot',q{&}=>'amp',);sub encode_entities {my$self=shift;my$ents=$self->html_encode_chars;return HTML::Entities::encode_entities($_[0],$ents)if$HAS_HTML_ENTITIES;if (defined$ents){$ents =~ s,(?<!\\)([]/]),\\$1,g;$ents =~ s,(?<!\\)\\\z,\\\\,}else {$ents=join '',keys%entities}my$str=$_[0];$str =~ s/([$ents])/'&' . ($entities{$1} || sprintf '#x%X', ord $1) . ';'/ge;return$str}__PACKAGE__->_accessorize('perldoc_url_prefix','perldoc_url_postfix','man_url_prefix','man_url_postfix','title_prefix','title_postfix','html_css','html_javascript','html_doctype','html_charset','html_encode_chars','html_h_level','title','default_title','force_title','html_header','html_footer','index','anchor_items','backlink','batch_mode','batch_mode_current_level',);sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->perldoc_url_prefix('http://search.cpan.org/perldoc?');$new->man_url_prefix('http://man.he.net/man');$new->html_charset('ISO-8859-1');$new->nix_X_codes(1);$new->{'scratch'}='';$new->{'to_index'}=[];$new->{'output'}=[];$new->{'saved'}=[];$new->{'ids'}={'_podtop_'=>1 };$new->{'in_li'}=[];$new->{'__region_targets'}=[];$new->{'__literal_targets'}={};$new->accept_targets_as_html('html','HTML');return$new}sub html_header_tags {my$self=shift;return$self->{html_header_tags}=shift if @_;return$self->{html_header_tags}||= '<meta http-equiv="Content-Type" content="text/html; charset=' .$self->html_charset .'" />'}sub __in_literal_xhtml_region {return unless @{$_[0]{__region_targets}};my$target=$_[0]{__region_targets}[-1];return $_[0]{__literal_targets}{$target }}sub accept_targets_as_html {my ($self,@targets)=@_;$self->accept_targets(@targets);$self->{__literal_targets}{$_}=1 for@targets}sub handle_text {my$text=$_[0]->__in_literal_xhtml_region ? $_[1]: $_[0]->encode_entities($_[1]);if ($_[0]{'in_code'}&& @{$_[0]{'in_code'}}){$_[0]->handle_code($_[1],$_[0]{'in_code'}[-1])}else {if ($_[0]->{in_for}){my$newlines=$_[0]->__in_literal_xhtml_region ? "\n\n" : '';if ($_[0]->{started_for}){if ($text =~ /\S/){delete $_[0]->{started_for};$_[0]{'scratch'}.= $text .$newlines}}else {$text =~ s/\n\z//;$_[0]{'scratch'}.= $text .$newlines}}else {$_[0]{'scratch'}.= $text}}$_[0]{htext}.= $text if $_[0]{'in_head'}}sub start_code {$_[0]{'scratch'}.= '<code>'}sub end_code {$_[0]{'scratch'}.= '</code>'}sub handle_code {$_[0]{'scratch'}.= $_[0]->encode_entities($_[1])}sub start_Para {$_[0]{'scratch'}.= '<p>'}sub start_Verbatim {$_[0]{'scratch'}='<pre>';push(@{$_[0]{'in_code'}},'Verbatim');$_[0]->start_code($_[0]{'in_code'}[-1])}sub start_head1 {$_[0]{'in_head'}=1;$_[0]{htext}=''}sub start_head2 {$_[0]{'in_head'}=2;$_[0]{htext}=''}sub start_head3 {$_[0]{'in_head'}=3;$_[0]{htext}=''}sub start_head4 {$_[0]{'in_head'}=4;$_[0]{htext}=''}sub start_item_number {$_[0]{'scratch'}="</li>\n" if ($_[0]{'in_li'}->[-1]&& pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '<li><p>';push @{$_[0]{'in_li'}},1}sub start_item_bullet {$_[0]{'scratch'}="</li>\n" if ($_[0]{'in_li'}->[-1]&& pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '<li><p>';push @{$_[0]{'in_li'}},1}sub start_item_text {}sub start_over_bullet {$_[0]{'scratch'}='<ul>';push @{$_[0]{'in_li'}},0;$_[0]->emit}sub start_over_block {$_[0]{'scratch'}='<ul>';$_[0]->emit}sub start_over_number {$_[0]{'scratch'}='<ol>';push @{$_[0]{'in_li'}},0;$_[0]->emit}sub start_over_text {$_[0]{'scratch'}='<dl>';$_[0]{'dl_level'}++;$_[0]{'in_dd'}||= [];$_[0]->emit}sub end_over_block {$_[0]{'scratch'}.= '</ul>';$_[0]->emit}sub end_over_number {$_[0]{'scratch'}="</li>\n" if (pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '</ol>';pop @{$_[0]{'in_li'}};$_[0]->emit}sub end_over_bullet {$_[0]{'scratch'}="</li>\n" if (pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '</ul>';pop @{$_[0]{'in_li'}};$_[0]->emit}sub end_over_text {if ($_[0]{'in_dd'}[$_[0]{'dl_level'}]){$_[0]{'scratch'}="</dd>\n";$_[0]{'in_dd'}[$_[0]{'dl_level'}]=0}$_[0]{'scratch'}.= '</dl>';$_[0]{'dl_level'}--;$_[0]->emit}sub end_Para {$_[0]{'scratch'}.= '</p>';$_[0]->emit}sub end_Verbatim {$_[0]->end_code(pop(@{$_[0]->{'in_code'}}));$_[0]{'scratch'}.= '</pre>';$_[0]->emit}sub _end_head {my$h=delete $_[0]{in_head};my$add=$_[0]->html_h_level;$add=1 unless defined$add;$h += $add - 1;my$id=$_[0]->idify($_[0]{htext});my$text=$_[0]{scratch};$_[0]{'scratch'}=$_[0]->backlink && ($h - $add==0)? qq{<a href="#_podtop_"><h$h id="$id">$text</h$h></a>} : qq{<h$h id="$id">$text</h$h>};$_[0]->emit;push @{$_[0]{'to_index'}},[$h,$id,delete $_[0]{'htext'}]}sub end_head1 {shift->_end_head(@_)}sub end_head2 {shift->_end_head(@_)}sub end_head3 {shift->_end_head(@_)}sub end_head4 {shift->_end_head(@_)}sub end_item_bullet {$_[0]{'scratch'}.= '</p>';$_[0]->emit}sub end_item_number {$_[0]{'scratch'}.= '</p>';$_[0]->emit}sub end_item_text {my$dt_id=$_[0]{'anchor_items'}? ' id="'.$_[0]->idify($_[0]{'scratch'}).'"' : '';my$text=$_[0]{scratch};$_[0]{'scratch'}='';if ($_[0]{'in_dd'}[$_[0]{'dl_level'}]){$_[0]{'scratch'}="</dd>\n";$_[0]{'in_dd'}[$_[0]{'dl_level'}]=0}$_[0]{'scratch'}.= qq{<dt$dt_id>$text</dt>\n<dd>};$_[0]{'in_dd'}[$_[0]{'dl_level'}]=1;$_[0]->emit}sub start_for {my ($self,$flags)=@_;push @{$self->{__region_targets}},$flags->{target_matching};$self->{started_for}=1;$self->{in_for}=1;unless ($self->__in_literal_xhtml_region){$self->{scratch}.= '<div';$self->{scratch}.= qq( class="$flags->{target}") if$flags->{target};$self->{scratch}.= ">\n\n"}}sub end_for {my ($self)=@_;delete$self->{started_for};delete$self->{in_for};if ($self->__in_literal_xhtml_region){$self->{'scratch'}=~ s/\s+\z//s}else {$self->{'scratch'}.= '</div>'}pop @{$self->{__region_targets}};$self->emit}sub start_Document {my ($self)=@_;if (defined$self->html_header){$self->{'scratch'}.= $self->html_header;$self->emit unless$self->html_header eq ""}else {my ($doctype,$title,$metatags,$bodyid);$doctype=$self->html_doctype || '';$title=$self->force_title || $self->title || $self->default_title || '';$metatags=$self->html_header_tags || '';if (my$css=$self->html_css){if ($css !~ /<link/){$metatags .= '<link rel="stylesheet" href="' .$self->encode_entities($css).'" type="text/css" />'}else {$metatags .= $css}}if ($self->html_javascript){$metatags .= qq{\n<script type="text/javascript" src="} .$self->html_javascript .'"></script>'}$bodyid=$self->backlink ? ' id="_podtop_"' : '';$self->{'scratch'}.= <<"HTML";$self->emit}}sub end_Document {my ($self)=@_;my$to_index=$self->{'to_index'};if ($self->index && @{$to_index}){my@out;my$level=0;my$indent=-1;my$space='';my$id=' id="index"';for my$h (@{$to_index},[0]){my$target_level=$h->[0];if ($level==$target_level){$out[-1].= '</li>'}elsif ($level > $target_level){$out[-1].= '</li>' if$out[-1]=~ /^\s+<li>/;while ($level > $target_level){--$level;push@out,('  ' x --$indent).'</li>' if@out && $out[-1]=~ m{^\s+<\/ul};push@out,('  ' x --$indent).'</ul>'}push@out,('  ' x --$indent).'</li>' if$level}else {while ($level < $target_level){++$level;push@out,('  ' x ++$indent).'<li>' if@out && $out[-1]=~ /^\s*<ul/;push@out,('  ' x ++$indent)."<ul$id>";$id=''}++$indent}next unless$level;$space='  ' x $indent;push@out,sprintf '%s<li><a href="#%s">%s</a>',$space,$h->[1],$h->[2]}my$offset=defined$self->html_header ? $self->html_header eq '' ? 0 : 1 : 1;splice @{$self->{'output'}},$offset,0,join "\n",@out}if (defined$self->html_footer){$self->{'scratch'}.= $self->html_footer;$self->emit unless$self->html_footer eq ""}else {$self->{'scratch'}.= "</body>\n</html>";$self->emit}if ($self->index){print {$self->{'output_fh'}}join ("\n\n",@{$self->{'output'}}),"\n\n";@{$self->{'output'}}=()}}sub start_B {$_[0]{'scratch'}.= '<b>'}sub end_B {$_[0]{'scratch'}.= '</b>'}sub start_C {push(@{$_[0]{'in_code'}},'C');$_[0]->start_code($_[0]{'in_code'}[-1])}sub end_C {$_[0]->end_code(pop(@{$_[0]{'in_code'}}))}sub start_F {$_[0]{'scratch'}.= '<i>'}sub end_F {$_[0]{'scratch'}.= '</i>'}sub start_I {$_[0]{'scratch'}.= '<i>'}sub end_I {$_[0]{'scratch'}.= '</i>'}sub start_L {my ($self,$flags)=@_;my ($type,$to,$section)=@{$flags}{'type','to','section'};my$url=$self->encode_entities($type eq 'url' ? $to : $type eq 'pod' ? $self->resolve_pod_page_link($to,$section): $type eq 'man' ? $self->resolve_man_page_link($to,$section): undef);$self->{'scratch'}.= '<a' .($url ? ' href="'.$url .'">' : '>')}sub end_L {$_[0]{'scratch'}.= '</a>'}sub start_S {$_[0]{'scratch'}.= '<span style="white-space: nowrap;">'}sub end_S {$_[0]{'scratch'}.= '</span>'}sub emit {my($self)=@_;if ($self->index){push @{$self->{'output'}},$self->{'scratch'}}else {print {$self->{'output_fh'}}$self->{'scratch'},"\n\n"}$self->{'scratch'}='';return}sub resolve_pod_page_link {my ($self,$to,$section)=@_;return undef unless defined$to || defined$section;if (defined$section){$section='#' .$self->idify($self->encode_entities($section),1);return$section unless defined$to}else {$section=''}return ($self->perldoc_url_prefix || '').$self->encode_entities($to).$section .($self->perldoc_url_postfix || '')}sub resolve_man_page_link {my ($self,$to,$section)=@_;return undef unless defined$to;my ($page,$part)=$to =~ /^([^(]+)(?:[(](\d+)[)])?$/;return undef unless$page;return ($self->man_url_prefix || '').($part || 1)."/" .$self->encode_entities($page).($self->man_url_postfix || '')}sub idify {my ($self,$t,$not_unique)=@_;for ($t){s/<[^>]+>//g;s/&[^;]+;//g;s/^\s+//;s/\s+$//;s/^([^a-zA-Z]+)$/pod$1/;s/^[^a-zA-Z]+//;s/[^-a-zA-Z0-9_:.]+/-/g;s/[-:.]+$//}return$t if$not_unique;my$i='';$i++ while$self->{ids}{"$t$i"}++;return "$t$i"}sub batch_mode_page_object_init {my ($self,$batchconvobj,$module,$infile,$outfile,$depth)=@_;$self->batch_mode(1);$self->batch_mode_current_level($depth);return$self}sub html_header_after_title {}1;
  $doctype
  <html>
  <head>
  <title>$title</title>
  $metatags
  </head>
  <body$bodyid>
  HTML
POD_SIMPLE_XHTML

$fatpacked{"Pod/Simple/XMLOutStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XMLOUTSTREAM';
  require 5;package Pod::Simple::XMLOutStream;use strict;use Carp ();use Pod::Simple ();use vars qw($ATTR_PAD @ISA $VERSION $SORT_ATTRS);$VERSION='3.35';BEGIN {@ISA=('Pod::Simple');*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}$ATTR_PAD="\n" unless defined$ATTR_PAD;$SORT_ATTRS=0 unless defined$SORT_ATTRS;sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->keep_encoding_directive(1);return$new}sub _handle_element_start {my$fh=$_[0]{'output_fh'};my($key,$value);DEBUG and print STDERR "++ $_[1]\n";print$fh "<",$_[1];if($SORT_ATTRS){for my$key (sort keys %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_xml_escape($value=$_[2]{$key});print$fh $ATTR_PAD,$key,'="',$value,'"'}}}else {while(($key,$value)=each %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_xml_escape($value);print$fh $ATTR_PAD,$key,'="',$value,'"'}}}print$fh ">";return}sub _handle_text {DEBUG and print STDERR "== \"$_[1]\"\n";if(length $_[1]){my$text=$_[1];_xml_escape($text);print {$_[0]{'output_fh'}}$text}return}sub _handle_element_end {DEBUG and print STDERR "-- $_[1]\n";print {$_[0]{'output_fh'}}"</",$_[1],">";return}sub _xml_escape {for my$x (@_){if ($] ge 5.007_003){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg}else {$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}}return}1;
POD_SIMPLE_XMLOUTSTREAM

$fatpacked{"Pod/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT';
  package Pod::Text;use 5.006;use strict;use warnings;use vars qw(@ISA @EXPORT %ESCAPES $VERSION);use Carp qw(carp croak);use Encode qw(encode);use Exporter ();use Pod::Simple ();@ISA=qw(Pod::Simple Exporter);@EXPORT=qw(pod2text);$VERSION='4.09';my ($NBSP,$SHY);if ($Pod::Simple::VERSION ge 3.30){$NBSP=$Pod::Simple::nbsp;$SHY=$Pod::Simple::shy}else {if ($] ge 5.007_003){$NBSP=chr utf8::unicode_to_native(0xA0);$SHY=chr utf8::unicode_to_native(0xAD)}elsif (Pod::Simple::ASCII){$NBSP="\xA0";$SHY="\xAD"}else {$NBSP="\x41";$SHY="\xCA"}}sub handle_code {my ($line,$number,$parser)=@_;$parser->output_code ($line ."\n")}sub new {my$class=shift;my$self=$class->SUPER::new;$self->nbsp_for_S (1);if ($self->can ('preserve_whitespace')){$self->preserve_whitespace (1)}else {$self->fullstop_space_harden (1)}$self->accept_targets (qw/text TEXT/);$self->merge_text (1);my%opts=@_;my@opts=map {("opt_$_",$opts{$_})}keys%opts;%$self=(%$self,@opts);if ($$self{opt_stderr}and not $$self{opt_errors}){$$self{opt_errors}='stderr'}delete $$self{opt_stderr};if (not defined $$self{opt_errors}){$$self{opt_errors}='pod'}if ($$self{opt_errors}eq 'stderr' || $$self{opt_errors}eq 'die'){$self->no_errata_section (1);$self->complain_stderr (1);if ($$self{opt_errors}eq 'die'){$$self{complain_die}=1}}elsif ($$self{opt_errors}eq 'pod'){$self->no_errata_section (0);$self->complain_stderr (0)}elsif ($$self{opt_errors}eq 'none'){$self->no_whining (1)}else {croak (qq(Invalid errors setting: "$$self{errors}"))}delete $$self{errors};$$self{opt_alt}=0 unless defined $$self{opt_alt};$$self{opt_indent}=4 unless defined $$self{opt_indent};$$self{opt_margin}=0 unless defined $$self{opt_margin};$$self{opt_loose}=0 unless defined $$self{opt_loose};$$self{opt_sentence}=0 unless defined $$self{opt_sentence};$$self{opt_width}=76 unless defined $$self{opt_width};$$self{opt_quotes}||= '"';if ($$self{opt_quotes}eq 'none'){$$self{LQUOTE}=$$self{RQUOTE}=''}elsif (length ($$self{opt_quotes})==1){$$self{LQUOTE}=$$self{RQUOTE}=$$self{opt_quotes}}elsif (length ($$self{opt_quotes})% 2==0){my$length=length ($$self{opt_quotes})/ 2;$$self{LQUOTE}=substr ($$self{opt_quotes},0,$length);$$self{RQUOTE}=substr ($$self{opt_quotes},$length)}else {croak qq(Invalid quote specification "$$self{opt_quotes}")}$self->code_handler (\&handle_code)if $$self{opt_code};return$self}sub _handle_text {my ($self,$text)=@_;my$tag=$$self{PENDING}[-1];$$tag[1].= $text}sub method_for_element {my ($self,$element)=@_;$element =~ tr/-/_/;$element =~ tr/A-Z/a-z/;$element =~ tr/_a-z0-9//cd;return$element}sub _handle_element_start {my ($self,$element,$attrs)=@_;my$method=$self->method_for_element ($element);if ($self->can ("cmd_$method")){push (@{$$self{PENDING}},[$attrs,'' ])}elsif ($self->can ("start_$method")){my$method='start_' .$method;$self->$method ($attrs,'')}}sub _handle_element_end {my ($self,$element)=@_;my$method=$self->method_for_element ($element);if ($self->can ("cmd_$method")){my$tag=pop @{$$self{PENDING}};my$method='cmd_' .$method;my$text=$self->$method (@$tag);if (defined$text){if (@{$$self{PENDING}}> 1){$$self{PENDING}[-1][1].= $text}else {$self->output ($text)}}}elsif ($self->can ("end_$method")){my$method='end_' .$method;$self->$method ()}}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};while (length > $width){if (s/^([^\n]{0,$width})\s+// || s/^([^\n]{$width})//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;return$output}sub reformat {my$self=shift;local $_=shift;if ($$self{opt_sentence}){s/ +$//mg;s/\.\n/. \n/g;s/\n/ /g;s/   +/  /g}else {s/\s+/ /g}return$self->wrap ($_)}sub output {my ($self,@text)=@_;my$text=join ('',@text);if ($NBSP){$text =~ s/$NBSP/ /g}if ($SHY){$text =~ s/$SHY//g}unless ($$self{opt_utf8}){my$encoding=$$self{encoding}|| '';if ($encoding && $encoding ne $$self{ENCODING}){$$self{ENCODING}=$encoding;eval {binmode ($$self{output_fh},":encoding($encoding)")}}}if ($$self{ENCODE}){print {$$self{output_fh}}encode ('UTF-8',$text)}else {print {$$self{output_fh}}$text}}sub output_code {$_[0]->output ($_[1])}sub start_document {my ($self,$attrs)=@_;if ($$attrs{contentless}&&!$$self{ALWAYS_EMIT_SOMETHING}){$$self{CONTENTLESS}=1}else {delete $$self{CONTENTLESS}}my$margin=$$self{opt_indent}+ $$self{opt_margin};$$self{INDENTS}=[];$$self{MARGIN}=$margin;$$self{PENDING}=[[]];$$self{ENCODING}='';$$self{ENCODE}=0;if ($$self{opt_utf8}){$$self{ENCODE}=1;eval {my@options=(output=>1,details=>1);my$flag=(PerlIO::get_layers ($$self{output_fh},@options))[-1];if ($flag & PerlIO::F_UTF8 ()){$$self{ENCODE}=0;$$self{ENCODING}='UTF-8'}}}return ''}sub end_document {my ($self)=@_;if ($$self{complain_die}&& $self->errors_seen){croak ("POD document had syntax errors")}}sub strip_format {my ($self,$string)=@_;return$string}sub item {my ($self,$text)=@_;my$tag=$$self{ITEM};unless (defined$tag){carp "Item called without tag";return}undef $$self{ITEM};my$indent=$$self{INDENTS}[-1];$indent=$$self{opt_indent}unless defined$indent;my$margin=' ' x $$self{opt_margin};my$tag_length=length ($self->strip_format ($tag));my$fits=($$self{MARGIN}- $indent >= $tag_length + 1);if (!$text || $text =~ /^\s+$/ ||!$fits){my$realindent=$$self{MARGIN};$$self{MARGIN}=$indent;my$output=$self->reformat ($tag);$output =~ s/^$margin /$margin:/ if ($$self{opt_alt}&& $indent > 0);$output =~ s/\n*$/\n/;$output .= "\n" if$text && $text =~ /^\s*$/;$self->output ($output);$$self{MARGIN}=$realindent;$self->output ($self->reformat ($text))if ($text && $text =~ /\S/)}else {my$space=' ' x $indent;$space =~ s/^$margin /$margin:/ if $$self{opt_alt};$text=$self->reformat ($text);$text =~ s/^$margin /$margin:/ if ($$self{opt_alt}&& $indent > 0);my$tagspace=' ' x $tag_length;$text =~ s/^($space)$tagspace/$1$tag/ or warn "Bizarre space in item";$self->output ($text)}}sub cmd_para {my ($self,$attrs,$text)=@_;$text =~ s/\s+$/\n/;if (defined $$self{ITEM}){$self->item ($text ."\n")}else {$self->output ($self->reformat ($text ."\n"))}return ''}sub cmd_verbatim {my ($self,$attrs,$text)=@_;$self->item if defined $$self{ITEM};return if$text =~ /^\s*$/;$text =~ s/^(\n*)([ \t]*\S+)/$1 . (' ' x $$self{MARGIN}) . $2/gme;$text =~ s/\s*$/\n\n/;$self->output ($text);return ''}sub cmd_data {my ($self,$attrs,$text)=@_;$text =~ s/^\n+//;$text =~ s/\n{0,2}$/\n/;$self->output ($text);return ''}sub heading {my ($self,$text,$indent,$marker)=@_;$self->item ("\n\n")if defined $$self{ITEM};$text =~ s/\s+$//;if ($$self{opt_alt}){my$closemark=reverse (split (//,$marker));my$margin=' ' x $$self{opt_margin};$self->output ("\n" ."$margin$marker $text $closemark" ."\n\n")}else {$text .= "\n" if $$self{opt_loose};my$margin=' ' x ($$self{opt_margin}+ $indent);$self->output ($margin .$text ."\n")}return ''}sub cmd_head1 {my ($self,$attrs,$text)=@_;$self->heading ($text,0,'====')}sub cmd_head2 {my ($self,$attrs,$text)=@_;$self->heading ($text,$$self{opt_indent}/ 2,'==  ')}sub cmd_head3 {my ($self,$attrs,$text)=@_;$self->heading ($text,$$self{opt_indent}* 2 / 3 + 0.5,'=   ')}sub cmd_head4 {my ($self,$attrs,$text)=@_;$self->heading ($text,$$self{opt_indent}* 3 / 4 + 0.5,'-   ')}sub over_common_start {my ($self,$attrs)=@_;$self->item ("\n\n")if defined $$self{ITEM};my$indent=$$attrs{indent};unless (defined ($indent)&& $indent =~ /^\s*[-+]?\d{1,4}\s*$/){$indent=$$self{opt_indent}}push (@{$$self{INDENTS}},$$self{MARGIN});$$self{MARGIN}+= ($indent + 0);return ''}sub over_common_end {my ($self)=@_;$self->item ("\n\n")if defined $$self{ITEM};$$self{MARGIN}=pop @{$$self{INDENTS}};return ''}sub start_over_bullet {$_[0]->over_common_start ($_[1])}sub start_over_number {$_[0]->over_common_start ($_[1])}sub start_over_text {$_[0]->over_common_start ($_[1])}sub start_over_block {$_[0]->over_common_start ($_[1])}sub end_over_bullet {$_[0]->over_common_end}sub end_over_number {$_[0]->over_common_end}sub end_over_text {$_[0]->over_common_end}sub end_over_block {$_[0]->over_common_end}sub item_common {my ($self,$type,$attrs,$text)=@_;$self->item if defined $$self{ITEM};$text =~ s/\s+$//;my ($item,$index);if ($type eq 'bullet'){$item='*'}elsif ($type eq 'number'){$item=$$attrs{'~orig_content'}}else {$item=$text;$item =~ s/\s*\n\s*/ /g;$text=''}$$self{ITEM}=$item;if ($text){$text =~ s/\s*$/\n/;$self->item ($text)}return ''}sub cmd_item_bullet {my$self=shift;$self->item_common ('bullet',@_)}sub cmd_item_number {my$self=shift;$self->item_common ('number',@_)}sub cmd_item_text {my$self=shift;$self->item_common ('text',@_)}sub cmd_item_block {my$self=shift;$self->item_common ('block',@_)}sub cmd_b {return $_[0]{alt}? "``$_[2]''" : $_[2]}sub cmd_f {return $_[0]{alt}? "\"$_[2]\"" : $_[2]}sub cmd_i {return '*' .$_[2].'*'}sub cmd_x {return ''}sub cmd_c {my ($self,$attrs,$text)=@_;my$index='(?: \[.*\] | \{.*\} )?';$text =~ m{
        ^\s*
        (?:
           ( [\'\`\"] ) .* \1                             # already quoted
         | \` .* \'                                       # `quoted'
         | \$+ [\#^]? \S $index                           # special ($^Foo, $")
         | [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
         | [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
         | [+-]? ( \d[\d.]* | \.\d+ ) (?: [eE][+-]?\d+ )? # a number
         | 0x [a-fA-F\d]+                                 # a hex constant
        )
        \s*\z
       }xo && return$text;return $$self{opt_alt}? "``$text''" : "$$self{LQUOTE}$text$$self{RQUOTE}"}sub cmd_l {my ($self,$attrs,$text)=@_;if ($$attrs{type}eq 'url'){if (not defined($$attrs{to})or $$attrs{to}eq $text){return "<$text>"}elsif ($$self{opt_nourls}){return$text}else {return "$text <$$attrs{to}>"}}else {return$text}}sub pod2text {my@args;while ($_[0]=~ /^-/){my$flag=shift;if ($flag eq '-a'){push (@args,alt=>1)}elsif ($flag =~ /^-(\d+)$/){push (@args,width=>$1)}else {unshift (@_,$flag);last}}my$parser=Pod::Text->new (@args);if (defined $_[1]){my@fhs=@_;local*IN;unless (open (IN,$fhs[0])){croak ("Can't open $fhs[0] for reading: $!\n");return}$fhs[0]=\*IN;$parser->output_fh ($fhs[1]);my$retval=$parser->parse_file ($fhs[0]);my$fh=$parser->output_fh ();close$fh;return$retval}else {$parser->output_fh (\*STDOUT);return$parser->parse_file (@_)}}sub parse_from_file {my$self=shift;$self->reinit;if (ref ($_[0])eq 'HASH'){my$opts=shift @_;if (defined ($$opts{-cutting})&&!$$opts{-cutting}){$$self{in_pod}=1;$$self{last_was_blank}=1}}my$retval=$self->Pod::Simple::parse_from_file (@_);my$fh=$self->output_fh ();my$oldfh=select$fh;my$oldflush=$|;$|=1;print$fh '';$|=$oldflush;select$oldfh;return$retval}sub parse_from_filehandle {my$self=shift;$self->parse_from_file (@_)}sub parse_file {my ($self,$in)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_file ($in)}sub parse_lines {my ($self,@lines)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_lines (@lines)}sub parse_string_document {my ($self,$doc)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_string_document ($doc)}1;
POD_TEXT

$fatpacked{"Pod/Text/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_COLOR';
  package Pod::Text::Color;use 5.006;use strict;use warnings;use Pod::Text ();use Term::ANSIColor qw(colored);use vars qw(@ISA $VERSION);@ISA=qw(Pod::Text);$VERSION='4.09';sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head1 ($attrs,colored ($text,'bold'))}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head2 ($attrs,colored ($text,'bold'))}sub cmd_b {return colored ($_[2],'bold')}sub cmd_f {return colored ($_[2],'cyan')}sub cmd_i {return colored ($_[2],'yellow')}sub output_code {my ($self,$code)=@_;$code=colored ($code,'green');$self->output ($code)}sub strip_format {my ($self,$text)=@_;$text =~ s/\e\[[\d;]*m//g;return$text}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};my$char='(?:(?:\e\[[\d;]+m)*[^\n])';my$shortchar=$char ."{0,$width}";my$longchar=$char ."{$width}";while (length > $width){if (s/^($shortchar)\s+// || s/^($longchar)//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;$output}1;
POD_TEXT_COLOR

$fatpacked{"Pod/Text/Overstrike.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_OVERSTRIKE';
  package Pod::Text::Overstrike;use 5.006;use strict;use warnings;use vars qw(@ISA $VERSION);use Pod::Text ();@ISA=qw(Pod::Text);$VERSION='4.09';sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/$1\b$1/g;return$self->SUPER::cmd_head1 ($attrs,$text)}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/$1\b$1/g;return$self->SUPER::cmd_head2 ($attrs,$text)}sub cmd_head3 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/_\b$1/g;return$self->SUPER::cmd_head3 ($attrs,$text)}sub cmd_head4 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/_\b$1/g;return$self->SUPER::cmd_head4 ($attrs,$text)}sub heading {my ($self,$text,$indent,$marker)=@_;$self->item ("\n\n")if defined $$self{ITEM};$text .= "\n" if $$self{opt_loose};my$margin=' ' x ($$self{opt_margin}+ $indent);$self->output ($margin .$text ."\n");return ''}sub cmd_b {local $_=$_[0]->strip_format ($_[2]);s/(.)/$1\b$1/g;$_}sub cmd_f {local $_=$_[0]->strip_format ($_[2]);s/(.)/_\b$1/g;$_}sub cmd_i {local $_=$_[0]->strip_format ($_[2]);s/(.)/_\b$1/g;$_}sub output_code {my ($self,$code)=@_;$code =~ s/(.)/$1\b$1/g;$self->output ($code)}sub strip_format {my ($self,$text)=@_;$text =~ s/(.)[\b]\1/$1/g;$text =~ s/_[\b]//g;return$text}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};while (length > $width){my$char='(?:[^\n][\b])?[^\n]';if (s/^((?>$char){0,$width})(?:\Z|\s+)//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;return$output}1;
POD_TEXT_OVERSTRIKE

$fatpacked{"Pod/Text/Termcap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_TERMCAP';
  package Pod::Text::Termcap;use 5.006;use strict;use warnings;use Pod::Text ();use POSIX ();use Term::Cap;use vars qw(@ISA $VERSION);@ISA=qw(Pod::Text);$VERSION='4.09';sub new {my ($self,@args)=@_;my ($ospeed,$term,$termios);$self=$self->SUPER::new (@args);unless (exists$ENV{TERMPATH}){my$home=exists$ENV{HOME}? "$ENV{HOME}/.termcap:" : '';$ENV{TERMPATH}="${home}/etc/termcap:/usr/share/misc/termcap:/usr/share/lib/termcap"}eval {$termios=POSIX::Termios->new};if ($@){$ospeed=9600}else {$termios->getattr;$ospeed=$termios->getospeed || 9600}eval {$term=Tgetent Term::Cap {TERM=>undef,OSPEED=>$ospeed}};$$self{BOLD}=$$term{_md}|| "\e[1m";$$self{UNDL}=$$term{_us}|| "\e[4m";$$self{NORM}=$$term{_me}|| "\e[m";unless (defined $$self{width}){$$self{opt_width}=$ENV{COLUMNS}|| $$term{_co}|| 80;$$self{opt_width}-= 2}return$self}sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head1 ($attrs,"$$self{BOLD}$text$$self{NORM}")}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head2 ($attrs,"$$self{BOLD}$text$$self{NORM}")}sub cmd_b {my$self=shift;return "$$self{BOLD}$_[1]$$self{NORM}"}sub cmd_i {my$self=shift;return "$$self{UNDL}$_[1]$$self{NORM}"}sub output_code {my ($self,$code)=@_;$self->output ($$self{BOLD}.$code .$$self{NORM})}sub strip_format {my ($self,$text)=@_;$text =~ s/\Q$$self{BOLD}//g;$text =~ s/\Q$$self{UNDL}//g;$text =~ s/\Q$$self{NORM}//g;return$text}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};my$codes="(?:\Q$$self{BOLD}\E|\Q$$self{UNDL}\E|\Q$$self{NORM}\E)";my$char="(?:$codes*[^\\n])";my$shortchar=$char ."{0,$width}";my$longchar=$char ."{$width}";while (length > $width){if (s/^($shortchar)\s+// || s/^($longchar)//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;return$output}1;
POD_TEXT_TERMCAP

$fatpacked{"Pod/Usage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_USAGE';
  package Pod::Usage;use strict;use vars qw($VERSION @ISA @EXPORT);$VERSION='1.69';require 5.006;use Carp;use Config;use Exporter;use File::Spec;@EXPORT=qw(&pod2usage);BEGIN {$Pod::Usage::Formatter ||= 'Pod::Text';eval "require $Pod::Usage::Formatter";die $@ if $@;@ISA=($Pod::Usage::Formatter)}our$MAX_HEADING_LEVEL=3;sub pod2usage {local($_)=shift;my%opts;if (@_ > 0){%opts=($_,@_)}elsif (!defined $_){$_=''}elsif (ref $_){%opts=%{$_}if (ref($_)eq 'HASH')}elsif (/^[-+]?\d+$/){$opts{'-exitval'}=$_}else {$_ and $opts{'-message'}=$_}%opts=map {my ($key,$val)=($_,$opts{$_});$key =~ s/^(?=\w)/-/;$key =~ /^-msg/i and $key='-message';$key =~ /^-exit/i and $key='-exitval';lc($key)=>$val}(keys%opts);if ((!defined$opts{'-exitval'})&& (!defined$opts{'-verbose'})){$opts{'-exitval'}=2;$opts{'-verbose'}=0}elsif (!defined$opts{'-exitval'}){$opts{'-exitval'}=($opts{'-verbose'}> 0)? 1 : 2}elsif (!defined$opts{'-verbose'}){$opts{'-verbose'}=(lc($opts{'-exitval'})eq 'noexit' || $opts{'-exitval'}< 2)}$opts{'-output'}=(lc($opts{'-exitval'})eq 'noexit' || $opts{'-exitval'}< 2)? \*STDOUT : \*STDERR unless (defined$opts{'-output'});$opts{'-input'}=$0 unless (defined$opts{'-input'});unless ((ref$opts{'-input'})|| (-e $opts{'-input'})){my$basename=$opts{'-input'};my$pathsep=($^O =~ /^(?:dos|os2|MSWin32)$/i)? ';' : (($^O eq 'MacOS' || $^O eq 'VMS')? ',' : ':');my$pathspec=$opts{'-pathlist'}|| $ENV{PATH}|| $ENV{PERL5LIB};my@paths=(ref$pathspec)? @$pathspec : split($pathsep,$pathspec);for my$dirname (@paths){$_=File::Spec->catfile($dirname,$basename)if length;last if (-e $_)&& ($opts{'-input'}=$_)}}my$parser=new Pod::Usage(USAGE_OPTIONS=>\%opts);if ($opts{'-verbose'}==0){$parser->select('(?:SYNOPSIS|USAGE)\s*')}elsif ($opts{'-verbose'}==1){my$opt_re='(?i)' .'(?:OPTIONS|ARGUMENTS)' .'(?:\s*(?:AND|\/)\s*(?:OPTIONS|ARGUMENTS))?';$parser->select('(?:SYNOPSIS|USAGE)\s*',$opt_re,"DESCRIPTION/$opt_re")}elsif ($opts{'-verbose'}>= 2 && $opts{'-verbose'}!=99){$parser->select('.*')}elsif ($opts{'-verbose'}==99){my$sections=$opts{'-sections'};$parser->select((ref$sections)? @$sections : $sections);$opts{'-verbose'}=1}my$progpath=$opts{'-perldoc'}? $opts{'-perldoc'}: File::Spec->catfile($Config{scriptdirexp}|| $Config{scriptdir},'perldoc');my$version=sprintf("%vd",$^V);if ($Config{versiononly}and $Config{startperl}=~ /\Q$version\E$/){$progpath .= $version}$opts{'-noperldoc'}=1 unless -e $progpath;if (!$opts{'-noperldoc'}and $opts{'-verbose'}>= 2 and!ref($opts{'-input'})and $opts{'-output'}==\*STDOUT){print {$opts{'-output'}}($opts{'-message'},"\n")if($opts{'-message'});if(defined$opts{-input}&& $opts{-input}=~ /^\s*(\S.*?)\s*$/){my$f=$1;my@perldoc_cmd=($progpath);if ($opts{'-perldocopt'}){$opts{'-perldocopt'}=~ s/^\s+|\s+$//g;push@perldoc_cmd,split(/\s+/,$opts{'-perldocopt'})}push@perldoc_cmd,('-F',$f);unshift@perldoc_cmd,$opts{'-perlcmd'}if$opts{'-perlcmd'};system(@perldoc_cmd);if($?){system(($Config{pager}|| $ENV{PAGER}|| '/bin/more'),$1)}}else {croak "Unspecified input file or insecure argument.\n"}}else {$parser->parse_from_file($opts{'-input'},$opts{'-output'})}exit($opts{'-exitval'})unless (lc($opts{'-exitval'})eq 'noexit')}sub new {my$this=shift;my$class=ref($this)|| $this;my%params=@_;my$self={%params};bless$self,$class;if ($self->can('initialize')){$self->initialize()}else {my%opts;for (qw(alt code indent loose margin quotes sentence stderr utf8 width)){my$val=$params{USAGE_OPTIONS}{"-$_"};$opts{$_}=$val if defined$val}$self=$self->SUPER::new(%opts);%$self=(%$self,%params)}return$self}sub _compile_section_spec {my ($section_spec)=@_;my (@regexs,$negated);local $_=$section_spec;s{\\\\}{\001}g;s{\\/}{\002}g;@regexs=split(/\//,$_,$MAX_HEADING_LEVEL);for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){$regexs[$i]='.*' unless ((defined$regexs[$i])&& (length$regexs[$i]))}my$bad_regexs=0;for (@regexs){$_ .= '.+' if ($_ eq '!');s{\001}{\\\\}g;s{\002}{\\/}g;$negated=s/^\!//;eval "m{$_}";if ($@){++$bad_regexs;carp qq{Bad regular expression /$_/ in "$section_spec": $@\n}}else {$_='^' .$_ unless (/^\^/);$_=$_ .'$' unless (/\$$/);$_='!' .$_ if ($negated)}}return (!$bad_regexs)? [@regexs ]: undef}sub select {my ($self,@sections)=@_;if ($ISA[0]->can('select')){$self->SUPER::select(@sections)}else {my$add=($sections[0]eq '+')? shift(@sections): '';unless (@sections){delete$self->{USAGE_SELECT}unless ($add);return}$self->{USAGE_SELECT}=[]unless ($add && $self->{USAGE_SELECT});my$sref=$self->{USAGE_SELECT};for my$spec (@sections){my$cs=_compile_section_spec($spec);if (defined$cs){push(@$sref,$cs)}else {carp qq{Ignoring section spec "$spec"!\n}}}}}sub seq_i {return $_[1]}sub cmd_i {return $_[2]}sub _handle_element_end {my ($self,$element)=@_;if ($element eq 'head1'){$self->{USAGE_HEADINGS}=[$$self{PENDING}[-1][1]];if ($self->{USAGE_OPTIONS}->{-verbose}< 2){$$self{PENDING}[-1][1]=~ s/^\s*SYNOPSIS\s*$/USAGE/}}elsif ($element =~ /^head(\d+)$/ && $1){my$idx=$1 - 1;$self->{USAGE_HEADINGS}=[]unless($self->{USAGE_HEADINGS});$self->{USAGE_HEADINGS}->[$idx]=$$self{PENDING}[-1][1];splice(@{$self->{USAGE_HEADINGS}},$idx+1)}if ($element =~ /^head\d+$/){$$self{USAGE_SKIPPING}=1;if (!$$self{USAGE_SELECT}||!@{$$self{USAGE_SELECT}}){$$self{USAGE_SKIPPING}=0}else {my@headings=@{$$self{USAGE_HEADINGS}};for my$section_spec (@{$$self{USAGE_SELECT}}){my$match=1;for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){$headings[$i]='' unless defined$headings[$i];my$regex=$section_spec->[$i];my$negated=($regex =~ s/^\!//);$match &= ($negated ? ($headings[$i]!~ /${regex}/): ($headings[$i]=~ /${regex}/));last unless ($match)}if ($match){$$self{USAGE_SKIPPING}=0;last}}}if($self->{USAGE_OPTIONS}->{-verbose}< 2){local $_=$$self{PENDING}[-1][1];s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;s/\s*$/:/ unless (/:\s*$/);$_ .= "\n";$$self{PENDING}[-1][1]=$_}}if ($$self{USAGE_SKIPPING}&& $element !~ m/^over-|^[BCFILSZ]$/){pop @{$$self{PENDING}}}else {$self->SUPER::_handle_element_end($element)}}sub start_document {my$self=shift;$self->SUPER::start_document();my$msg=$self->{USAGE_OPTIONS}->{-message}or return 1;my$out_fh=$self->output_fh();print$out_fh "$msg\n"}sub begin_pod {my$self=shift;$self->SUPER::begin_pod();my$msg=$self->{USAGE_OPTIONS}->{-message}or return 1;my$out_fh=$self->output_handle();print$out_fh "$msg\n"}sub preprocess_paragraph {my$self=shift;local $_=shift;my$line=shift;if (($self->{USAGE_OPTIONS}->{-verbose}< 2)&& /^=head/){s/^=head1\s+SYNOPSIS\s*$/=head1 USAGE/;s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;s/\s*$/:/ unless (/:\s*$/);$_ .= "\n"}return$self->SUPER::preprocess_paragraph($_)}1;
POD_USAGE

$fatpacked{"Version/Requirements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_REQUIREMENTS';
  use strict;use warnings;package Version::Requirements;BEGIN {$Version::Requirements::VERSION='0.101020'}use Carp ();use Scalar::Util ();use version 0.77 ();sub new {my ($class)=@_;return bless {}=>$class}sub _version_object {my ($self,$version)=@_;$version=(!defined$version)? version->parse(0): (!Scalar::Util::blessed($version))? version->parse($version): $version;return$version}BEGIN {for my$type (qw(minimum maximum exclusion exact_version)){my$method="with_$type";my$to_add=$type eq 'exact_version' ? $type : "add_$type";my$code=sub {my ($self,$name,$version)=@_;$version=$self->_version_object($version);$self->__modify_entry_for($name,$method,$version);return$self};no strict 'refs';*$to_add=$code}}sub add_requirements {my ($self,$req)=@_;for my$module ($req->required_modules){my$modifiers=$req->__entry_for($module)->as_modifiers;for my$modifier (@$modifiers){my ($method,@args)=@$modifier;$self->$method($module=>@args)}}return$self}sub accepts_module {my ($self,$module,$version)=@_;$version=$self->_version_object($version);return 1 unless my$range=$self->__entry_for($module);return$range->_accepts($version)}sub clear_requirement {my ($self,$module)=@_;return$self unless$self->__entry_for($module);Carp::confess("can't clear requirements on finalized requirements")if$self->is_finalized;delete$self->{requirements}{$module };return$self}sub required_modules {keys %{$_[0]{requirements}}}sub clone {my ($self)=@_;my$new=(ref$self)->new;return$new->add_requirements($self)}sub __entry_for {$_[0]{requirements}{$_[1]}}sub __modify_entry_for {my ($self,$name,$method,$version)=@_;my$fin=$self->is_finalized;my$old=$self->__entry_for($name);Carp::confess("can't add new requirements to finalized requirements")if$fin and not $old;my$new=($old || 'Version::Requirements::_Range::Range')->$method($version);Carp::confess("can't modify finalized requirements")if$fin and $old->as_string ne $new->as_string;$self->{requirements}{$name }=$new}sub is_simple {my ($self)=@_;for my$module ($self->required_modules){return if$self->__entry_for($module)->as_string =~ /\s/}return 1}sub is_finalized {$_[0]{finalized}}sub finalize {$_[0]{finalized}=1}sub as_string_hash {my ($self)=@_;my%hash=map {;$_=>$self->{requirements}{$_}->as_string}$self->required_modules;return \%hash}my%methods_for_op=('=='=>[qw(exact_version) ],'!='=>[qw(add_exclusion) ],'>='=>[qw(add_minimum) ],'<='=>[qw(add_maximum) ],'>'=>[qw(add_minimum add_exclusion) ],'<'=>[qw(add_maximum add_exclusion) ],);sub from_string_hash {my ($class,$hash)=@_;my$self=$class->new;for my$module (keys %$hash){my@parts=split qr{\s*,\s*},$hash->{$module };for my$part (@parts){my ($op,$ver)=split /\s+/,$part,2;if (!defined$ver){$self->add_minimum($module=>$op)}else {Carp::confess("illegal requirement string: $hash->{ $module }")unless my$methods=$methods_for_op{$op };$self->$_($module=>$ver)for @$methods}}}return$self}{package Version::Requirements::_Range::Exact;BEGIN {$Version::Requirements::_Range::Exact::VERSION='0.101020'}sub _new {bless {version=>$_[1]}=>$_[0]}sub _accepts {return $_[0]{version}==$_[1]}sub as_string {return "== $_[0]{version}"}sub as_modifiers {return [[exact_version=>$_[0]{version}]]}sub _clone {(ref $_[0])->_new(version->new($_[0]{version}))}sub with_exact_version {my ($self,$version)=@_;return$self->_clone if$self->_accepts($version);Carp::confess("illegal requirements: unequal exact version specified")}sub with_minimum {my ($self,$minimum)=@_;return$self->_clone if$self->{version}>= $minimum;Carp::confess("illegal requirements: minimum above exact specification")}sub with_maximum {my ($self,$maximum)=@_;return$self->_clone if$self->{version}<= $maximum;Carp::confess("illegal requirements: maximum below exact specification")}sub with_exclusion {my ($self,$exclusion)=@_;return$self->_clone unless$exclusion==$self->{version};Carp::confess("illegal requirements: excluded exact specification")}}{package Version::Requirements::_Range::Range;BEGIN {$Version::Requirements::_Range::Range::VERSION='0.101020'}sub _self {ref($_[0])? $_[0]: (bless {}=>$_[0])}sub _clone {return (bless {}=>$_[0])unless ref $_[0];my ($s)=@_;my%guts=((exists$s->{minimum}? (minimum=>version->new($s->{minimum})): ()),(exists$s->{maximum}? (maximum=>version->new($s->{maximum})): ()),(exists$s->{exclusions}? (exclusions=>[map {version->new($_)}@{$s->{exclusions}}]): ()),);bless \%guts=>ref($s)}sub as_modifiers {my ($self)=@_;my@mods;push@mods,[add_minimum=>$self->{minimum}]if exists$self->{minimum};push@mods,[add_maximum=>$self->{maximum}]if exists$self->{maximum};push@mods,map {;[add_exclusion=>$_ ]}@{$self->{exclusions}|| []};return \@mods}sub as_string {my ($self)=@_;return 0 if!keys %$self;return "$self->{minimum}" if (keys %$self)==1 and exists$self->{minimum};my@exclusions=@{$self->{exclusions}|| []};my@parts;for my$pair ([qw(>= > minimum) ],[qw(<= < maximum) ],){my ($op,$e_op,$k)=@$pair;if (exists$self->{$k}){my@new_exclusions=grep {$_!=$self->{$k }}@exclusions;if (@new_exclusions==@exclusions){push@parts,"$op $self->{ $k }"}else {push@parts,"$e_op $self->{ $k }";@exclusions=@new_exclusions}}}push@parts,map {;"!= $_"}@exclusions;return join q{, },@parts}sub with_exact_version {my ($self,$version)=@_;$self=$self->_clone;Carp::confess("illegal requirements: exact specification outside of range")unless$self->_accepts($version);return Version::Requirements::_Range::Exact->_new($version)}sub _simplify {my ($self)=@_;if (defined$self->{minimum}and defined$self->{maximum}){if ($self->{minimum}==$self->{maximum}){Carp::confess("illegal requirements: excluded all values")if grep {$_==$self->{minimum}}@{$self->{exclusions}|| []};return Version::Requirements::_Range::Exact->_new($self->{minimum})}Carp::confess("illegal requirements: minimum exceeds maximum")if$self->{minimum}> $self->{maximum}}if ($self->{exclusions}){my%seen;@{$self->{exclusions}}=grep {(!defined$self->{minimum}or $_ >= $self->{minimum})and (!defined$self->{maximum}or $_ <= $self->{maximum})and !$seen{$_}++}@{$self->{exclusions}}}return$self}sub with_minimum {my ($self,$minimum)=@_;$self=$self->_clone;if (defined (my$old_min=$self->{minimum})){$self->{minimum}=(sort {$b cmp $a}($minimum,$old_min))[0]}else {$self->{minimum}=$minimum}return$self->_simplify}sub with_maximum {my ($self,$maximum)=@_;$self=$self->_clone;if (defined (my$old_max=$self->{maximum})){$self->{maximum}=(sort {$a cmp $b}($maximum,$old_max))[0]}else {$self->{maximum}=$maximum}return$self->_simplify}sub with_exclusion {my ($self,$exclusion)=@_;$self=$self->_clone;push @{$self->{exclusions}||= []},$exclusion;return$self->_simplify}sub _accepts {my ($self,$version)=@_;return if defined$self->{minimum}and $version < $self->{minimum};return if defined$self->{maximum}and $version > $self->{maximum};return if defined$self->{exclusions}and grep {$version==$_}@{$self->{exclusions}};return 1}}1;
VERSION_REQUIREMENTS

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;use strict;use vars qw($VERSION);$VERSION='0.236';sub import {my$class=shift;my$inheritor=caller(0);if (@_ and $_[0]eq '-norequire'){shift @_}else {for (my@filename=@_){s{::|'}{/}g;require "$_.pm"}}{no strict 'refs';push @{"$inheritor\::ISA"},@_}};1;
PARENT

$fatpacked{"version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION';
  package version;use 5.005_04;use strict;use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);$VERSION=0.88;$CLASS='version';my$FRACTION_PART=qr/\.[0-9]+/;my$STRICT_INTEGER_PART=qr/0|[1-9][0-9]*/;my$LAX_INTEGER_PART=qr/[0-9]+/;my$STRICT_DOTTED_DECIMAL_PART=qr/\.[0-9]{1,3}/;my$LAX_DOTTED_DECIMAL_PART=qr/\.[0-9]+/;my$LAX_ALPHA_PART=qr/_[0-9]+/;my$STRICT_DECIMAL_VERSION=qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;my$STRICT_DOTTED_DECIMAL_VERSION=qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;$STRICT=qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;my$LAX_DECIMAL_VERSION=qr/ $LAX_INTEGER_PART (?: \. | $FRACTION_PART $LAX_ALPHA_PART? )?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;my$LAX_DOTTED_DECIMAL_VERSION=qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;$LAX=qr/ undef | $LAX_DECIMAL_VERSION | $LAX_DOTTED_DECIMAL_VERSION /x;eval "use version::vxs $VERSION";if ($@){eval "use version::vpp $VERSION";die "$@" if ($@);push@ISA,"version::vpp";local $^W;*version::qv=\&version::vpp::qv;*version::declare=\&version::vpp::declare;*version::_VERSION=\&version::vpp::_VERSION;if ($] >= 5.009000 && $] < 5.011004){no strict 'refs';*version::stringify=\&version::vpp::stringify;*{'version::(""'}=\&version::vpp::stringify;*version::new=\&version::vpp::new;*version::parse=\&version::vpp::parse}}else {push@ISA,"version::vxs";local $^W;*version::declare=\&version::vxs::declare;*version::qv=\&version::vxs::qv;*version::_VERSION=\&version::vxs::_VERSION;*version::vcmp=\&version::vxs::VCMP;if ($] >= 5.009000 && $] < 5.011004){no strict 'refs';*version::stringify=\&version::vxs::stringify;*{'version::(""'}=\&version::vxs::stringify;*version::new=\&version::vxs::new;*version::parse=\&version::vxs::parse}}sub import {no strict 'refs';my ($class)=shift;unless ($class eq 'version'){local $^W;*{$class.'::declare'}=\&version::declare;*{$class.'::qv'}=\&version::qv}my%args;if (@_){map {$args{$_}=1}@_}else {%args=(qv=>1,'UNIVERSAL::VERSION'=>1,)}my$callpkg=caller();if (exists($args{declare})){*{$callpkg.'::declare'}=sub {return$class->declare(shift)}unless defined(&{$callpkg.'::declare'})}if (exists($args{qv})){*{$callpkg.'::qv'}=sub {return$class->qv(shift)}unless defined(&{$callpkg.'::qv'})}if (exists($args{'UNIVERSAL::VERSION'})){local $^W;*UNIVERSAL::VERSION =\&version::_VERSION}if (exists($args{'VERSION'})){*{$callpkg.'::VERSION'}=\&version::_VERSION}if (exists($args{'is_strict'})){*{$callpkg.'::is_strict'}=\&version::is_strict unless defined(&{$callpkg.'::is_strict'})}if (exists($args{'is_lax'})){*{$callpkg.'::is_lax'}=\&version::is_lax unless defined(&{$callpkg.'::is_lax'})}}sub is_strict {defined $_[0]&& $_[0]=~ qr/ \A $STRICT \z /x}sub is_lax {defined $_[0]&& $_[0]=~ qr/ \A $LAX \z /x}1;
VERSION

$fatpacked{"version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_VPP';
  package charstar;use overload ('""'=>\&thischar,'0+'=>\&thischar,'++'=>\&increment,'--'=>\&decrement,'+'=>\&plus,'-'=>\&minus,'*'=>\&multiply,'cmp'=>\&cmp,'<=>'=>\&spaceship,'bool'=>\&thischar,'='=>\&clone,);sub new {my ($self,$string)=@_;my$class=ref($self)|| $self;my$obj={string=>[split(//,$string)],current=>0,};return bless$obj,$class}sub thischar {my ($self)=@_;my$last=$#{$self->{string}};my$curr=$self->{current};if ($curr >= 0 && $curr <= $last){return$self->{string}->[$curr]}else {return ''}}sub increment {my ($self)=@_;$self->{current}++}sub decrement {my ($self)=@_;$self->{current}--}sub plus {my ($self,$offset)=@_;my$rself=$self->clone;$rself->{current}+= $offset;return$rself}sub minus {my ($self,$offset)=@_;my$rself=$self->clone;$rself->{current}-= $offset;return$rself}sub multiply {my ($left,$right,$swapped)=@_;my$char=$left->thischar();return$char * $right}sub spaceship {my ($left,$right,$swapped)=@_;unless (ref($right)){$right=$left->new($right)}return$left->{current}<=> $right->{current}}sub cmp {my ($left,$right,$swapped)=@_;unless (ref($right)){if (length($right)==1){return$left->thischar cmp $right}$right=$left->new($right)}return$left->currstr cmp $right->currstr}sub bool {my ($self)=@_;my$char=$self->thischar;return ($char ne '')}sub clone {my ($left,$right,$swapped)=@_;$right={string=>[@{$left->{string}}],current=>$left->{current},};return bless$right,ref($left)}sub currstr {my ($self,$s)=@_;my$curr=$self->{current};my$last=$#{$self->{string}};if (defined($s)&& $s->{current}< $last){$last=$s->{current}}my$string=join('',@{$self->{string}}[$curr..$last]);return$string}package version::vpp;use strict;use POSIX qw/locale_h/;use locale;use vars qw ($VERSION @ISA @REGEXS);$VERSION=0.88;use overload ('""'=>\&stringify,'0+'=>\&numify,'cmp'=>\&vcmp,'<=>'=>\&vcmp,'bool'=>\&vbool,'nomethod'=>\&vnoop,);eval "use warnings";if ($@){eval '
  	package warnings;
  	sub enabled {return $^W;}
  	1;
      '}my$VERSION_MAX=0x7FFFFFFF;use constant TRUE=>1;use constant FALSE=>0;sub isDIGIT {my ($char)=shift->thischar();return ($char =~ /\d/)}sub isALPHA {my ($char)=shift->thischar();return ($char =~ /[a-zA-Z]/)}sub isSPACE {my ($char)=shift->thischar();return ($char =~ /\s/)}sub BADVERSION {my ($s,$errstr,$error)=@_;if ($errstr){$$errstr=$error}return$s}sub prescan_version {my ($s,$strict,$errstr,$sqv,$ssaw_decimal,$swidth,$salpha)=@_;my$qv=defined$sqv ? $$sqv : FALSE;my$saw_decimal=defined$ssaw_decimal ? $$ssaw_decimal : 0;my$width=defined$swidth ? $$swidth : 3;my$alpha=defined$salpha ? $$salpha : FALSE;my$d=$s;if ($qv && isDIGIT($d)){goto dotted_decimal_version}if ($d eq 'v'){$d++;if (isDIGIT($d)){$qv=TRUE}else {return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}dotted_decimal_version: if ($strict && $d eq '0' && isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)")}while (isDIGIT($d)){$d++}if ($d eq '.'){$saw_decimal++;$d++}else {if ($strict){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}else {goto version_prescan_finish}}{my$i=0;my$j=0;while (isDIGIT($d)){$i++;while (isDIGIT($d)){$d++;$j++;if ($strict && $j > 3){return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)")}}if ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)")}$d++;$alpha=TRUE}elsif ($d eq '.'){if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)")}$saw_decimal++;$d++}elsif (!isDIGIT($d)){last}$j=0}if ($strict && $i < 2){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}}}else {if ($strict){if ($d eq '.'){return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)")}if ($d eq '0' && isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)")}}while (isDIGIT($d)){$d++}if ($d eq '.'){$saw_decimal++;$d++}elsif (!$d || $d eq ';' || isSPACE($d)|| $d eq '}'){if ($d==$s){return BADVERSION($s,$errstr,"Invalid version format (version required)")}goto version_prescan_finish}elsif ($d==$s){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}elsif ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}elsif (isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)")}else {return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)")}}elsif ($d){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}if ($d &&!isDIGIT($d)&& ($strict ||!($d eq ';' || isSPACE($d)|| $d eq '}'))){return BADVERSION($s,$errstr,"Invalid version format (fractional part required)")}while (isDIGIT($d)){$d++;if ($d eq '.' && isDIGIT($d-1)){if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)")}if ($strict){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')")}$d=$s;$qv=TRUE;goto dotted_decimal_version}if ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)")}if (!isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)")}$d++;$alpha=TRUE}}}version_prescan_finish: while (isSPACE($d)){$d++}if ($d &&!isDIGIT($d)&& (!($d eq ';' || $d eq '}'))){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}if (defined$sqv){$$sqv=$qv}if (defined$swidth){$$swidth=$width}if (defined$ssaw_decimal){$$ssaw_decimal=$saw_decimal}if (defined$salpha){$$salpha=$alpha}return$d}sub scan_version {my ($s,$rv,$qv)=@_;my$start;my$pos;my$last;my$errstr;my$saw_decimal=0;my$width=3;my$alpha=FALSE;my$vinf=FALSE;my@av;$s=new charstar$s;while (isSPACE($s)){$s++}$last=prescan_version($s,FALSE,\$errstr,\$qv,\$saw_decimal,\$width,\$alpha);if ($errstr){if ($s ne 'undef'){use Carp;Carp::croak($errstr)}}$start=$s;if ($s eq 'v'){$s++}$pos=$s;if ($qv){$$rv->{qv}=$qv}if ($alpha){$$rv->{alpha}=$alpha}if (!$qv && $width < 3){$$rv->{width}=$width}while (isDIGIT($pos)){$pos++}if (!isALPHA($pos)){my$rev;for (;;){$rev=0;{my$end=$pos;my$mult=1;my$orev;if (!$qv && $s > $start && $saw_decimal==1){$mult *= 100;while ($s < $end){$orev=$rev;$rev += $s * $mult;$mult /= 10;if ((abs($orev)> abs($rev))|| (abs($rev)> $VERSION_MAX)){warn("Integer overflow in version %d",$VERSION_MAX);$s=$end - 1;$rev=$VERSION_MAX;$vinf=1}$s++;if ($s eq '_'){$s++}}}else {while (--$end >= $s){$orev=$rev;$rev += $end * $mult;$mult *= 10;if ((abs($orev)> abs($rev))|| (abs($rev)> $VERSION_MAX)){warn("Integer overflow in version");$end=$s - 1;$rev=$VERSION_MAX;$vinf=1}}}}push@av,$rev;if ($vinf){$s=$last;last}elsif ($pos eq '.'){$s=++$pos}elsif ($pos eq '_' && isDIGIT($pos+1)){$s=++$pos}elsif ($pos eq ',' && isDIGIT($pos+1)){$s=++$pos}elsif (isDIGIT($pos)){$s=$pos}else {$s=$pos;last}if ($qv){while (isDIGIT($pos)){$pos++}}else {my$digits=0;while ((isDIGIT($pos)|| $pos eq '_')&& $digits < 3){if ($pos ne '_'){$digits++}$pos++}}}}if ($qv){my$len=$#av;$len=2 - $len;while ($len-- > 0){push@av,0}}if ($vinf){$$rv->{original}="v.Inf";$$rv->{vinf}=1}elsif ($s > $start){$$rv->{original}=$start->currstr($s);if ($qv && $saw_decimal==1 && $start ne 'v'){$$rv->{original}='v' .$$rv->{original}}}else {$$rv->{original}='0';push(@av,0)}$$rv->{version}=\@av;if ($s eq 'undef'){$s += 5}return$s}sub new {my ($class,$value)=@_;my$self=bless ({},ref ($class)|| $class);my$qv=FALSE;if (ref($value)&& eval('$value->isa("version")')){$self->{version}=[@{$value->{version}}];$self->{qv}=1 if$value->{qv};$self->{alpha}=1 if$value->{alpha};$self->{original}=''.$value->{original};return$self}my$currlocale=setlocale(LC_ALL);if (localeconv()->{decimal_point}eq ','){$value =~ tr/,/./}if (not defined$value or $value =~ /^undef$/){push @{$self->{version}},0;$self->{original}="0";return ($self)}if ($#_==2){$value=$_[2];$qv=TRUE}$value=_un_vstring($value);if ($value =~ /\d+.?\d*e[-+]?\d+/){$value=sprintf("%.9f",$value);$value =~ s/(0+)$//}my$s=scan_version($value,\$self,$qv);if ($s){warn("Version string '%s' contains invalid data; " ."ignoring: '%s'",$value,$s)}return ($self)}*parse=\&new;sub numify {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}my$width=$self->{width}|| 3;my$alpha=$self->{alpha}|| "";my$len=$#{$self->{version}};my$digit=$self->{version}[0];my$string=sprintf("%d.",$digit);for (my$i=1 ;$i < $len ;$i++ ){$digit=$self->{version}[$i];if ($width < 3){my$denom=10**(3-$width);my$quot=int($digit/$denom);my$rem=$digit - ($quot * $denom);$string .= sprintf("%0".$width."d_%d",$quot,$rem)}else {$string .= sprintf("%03d",$digit)}}if ($len > 0){$digit=$self->{version}[$len];if ($alpha && $width==3){$string .= "_"}$string .= sprintf("%0".$width."d",$digit)}else {$string .= sprintf("000")}return$string}sub normal {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}my$alpha=$self->{alpha}|| "";my$len=$#{$self->{version}};my$digit=$self->{version}[0];my$string=sprintf("v%d",$digit);for (my$i=1 ;$i < $len ;$i++ ){$digit=$self->{version}[$i];$string .= sprintf(".%d",$digit)}if ($len > 0){$digit=$self->{version}[$len];if ($alpha){$string .= sprintf("_%0d",$digit)}else {$string .= sprintf(".%0d",$digit)}}if ($len <= 2){for ($len=2 - $len;$len!=0;$len-- ){$string .= sprintf(".%0d",0)}}return$string}sub stringify {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}return exists$self->{original}? $self->{original}: exists$self->{qv}? $self->normal : $self->numify}sub vcmp {require UNIVERSAL;my ($left,$right,$swap)=@_;my$class=ref($left);unless (UNIVERSAL::isa($right,$class)){$right=$class->new($right)}if ($swap){($left,$right)=($right,$left)}unless (_verify($left)){require Carp;Carp::croak("Invalid version object")}unless (_verify($right)){require Carp;Carp::croak("Invalid version object")}my$l=$#{$left->{version}};my$r=$#{$right->{version}};my$m=$l < $r ? $l : $r;my$lalpha=$left->is_alpha;my$ralpha=$right->is_alpha;my$retval=0;my$i=0;while ($i <= $m && $retval==0){$retval=$left->{version}[$i]<=> $right->{version}[$i];$i++}if ($retval==0 && $l==$r && $left->{version}[$m]==$right->{version}[$m]&& ($lalpha || $ralpha)){if ($lalpha &&!$ralpha){$retval=-1}elsif ($ralpha &&!$lalpha){$retval=+1}}if ($retval==0 && $l!=$r){if ($l < $r){while ($i <= $r && $retval==0){if ($right->{version}[$i]!=0){$retval=-1}$i++}}else {while ($i <= $l && $retval==0){if ($left->{version}[$i]!=0){$retval=+1}$i++}}}return$retval}sub vbool {my ($self)=@_;return vcmp($self,$self->new("0"),1)}sub vnoop {require Carp;Carp::croak("operation not supported with version object")}sub is_alpha {my ($self)=@_;return (exists$self->{alpha})}sub qv {my$value=shift;my$class='version';if (@_){$class=ref($value)|| $value;$value=shift}$value=_un_vstring($value);$value='v'.$value unless$value =~ /(^v|\d+\.\d+\.\d)/;my$version=$class->new($value);return$version}*declare=\&qv;sub is_qv {my ($self)=@_;return (exists$self->{qv})}sub _verify {my ($self)=@_;if (ref($self)&& eval {exists$self->{version}}&& ref($self->{version})eq 'ARRAY'){return 1}else {return 0}}sub _is_non_alphanumeric {my$s=shift;$s=new charstar$s;while ($s){return 0 if isSPACE($s);return 1 unless (isALPHA($s)|| isDIGIT($s)|| $s =~ /[.-]/);$s++}return 0}sub _un_vstring {my$value=shift;if (length($value)>= 3 && $value !~ /[._]/ && _is_non_alphanumeric($value)){my$tvalue;if ($] ge 5.008_001){$tvalue=_find_magic_vstring($value);$value=$tvalue if length$tvalue}elsif ($] ge 5.006_000){$tvalue=sprintf("v%vd",$value);if ($tvalue =~ /^v\d+(\.\d+){2,}$/){$value=$tvalue}}}return$value}sub _find_magic_vstring {my$value=shift;my$tvalue='';require B;my$sv=B::svref_2object(\$value);my$magic=ref($sv)eq 'B::PVMG' ? $sv->MAGIC : undef;while ($magic){if ($magic->TYPE eq 'V'){$tvalue=$magic->PTR;$tvalue =~ s/^v?(.+)$/v$1/;last}else {$magic=$magic->MOREMAGIC}}return$tvalue}sub _VERSION {my ($obj,$req)=@_;my$class=ref($obj)|| $obj;no strict 'refs';if (exists$INC{"$class.pm"}and not %{"$class\::"}and $] >= 5.008){require Carp;Carp::croak("$class defines neither package nor VERSION" ."--version check failed")}my$version=eval "\$$class\::VERSION";if (defined$version){local $^W if $] <= 5.008;$version=version::vpp->new($version)}if (defined$req){unless (defined$version){require Carp;my$msg=$] < 5.006 ? "$class version $req required--this is only version " : "$class does not define \$$class\::VERSION" ."--version check failed";if ($ENV{VERSION_DEBUG}){Carp::confess($msg)}else {Carp::croak($msg)}}$req=version::vpp->new($req);if ($req > $version){require Carp;if ($req->is_qv){Carp::croak(sprintf ("%s version %s required--"."this is only version %s",$class,$req->normal,$version->normal))}else {Carp::croak(sprintf ("%s version %s required--"."this is only version %s",$class,$req->stringify,$version->stringify))}}}return defined$version ? $version->stringify : undef}1;
VERSION_VPP

$fatpacked{"x86_64-linux/Cwd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_CWD';
  package Cwd;use strict;use Exporter;use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);$VERSION='3.62';my$xs_version=$VERSION;$VERSION =~ tr/_//d;@ISA=qw/Exporter/;@EXPORT=qw(cwd getcwd fastcwd fastgetcwd);push@EXPORT,qw(getdcwd) if $^O eq 'MSWin32';@EXPORT_OK=qw(chdir abs_path fast_abs_path realpath fast_realpath);if ($^O eq 'os2'){local $^W=0;*cwd=defined&sys_cwd ? \&sys_cwd : \&_os2_cwd;*getcwd=\&cwd;*fastgetcwd=\&cwd;*fastcwd=\&cwd;*fast_abs_path=\&sys_abspath if defined&sys_abspath;*abs_path=\&fast_abs_path;*realpath=\&fast_abs_path;*fast_realpath=\&fast_abs_path;return 1}my$use_vms_feature;BEGIN {if ($^O eq 'VMS'){if (eval {local$SIG{__DIE__};require VMS::Feature}){$use_vms_feature=1}}}sub _vms_unix_rpt {my$unix_rpt;if ($use_vms_feature){$unix_rpt=VMS::Feature::current("filename_unix_report")}else {my$env_unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';$unix_rpt=$env_unix_rpt =~ /^[ET1]/i}return$unix_rpt}sub _vms_efs {my$efs;if ($use_vms_feature){$efs=VMS::Feature::current("efs_charset")}else {my$env_efs=$ENV{'DECC$EFS_CHARSET'}|| '';$efs=$env_efs =~ /^[ET1]/i}return$efs}if(!defined&getcwd && defined&DynaLoader::boot_DynaLoader){eval {if ($] >= 5.006){require XSLoader;XSLoader::load(__PACKAGE__,$xs_version)}else {require DynaLoader;push@ISA,'DynaLoader';__PACKAGE__->bootstrap($xs_version)}}}my%METHOD_MAP=(VMS=>{cwd=>'_vms_cwd',getcwd=>'_vms_cwd',fastcwd=>'_vms_cwd',fastgetcwd=>'_vms_cwd',abs_path=>'_vms_abs_path',fast_abs_path=>'_vms_abs_path',},MSWin32=>{cwd=>'_NT_cwd',getcwd=>'_NT_cwd',fastcwd=>'_NT_cwd',fastgetcwd=>'_NT_cwd',abs_path=>'fast_abs_path',realpath=>'fast_abs_path',},dos=>{cwd=>'_dos_cwd',getcwd=>'_dos_cwd',fastgetcwd=>'_dos_cwd',fastcwd=>'_dos_cwd',abs_path=>'fast_abs_path',},qnx=>{cwd=>'_qnx_cwd',getcwd=>'_qnx_cwd',fastgetcwd=>'_qnx_cwd',fastcwd=>'_qnx_cwd',abs_path=>'_qnx_abs_path',fast_abs_path=>'_qnx_abs_path',},cygwin=>{getcwd=>'cwd',fastgetcwd=>'cwd',fastcwd=>'cwd',abs_path=>'fast_abs_path',realpath=>'fast_abs_path',},epoc=>{cwd=>'_epoc_cwd',getcwd=>'_epoc_cwd',fastgetcwd=>'_epoc_cwd',fastcwd=>'_epoc_cwd',abs_path=>'fast_abs_path',},MacOS=>{getcwd=>'cwd',fastgetcwd=>'cwd',fastcwd=>'cwd',abs_path=>'fast_abs_path',},amigaos=>{getcwd=>'_backtick_pwd',fastgetcwd=>'_backtick_pwd',fastcwd=>'_backtick_pwd',abs_path=>'fast_abs_path',});$METHOD_MAP{NT}=$METHOD_MAP{MSWin32};my$pwd_cmd;if($^O ne 'MSWin32'){for my$try ('/bin/pwd','/usr/bin/pwd','/QOpenSys/bin/pwd',){if(-x $try){$pwd_cmd=$try;last}}}if ($^O =~ /android/){if (-x $Config::Config{targetsh}){$pwd_cmd="$Config::Config{targetsh} -c pwd"}else {my$sh=$Config::Config{sh}|| (-x '/system/bin/sh' ? '/system/bin/sh' : 'sh');$pwd_cmd="$sh -c pwd"}}my$found_pwd_cmd=defined($pwd_cmd);unless ($pwd_cmd){$pwd_cmd='pwd'}sub _carp {require Carp;Carp::carp(@_)}sub _croak {require Carp;Carp::croak(@_)}sub _backtick_pwd {my@localize=grep exists$ENV{$_},qw(PATH IFS CDPATH ENV BASH_ENV) if $^O ne "amigaos";local@ENV{@localize}if@localize;my$cwd=`$pwd_cmd`;local $/="\n";chomp($cwd)if defined$cwd;$cwd}unless ($METHOD_MAP{$^O}{cwd}or defined&cwd){my$sep=$Config::Config{path_sep}|| ':';my$os=$^O;if (defined$ENV{PATH}and $os ne 'MSWin32'){my@candidates=split($sep,$ENV{PATH});while (!$found_pwd_cmd and @candidates){my$candidate=shift@candidates;$found_pwd_cmd=1 if -x "$candidate/pwd"}}if($os eq 'MacOS' || $found_pwd_cmd){*cwd=\&_backtick_pwd}else {*cwd=\&getcwd}}if ($^O eq 'cygwin'){local $^W=0;my$orig_cwd=\&cwd;*cwd=sub {&$orig_cwd()}}*fastgetcwd=\&cwd;sub _perl_getcwd {abs_path('.')}sub fastcwd_ {my($odev,$oino,$cdev,$cino,$tdev,$tino);my(@path,$path);local(*DIR);my($orig_cdev,$orig_cino)=stat('.');($cdev,$cino)=($orig_cdev,$orig_cino);for (;;){my$direntry;($odev,$oino)=($cdev,$cino);CORE::chdir('..')|| return undef;($cdev,$cino)=stat('.');last if$odev==$cdev && $oino==$cino;opendir(DIR,'.')|| return undef;for (;;){$direntry=readdir(DIR);last unless defined$direntry;next if$direntry eq '.';next if$direntry eq '..';($tdev,$tino)=lstat($direntry);last unless$tdev!=$odev || $tino!=$oino}closedir(DIR);return undef unless defined$direntry;unshift(@path,$direntry)}$path='/' .join('/',@path);if ($^O eq 'apollo'){$path="/".$path}$path =~ /^(.*)\z/s && CORE::chdir($1)or return undef;($cdev,$cino)=stat('.');die "Unstable directory path, current directory changed unexpectedly" if$cdev!=$orig_cdev || $cino!=$orig_cino;$path}if (not defined&fastcwd){*fastcwd=\&fastcwd_}my$chdir_init=0;sub chdir_init {if ($ENV{'PWD'}and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32'){my($dd,$di)=stat('.');my($pd,$pi)=stat($ENV{'PWD'});if (!defined$dd or!defined$pd or $di!=$pi or $dd!=$pd){$ENV{'PWD'}=cwd()}}else {my$wd=cwd();$wd=Win32::GetFullPathName($wd)if $^O eq 'MSWin32';$ENV{'PWD'}=$wd}if ($^O ne 'MSWin32' and $ENV{'PWD'}=~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s){my($pd,$pi)=stat($2);my($dd,$di)=stat($1);if (defined$pd and defined$dd and $di==$pi and $dd==$pd){$ENV{'PWD'}="$2$3"}}$chdir_init=1}sub chdir {my$newdir=@_ ? shift : '';if ($^O eq "cygwin"){$newdir =~ s|\A///+|//|;$newdir =~ s|(?<=[^/])//+|/|g}elsif ($^O ne 'MSWin32'){$newdir =~ s|///*|/|g}chdir_init()unless$chdir_init;my$newpwd;if ($^O eq 'MSWin32'){$newpwd=Win32::GetFullPathName($newdir)}return 0 unless CORE::chdir$newdir;if ($^O eq 'VMS'){return$ENV{'PWD'}=$ENV{'DEFAULT'}}elsif ($^O eq 'MacOS'){return$ENV{'PWD'}=cwd()}elsif ($^O eq 'MSWin32'){$ENV{'PWD'}=$newpwd;return 1}if (ref$newdir eq 'GLOB'){$ENV{'PWD'}=cwd()}elsif ($newdir =~ m#^/#s){$ENV{'PWD'}=$newdir}else {my@curdir=split(m#/#,$ENV{'PWD'});@curdir=('')unless@curdir;my$component;for$component (split(m#/#,$newdir)){next if$component eq '.';pop(@curdir),next if$component eq '..';push(@curdir,$component)}$ENV{'PWD'}=join('/',@curdir)|| '/'}1}sub _perl_abs_path {my$start=@_ ? shift : '.';my($dotdots,$cwd,@pst,@cst,$dir,@tst);unless (@cst=stat($start)){_carp("stat($start): $!");return ''}unless (-d _){my ($dir,$file)=$start =~ m{^(.*)/(.+)$} or return cwd().'/' .$start;if (-l $start){my$link_target=readlink($start);die "Can't resolve link $start: $!" unless defined$link_target;require File::Spec;$link_target=$dir .'/' .$link_target unless File::Spec->file_name_is_absolute($link_target);return abs_path($link_target)}return$dir ? abs_path($dir)."/$file" : "/$file"}$cwd='';$dotdots=$start;do {$dotdots .= '/..';@pst=@cst;local*PARENT;unless (opendir(PARENT,$dotdots)){require File::Spec;return File::Spec->rel2abs($start,_backtick_pwd())}unless (@cst=stat($dotdots)){_carp("stat($dotdots): $!");closedir(PARENT);return ''}if ($pst[0]==$cst[0]&& $pst[1]==$cst[1]){$dir=undef}else {do {unless (defined ($dir=readdir(PARENT))){_carp("readdir($dotdots): $!");closedir(PARENT);return ''}$tst[0]=$pst[0]+1 unless (@tst=lstat("$dotdots/$dir"))}while ($dir eq '.' || $dir eq '..' || $tst[0]!=$pst[0]|| $tst[1]!=$pst[1])}$cwd=(defined$dir ? "$dir" : "")."/$cwd" ;closedir(PARENT)}while (defined$dir);chop($cwd)unless$cwd eq '/';$cwd}my$Curdir;sub fast_abs_path {local$ENV{PWD}=$ENV{PWD}|| '';my$cwd=getcwd();require File::Spec;my$path=@_ ? shift : ($Curdir ||= File::Spec->curdir);($path)=$path =~ /(.*)/s;($cwd)=$cwd =~ /(.*)/s;unless (-e $path){_croak("$path: No such file or directory")}unless (-d _){my ($vol,$dir,$file)=File::Spec->splitpath($path);return File::Spec->catfile($cwd,$path)unless length$dir;if (-l $path){my$link_target=readlink($path);die "Can't resolve link $path: $!" unless defined$link_target;$link_target=File::Spec->catpath($vol,$dir,$link_target)unless File::Spec->file_name_is_absolute($link_target);return fast_abs_path($link_target)}return$dir eq File::Spec->rootdir ? File::Spec->catpath($vol,$dir,$file): fast_abs_path(File::Spec->catpath($vol,$dir,'')).'/' .$file}if (!CORE::chdir($path)){_croak("Cannot chdir to $path: $!")}my$realpath=getcwd();if (!((-d $cwd)&& (CORE::chdir($cwd)))){_croak("Cannot chdir back to $cwd: $!")}$realpath}*fast_realpath=\&fast_abs_path;sub _vms_cwd {return$ENV{'DEFAULT'}}sub _vms_abs_path {return$ENV{'DEFAULT'}unless @_;my$path=shift;my$efs=_vms_efs;my$unix_rpt=_vms_unix_rpt;if (defined&VMS::Filespec::vmsrealpath){my$path_unix=0;my$path_vms=0;$path_unix=1 if ($path =~ m#(?<=\^)/#);$path_unix=1 if ($path =~ /^\.\.?$/);$path_vms=1 if ($path =~ m#[\[<\]]#);$path_vms=1 if ($path =~ /^--?$/);my$unix_mode=$path_unix;if ($efs){if ($path_vms==$path_unix){$unix_mode=$unix_rpt}else {$unix_mode=0 if$path_vms}}if ($unix_mode){return VMS::Filespec::unixrealpath($path)}my$new_path=VMS::Filespec::vmsrealpath($path);$new_path=VMS::Filespec::pathify($new_path)if -d $path;return$new_path}if (-l $path){my$link_target=readlink($path);die "Can't resolve link $path: $!" unless defined$link_target;return _vms_abs_path($link_target)}my$pathified=VMS::Filespec::pathify($path);$path=$pathified if defined$pathified;return VMS::Filespec::rmsexpand($path)}sub _os2_cwd {my$pwd=`cmd /c cd`;chomp$pwd;$pwd =~ s:\\:/:g ;$ENV{'PWD'}=$pwd;return$pwd}sub _win32_cwd_simple {my$pwd=`cd`;chomp$pwd;$pwd =~ s:\\:/:g ;$ENV{'PWD'}=$pwd;return$pwd}sub _win32_cwd {my$pwd;$pwd=Win32::GetCwd();$pwd =~ s:\\:/:g ;$ENV{'PWD'}=$pwd;return$pwd}*_NT_cwd=defined&Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;sub _dos_cwd {my$pwd;if (!defined&Dos::GetCwd){chomp($pwd=`command /c cd`);$pwd =~ s:\\:/:g }else {$pwd=Dos::GetCwd()}$ENV{'PWD'}=$pwd;return$pwd}sub _qnx_cwd {local$ENV{PATH}='';local$ENV{CDPATH}='';local$ENV{ENV}='';my$pwd=`/usr/bin/fullpath -t`;chomp$pwd;$ENV{'PWD'}=$pwd;return$pwd}sub _qnx_abs_path {local$ENV{PATH}='';local$ENV{CDPATH}='';local$ENV{ENV}='';my$path=@_ ? shift : '.';local*REALPATH;defined(open(REALPATH,'-|')|| exec '/usr/bin/fullpath','-t',$path)or die "Can't open /usr/bin/fullpath: $!";my$realpath=<REALPATH>;close REALPATH;chomp$realpath;return$realpath}sub _epoc_cwd {return$ENV{'PWD'}=EPOC::getcwd()}if (exists$METHOD_MAP{$^O}){my$map=$METHOD_MAP{$^O};for my$name (keys %$map){local $^W=0;no strict 'refs';*{$name}=\&{$map->{$name}}}}*abs_path=\&_perl_abs_path unless defined&abs_path;*getcwd=\&_perl_getcwd unless defined&getcwd;*realpath=\&abs_path;1;
X86_64-LINUX_CWD

$fatpacked{"x86_64-linux/File/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC';
  package File::Spec;use strict;use vars qw(@ISA $VERSION);$VERSION='3.62';$VERSION =~ tr/_//d;my%module=(MacOS=>'Mac',MSWin32=>'Win32',os2=>'OS2',VMS=>'VMS',epoc=>'Epoc',NetWare=>'Win32',symbian=>'Win32',dos=>'OS2',cygwin=>'Cygwin',amigaos=>'AmigaOS');my$module=$module{$^O}|| 'Unix';require "File/Spec/$module.pm";@ISA=("File::Spec::$module");1;
X86_64-LINUX_FILE_SPEC

$fatpacked{"x86_64-linux/File/Spec/AmigaOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_AMIGAOS';
  package File::Spec::AmigaOS;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.62';$VERSION =~ tr/_//d;@ISA=qw(File::Spec::Unix);my$tmpdir;sub tmpdir {return$tmpdir if defined$tmpdir;$tmpdir=$_[0]->_tmpdir($ENV{TMPDIR},"/t")}sub file_name_is_absolute {my ($self,$file)=@_;return$file =~ m{^/|:}s}1;
X86_64-LINUX_FILE_SPEC_AMIGAOS

$fatpacked{"x86_64-linux/File/Spec/Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.62';$VERSION =~ tr/_//d;@ISA=qw(File::Spec::Unix);sub canonpath {my($self,$path)=@_;return unless defined$path;$path =~ s|\\|/|g;my$node='';if ($path =~ s@^(//[^/]+)(?:/|\z)@/@s){$node=$1}return$node .$self->SUPER::canonpath($path)}sub catdir {my$self=shift;return unless @_;if ($_[0]and ($_[0]eq '/' or $_[0]eq '\\')){shift;return$self->SUPER::catdir('',@_)}$self->SUPER::catdir(@_)}sub file_name_is_absolute {my ($self,$file)=@_;return 1 if$file =~ m{^([a-z]:)?[\\/]}is;return$self->SUPER::file_name_is_absolute($file)}sub tmpdir {my$cached=$_[0]->_cached_tmpdir(qw 'TMPDIR TMP TEMP');return$cached if defined$cached;$_[0]->_cache_tmpdir($_[0]->_tmpdir($ENV{TMPDIR},"/tmp",$ENV{'TMP'},$ENV{'TEMP'},'C:/temp'),qw 'TMPDIR TMP TEMP')}sub case_tolerant {return 1 unless $^O eq 'cygwin' and defined&Cygwin::mount_flags;my$drive=shift;if (!$drive){my@flags=split(/,/,Cygwin::mount_flags('/cygwin'));my$prefix=pop(@flags);if (!$prefix || $prefix eq 'cygdrive'){$drive='/cygdrive/c'}elsif ($prefix eq '/'){$drive='/c'}else {$drive="$prefix/c"}}my$mntopts=Cygwin::mount_flags($drive);if ($mntopts and ($mntopts =~ /,managed/)){return 0}eval {require Win32API::File}or return 1;my$osFsType="\0"x256;my$osVolName="\0"x256;my$ouFsFlags=0;Win32API::File::GetVolumeInformation($drive,$osVolName,256,[],[],$ouFsFlags,$osFsType,256);if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()){return 0}else {return 1}}1;
X86_64-LINUX_FILE_SPEC_CYGWIN

$fatpacked{"x86_64-linux/File/Spec/Epoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_EPOC';
  package File::Spec::Epoc;use strict;use vars qw($VERSION @ISA);$VERSION='3.62';$VERSION =~ tr/_//d;require File::Spec::Unix;@ISA=qw(File::Spec::Unix);sub case_tolerant {return 1}sub canonpath {my ($self,$path)=@_;return unless defined$path;$path =~ s|/+|/|g;$path =~ s|(/\.)+/|/|g;$path =~ s|^(\./)+||s unless$path eq "./";$path =~ s|^/(\.\./)+|/|s;$path =~ s|/\Z(?!\n)|| unless$path eq "/";return$path}1;
X86_64-LINUX_FILE_SPEC_EPOC

$fatpacked{"x86_64-linux/File/Spec/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;use File::Spec;use strict;use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);$VERSION='3.62';$VERSION =~ tr/_//d;require Exporter;@ISA=qw(Exporter);@EXPORT=qw(canonpath catdir catfile curdir rootdir updir no_upwards file_name_is_absolute path);@EXPORT_OK=qw(devnull tmpdir splitpath splitdir catpath abs2rel rel2abs case_tolerant);%EXPORT_TAGS=(ALL=>[@EXPORT_OK,@EXPORT ]);require File::Spec::Unix;my%udeps=(canonpath=>[],catdir=>[qw(canonpath)],catfile=>[qw(canonpath catdir)],case_tolerant=>[],curdir=>[],devnull=>[],rootdir=>[],updir=>[],);for my$meth (@EXPORT,@EXPORT_OK){my$sub=File::Spec->can($meth);no strict 'refs';if (exists($udeps{$meth})&& $sub==File::Spec::Unix->can($meth)&& !(grep {File::Spec->can($_)!=File::Spec::Unix->can($_)}@{$udeps{$meth}})&& defined(&{"File::Spec::Unix::_fn_$meth"})){*{$meth}=\&{"File::Spec::Unix::_fn_$meth"}}else {*{$meth}=sub {&$sub('File::Spec',@_)}}}1;
X86_64-LINUX_FILE_SPEC_FUNCTIONS

$fatpacked{"x86_64-linux/File/Spec/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_MAC';
  package File::Spec::Mac;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.62';$VERSION =~ tr/_//d;@ISA=qw(File::Spec::Unix);my$macfiles;if ($^O eq 'MacOS'){$macfiles=eval {require Mac::Files}}sub case_tolerant {1}sub canonpath {my ($self,$path)=@_;return$path}sub catdir {my$self=shift;return '' unless @_;my@args=@_;my$first_arg;my$relative;if ($args[0]eq ''){shift@args;$relative=0;$first_arg=$self->rootdir}elsif ($args[0]=~ /^[^:]+:/){$relative=0;$first_arg=shift@args;$first_arg="$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/)}else {$relative=1;if ($args[0]=~ /^::+\Z(?!\n)/){$first_arg=':'}elsif ($args[0]eq ':'){$first_arg=shift@args}else {$first_arg=shift@args;$first_arg="$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/)}}my$result=$first_arg;while (@args){my$arg=shift@args;unless (($arg eq '')|| ($arg eq ':')){if ($arg =~ /^::+\Z(?!\n)/){my$updir_count=length($arg)- 1;while ((@args)&& ($args[0]=~ /^::+\Z(?!\n)/)){$arg=shift@args;$updir_count += (length($arg)- 1)}$arg=(':' x $updir_count)}else {$arg =~ s/^://s;$arg="$arg:" unless ($arg =~ /:\Z(?!\n)/)}$result .= $arg}}if (($relative)&& ($result !~ /^:/)){$result=":$result"}unless ($relative){$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/}return$result}sub catfile {my$self=shift;return '' unless @_;my$file=pop @_;return$file unless @_;my$dir=$self->catdir(@_);$file =~ s/^://s;return$dir.$file}sub curdir {return ":"}sub devnull {return "Dev:Null"}sub rootdir {return '' unless$macfiles;my$system=Mac::Files::FindFolder(&Mac::Files::kOnSystemDisk,&Mac::Files::kSystemFolderType);$system =~ s/:.*\Z(?!\n)/:/s;return$system}sub tmpdir {my$cached=$_[0]->_cached_tmpdir('TMPDIR');return$cached if defined$cached;$_[0]->_cache_tmpdir($_[0]->_tmpdir($ENV{TMPDIR}),'TMPDIR')}sub updir {return "::"}sub file_name_is_absolute {my ($self,$file)=@_;if ($file =~ /:/){return (!($file =~ m/^:/s))}elsif ($file eq ''){return 1 }else {return 0}}sub path {return unless exists$ENV{Commands};return split(/,/,$ENV{Commands})}sub splitpath {my ($self,$path,$nofile)=@_;my ($volume,$directory,$file);if ($nofile){($volume,$directory)=$path =~ m|^((?:[^:]+:)?)(.*)|s}else {$path =~ m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;$volume=$1;$directory=$2;$file=$3}$volume='' unless defined($volume);$directory=":$directory" if ($volume && $directory);if ($directory){$directory .= ':' unless (substr($directory,-1)eq ':');$directory=":$directory" unless (substr($directory,0,1)eq ':')}else {$directory=''}$file='' unless defined($file);return ($volume,$directory,$file)}sub splitdir {my ($self,$path)=@_;my@result=();my ($head,$sep,$tail,$volume,$directories);return@result if ((!defined($path))|| ($path eq ''));return (':')if ($path eq ':');($volume,$sep,$directories)=$path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;if ($volume){push (@result,$volume);$sep .= ':'}while ($sep || $directories){if (length($sep)> 1){my$updir_count=length($sep)- 1;for (my$i=0;$i<$updir_count;$i++){push (@result,'::')}}$sep='';if ($directories){($head,$sep,$tail)=$directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;push (@result,$head);$directories=$tail}}return@result}sub catpath {my ($self,$volume,$directory,$file)=@_;if ((!$volume)&& (!$directory)){$file =~ s/^:// if$file;return$file }my ($dir_volume,$dir_dirs)=$self->splitpath($directory,1);$volume=$dir_volume unless length$volume;my$path=$volume;$path .= ':' unless (substr($path,-1)eq ':');if ($directory){$directory=$dir_dirs if$volume;$directory =~ s/^://;$path .= $directory;$path .= ':' unless (substr($path,-1)eq ':')}if ($file){$file =~ s/^://;$path .= $file}return$path}sub _resolve_updirs {my$path=shift @_;my$proceed;do {$proceed=($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/)}while ($proceed);return$path}sub abs2rel {my($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){$path=$self->rel2abs($path)}if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base);$base=_resolve_updirs($base)}else {$base=_resolve_updirs($base)}my ($path_vol,$path_dirs,$path_file)=$self->splitpath($path);my ($base_vol,$base_dirs)=$self->splitpath($base);return$path unless lc($path_vol)eq lc($base_vol);my@pathchunks=$self->splitdir($path_dirs);my@basechunks=$self->splitdir($base_dirs);while (@pathchunks && @basechunks && lc($pathchunks[0])eq lc($basechunks[0])){shift@pathchunks ;shift@basechunks }$path_dirs=$self->catdir(':',@pathchunks);$base_dirs=(':' x @basechunks).':' ;return$self->catpath('',$self->catdir($base_dirs,$path_dirs),$path_file)}sub rel2abs {my ($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}my ($path_dirs,$path_file)=($self->splitpath($path))[1,2];my ($base_vol,$base_dirs)=$self->splitpath($base);$path_dirs=':' if ($path_dirs eq '');$base_dirs =~ s/:$//;$base_dirs=$base_dirs .$path_dirs;$path=$self->catpath($base_vol,$base_dirs,$path_file)}return$path}1;
X86_64-LINUX_FILE_SPEC_MAC

$fatpacked{"x86_64-linux/File/Spec/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_OS2';
  package File::Spec::OS2;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.62';$VERSION =~ tr/_//d;@ISA=qw(File::Spec::Unix);sub devnull {return "/dev/nul"}sub case_tolerant {return 1}sub file_name_is_absolute {my ($self,$file)=@_;return scalar($file =~ m{^([a-z]:)?[\\/]}is)}sub path {my$path=$ENV{PATH};$path =~ s:\\:/:g;my@path=split(';',$path);for (@path){$_='.' if $_ eq ''}return@path}sub _cwd {return Cwd::sys_cwd()}sub tmpdir {my$cached=$_[0]->_cached_tmpdir(qw 'TMPDIR TEMP TMP');return$cached if defined$cached;my@d=@ENV{qw(TMPDIR TEMP TMP)};$_[0]->_cache_tmpdir($_[0]->_tmpdir(@d,'/tmp','/'),qw 'TMPDIR TEMP TMP')}sub catdir {my$self=shift;my@args=@_;for (@args){tr[\\][/];$_ .= "/" unless m{/$}}return$self->canonpath(join('',@args))}sub canonpath {my ($self,$path)=@_;return unless defined$path;$path =~ s/^([a-z]:)/\l$1/s;$path =~ s|\\|/|g;$path =~ s|([^/])/+|$1/|g;$path =~ s|(/\.)+/|/|g;$path =~ s|^(\./)+(?=[^/])||s;$path =~ s|/\Z(?!\n)|| unless$path =~ m#^([a-z]:)?/\Z(?!\n)#si;$path =~ s{^/\.\.$}{/};1 while$path =~ s{^/\.\.}{};return$path}sub splitpath {my ($self,$path,$nofile)=@_;my ($volume,$directory,$file)=('','','');if ($nofile){$path =~ m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;$volume=$1;$directory=$2}else {$path =~ m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;$volume=$1;$directory=$2;$file=$3}return ($volume,$directory,$file)}sub splitdir {my ($self,$directories)=@_ ;split m|[\\/]|,$directories,-1}sub catpath {my ($self,$volume,$directory,$file)=@_;$volume .= $1 if ($volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s && $directory =~ m@^[^\\/]@s);$volume .= $directory ;if ($volume !~ m@^[a-zA-Z]:\Z(?!\n)@s && $volume =~ m@[^\\/]\Z(?!\n)@ && $file =~ m@[^\\/]@){$volume =~ m@([\\/])@ ;my$sep=$1 ? $1 : '/' ;$volume .= $sep }$volume .= $file ;return$volume }sub abs2rel {my($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){$path=$self->rel2abs($path)}else {$path=$self->canonpath($path)}if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}my ($path_volume,$path_directories,$path_file)=$self->splitpath($path,1);my ($base_volume,$base_directories)=$self->splitpath($base,1);return$path unless$path_volume eq $base_volume;my@pathchunks=$self->splitdir($path_directories);my@basechunks=$self->splitdir($base_directories);while (@pathchunks && @basechunks && lc($pathchunks[0])eq lc($basechunks[0])){shift@pathchunks ;shift@basechunks }$path_directories=CORE::join('/',@pathchunks);$base_directories=CORE::join('/',@basechunks);$base_directories =~ s|[^\\/]+|..|g ;if ($path_directories ne '' && $base_directories ne ''){$path_directories="$base_directories/$path_directories" }else {$path_directories="$base_directories$path_directories" }return$self->canonpath($self->catpath("",$path_directories,$path_file))}sub rel2abs {my ($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}my ($path_directories,$path_file)=($self->splitpath($path,1))[1,2];my ($base_volume,$base_directories)=$self->splitpath($base,1);$path=$self->catpath($base_volume,$self->catdir($base_directories,$path_directories),$path_file)}return$self->canonpath($path)}1;
X86_64-LINUX_FILE_SPEC_OS2

$fatpacked{"x86_64-linux/File/Spec/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_UNIX';
  package File::Spec::Unix;use strict;use vars qw($VERSION);$VERSION='3.62';my$xs_version=$VERSION;$VERSION =~ tr/_//d;if(!defined&canonpath && defined&DynaLoader::boot_DynaLoader){eval {if ($] >= 5.006){require XSLoader;XSLoader::load("Cwd",$xs_version)}else {require Cwd}}}sub _pp_canonpath {my ($self,$path)=@_;return unless defined$path;my$node='';my$double_slashes_special=$^O eq 'qnx' || $^O eq 'nto';if ($double_slashes_special && ($path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s)){$node=$1}$path =~ s|/{2,}|/|g;$path =~ s{(?:/\.)+(?:/|\z)}{/}g;$path =~ s|^(?:\./)+||s unless$path eq "./";$path =~ s|^/(?:\.\./)+|/|;$path =~ s|^/\.\.$|/|;$path =~ s|/\z|| unless$path eq "/";return "$node$path"}*canonpath=\&_pp_canonpath unless defined&canonpath;sub _pp_catdir {my$self=shift;$self->canonpath(join('/',@_,''))}*catdir=\&_pp_catdir unless defined&catdir;sub _pp_catfile {my$self=shift;my$file=$self->canonpath(pop @_);return$file unless @_;my$dir=$self->catdir(@_);$dir .= "/" unless substr($dir,-1)eq "/";return$dir.$file}*catfile=\&_pp_catfile unless defined&catfile;sub curdir {'.'}use constant _fn_curdir=>".";sub devnull {'/dev/null'}use constant _fn_devnull=>"/dev/null";sub rootdir {'/'}use constant _fn_rootdir=>"/";my ($tmpdir,%tmpenv);sub _cache_tmpdir {@tmpenv{@_[2..$#_]}=@ENV{@_[2..$#_]};return$tmpdir=$_[1]}sub _cached_tmpdir {shift;local $^W;return if grep$ENV{$_}ne $tmpenv{$_},@_;return$tmpdir}sub _tmpdir {my$self=shift;my@dirlist=@_;my$taint=do {no strict 'refs';${"\cTAINT"}};if ($taint){require Scalar::Util;@dirlist=grep {!Scalar::Util::tainted($_)}@dirlist}elsif ($] < 5.007){@dirlist=grep {eval {eval('1'.substr $_,0,0)}}@dirlist}for (@dirlist){next unless defined && -d && -w _;$tmpdir=$_;last}$tmpdir=$self->curdir unless defined$tmpdir;$tmpdir=defined$tmpdir && $self->canonpath($tmpdir);if (!$self->file_name_is_absolute($tmpdir)){($tmpdir)=grep {$taint ?!Scalar::Util::tainted($_): $] < 5.007 ? eval {eval('1'.substr $_,0,0)}: 1}$self->rel2abs($tmpdir),$tmpdir}return$tmpdir}sub tmpdir {my$cached=$_[0]->_cached_tmpdir('TMPDIR');return$cached if defined$cached;$_[0]->_cache_tmpdir($_[0]->_tmpdir($ENV{TMPDIR},"/tmp"),'TMPDIR')}sub updir {'..'}use constant _fn_updir=>"..";sub no_upwards {my$self=shift;return grep(!/^\.{1,2}\z/s,@_)}sub case_tolerant {0}use constant _fn_case_tolerant=>0;sub file_name_is_absolute {my ($self,$file)=@_;return scalar($file =~ m:^/:s)}sub path {return ()unless exists$ENV{PATH};my@path=split(':',$ENV{PATH});for (@path){$_='.' if $_ eq ''}return@path}sub join {my$self=shift;return$self->catfile(@_)}sub splitpath {my ($self,$path,$nofile)=@_;my ($volume,$directory,$file)=('','','');if ($nofile){$directory=$path}else {$path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;$directory=$1;$file=$2}return ($volume,$directory,$file)}sub splitdir {return split m|/|,$_[1],-1}sub catpath {my ($self,$volume,$directory,$file)=@_;if ($directory ne '' && $file ne '' && substr($directory,-1)ne '/' && substr($file,0,1)ne '/'){$directory .= "/$file" }else {$directory .= $file }return$directory }sub abs2rel {my($self,$path,$base)=@_;$base=$self->_cwd()unless defined$base and length$base;($path,$base)=map$self->canonpath($_),$path,$base;my$path_directories;my$base_directories;if (grep$self->file_name_is_absolute($_),$path,$base){($path,$base)=map$self->rel2abs($_),$path,$base;my ($path_volume)=$self->splitpath($path,1);my ($base_volume)=$self->splitpath($base,1);return$path unless$path_volume eq $base_volume;$path_directories=($self->splitpath($path,1))[1];$base_directories=($self->splitpath($base,1))[1];if (!length($base_directories)and $self->file_name_is_absolute($base)){$base_directories=$self->rootdir}}else {my$wd=($self->splitpath($self->_cwd(),1))[1];$path_directories=$self->catdir($wd,$path);$base_directories=$self->catdir($wd,$base)}my@pathchunks=$self->splitdir($path_directories);my@basechunks=$self->splitdir($base_directories);if ($base_directories eq $self->rootdir){return$self->curdir if$path_directories eq $self->rootdir;shift@pathchunks;return$self->canonpath($self->catpath('',$self->catdir(@pathchunks),''))}my@common;while (@pathchunks && @basechunks && $self->_same($pathchunks[0],$basechunks[0])){push@common,shift@pathchunks ;shift@basechunks }return$self->curdir unless@pathchunks || @basechunks;my@reverse_base;while(defined(my$dir=shift@basechunks)){if($dir ne $self->updir){unshift@reverse_base,$self->updir;push@common,$dir}elsif(@common){if(@reverse_base && $reverse_base[0]eq $self->updir){shift@reverse_base;pop@common}else {unshift@reverse_base,pop@common}}}my$result_dirs=$self->catdir(@reverse_base,@pathchunks);return$self->canonpath($self->catpath('',$result_dirs,''))}sub _same {$_[1]eq $_[2]}sub rel2abs {my ($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}$path=$self->catdir($base,$path)}return$self->canonpath($path)}sub _cwd {require Cwd;Cwd::getcwd()}sub _collapse {my($fs,$path)=@_;my$updir=$fs->updir;my$curdir=$fs->curdir;my($vol,$dirs,$file)=$fs->splitpath($path);my@dirs=$fs->splitdir($dirs);pop@dirs if@dirs && $dirs[-1]eq '';my@collapsed;for my$dir (@dirs){if($dir eq $updir and @collapsed and length$collapsed[-1]and $collapsed[-1]ne $updir and $collapsed[-1]ne $curdir){pop@collapsed}else {push@collapsed,$dir}}return$fs->catpath($vol,$fs->catdir(@collapsed),$file)}1;
X86_64-LINUX_FILE_SPEC_UNIX

$fatpacked{"x86_64-linux/File/Spec/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_VMS';
  package File::Spec::VMS;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.62';$VERSION =~ tr/_//d;@ISA=qw(File::Spec::Unix);use File::Basename;use VMS::Filespec;my$use_feature;BEGIN {if (eval {local$SIG{__DIE__};require VMS::Feature}){$use_feature=1}}sub _unix_rpt {my$unix_rpt;if ($use_feature){$unix_rpt=VMS::Feature::current("filename_unix_report")}else {my$env_unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';$unix_rpt=$env_unix_rpt =~ /^[ET1]/i}return$unix_rpt}sub canonpath {my($self,$path)=@_;return undef unless defined$path;my$unix_rpt=$self->_unix_rpt;if ($path =~ m|/|){my$pathify=$path =~ m|/\Z(?!\n)|;$path=$self->SUPER::canonpath($path);return$path if$unix_rpt;$path=$pathify ? vmspath($path): vmsify($path)}$path =~ s/(?<!\^)</[/;$path =~ s/(?<!\^)>/]/;$path =~ s/(?<!\^)\]\[\./\.\]\[/g;$path =~ s/(?<!\^)\[000000\.\]\[/\[/g;$path =~ s/(?<!\^)\[000000\./\[/g;$path =~ s/(?<!\^)\.\]\[000000\]/\]/g;$path =~ s/(?<!\^)\.\]\[/\./g;1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);1 while ($path =~ s/(?<!\^)([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);$path =~ s/(?<!\^)\[\.-/[-/;$path =~ s/(?<!\^)\.[^\]\.]+\.-\./\./g;$path =~ s/(?<!\^)\[[^\]\.]+\.-\./\[/g;$path =~ s/(?<!\^)\.[^\]\.]+\.-\]/\]/g;$path =~ s/(?<!\^)\[[^\]\.]+\.-\]/\[000000\]/g;$path =~ s/(?<!\^)\[\]// unless$path eq '[]';return$unix_rpt ? unixify($path): $path}sub catdir {my$self=shift;my$dir=pop;my$unix_rpt=$self->_unix_rpt;my@dirs=grep {defined()&& length()}@_;my$rslt;if (@dirs){my$path=(@dirs==1 ? $dirs[0]: $self->catdir(@dirs));my ($spath,$sdir)=($path,$dir);$spath =~ s/\.dir\Z(?!\n)//i;$sdir =~ s/\.dir\Z(?!\n)//i;if ($unix_rpt){$spath=unixify($spath)unless$spath =~ m#/#;$sdir=unixify($sdir)unless$sdir =~ m#/#;return$self->SUPER::catdir($spath,$sdir)}$rslt=vmspath(unixify($spath).'/' .unixify($sdir));if ($spath =~ /^[\[<][^.\-]/s){$rslt =~ s/^[^\[<]+//s}}else {if (not defined$dir or not length$dir){$rslt=''}else {$rslt=$unix_rpt ? $dir : vmspath($dir)}}return$self->canonpath($rslt)}sub catfile {my$self=shift;my$tfile=pop();my$file=$self->canonpath($tfile);my@files=grep {defined()&& length()}@_;my$unix_rpt=$self->_unix_rpt;my$rslt;if (@files){my$path=(@files==1 ? $files[0]: $self->catdir(@files));my$spath=$path;$spath =~ s/\.dir\Z(?!\n)//i;if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file)eq $file){$rslt="$spath$file"}else {$rslt=unixify($spath);$rslt .= (defined($rslt)&& length($rslt)? '/' : '').unixify($file);$rslt=vmsify($rslt)unless$unix_rpt}}else {my$xfile=(defined($file)&& length($file))? $file : '';$rslt=$unix_rpt ? $xfile : vmsify($xfile)}return$self->canonpath($rslt)unless$unix_rpt;return$rslt}sub curdir {my$self=shift @_;return '.' if ($self->_unix_rpt);return '[]'}sub devnull {my$self=shift @_;return '/dev/null' if ($self->_unix_rpt);return "_NLA0:"}sub rootdir {my$self=shift @_;if ($self->_unix_rpt){my$try='/';my ($dev1,$ino1)=stat('/');my ($dev2,$ino2)=stat('.');if (($dev1!=$dev2)|| ($ino1!=$ino2)){return$try}return '/sys$disk/'}return 'SYS$DISK:[000000]'}sub tmpdir {my$self=shift @_;my$tmpdir=$self->_cached_tmpdir('TMPDIR');return$tmpdir if defined$tmpdir;if ($self->_unix_rpt){$tmpdir=$self->_tmpdir('/tmp','/sys$scratch',$ENV{TMPDIR})}else {$tmpdir=$self->_tmpdir('sys$scratch:',$ENV{TMPDIR})}$self->_cache_tmpdir($tmpdir,'TMPDIR')}sub updir {my$self=shift @_;return '..' if ($self->_unix_rpt);return '[-]'}sub case_tolerant {return 1}sub path {my (@dirs,$dir,$i);while ($dir=$ENV{'DCL$PATH;' .$i++}){push(@dirs,$dir)}return@dirs}sub file_name_is_absolute {my ($self,$file)=@_;$file=$ENV{$file}while$file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};return scalar($file =~ m!^/!s || $file =~ m![<\[][^.\-\]>]! || $file =~ /^[A-Za-z0-9_\$\-\~]+(?<!\^):/)}sub splitpath {my($self,$path,$nofile)=@_;my($dev,$dir,$file)=('','','');my$vmsify_path=vmsify($path);if ($nofile){if($vmsify_path =~ /(.*)\](.+)/){$vmsify_path=$1.'.'.$2.']'}$vmsify_path =~ /(.+:)?(.*)/s;$dir=defined $2 ? $2 : '';return ($1 || '',$dir,$file)}else {$vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;return ($1 || '',$2 || '',$3)}}sub splitdir {my($self,$dirspec)=@_;my@dirs=();return@dirs if ((!defined$dirspec)|| ('' eq $dirspec));$dirspec =~ s/(?<!\^)</[/;$dirspec =~ s/(?<!\^)>/]/;$dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;$dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;$dirspec =~ s/(?<!\^)\[000000\./\[/g;$dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;$dirspec =~ s/(?<!\^)\.\]\[/\./g;while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g){}$dirspec="[$dirspec]" unless$dirspec =~ /(?<!\^)[\[<]/;$dirspec =~ s/^(\[|<)\./$1/;@dirs=split /(?<!\^)\./,vmspath($dirspec);$dirs[0]=~ s/^[\[<]//s;$dirs[-1]=~ s/[\]>]\Z(?!\n)//s;@dirs}sub catpath {my($self,$dev,$dir,$file)=@_;my ($dir_volume,$dir_dir,$dir_file)=$self->splitpath($dir);$dev=$dir_volume unless length$dev;$dir=length$dir_file ? $self->catfile($dir_dir,$dir_file): $dir_dir;if ($dev =~ m|^(?<!\^)/+([^/]+)|){$dev="$1:"}else {$dev .= ':' unless$dev eq '' or $dev =~ /:\Z(?!\n)/}if (length($dev)or length($dir)){$dir="[$dir]" unless$dir =~ /(?<!\^)[\[<\/]/;$dir=vmspath($dir)}$dir='' if length($dev)&& ($dir eq '[]' || $dir eq '<>');"$dev$dir$file"}sub abs2rel {my$self=shift;return vmspath(File::Spec::Unix::abs2rel($self,@_))if ((grep m{/},@_)&&!(grep m{(?<!\^)[\[<:]},@_));my($path,$base)=@_;$base=$self->_cwd()unless defined$base and length$base;$base=VMS::Filespec::vmspath($base)unless$base =~ m{(?<!\^)[\[<:]};for ($path,$base){$_=$self->rel2abs($_)}my ($path_volume,$path_directories,$path_file)=$self->splitpath($path);my ($base_volume,$base_directories,$base_file)=$self->splitpath($base);return$path unless lc($path_volume)eq lc($base_volume);my@pathchunks=$self->splitdir($path_directories);my$pathchunks=@pathchunks;unshift(@pathchunks,'000000')unless$pathchunks[0]eq '000000';my@basechunks=$self->splitdir($base_directories);my$basechunks=@basechunks;unshift(@basechunks,'000000')unless$basechunks[0]eq '000000';while (@pathchunks && @basechunks && lc($pathchunks[0])eq lc($basechunks[0])){shift@pathchunks ;shift@basechunks }if ((@basechunks > 0)|| ($basechunks!=$pathchunks)){$path_directories=join '.',('-' x @basechunks,@pathchunks)}else {$path_directories=join '.',@pathchunks}$path_directories='['.$path_directories.']';return$self->canonpath($self->catpath('',$path_directories,$path_file))}sub rel2abs {my$self=shift ;my ($path,$base)=@_;return undef unless defined$path;if ($path =~ m/\//){$path=(-d $path || $path =~ m/\/\z/ ? vmspath($path): vmsify($path))}$base=vmspath($base)if defined$base && $base =~ m/\//;if (!$self->file_name_is_absolute($path)){if (!defined($base)|| $base eq ''){$base=$self->_cwd}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}my ($path_directories,$path_file)=($self->splitpath($path))[1,2];my ($base_volume,$base_directories)=$self->splitpath($base);$path_directories='' if$path_directories eq '[]' || $path_directories eq '<>';my$sep='' ;$sep='.' if ($base_directories =~ m{[^.\]>]\Z(?!\n)} && $path_directories =~ m{^[^.\[<]}s);$base_directories="$base_directories$sep$path_directories";$base_directories =~ s{\.?[\]>][\[<]\.?}{.};$path=$self->catpath($base_volume,$base_directories,$path_file)}return$self->canonpath($path)}1;
X86_64-LINUX_FILE_SPEC_VMS

$fatpacked{"x86_64-linux/File/Spec/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_WIN32';
  package File::Spec::Win32;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.62';$VERSION =~ tr/_//d;@ISA=qw(File::Spec::Unix);my$DRIVE_RX='[a-zA-Z]:';my$UNC_RX='(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';my$VOL_RX="(?:$DRIVE_RX|$UNC_RX)";sub devnull {return "nul"}sub rootdir {'\\'}sub tmpdir {my$tmpdir=$_[0]->_cached_tmpdir(qw(TMPDIR TEMP TMP));return$tmpdir if defined$tmpdir;$tmpdir=$_[0]->_tmpdir(map($ENV{$_},qw(TMPDIR TEMP TMP)),'SYS:/temp','C:\system\temp','C:/temp','/tmp','/');$_[0]->_cache_tmpdir($tmpdir,qw(TMPDIR TEMP TMP))}sub case_tolerant {eval {require Win32API::File}or return 1;my$drive=shift || "C:";my$osFsType="\0"x256;my$osVolName="\0"x256;my$ouFsFlags=0;Win32API::File::GetVolumeInformation($drive,$osVolName,256,[],[],$ouFsFlags,$osFsType,256);if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()){return 0}else {return 1}}sub file_name_is_absolute {my ($self,$file)=@_;if ($file =~ m{^($VOL_RX)}o){my$vol=$1;return ($vol =~ m{^$UNC_RX}o ? 2 : $file =~ m{^$DRIVE_RX[\\/]}o ? 2 : 0)}return$file =~ m{^[\\/]} ? 1 : 0}sub catfile {shift;shift,return _canon_cat("/",@_)if $_[0]eq "";return _canon_cat(($_[0].'\\'),@_[1..$#_])if $_[0]=~ m{^$DRIVE_RX\z}o;return _canon_cat(@_)}sub catdir {shift;return "" unless @_;shift,return _canon_cat("/",@_)if $_[0]eq "";return _canon_cat(($_[0].'\\'),@_[1..$#_])if $_[0]=~ m{^$DRIVE_RX\z}o;return _canon_cat(@_)}sub path {my@path=split(';',$ENV{PATH});s/"//g for@path;@path=grep length,@path;unshift(@path,".");return@path}sub canonpath {return $_[1]if!defined($_[1])or $_[1]eq '';return _canon_cat($_[1])}sub splitpath {my ($self,$path,$nofile)=@_;my ($volume,$directory,$file)=('','','');if ($nofile){$path =~ m{^ ( $VOL_RX ? ) (.*) }sox;$volume=$1;$directory=$2}else {$path =~ m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;$volume=$1;$directory=$2;$file=$3}return ($volume,$directory,$file)}sub splitdir {my ($self,$directories)=@_ ;if ($directories !~ m|[\\/]\Z(?!\n)|){return split(m|[\\/]|,$directories)}else {my(@directories)=split(m|[\\/]|,"${directories}dummy");$directories[$#directories ]='' ;return@directories }}sub catpath {my ($self,$volume,$directory,$file)=@_;my$v;$volume .= $v if ((($v)=$volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s)&& $directory =~ m@^[^\\/]@s);$volume .= $directory ;if ($volume !~ m@^[a-zA-Z]:\Z(?!\n)@s && $volume =~ m@[^\\/]\Z(?!\n)@ && $file =~ m@[^\\/]@){$volume =~ m@([\\/])@ ;my$sep=$1 ? $1 : '\\' ;$volume .= $sep }$volume .= $file ;return$volume }sub _same {lc($_[1])eq lc($_[2])}sub rel2abs {my ($self,$path,$base)=@_;my$is_abs=$self->file_name_is_absolute($path);return$self->canonpath($path)if$is_abs==2;if ($is_abs){my$vol=($self->splitpath($self->_cwd()))[0];return$self->canonpath($vol .$path)}if (!defined($base)|| $base eq ''){require Cwd ;$base=Cwd::getdcwd(($self->splitpath($path))[0])if defined&Cwd::getdcwd ;$base=$self->_cwd()unless defined$base }elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}my ($path_directories,$path_file)=($self->splitpath($path,1))[1,2];my ($base_volume,$base_directories)=$self->splitpath($base,1);$path=$self->catpath($base_volume,$self->catdir($base_directories,$path_directories),$path_file);return$self->canonpath($path)}sub _canon_cat {my ($first,@rest)=@_;my$volume=$first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x ? ucfirst($1).($2 ? "\\" : ""): $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs ? "\\\\$1".(defined $2 ? "\\$2" : "")."\\" : $first =~ s{ \A [\\/] }{}x ? "\\" : "";my$path=join "\\",$first,@rest;$path =~ tr#\\/#\\\\#s;$path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;$path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;while ($path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx){}$path =~ s#\A\\##;$path =~ s#\\\z##;if ($volume =~ m#\\\z#){$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;return $1 if$path eq "" and $volume =~ m#\A(\\\\.*)\\\z#s}return$path ne "" || $volume ? $volume.$path : "."}1;
X86_64-LINUX_FILE_SPEC_WIN32

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  package List::Util;use strict;use warnings;require Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=qw(all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst);our$VERSION="1.47";our$XS_VERSION=$VERSION;$VERSION=eval$VERSION;require XSLoader;XSLoader::load('List::Util',$XS_VERSION);sub import {my$pkg=caller;no strict 'refs';${"${pkg}::a"}=${"${pkg}::a"};${"${pkg}::b"}=${"${pkg}::b"};goto&Exporter::import}sub List::Util::_Pair::key {shift->[0]}sub List::Util::_Pair::value {shift->[1]}1;
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;use strict;use warnings;use List::Util;our$VERSION="1.47";$VERSION=eval$VERSION;1;
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  package Scalar::Util;use strict;use warnings;require Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=qw(blessed refaddr reftype weaken unweaken isweak dualvar isdual isvstring looks_like_number openhandle readonly set_prototype tainted);our$VERSION="1.47";$VERSION=eval$VERSION;require List::Util;List::Util->VERSION($VERSION);our@EXPORT_FAIL;unless (defined&weaken){push@EXPORT_FAIL,qw(weaken)}unless (defined&isweak){push@EXPORT_FAIL,qw(isweak isvstring)}unless (defined&isvstring){push@EXPORT_FAIL,qw(isvstring)}sub export_fail {if (grep {/^(?:weaken|isweak)$/}@_){require Carp;Carp::croak("Weak references are not implemented in the version of perl")}if (grep {/^isvstring$/}@_){require Carp;Carp::croak("Vstrings are not implemented in the version of perl")}@_}sub set_prototype(&$) {my ($code,$proto)=@_;return Sub::Util::set_prototype($proto,$code)}1;
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_UTIL';
  package Sub::Util;use strict;use warnings;require Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=qw(prototype set_prototype subname set_subname);our$VERSION="1.47";$VERSION=eval$VERSION;require List::Util;List::Util->VERSION($VERSION);sub prototype {my ($code)=@_;return CORE::prototype($code)}1;
X86_64-LINUX_SUB_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl
use strict;
use warnings;
use FindBin;
use lib "$FindBin::Bin/../lib/";
use Perl::Build;
use Getopt::Long;
use Pod::Usage;
use File::Spec;

my $test = undef;
my $patches;
my $build_dir;
my $symlink_devel_executables;
my (@D, @A, @U);
Getopt::Long::Configure(
    'pass_through',
    'no_ignore_case',
    'bundling',
);
GetOptions(
    'h|help' => \my $help,
    'test!' => \$test,
    'D=s@'  => \@D,
    'A=s@'  => \@A,
    'U=s@'  => \@U,
    'definitions' => \my $definitions,
    'patches=s' => \$patches,
    'build-dir=s' => \$build_dir,
    'j|jobs=i' => \my $jobs,
    'tarball-dir=s' => \my $tarball_dir,
    'version' => \my $show_version,
    'symlink-devel-executables!' => \$symlink_devel_executables,
    'noman' => \my $noman,
);
for (@D, @A, @U) {
    s/^=//;
}

if ($show_version) {
    print "$Perl::Build::VERSION\n";
    exit 0;
}

pod2usage(1) if $help;

if ($definitions) {
    for (Perl::Build->available_perls()) {
        print "$_\n";
    }
    exit 0;
}

shift @ARGV if @ARGV >= 1 && $ARGV[0] eq '--';

my $stuff   = shift @ARGV or pod2usage();
my $dest    = shift @ARGV or pod2usage();
   $dest    = File::Spec->rel2abs($dest);

my @configure_options = @ARGV ? @ARGV : ('-de');
push @configure_options, map { "-D$_" } @D;
push @configure_options, map { "-A$_" } @A;
push @configure_options, map { "-U$_" } @U;
push @configure_options, "-Dman1dir=none", "-Dman3dir=none" if $noman;

$ENV{PERL5_PATCHPERL_PLUGIN} = $patches if defined $patches;

if ($stuff eq 'blead') {
    my $url = "http://perl5.git.perl.org/perl.git/snapshot/blead.tar.gz";
    Perl::Build->install_from_url(
        $url => (
            dst_path          => $dest,
            configure_options => ['-Dusedevel', @configure_options],
            test              => $test,
            build_dir         => $build_dir,
            jobs              => $jobs,
            tarball_dir       => $tarball_dir,
        )
    );
} elsif ($stuff =~ m{^https?://}) {
    Perl::Build->install_from_url(
        $stuff => (
            dst_path          => $dest,
            configure_options => \@configure_options,
            test              => $test,
            build_dir         => $build_dir,
            jobs              => $jobs,
            tarball_dir       => $tarball_dir,
        )
    );
} elsif ($stuff =~ /\.(gz|bz2)$/) {
    Perl::Build->install_from_tarball(
        $stuff => (
            dst_path          => $dest,
            configure_options => \@configure_options,
            test              => $test,
            build_dir         => $build_dir,
            jobs              => $jobs,
        )
    );
} else {
    my $version = $stuff;
    Perl::Build->install_from_cpan(
        $version => (
            dst_path          => $dest,
            configure_options => \@configure_options,
            test              => $test,
            build_dir         => $build_dir,
            jobs              => $jobs,
            tarball_dir       => $tarball_dir,
        )
    );
}

if ($symlink_devel_executables) {
    Perl::Build->symlink_devel_executables(
        File::Spec->catdir($dest, 'bin')
    );
}

__END__

=head1 NAME

perl-build - perl binary builder

=head1 SYNOPSIS 

    # perl-build command is FatPacker ready
    % curl https://raw.github.com/tokuhirom/Perl-Build/master/perl-build | perl - 5.16.2 /opt/perl-5.16/

    # Or, just install from CPAN
    % cpanm Perl::Build

    # And run it.
    % perl-build 5.16.2 /usr/local/perl-5.16.2
    % perl-build path/to/perl-5.16.2.tar.gz /usr/local/perl-5.16.2

=head1 DESCRIPTION

This script fetch/build/install perl5 from CPAN or tar ball.

=head1 OPTIONS

=over 4

=item -D, -A, -U

-Dxxx, -Axxx, -Uxxx options are pass through to ./Configure script.

=item --test

This option enables C<< make test >> after building.

(Default: disabled)

=item --patches=Asan

You can set I<PERL5_PATCHPERL_PLUGIN> environment variable by this option.

=item --build-dir=path

Specify perl build path. optional. (Default: temporary directory)

=item -j n

=item --jobs n

Parallel building and testing.

=item --tarball-dir

Specify the tar ball saving directory.

(Default: temporary directory, will remove after building)

=item --definitions

    % perl-build --definitions

Display the available perl versions and exit.

=item --version

Show version number and exit.

=item --symlink-devel-executables

Create symlinks for development version perl commands.

=item --noman

Skip installation of manpages.
This is equivalent to specifying C<-Dman1dir=none> and C<-Dman3dir=none>.

=back

=head1 FAQ

=over 4

=item How can I apply security fixes like CVE-2013-1667?

RURBAN provides L<Devel::PatchPerl::Plugin::Asan>. Install it and run C<< perl-build --patches=Asan 5.16.1 /opt/perl/5.16/ >>.

=back

=head1 SEE ALSO

L<perlbrew>, L<plenv>

